(function(global, factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
                throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
    var arr = [];
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var support = {};
    var document = window.document, version = "2.1.4", jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
    }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function(all, letter) {
        return letter.toUpperCase();
    };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: "",
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        get: function(num) {
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
        },
        pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret;
        },
        each: function(callback, args) {
            return jQuery.each(this, callback, args);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [ this[j] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (;i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        isReady: true,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isFunction: function(obj) {
            return jQuery.type(obj) === "function";
        },
        isArray: Array.isArray,
        isWindow: function(obj) {
            return obj != null && obj === obj.window;
        },
        isNumeric: function(obj) {
            return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
        },
        isPlainObject: function(obj) {
            if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                return false;
            }
            return true;
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        type: function(obj) {
            if (obj == null) {
                return obj + "";
            }
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        globalEval: function(code) {
            var script, indirect = eval;
            code = jQuery.trim(code);
            if (code) {
                if (code.indexOf("use strict") === 1) {
                    script = document.createElement("script");
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script);
                } else {
                    indirect(code);
                }
            }
        },
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function(obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
                if (isArray) {
                    for (;i < length; i++) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                }
            } else {
                if (isArray) {
                    for (;i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                }
            }
            return obj;
        },
        trim: function(text) {
            return text == null ? "" : (text + "").replace(rtrim, "");
        },
        makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === "string" ? [ arr ] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (;j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (;i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function(elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            if (isArray) {
                for (;i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function(fn, context) {
            var tmp, args, proxy;
            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: Date.now,
        support: support
    });
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    function isArraylike(obj) {
        var length = "length" in obj && obj.length, type = jQuery.type(obj);
        if (type === "function" || jQuery.isWindow(obj)) {
            return false;
        }
        if (obj.nodeType === 1 && length) {
            return true;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = function(window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            if (a === b) {
                hasDuplicate = true;
            }
            return 0;
        }, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function(list, elem) {
            var i = 0, len = list.length;
            for (;i < len; i++) {
                if (list[i] === elem) {
                    return i;
                }
            }
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", identifier = characterEncoding.replace("w", "w#"), attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + characterEncoding + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + characterEncoding + ")"),
            CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
            TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, unloadHandler = function() {
            setDocument();
        };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function(target, els) {
                    push_native.apply(target, slice.call(els));
                } : function(target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {}
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                setDocument(context);
            }
            context = context || document;
            results = results || [];
            nodeType = context.nodeType;
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
            }
            if (!seed && documentIsHTML) {
                if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                    if (m = match[1]) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            if (elem && elem.parentNode) {
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            } else {
                                return results;
                            }
                        } else {
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        }
                    } else if (match[2]) {
                        push.apply(results, context.getElementsByTagName(selector));
                        return results;
                    } else if ((m = match[3]) && support.getElementsByClassName) {
                        push.apply(results, context.getElementsByClassName(m));
                        return results;
                    }
                }
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    nid = old = expando;
                    newContext = context;
                    newSelector = nodeType !== 1 && selector;
                    if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                        groups = tokenize(selector);
                        if (old = context.getAttribute("id")) {
                            nid = old.replace(rescape, "\\$&");
                        } else {
                            context.setAttribute("id", nid);
                        }
                        nid = "[id='" + nid + "'] ";
                        i = groups.length;
                        while (i--) {
                            groups[i] = nid + toSelector(groups[i]);
                        }
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        newSelector = groups.join(",");
                    }
                    if (newSelector) {
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {} finally {
                            if (!old) {
                                context.removeAttribute("id");
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + " ") > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + " "] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var div = document.createElement("div");
            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                div = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split("|"), i = attrs.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };
        setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = doc.documentElement;
            parent = doc.defaultView;
            if (parent && parent !== parent.top) {
                if (parent.addEventListener) {
                    parent.addEventListener("unload", unloadHandler, false);
                } else if (parent.attachEvent) {
                    parent.attachEvent("onunload", unloadHandler);
                }
            }
            documentIsHTML = !isXML(doc);
            support.attributes = assert(function(div) {
                div.className = "i";
                return !div.getAttribute("className");
            });
            support.getElementsByTagName = assert(function(div) {
                div.appendChild(doc.createComment(""));
                return !div.getElementsByTagName("*").length;
            });
            support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
            support.getById = assert(function(div) {
                docElem.appendChild(div).id = expando;
                return !doc.getElementsByName || !doc.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var m = context.getElementById(id);
                        return m && m.parentNode ? [ m ] : [];
                    }
                };
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId;
                    };
                };
            } else {
                delete Expr.find["ID"];
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    };
                };
            }
            Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") {
                    return context.getElementsByTagName(tag);
                } else if (support.qsa) {
                    return context.querySelectorAll(tag);
                }
            } : function(tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === "*") {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                if (documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(doc.querySelectorAll)) {
                assert(function(div) {
                    docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\f]' msallowcapture=''>" + "<option selected=''></option></select>";
                    if (div.querySelectorAll("[msallowcapture^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    }
                    if (!div.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    }
                    if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                        rbuggyQSA.push("~=");
                    }
                    if (!div.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked");
                    }
                    if (!div.querySelectorAll("a#" + expando + "+*").length) {
                        rbuggyQSA.push(".#.+[+~]");
                    }
                });
                assert(function(div) {
                    var input = doc.createElement("input");
                    input.setAttribute("type", "hidden");
                    div.appendChild(input).setAttribute("name", "D");
                    if (div.querySelectorAll("[name=d]").length) {
                        rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    }
                    if (!div.querySelectorAll(":enabled").length) {
                        rbuggyQSA.push(":enabled", ":disabled");
                    }
                    div.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:");
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function(div) {
                    support.disconnectedMatch = matches.call(div, "div");
                    matches.call(div, "[s!='']:x");
                    rbuggyMatches.push("!=", pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
                if (!aup || !bup) {
                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return doc;
        };
        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, "='$1']");
            if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {}
            }
            return Sizzle(expr, document, null, [ elem ]).length > 0;
        };
        Sizzle.contains = function(context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === "string") {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                    if (match[2] === "~=") {
                        match[3] = " " + match[3] + " ";
                    }
                    return match.slice(0, 4);
                },
                CHILD: function(match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === "nth") {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +(match[7] + match[8] || match[3] === "odd");
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                PSEUDO: function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr["CHILD"].test(match[0])) {
                        return null;
                    }
                    if (match[3]) {
                        match[2] = match[4] || match[5] || "";
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                TAG: function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function() {
                        return true;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                CLASS: function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                    });
                },
                ATTR: function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === "!=";
                        }
                        if (!operator) {
                            return true;
                        }
                        result += "";
                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                    };
                },
                CHILD: function(type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                    return first === 1 && last === 0 ? function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }
                            start = [ forward ? parent.firstChild : parent.lastChild ];
                            if (forward && useCache) {
                                outerCache = parent[expando] || (parent[expando] = {});
                                cache = outerCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = cache[0] === dirruns && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        outerCache[type] = [ dirruns, nodeIndex, diff ];
                                        break;
                                    }
                                }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                diff = cache[1];
                            } else {
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        if (useCache) {
                                            (node[expando] || (node[expando] = {}))[type] = [ dirruns, diff ];
                                        }
                                        if (node === elem) {
                                            break;
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                PSEUDO: function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [ pseudo, pseudo, "", argument ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                not: markFunction(function(selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function(elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                contains: markFunction(function(text) {
                    text = text.replace(runescape, funescape);
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                lang: markFunction(function(lang) {
                    if (!ridentifier.test(lang || "")) {
                        Sizzle.error("unsupported lang: " + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function(elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                target: function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                root: function(elem) {
                    return elem === docElem;
                },
                focus: function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                enabled: function(elem) {
                    return elem.disabled === false;
                },
                disabled: function(elem) {
                    return elem.disabled === true;
                },
                checked: function(elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
                },
                selected: function(elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                empty: function(elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                parent: function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },
                header: function(elem) {
                    return rheader.test(elem.nodeName);
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },
                text: function(elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                first: createPositionalPseudo(function() {
                    return [ 0 ];
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [ length - 1 ];
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [ argument < 0 ? argument + length : argument ];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 0;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 1;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;--i >= 0; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;++i < length; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        for (i in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
        }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
            submit: true,
            reset: true
        }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = "";
            for (;i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === "parentNode", doneName = done++;
            return combinator.first ? function(elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            } : function(elem, context, xml) {
                var oldCache, outerCache, newCache = [ dirruns, doneName ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                outerCache[dir] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (;i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (;i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [ function(elem, context, xml) {
                var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                checkContext = null;
                return ret;
            } ];
            for (;i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [ addCombinator(elementMatcher(matchers), matcher) ];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (;j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                            value: tokens[i - 2].type === " " ? "*" : ""
                        })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || .1, len = elems.length;
                if (outermost) {
                    outermostContext = context !== document && context;
                }
                for (;i !== len && (elem = elems[i]) != null; i++) {
                    if (byElement && elem) {
                        j = 0;
                        while (matcher = elementMatchers[j++]) {
                            if (matcher(elem, context, xml)) {
                                results.push(elem);
                                break;
                            }
                        }
                        if (outermost) {
                            dirruns = dirrunsUnique;
                        }
                    }
                    if (bySet) {
                        if (elem = !matcher && elem) {
                            matchedCount--;
                        }
                        if (seed) {
                            unmatched.push(elem);
                        }
                    }
                }
                matchedCount += i;
                if (bySet && i !== matchedCount) {
                    j = 0;
                    while (matcher = setMatchers[j++]) {
                        matcher(unmatched, setMatched, context, xml);
                    }
                    if (seed) {
                        if (matchedCount > 0) {
                            while (i--) {
                                if (!(unmatched[i] || setMatched[i])) {
                                    setMatched[i] = pop.call(results);
                                }
                            }
                        }
                        setMatched = condense(setMatched);
                    }
                    push.apply(results, setMatched);
                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                        Sizzle.uniqueSort(results);
                    }
                }
                if (outermost) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }
                return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                cached.selector = selector;
            }
            return cached;
        };
        select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;
                    } else if (compiled) {
                        context = context.parentNode;
                    }
                    selector = selector.slice(tokens.shift().value.length);
                }
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function(div1) {
            return div1.compareDocumentPosition(document.createElement("div")) & 1;
        });
        if (!assert(function(div) {
            div.innerHTML = "<a href='#'></a>";
            return div.firstChild.getAttribute("href") === "#";
        })) {
            addHandle("type|href|height|width", function(elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function(div) {
            div.innerHTML = "<input/>";
            div.firstChild.setAttribute("value", "");
            return div.firstChild.getAttribute("value") === "";
        })) {
            addHandle("value", function(elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === "input") {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function(div) {
            return div.getAttribute("disabled") == null;
        })) {
            addHandle(booleans, function(elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function(elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier === "string") {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) >= 0 !== not;
        });
    }
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ":not(" + expr + ")";
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function(selector) {
            var i, len = this.length, ret = [], self = this;
            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function() {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
            return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function(selector, context) {
        var match, elem;
        if (!selector) {
            return this;
        }
        if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                match = [ null, selector, null ];
            } else {
                match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context)) {
                if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context;
                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                        for (match in context) {
                            if (jQuery.isFunction(this[match])) {
                                this[match](context[match]);
                            } else {
                                this.attr(match, context[match]);
                            }
                        }
                    }
                    return this;
                } else {
                    elem = document.getElementById(match[2]);
                    if (elem && elem.parentNode) {
                        this.length = 1;
                        this[0] = elem;
                    }
                    this.context = document;
                    this.selector = selector;
                    return this;
                }
            } else if (!context || context.jquery) {
                return (context || rootjQuery).find(selector);
            } else {
                return this.constructor(context).find(selector);
            }
        } else if (selector.nodeType) {
            this.context = this[0] = selector;
            this.length = 1;
            return this;
        } else if (jQuery.isFunction(selector)) {
            return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
            this.selector = selector.selector;
            this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
    };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };
    jQuery.extend({
        dir: function(elem, dir, until) {
            var matched = [], truncate = until !== undefined;
            while ((elem = elem[dir]) && elem.nodeType !== 9) {
                if (elem.nodeType === 1) {
                    if (truncate && jQuery(elem).is(until)) {
                        break;
                    }
                    matched.push(elem);
                }
            }
            return matched;
        },
        sibling: function(n, elem) {
            var matched = [];
            for (;n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    matched.push(n);
                }
            }
            return matched;
        }
    });
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                var i = 0;
                for (;i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
            for (;i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break;
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },
        index: function(elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
            }
            return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {}
        return cur;
    }
    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function(elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== "Until") {
                selector = until;
            }
            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    jQuery.unique(matched);
                }
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }
            return this.pushStack(matched);
        };
    });
    var rnotwhite = /\S+/g;
    var optionsCache = {};
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
        var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function(data) {
            memory = options.memory && data;
            fired = true;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            firing = true;
            for (;list && firingIndex < firingLength; firingIndex++) {
                if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                    memory = false;
                    break;
                }
            }
            firing = false;
            if (list) {
                if (stack) {
                    if (stack.length) {
                        fire(stack.shift());
                    }
                } else if (memory) {
                    list = [];
                } else {
                    self.disable();
                }
            }
        }, self = {
            add: function() {
                if (list) {
                    var start = list.length;
                    (function add(args) {
                        jQuery.each(args, function(_, arg) {
                            var type = jQuery.type(arg);
                            if (type === "function") {
                                if (!options.unique || !self.has(arg)) {
                                    list.push(arg);
                                }
                            } else if (arg && arg.length && type !== "string") {
                                add(arg);
                            }
                        });
                    })(arguments);
                    if (firing) {
                        firingLength = list.length;
                    } else if (memory) {
                        firingStart = start;
                        fire(memory);
                    }
                }
                return this;
            },
            remove: function() {
                if (list) {
                    jQuery.each(arguments, function(_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);
                            if (firing) {
                                if (index <= firingLength) {
                                    firingLength--;
                                }
                                if (index <= firingIndex) {
                                    firingIndex--;
                                }
                            }
                        }
                    });
                }
                return this;
            },
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
            },
            empty: function() {
                list = [];
                firingLength = 0;
                return this;
            },
            disable: function() {
                list = stack = memory = undefined;
                return this;
            },
            disabled: function() {
                return !list;
            },
            lock: function() {
                stack = undefined;
                if (!memory) {
                    self.disable();
                }
                return this;
            },
            locked: function() {
                return !stack;
            },
            fireWith: function(context, args) {
                if (list && (!fired || stack)) {
                    args = args || [];
                    args = [ context, args.slice ? args.slice() : args ];
                    if (firing) {
                        stack.push(args);
                    } else {
                        fire(args);
                    }
                }
                return this;
            },
            fire: function() {
                self.fireWith(this, arguments);
                return this;
            },
            fired: function() {
                return !!fired;
            }
        };
        return self;
    };
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [ [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ], [ "notify", "progress", jQuery.Callbacks("memory") ] ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done(arguments).fail(arguments);
                    return this;
                },
                then: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var fn = jQuery.isFunction(fns[i]) && fns[i];
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                if (returned && jQuery.isFunction(returned.promise)) {
                                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                } else {
                                    newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments);
                                }
                            });
                        });
                        fns = null;
                    }).promise();
                },
                promise: function(obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function() {
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function(subordinate) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function(i, contexts, values) {
                return function(value) {
                    contexts[i] = this;
                    values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                    if (values === progressValues) {
                        deferred.notifyWith(contexts, values);
                    } else if (!--remaining) {
                        deferred.resolveWith(contexts, values);
                    }
                };
            }, progressValues, progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (;i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    var readyList;
    jQuery.fn.ready = function(fn) {
        jQuery.ready.promise().done(fn);
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function(hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        ready: function(wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [ jQuery ]);
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler("ready");
                jQuery(document).off("ready");
            }
        }
    });
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed, false);
        window.removeEventListener("load", completed, false);
        jQuery.ready();
    }
    jQuery.ready.promise = function(obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === "complete") {
                setTimeout(jQuery.ready);
            } else {
                document.addEventListener("DOMContentLoaded", completed, false);
                window.addEventListener("load", completed, false);
            }
        }
        return readyList.promise(obj);
    };
    jQuery.ready.promise();
    var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (jQuery.type(key) === "object") {
            chainable = true;
            for (i in key) {
                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function(elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (;i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    };
    jQuery.acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        Object.defineProperty(this.cache = {}, 0, {
            get: function() {
                return {};
            }
        });
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.accepts = jQuery.acceptData;
    Data.prototype = {
        key: function(owner) {
            if (!Data.accepts(owner)) {
                return 0;
            }
            var descriptor = {}, unlock = owner[this.expando];
            if (!unlock) {
                unlock = Data.uid++;
                try {
                    descriptor[this.expando] = {
                        value: unlock
                    };
                    Object.defineProperties(owner, descriptor);
                } catch (e) {
                    descriptor[this.expando] = unlock;
                    jQuery.extend(owner, descriptor);
                }
            }
            if (!this.cache[unlock]) {
                this.cache[unlock] = {};
            }
            return unlock;
        },
        set: function(owner, data, value) {
            var prop, unlock = this.key(owner), cache = this.cache[unlock];
            if (typeof data === "string") {
                cache[data] = value;
            } else {
                if (jQuery.isEmptyObject(cache)) {
                    jQuery.extend(this.cache[unlock], data);
                } else {
                    for (prop in data) {
                        cache[prop] = data[prop];
                    }
                }
            }
            return cache;
        },
        get: function(owner, key) {
            var cache = this.cache[this.key(owner)];
            return key === undefined ? cache : cache[key];
        },
        access: function(owner, key, value) {
            var stored;
            if (key === undefined || key && typeof key === "string" && value === undefined) {
                stored = this.get(owner, key);
                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
            var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
            if (key === undefined) {
                this.cache[unlock] = {};
            } else {
                if (jQuery.isArray(key)) {
                    name = key.concat(key.map(jQuery.camelCase));
                } else {
                    camel = jQuery.camelCase(key);
                    if (key in cache) {
                        name = [ key, camel ];
                    } else {
                        name = camel;
                        name = name in cache ? [ name ] : name.match(rnotwhite) || [];
                    }
                }
                i = name.length;
                while (i--) {
                    delete cache[name[i]];
                }
            }
        },
        hasData: function(owner) {
            return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
        },
        discard: function(owner) {
            if (owner[this.expando]) {
                delete this.cache[owner[this.expando]];
            }
        }
    };
    var data_priv = new Data();
    var data_user = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
                try {
                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {}
                data_user.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    jQuery.extend({
        hasData: function(elem) {
            return data_user.hasData(elem) || data_priv.hasData(elem);
        },
        data: function(elem, name, data) {
            return data_user.access(elem, name, data);
        },
        removeData: function(elem, name) {
            data_user.remove(elem, name);
        },
        _data: function(elem, name, data) {
            return data_priv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            data_priv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = data_user.get(elem);
                    if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--) {
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        data_priv.set(elem, "hasDataAttrs", true);
                    }
                }
                return data;
            }
            if (typeof key === "object") {
                return this.each(function() {
                    data_user.set(this, key);
                });
            }
            return access(this, function(value) {
                var data, camelKey = jQuery.camelCase(key);
                if (elem && value === undefined) {
                    data = data_user.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }
                    data = data_user.get(elem, camelKey);
                    if (data !== undefined) {
                        return data;
                    }
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) {
                        return data;
                    }
                    return;
                }
                this.each(function() {
                    var data = data_user.get(this, camelKey);
                    data_user.set(this, camelKey, value);
                    if (key.indexOf("-") !== -1 && data !== undefined) {
                        data_user.set(this, key, value);
                    }
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
            return this.each(function() {
                data_user.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = data_priv.get(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = data_priv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === "fx") {
                    queue.unshift("inprogress");
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return data_priv.get(elem, key) || data_priv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    data_priv.remove(elem, [ type + "queue", key ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                if (!--count) {
                    defer.resolveWith(elements, [ elements ]);
                }
            };
            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";
            while (i--) {
                tmp = data_priv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
    var isHidden = function(elem, el) {
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    };
    var rcheckableType = /^(?:checkbox|radio)$/i;
    (function() {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();
    var strundefined = typeof undefined;
    support.focusinBubbles = "onfocusin" in window;
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function(e) {
                    return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                data_priv.remove(elem, "events");
            }
        },
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf(".") >= 0) {
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [ event ] : jQuery.makeArray(data, [ event ]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (;cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        dispatch: function(event) {
            event = jQuery.event.fix(event);
            var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (data_priv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function(event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
                for (;cur !== this; cur = cur.parentNode || this) {
                    if (cur.disabled !== true || event.type !== "click") {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + " ";
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [ cur ]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(event, original) {
                var eventDoc, doc, body, button = original.button;
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }
                return event;
            }
        },
        fix: function(event) {
            if (event[jQuery.expando]) {
                return event;
            }
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }
            if (!event.target) {
                event.target = document;
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
            load: {
                noBubble: true
            },
            focus: {
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                        this.click();
                        return false;
                    }
                },
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },
        simulate: function(type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true,
                originalEvent: {}
            });
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };
    jQuery.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
        }
    };
    jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && e.preventDefault) {
                e.preventDefault();
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && e.stopPropagation) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && e.stopImmediatePropagation) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    if (!support.focusinBubbles) {
        jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(orig, fix) {
            var handler = function(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };
            jQuery.event.special[fix] = {
                setup: function() {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    data_priv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function() {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        data_priv.remove(doc, fix);
                    } else {
                        data_priv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    jQuery.fn.extend({
        on: function(types, selector, data, fn, one) {
            var origFn, type;
            if (typeof types === "object") {
                if (typeof selector !== "string") {
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }
            if (data == null && fn == null) {
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === "string") {
                    fn = data;
                    data = undefined;
                } else {
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }
            if (one === 1) {
                origFn = fn;
                fn = function(event) {
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function() {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function(types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === "object") {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        },
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
    }
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute("type");
        }
        return elem;
    }
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for (;i < l; i++) {
            data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
        }
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
            return;
        }
        if (data_priv.hasData(src)) {
            pdataOld = data_priv.access(src);
            pdataCur = data_priv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }
        if (data_user.hasData(src)) {
            udataOld = data_user.access(src);
            udataCur = jQuery.extend({}, udataOld);
            data_user.set(dest, udataCur);
        }
    }
    function getAll(context, tag) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([ context ], ret) : ret;
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }
    jQuery.extend({
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
        },
        buildFragment: function(elems, context, scripts, selection) {
            var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
            for (;i < l; i++) {
                elem = elems[i];
                if (elem || elem === 0) {
                    if (jQuery.type(elem) === "object") {
                        jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem);
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));
                    } else {
                        tmp = tmp || fragment.appendChild(context.createElement("div"));
                        tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }
                        jQuery.merge(nodes, tmp.childNodes);
                        tmp = fragment.firstChild;
                        tmp.textContent = "";
                    }
                }
            }
            fragment.textContent = "";
            i = 0;
            while (elem = nodes[i++]) {
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue;
                }
                contains = jQuery.contains(elem.ownerDocument, elem);
                tmp = getAll(fragment.appendChild(elem), "script");
                if (contains) {
                    setGlobalEval(tmp);
                }
                if (scripts) {
                    j = 0;
                    while (elem = tmp[j++]) {
                        if (rscriptType.test(elem.type || "")) {
                            scripts.push(elem);
                        }
                    }
                }
            }
            return fragment;
        },
        cleanData: function(elems) {
            var data, elem, type, key, special = jQuery.event.special, i = 0;
            for (;(elem = elems[i]) !== undefined; i++) {
                if (jQuery.acceptData(elem)) {
                    key = elem[data_priv.expando];
                    if (key && (data = data_priv.cache[key])) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        if (data_priv.cache[key]) {
                            delete data_priv.cache[key];
                        }
                    }
                }
                delete data_user.cache[elem[data_user.expando]];
            }
        }
    });
    jQuery.fn.extend({
        text: function(value) {
            return access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },
        append: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        remove: function(selector, keepData) {
            var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
            for (;(elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem));
                }
                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, "script"));
                    }
                    elem.parentNode.removeChild(elem);
                }
            }
            return this;
        },
        empty: function() {
            var elem, i = 0;
            for (;(elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = "";
                }
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, "<$1></$2>");
                    try {
                        for (;i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {}
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var arg = arguments[0];
            this.domManip(arguments, function(elem) {
                arg = this.parentNode;
                jQuery.cleanData(getAll(this));
                if (arg) {
                    arg.replaceChild(elem, this);
                }
            });
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },
        detach: function(selector) {
            return this.remove(selector, true);
        },
        domManip: function(args, callback) {
            args = concat.apply([], args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
                return this.each(function(index) {
                    var self = set.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    self.domManip(args, callback);
                });
            }
            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }
                if (first) {
                    scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                    hasScripts = scripts.length;
                    for (;i < l; i++) {
                        node = fragment;
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);
                            if (hasScripts) {
                                jQuery.merge(scripts, getAll(node, "script"));
                            }
                        }
                        callback.call(this[i], node, i);
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;
                        jQuery.map(scripts, restoreScript);
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                                if (node.src) {
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src);
                                    }
                                } else {
                                    jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                                }
                            }
                        }
                    }
                }
            }
            return this;
        }
    });
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for (;i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {};
    function actualDisplay(name, doc) {
        var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], "display");
        elem.detach();
        return display;
    }
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            if (display === "none" || !display) {
                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
                doc = iframe[0].contentDocument;
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }
            elemdisplay[nodeName] = display;
        }
        return display;
    }
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var getStyles = function(elem) {
        if (elem.ownerDocument.defaultView.opener) {
            return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
        }
        return window.getComputedStyle(elem, null);
    };
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
        }
        if (computed) {
            if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name);
            }
            if (rnumnonpx.test(ret) && rmargin.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function() {
                if (conditionFn()) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    (function() {
        var pixelPositionVal, boxSizingReliableVal, docElem = document.documentElement, container = document.createElement("div"), div = document.createElement("div");
        if (!div.style) {
            return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" + "position:absolute";
        container.appendChild(div);
        function computePixelPositionAndBoxSizingReliable() {
            div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute";
            div.innerHTML = "";
            docElem.appendChild(container);
            var divStyle = window.getComputedStyle(div, null);
            pixelPositionVal = divStyle.top !== "1%";
            boxSizingReliableVal = divStyle.width === "4px";
            docElem.removeChild(container);
        }
        if (window.getComputedStyle) {
            jQuery.extend(support, {
                pixelPosition: function() {
                    computePixelPositionAndBoxSizingReliable();
                    return pixelPositionVal;
                },
                boxSizingReliable: function() {
                    if (boxSizingReliableVal == null) {
                        computePixelPositionAndBoxSizingReliable();
                    }
                    return boxSizingReliableVal;
                },
                reliableMarginRight: function() {
                    var ret, marginDiv = div.appendChild(document.createElement("div"));
                    marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                    marginDiv.style.marginRight = marginDiv.style.width = "0";
                    div.style.width = "1px";
                    docElem.appendChild(container);
                    ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
                    docElem.removeChild(container);
                    div.removeChild(marginDiv);
                    return ret;
                }
            });
        }
    })();
    jQuery.swap = function(elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"), rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"), cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }, cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
    function vendorPropName(style, name) {
        if (name in style) {
            return name;
        }
        var capName = name[0].toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }
        return origName;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0, val = 0;
        for (;i < 4; i += 2) {
            if (extra === "margin") {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                if (extra === "content") {
                    val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }
                if (extra !== "margin") {
                    val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            } else {
                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                if (extra !== "padding") {
                    val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val = name === "width" ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
    }
    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length;
        for (;index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = data_priv.get(elem, "olddisplay");
            display = elem.style.display;
            if (show) {
                if (!values[index] && display === "none") {
                    elem.style.display = "";
                }
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);
                if (display !== "none" || !hidden) {
                    data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                }
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none";
            }
        }
        return elements;
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },
        cssNumber: {
            columnCount: true,
            fillOpacity: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            widows: true,
            zIndex: true,
            zoom: true
        },
        cssProps: {
            float: "cssFloat"
        },
        style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === "string" && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    type = "number";
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value;
                }
            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([ "height", "width" ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) {
                    return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function() {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function(elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
            }
        };
    });
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
        if (computed) {
            return jQuery.swap(elem, {
                display: "inline-block"
            }, curCSS, [ elem, "marginRight" ]);
        }
    });
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [ value ];
                for (;i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (;i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }
            return this.each(function() {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, "");
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2;
        }
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), rrun = /queueHooks$/, animationPrefilters = [ defaultPrefilter ], tweeners = {
        "*": [ function(prop, value) {
            var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"), start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
            if (start && start[3] !== unit) {
                unit = unit || start[3];
                parts = parts || [];
                start = +target || 1;
                do {
                    scale = scale || ".5";
                    start = start / scale;
                    jQuery.style(tween.elem, prop, start + unit);
                } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
            }
            if (parts) {
                start = tween.start = +start || +target || 0;
                tween.unit = unit;
                tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
            }
            return tween;
        } ]
    };
    function createFxNow() {
        setTimeout(function() {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        includeWidth = includeWidth ? 1 : 0;
        for (;i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length;
        for (;index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, "fxshow");
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function() {
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
            display = jQuery.css(elem, "display");
            checkDisplay = display === "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
            if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                style.display = "inline-block";
            }
        }
        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            } else {
                display = undefined;
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ("hidden" in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = data_priv.access(elem, "fxshow", {});
            }
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function() {
                    jQuery(elem).hide();
                });
            }
            anim.done(function() {
                var prop;
                data_priv.remove(elem, "fxshow");
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
            style.display = display;
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function() {
            delete tick.elem;
        }), tick = function() {
            if (stopped) {
                return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
            for (;index < length; index++) {
                animation.tweens[index].run(percent);
            }
            deferred.notifyWith(elem, [ animation, percent, remaining ]);
            if (percent < 1 && length) {
                return remaining;
            } else {
                deferred.resolveWith(elem, [ animation ]);
                return false;
            }
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
                specialEasing: {}
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
            },
            stop: function(gotoEnd) {
                var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) {
                    return this;
                }
                stopped = true;
                for (;index < length; index++) {
                    animation.tweens[index].run(1);
                }
                if (gotoEnd) {
                    deferred.resolveWith(elem, [ animation, gotoEnd ]);
                } else {
                    deferred.rejectWith(elem, [ animation, gotoEnd ]);
                }
                return this;
            }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (;index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = [ "*" ];
            } else {
                props = props.split(" ");
            }
            var prop, index = 0, length = props.length;
            for (;index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },
        prefilter: function(callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHidden).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                if (empty || data_priv.get(this, "finish")) {
                    anim.stop(true);
                }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }
            return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = data_priv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function(type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function() {
                var index, data = data_priv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = jQuery.now();
        for (;i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if (!timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function() {
        clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function() {
                clearTimeout(timeout);
            };
        });
    };
    (function() {
        var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function(elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === strundefined) {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                } else {
                    elem.setAttribute(name, value + "");
                    return value;
                }
            } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            } else {
                ret = jQuery.find.attr(elem, name);
                return ret == null ? undefined : ret;
            }
        },
        removeAttr: function(elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    if (jQuery.expr.match.bool.test(name)) {
                        elem[propName] = false;
                    }
                    elem.removeAttribute(name);
                }
            }
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        }
    });
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        propFix: {
            for: "htmlFor",
            class: "className"
        },
        prop: function(elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
            } else {
                return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
            }
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
                }
            }
        }
    });
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function(elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            }
        };
    }
    jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    var rclass = /[\t\r\n\f]/g;
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = typeof value === "string" && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || "").match(rnotwhite) || [];
                for (;i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = arguments.length === 0 || typeof value === "string" && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || "").match(rnotwhite) || [];
                for (;i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(" " + clazz + " ") >= 0) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }
                        finalValue = value ? jQuery.trim(cur) : "";
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === "boolean" && type === "string") {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }
            return this.each(function() {
                if (type === "string") {
                    var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || [];
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (type === strundefined || type === "boolean") {
                    if (this.className) {
                        data_priv.set(this, "__className__", this.className);
                    }
                    this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
                }
            });
        },
        hasClass: function(selector) {
            var className = " " + selector + " ", i = 0, l = this.length;
            for (;i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                    return true;
                }
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function(value) {
                        return value == null ? "" : value + "";
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return val != null ? val : jQuery.trim(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one" || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                    for (;i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function(elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(option.value, values) >= 0) {
                            optionSet = true;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function(elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });
    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
    });
    var nonce = jQuery.now();
    var rquery = /\?/;
    jQuery.parseJSON = function(data) {
        return JSON.parse(data + "");
    };
    jQuery.parseXML = function(data) {
        var xml, tmp;
        if (!data || typeof data !== "string") {
            return null;
        }
        try {
            tmp = new DOMParser();
            xml = tmp.parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    };
    var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), ajaxLocation = window.location.href, ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
    function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === "*") {
                    current = prev;
                } else if (prev !== "*" && prev !== current) {
                    conv = converters[prev + " " + current] || converters["* " + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {
                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s["throws"]) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ajaxLocation,
            type: "GET",
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": true,
                "text json": jQuery.parseJSON,
                "text xml": jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = "canceled", jqXHR = {
                readyState: 0,
                getResponseHeader: function(key) {
                    var match;
                    if (state === 2) {
                        if (!responseHeaders) {
                            responseHeaders = {};
                            while (match = rheaders.exec(responseHeadersString)) {
                                responseHeaders[match[1].toLowerCase()] = match[2];
                            }
                        }
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return match == null ? null : match;
                },
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : null;
                },
                setRequestHeader: function(name, value) {
                    var lname = name.toLowerCase();
                    if (!state) {
                        name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },
                overrideMimeType: function(type) {
                    if (!state) {
                        s.mimeType = type;
                    }
                    return this;
                },
                statusCode: function(map) {
                    var code;
                    if (map) {
                        if (state < 2) {
                            for (code in map) {
                                statusCode[code] = [ statusCode[code], map[code] ];
                            }
                        } else {
                            jqXHR.always(map[jqXHR.status]);
                        }
                    }
                    return this;
                },
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    if (transport) {
                        transport.abort(finalText);
                    }
                    done(0, finalText);
                    return this;
                }
            };
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [ "" ];
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
            }
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) {
                return jqXHR;
            }
            fireGlobals = jQuery.event && s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
                }
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort();
            }
            strAbort = "abort";
            for (i in {
                success: 1,
                error: 1,
                complete: 1
            }) {
                jqXHR[i](s[i]);
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [ jqXHR, s ]);
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) {
                    return;
                }
                state = 2;
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || "";
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";
                    } else if (status === 304) {
                        statusText = "notmodified";
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]);
                } else {
                    deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]);
                }
                completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });
    jQuery.each([ "get", "post" ], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    });
    jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            throws: true
        });
    };
    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function() {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function() {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });
    jQuery.expr.filters.hidden = function(elem) {
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    };
    jQuery.expr.filters.visible = function(elem) {
        return !jQuery.expr.filters.hidden(elem);
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function(i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === "object") {
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, value) {
            value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function() {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join("&").replace(r20, "+");
    };
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    jQuery.ajaxSettings.xhr = function() {
        try {
            return new XMLHttpRequest();
        } catch (e) {}
    };
    var xhrId = 0, xhrCallbacks = {}, xhrSuccessStatus = {
        0: 200,
        1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    if (window.attachEvent) {
        window.attachEvent("onunload", function() {
            for (var key in xhrCallbacks) {
                xhrCallbacks[key]();
            }
        });
    }
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
        var callback;
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function(headers, complete) {
                    var i, xhr = options.xhr(), id = ++xhrId;
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }
                    callback = function(type) {
                        return function() {
                            if (callback) {
                                delete xhrCallbacks[id];
                                callback = xhr.onload = xhr.onerror = null;
                                if (type === "abort") {
                                    xhr.abort();
                                } else if (type === "error") {
                                    complete(xhr.status, xhr.statusText);
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === "string" ? {
                                        text: xhr.responseText
                                    } : undefined, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };
                    xhr.onload = callback();
                    xhr.onerror = callback("error");
                    callback = xhrCallbacks[id] = callback("abort");
                    try {
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        if (callback) {
                            throw e;
                        }
                    }
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
        }
    });
    jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        async: true,
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === "error" ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            s.converters["script json"] = function() {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            overwritten = window[callbackName];
            window[callbackName] = function() {
                responseContainer = arguments;
            };
            jqXHR.always(function() {
                window[callbackName] = overwritten;
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return "script";
        }
    });
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || typeof data !== "string") {
            return null;
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        if (parsed) {
            return [ context.createElement(parsed[1]) ];
        }
        parsed = jQuery.buildFragment([ data ], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
        }
        var selector, type, response, self = this, off = url.indexOf(" ");
        if (off >= 0) {
            selector = jQuery.trim(url.slice(off));
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === "object") {
            type = "POST";
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params
            }).done(function(responseText) {
                response = arguments;
                self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).complete(callback && function(jqXHR, status) {
                self.each(callback, response || [ jqXHR.responseText, status, jqXHR ]);
            });
        }
        return this;
    };
    jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    });
    jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };
    var docElem = window.document.documentElement;
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            if (position === "static") {
                elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, elem = this[0], box = {
                top: 0,
                left: 0
            }, doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            if (typeof elem.getBoundingClientRect !== strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },
        position: function() {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, elem = this[0], parentOffset = {
                top: 0,
                left: 0
            };
            if (jQuery.css(elem, "position") === "fixed") {
                offset = elem.getBoundingClientRect();
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], "html")) {
                    parentOffset = offsetParent.offset();
                }
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || docElem;
                while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || docElem;
            });
        }
    });
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });
    jQuery.each([ "top", "left" ], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return elem.document.documentElement["client" + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    jQuery.fn.size = function() {
        return this.length;
    };
    jQuery.fn.andSelf = jQuery.fn.addBack;
    if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function(deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
});

(function() {
    var undefined;
    var VERSION = "3.8.0";
    var BIND_FLAG = 1, BIND_KEY_FLAG = 2, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, CURRY_RIGHT_FLAG = 16, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64, ARY_FLAG = 128, REARG_FLAG = 256;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 150, HOT_SPAN = 16;
    var LAZY_DROP_WHILE_FLAG = 0, LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2;
    var FUNC_ERROR_TEXT = "Expected a function";
    var PLACEHOLDER = "__lodash_placeholder__";
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g, reUnescapedHtml = /[&<>"'`]/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
    var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g, reHasRegExpChars = RegExp(reRegExpChars.source);
    var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reHasHexPrefix = /^0[xX]/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var reWords = function() {
        var upper = "[A-Z\\xc0-\\xd6\\xd8-\\xde]", lower = "[a-z\\xdf-\\xf6\\xf8-\\xff]+";
        return RegExp(upper + "+(?=" + upper + lower + ")|" + upper + "?" + lower + "|" + upper + "+|[0-9]+", "g");
    }();
    var whitespace = " \t\v\f \ufeff" + "\n\r\u2028\u2029" + " ᠎             　";
    var contextProps = [ "Array", "ArrayBuffer", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Math", "Number", "Object", "RegExp", "Set", "String", "_", "clearTimeout", "document", "isFinite", "parseInt", "setTimeout", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "window" ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
    var debounceOptions = {
        leading: false,
        maxWait: 0,
        trailing: false
    };
    var deburredLetters = {
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss"
    };
    var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "`": "&#96;"
    };
    var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'",
        "&#96;": "`"
    };
    var objectTypes = {
        function: true,
        object: true
    };
    var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    var freeGlobal = freeExports && freeModule && typeof global == "object" && global && global.Object && global;
    var freeSelf = objectTypes[typeof self] && self && self.Object && self;
    var freeWindow = objectTypes[typeof window] && window && window.Object && window;
    var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
    var root = freeGlobal || freeWindow !== (this && this.window) && freeWindow || freeSelf || this;
    function baseCompareAscending(value, other) {
        if (value !== other) {
            var valIsReflexive = value === value, othIsReflexive = other === other;
            if (value > other || !valIsReflexive || value === undefined && othIsReflexive) {
                return 1;
            }
            if (value < other || !othIsReflexive || other === undefined && valIsReflexive) {
                return -1;
            }
        }
        return 0;
    }
    function baseFindIndex(array, predicate, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
                return index;
            }
        }
        return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
            return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
            if (array[index] === value) {
                return index;
            }
        }
        return -1;
    }
    function baseIsFunction(value) {
        return typeof value == "function" || false;
    }
    function baseToString(value) {
        if (typeof value == "string") {
            return value;
        }
        return value == null ? "" : value + "";
    }
    function charAtCallback(string) {
        return string.charCodeAt(0);
    }
    function charsLeftIndex(string, chars) {
        var index = -1, length = string.length;
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
    }
    function charsRightIndex(string, chars) {
        var index = string.length;
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
    }
    function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || object.index - other.index;
    }
    function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
            var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
            if (result) {
                if (index >= ordersLength) {
                    return result;
                }
                return result * (orders[index] ? 1 : -1);
            }
        }
        return object.index - other.index;
    }
    function deburrLetter(letter) {
        return deburredLetters[letter];
    }
    function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
    }
    function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
    }
    function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 0 : -1);
        while (fromRight ? index-- : ++index < length) {
            var other = array[index];
            if (other !== other) {
                return index;
            }
        }
        return -1;
    }
    function isObjectLike(value) {
        return !!value && typeof value == "object";
    }
    function isSpace(charCode) {
        return charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160 || charCode == 5760 || charCode == 6158 || charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279);
    }
    function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = -1, result = [];
        while (++index < length) {
            if (array[index] === placeholder) {
                array[index] = PLACEHOLDER;
                result[++resIndex] = index;
            }
        }
        return result;
    }
    function sortedUniq(array, iteratee) {
        var seen, index = -1, length = array.length, resIndex = -1, result = [];
        while (++index < length) {
            var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
            if (!index || seen !== computed) {
                seen = computed;
                result[++resIndex] = value;
            }
        }
        return result;
    }
    function trimmedLeftIndex(string) {
        var index = -1, length = string.length;
        while (++index < length && isSpace(string.charCodeAt(index))) {}
        return index;
    }
    function trimmedRightIndex(string) {
        var index = string.length;
        while (index-- && isSpace(string.charCodeAt(index))) {}
        return index;
    }
    function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
    }
    function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
        var arrayProto = Array.prototype, objectProto = Object.prototype, stringProto = String.prototype;
        var document = (document = context.window) && document.document;
        var fnToString = Function.prototype.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objToString = objectProto.toString;
        var oldDash = context._;
        var reIsNative = RegExp("^" + escapeRegExp(objToString).replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer, bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice, ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, getOwnPropertySymbols = isNative(getOwnPropertySymbols = Object.getOwnPropertySymbols) && getOwnPropertySymbols, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, push = arrayProto.push, preventExtensions = isNative(preventExtensions = Object.preventExtensions) && preventExtensions, propertyIsEnumerable = objectProto.propertyIsEnumerable, Set = isNative(Set = context.Set) && Set, setTimeout = context.setTimeout, splice = arrayProto.splice, Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array, WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;
        var Float64Array = function() {
            try {
                var func = isNative(func = context.Float64Array) && func, result = new func(new ArrayBuffer(10), 0, 1) && func;
            } catch (e) {}
            return result;
        }();
        var nativeAssign = function() {
            var func = preventExtensions && isNative(func = Object.assign) && func;
            try {
                if (func) {
                    var object = preventExtensions({
                        "1": 0
                    });
                    object[0] = 1;
                }
            } catch (e) {
                try {
                    func(object, "xo");
                } catch (e) {}
                return !object[1] && func;
            }
            return false;
        }();
        var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsFinite = context.isFinite, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeNow = isNative(nativeNow = Date.now) && nativeNow, nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite, nativeParseInt = context.parseInt, nativeRandom = Math.random;
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;
        var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                if (value instanceof LodashWrapper) {
                    return value;
                }
                if (hasOwnProperty.call(value, "__chain__") && hasOwnProperty.call(value, "__wrapped__")) {
                    return wrapperClone(value);
                }
            }
            return new LodashWrapper(value);
        }
        function baseLodash() {}
        function LodashWrapper(value, chainAll, actions) {
            this.__wrapped__ = value;
            this.__actions__ = actions || [];
            this.__chain__ = !!chainAll;
        }
        var support = lodash.support = {};
        (function(x) {
            var Ctor = function() {
                this.x = x;
            }, args = arguments, object = {
                "0": x,
                length: x
            }, props = [];
            Ctor.prototype = {
                valueOf: x,
                y: x
            };
            for (var key in new Ctor()) {
                props.push(key);
            }
            support.funcDecomp = /\bthis\b/.test(function() {
                return this;
            });
            support.funcNames = typeof Function.name == "string";
            try {
                support.dom = document.createDocumentFragment().nodeType === 11;
            } catch (e) {
                support.dom = false;
            }
            try {
                support.nonEnumArgs = !propertyIsEnumerable.call(args, 1);
            } catch (e) {
                support.nonEnumArgs = true;
            }
        })(1, 0);
        lodash.templateSettings = {
            escape: reEscape,
            evaluate: reEvaluate,
            interpolate: reInterpolate,
            variable: "",
            imports: {
                _: lodash
            }
        };
        function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = null;
            this.__dir__ = 1;
            this.__dropCount__ = 0;
            this.__filtered__ = false;
            this.__iteratees__ = null;
            this.__takeCount__ = POSITIVE_INFINITY;
            this.__views__ = null;
        }
        function lazyClone() {
            var actions = this.__actions__, iteratees = this.__iteratees__, views = this.__views__, result = new LazyWrapper(this.__wrapped__);
            result.__actions__ = actions ? arrayCopy(actions) : null;
            result.__dir__ = this.__dir__;
            result.__filtered__ = this.__filtered__;
            result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
            result.__takeCount__ = this.__takeCount__;
            result.__views__ = views ? arrayCopy(views) : null;
            return result;
        }
        function lazyReverse() {
            if (this.__filtered__) {
                var result = new LazyWrapper(this);
                result.__dir__ = -1;
                result.__filtered__ = true;
            } else {
                result = this.clone();
                result.__dir__ *= -1;
            }
            return result;
        }
        function lazyValue() {
            var array = this.__wrapped__.value();
            if (!isArray(array)) {
                return baseWrapperValue(array, this.__actions__);
            }
            var dir = this.__dir__, isRight = dir < 0, view = getView(0, array.length, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, takeCount = nativeMin(length, this.__takeCount__), iteratees = this.__iteratees__, iterLength = iteratees ? iteratees.length : 0, resIndex = 0, result = [];
            outer: while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array[index];
                while (++iterIndex < iterLength) {
                    var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type;
                    if (type == LAZY_DROP_WHILE_FLAG) {
                        if (data.done && (isRight ? index > data.index : index < data.index)) {
                            data.count = 0;
                            data.done = false;
                        }
                        data.index = index;
                        if (!data.done) {
                            var limit = data.limit;
                            if (!(data.done = limit > -1 ? data.count++ >= limit : !iteratee(value))) {
                                continue outer;
                            }
                        }
                    } else {
                        var computed = iteratee(value);
                        if (type == LAZY_MAP_FLAG) {
                            value = computed;
                        } else if (!computed) {
                            if (type == LAZY_FILTER_FLAG) {
                                continue outer;
                            } else {
                                break outer;
                            }
                        }
                    }
                }
                result[resIndex++] = value;
            }
            return result;
        }
        function MapCache() {
            this.__data__ = {};
        }
        function mapDelete(key) {
            return this.has(key) && delete this.__data__[key];
        }
        function mapGet(key) {
            return key == "__proto__" ? undefined : this.__data__[key];
        }
        function mapHas(key) {
            return key != "__proto__" && hasOwnProperty.call(this.__data__, key);
        }
        function mapSet(key, value) {
            if (key != "__proto__") {
                this.__data__[key] = value;
            }
            return this;
        }
        function SetCache(values) {
            var length = values ? values.length : 0;
            this.data = {
                hash: nativeCreate(null),
                set: new Set()
            };
            while (length--) {
                this.push(values[length]);
            }
        }
        function cacheIndexOf(cache, value) {
            var data = cache.data, result = typeof value == "string" || isObject(value) ? data.set.has(value) : data.hash[value];
            return result ? 0 : -1;
        }
        function cachePush(value) {
            var data = this.data;
            if (typeof value == "string" || isObject(value)) {
                data.set.add(value);
            } else {
                data.hash[value] = true;
            }
        }
        function arrayCopy(source, array) {
            var index = -1, length = source.length;
            array || (array = Array(length));
            while (++index < length) {
                array[index] = source[index];
            }
            return array;
        }
        function arrayEach(array, iteratee) {
            var index = -1, length = array.length;
            while (++index < length) {
                if (iteratee(array[index], index, array) === false) {
                    break;
                }
            }
            return array;
        }
        function arrayEachRight(array, iteratee) {
            var length = array.length;
            while (length--) {
                if (iteratee(array[length], length, array) === false) {
                    break;
                }
            }
            return array;
        }
        function arrayEvery(array, predicate) {
            var index = -1, length = array.length;
            while (++index < length) {
                if (!predicate(array[index], index, array)) {
                    return false;
                }
            }
            return true;
        }
        function arrayFilter(array, predicate) {
            var index = -1, length = array.length, resIndex = -1, result = [];
            while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                    result[++resIndex] = value;
                }
            }
            return result;
        }
        function arrayMap(array, iteratee) {
            var index = -1, length = array.length, result = Array(length);
            while (++index < length) {
                result[index] = iteratee(array[index], index, array);
            }
            return result;
        }
        function arrayMax(array) {
            var index = -1, length = array.length, result = NEGATIVE_INFINITY;
            while (++index < length) {
                var value = array[index];
                if (value > result) {
                    result = value;
                }
            }
            return result;
        }
        function arrayMin(array) {
            var index = -1, length = array.length, result = POSITIVE_INFINITY;
            while (++index < length) {
                var value = array[index];
                if (value < result) {
                    result = value;
                }
            }
            return result;
        }
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
            var index = -1, length = array.length;
            if (initFromArray && length) {
                accumulator = array[++index];
            }
            while (++index < length) {
                accumulator = iteratee(accumulator, array[index], index, array);
            }
            return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
            var length = array.length;
            if (initFromArray && length) {
                accumulator = array[--length];
            }
            while (length--) {
                accumulator = iteratee(accumulator, array[length], length, array);
            }
            return accumulator;
        }
        function arraySome(array, predicate) {
            var index = -1, length = array.length;
            while (++index < length) {
                if (predicate(array[index], index, array)) {
                    return true;
                }
            }
            return false;
        }
        function arraySum(array) {
            var length = array.length, result = 0;
            while (length--) {
                result += +array[length] || 0;
            }
            return result;
        }
        function assignDefaults(objectValue, sourceValue) {
            return objectValue === undefined ? sourceValue : objectValue;
        }
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
            return objectValue === undefined || !hasOwnProperty.call(object, key) ? sourceValue : objectValue;
        }
        function assignWith(object, source, customizer) {
            var props = keys(source);
            push.apply(props, getSymbols(source));
            var index = -1, length = props.length;
            while (++index < length) {
                var key = props[index], value = object[key], result = customizer(value, source[key], key, object, source);
                if ((result === result ? result !== value : value === value) || value === undefined && !(key in object)) {
                    object[key] = result;
                }
            }
            return object;
        }
        var baseAssign = nativeAssign || function(object, source) {
            return source == null ? object : baseCopy(source, getSymbols(source), baseCopy(source, keys(source), object));
        };
        function baseAt(collection, props) {
            var index = -1, isNil = collection == null, isArr = !isNil && isArrayLike(collection), length = isArr && collection.length, propsLength = props.length, result = Array(propsLength);
            while (++index < propsLength) {
                var key = props[index];
                if (isArr) {
                    result[index] = isIndex(key, length) ? collection[key] : undefined;
                } else {
                    result[index] = isNil ? undefined : collection[key];
                }
            }
            return result;
        }
        function baseCopy(source, props, object) {
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
                var key = props[index];
                object[key] = source[key];
            }
            return object;
        }
        function baseCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (type == "function") {
                return thisArg === undefined ? func : bindCallback(func, thisArg, argCount);
            }
            if (func == null) {
                return identity;
            }
            if (type == "object") {
                return baseMatches(func);
            }
            return thisArg === undefined ? property(func) : baseMatchesProperty(func, thisArg);
        }
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
            var result;
            if (customizer) {
                result = object ? customizer(value, key, object) : customizer(value);
            }
            if (result !== undefined) {
                return result;
            }
            if (!isObject(value)) {
                return value;
            }
            var isArr = isArray(value);
            if (isArr) {
                result = initCloneArray(value);
                if (!isDeep) {
                    return arrayCopy(value, result);
                }
            } else {
                var tag = objToString.call(value), isFunc = tag == funcTag;
                if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    result = initCloneObject(isFunc ? {} : value);
                    if (!isDeep) {
                        return baseAssign(result, value);
                    }
                } else {
                    return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : object ? value : {};
                }
            }
            stackA || (stackA = []);
            stackB || (stackB = []);
            var length = stackA.length;
            while (length--) {
                if (stackA[length] == value) {
                    return stackB[length];
                }
            }
            stackA.push(value);
            stackB.push(result);
            (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
                result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
            });
            return result;
        }
        var baseCreate = function() {
            function Object() {}
            return function(prototype) {
                if (isObject(prototype)) {
                    Object.prototype = prototype;
                    var result = new Object();
                    Object.prototype = null;
                }
                return result || context.Object();
            };
        }();
        function baseDelay(func, wait, args) {
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return setTimeout(function() {
                func.apply(undefined, args);
            }, wait);
        }
        function baseDifference(array, values) {
            var length = array ? array.length : 0, result = [];
            if (!length) {
                return result;
            }
            var index = -1, indexOf = getIndexOf(), isCommon = indexOf == baseIndexOf, cache = isCommon && values.length >= 200 ? createCache(values) : null, valuesLength = values.length;
            if (cache) {
                indexOf = cacheIndexOf;
                isCommon = false;
                values = cache;
            }
            outer: while (++index < length) {
                var value = array[index];
                if (isCommon && value === value) {
                    var valuesIndex = valuesLength;
                    while (valuesIndex--) {
                        if (values[valuesIndex] === value) {
                            continue outer;
                        }
                    }
                    result.push(value);
                } else if (indexOf(values, value, 0) < 0) {
                    result.push(value);
                }
            }
            return result;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
            var result = true;
            baseEach(collection, function(value, index, collection) {
                result = !!predicate(value, index, collection);
                return result;
            });
            return result;
        }
        function baseFill(array, value, start, end) {
            var length = array.length;
            start = start == null ? 0 : +start || 0;
            if (start < 0) {
                start = -start > length ? 0 : length + start;
            }
            end = end === undefined || end > length ? length : +end || 0;
            if (end < 0) {
                end += length;
            }
            length = start > end ? 0 : end >>> 0;
            start >>>= 0;
            while (start < length) {
                array[start++] = value;
            }
            return array;
        }
        function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function(value, index, collection) {
                if (predicate(value, index, collection)) {
                    result.push(value);
                }
            });
            return result;
        }
        function baseFind(collection, predicate, eachFunc, retKey) {
            var result;
            eachFunc(collection, function(value, key, collection) {
                if (predicate(value, key, collection)) {
                    result = retKey ? key : value;
                    return false;
                }
            });
            return result;
        }
        function baseFlatten(array, isDeep, isStrict) {
            var index = -1, length = array.length, resIndex = -1, result = [];
            while (++index < length) {
                var value = array[index];
                if (isObjectLike(value) && isArrayLike(value) && (isStrict || isArray(value) || isArguments(value))) {
                    if (isDeep) {
                        value = baseFlatten(value, isDeep, isStrict);
                    }
                    var valIndex = -1, valLength = value.length;
                    while (++valIndex < valLength) {
                        result[++resIndex] = value[valIndex];
                    }
                } else if (!isStrict) {
                    result[++resIndex] = value;
                }
            }
            return result;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForIn(object, iteratee) {
            return baseFor(object, iteratee, keysIn);
        }
        function baseForOwn(object, iteratee) {
            return baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
            return baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
            var index = -1, length = props.length, resIndex = -1, result = [];
            while (++index < length) {
                var key = props[index];
                if (isFunction(object[key])) {
                    result[++resIndex] = key;
                }
            }
            return result;
        }
        function baseGet(object, path, pathKey) {
            if (object == null) {
                return;
            }
            if (pathKey !== undefined && pathKey in toObject(object)) {
                path = [ pathKey ];
            }
            var index = -1, length = path.length;
            while (object != null && ++index < length) {
                object = object[path[index]];
            }
            return index && index == length ? object : undefined;
        }
        function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
            if (value === other) {
                return true;
            }
            var valType = typeof value, othType = typeof other;
            if (valType != "function" && valType != "object" && othType != "function" && othType != "object" || value == null || other == null) {
                return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
            if (!objIsArr) {
                objTag = objToString.call(object);
                if (objTag == argsTag) {
                    objTag = objectTag;
                } else if (objTag != objectTag) {
                    objIsArr = isTypedArray(object);
                }
            }
            if (!othIsArr) {
                othTag = objToString.call(other);
                if (othTag == argsTag) {
                    othTag = objectTag;
                } else if (othTag != objectTag) {
                    othIsArr = isTypedArray(other);
                }
            }
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && !(objIsArr || objIsObj)) {
                return equalByTag(object, other, objTag);
            }
            if (!isLoose) {
                var valWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                if (valWrapped || othWrapped) {
                    return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
                }
            }
            if (!isSameTag) {
                return false;
            }
            stackA || (stackA = []);
            stackB || (stackB = []);
            var length = stackA.length;
            while (length--) {
                if (stackA[length] == object) {
                    return stackB[length] == other;
                }
            }
            stackA.push(object);
            stackB.push(other);
            var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
            stackA.pop();
            stackB.pop();
            return result;
        }
        function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
            var index = -1, length = props.length, noCustomizer = !customizer;
            while (++index < length) {
                if (noCustomizer && strictCompareFlags[index] ? values[index] !== object[props[index]] : !(props[index] in object)) {
                    return false;
                }
            }
            index = -1;
            while (++index < length) {
                var key = props[index], objValue = object[key], srcValue = values[index];
                if (noCustomizer && strictCompareFlags[index]) {
                    var result = objValue !== undefined || key in object;
                } else {
                    result = customizer ? customizer(objValue, srcValue, key) : undefined;
                    if (result === undefined) {
                        result = baseIsEqual(srcValue, objValue, customizer, true);
                    }
                }
                if (!result) {
                    return false;
                }
            }
            return true;
        }
        function baseMap(collection, iteratee) {
            var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function(value, key, collection) {
                result[++index] = iteratee(value, key, collection);
            });
            return result;
        }
        function baseMatches(source) {
            var props = keys(source), length = props.length;
            if (!length) {
                return constant(true);
            }
            if (length == 1) {
                var key = props[0], value = source[key];
                if (isStrictComparable(value)) {
                    return function(object) {
                        if (object == null) {
                            return false;
                        }
                        return object[key] === value && (value !== undefined || key in toObject(object));
                    };
                }
            }
            var values = Array(length), strictCompareFlags = Array(length);
            while (length--) {
                value = source[props[length]];
                values[length] = value;
                strictCompareFlags[length] = isStrictComparable(value);
            }
            return function(object) {
                return object != null && baseIsMatch(toObject(object), props, values, strictCompareFlags);
            };
        }
        function baseMatchesProperty(path, value) {
            var isArr = isArray(path), isCommon = isKey(path) && isStrictComparable(value), pathKey = path + "";
            path = toPath(path);
            return function(object) {
                if (object == null) {
                    return false;
                }
                var key = pathKey;
                object = toObject(object);
                if ((isArr || !isCommon) && !(key in object)) {
                    object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                    if (object == null) {
                        return false;
                    }
                    key = last(path);
                    object = toObject(object);
                }
                return object[key] === value ? value !== undefined || key in object : baseIsEqual(value, object[key], null, true);
            };
        }
        function baseMerge(object, source, customizer, stackA, stackB) {
            if (!isObject(object)) {
                return object;
            }
            var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source));
            if (!isSrcArr) {
                var props = keys(source);
                push.apply(props, getSymbols(source));
            }
            arrayEach(props || source, function(srcValue, key) {
                if (props) {
                    key = srcValue;
                    srcValue = source[key];
                }
                if (isObjectLike(srcValue)) {
                    stackA || (stackA = []);
                    stackB || (stackB = []);
                    baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
                } else {
                    var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : undefined, isCommon = result === undefined;
                    if (isCommon) {
                        result = srcValue;
                    }
                    if ((isSrcArr || result !== undefined) && (isCommon || (result === result ? result !== value : value === value))) {
                        object[key] = result;
                    }
                }
            });
            return object;
        }
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
            var length = stackA.length, srcValue = source[key];
            while (length--) {
                if (stackA[length] == srcValue) {
                    object[key] = stackB[length];
                    return;
                }
            }
            var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : undefined, isCommon = result === undefined;
            if (isCommon) {
                result = srcValue;
                if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
                    result = isArray(value) ? value : isArrayLike(value) ? arrayCopy(value) : [];
                } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    result = isArguments(value) ? toPlainObject(value) : isPlainObject(value) ? value : {};
                } else {
                    isCommon = false;
                }
            }
            stackA.push(srcValue);
            stackB.push(result);
            if (isCommon) {
                object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
            } else if (result === result ? result !== value : value === value) {
                object[key] = result;
            }
        }
        function baseProperty(key) {
            return function(object) {
                return object == null ? undefined : object[key];
            };
        }
        function basePropertyDeep(path) {
            var pathKey = path + "";
            path = toPath(path);
            return function(object) {
                return baseGet(object, path, pathKey);
            };
        }
        function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0;
            while (length--) {
                var index = parseFloat(indexes[length]);
                if (index != previous && isIndex(index)) {
                    var previous = index;
                    splice.call(array, index, 1);
                }
            }
            return array;
        }
        function baseRandom(min, max) {
            return min + floor(nativeRandom() * (max - min + 1));
        }
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
            eachFunc(collection, function(value, index, collection) {
                accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
            });
            return accumulator;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
        };
        function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            start = start == null ? 0 : +start || 0;
            if (start < 0) {
                start = -start > length ? 0 : length + start;
            }
            end = end === undefined || end > length ? length : +end || 0;
            if (end < 0) {
                end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result = Array(length);
            while (++index < length) {
                result[index] = array[index + start];
            }
            return result;
        }
        function baseSome(collection, predicate) {
            var result;
            baseEach(collection, function(value, index, collection) {
                result = predicate(value, index, collection);
                return !result;
            });
            return !!result;
        }
        function baseSortBy(array, comparer) {
            var length = array.length;
            array.sort(comparer);
            while (length--) {
                array[length] = array[length].value;
            }
            return array;
        }
        function baseSortByOrder(collection, iteratees, orders) {
            var callback = getCallback(), index = -1;
            iteratees = arrayMap(iteratees, function(iteratee) {
                return callback(iteratee);
            });
            var result = baseMap(collection, function(value) {
                var criteria = arrayMap(iteratees, function(iteratee) {
                    return iteratee(value);
                });
                return {
                    criteria: criteria,
                    index: ++index,
                    value: value
                };
            });
            return baseSortBy(result, function(object, other) {
                return compareMultiple(object, other, orders);
            });
        }
        function baseSum(collection, iteratee) {
            var result = 0;
            baseEach(collection, function(value, index, collection) {
                result += +iteratee(value, index, collection) || 0;
            });
            return result;
        }
        function baseUniq(array, iteratee) {
            var index = -1, indexOf = getIndexOf(), length = array.length, isCommon = indexOf == baseIndexOf, isLarge = isCommon && length >= 200, seen = isLarge ? createCache() : null, result = [];
            if (seen) {
                indexOf = cacheIndexOf;
                isCommon = false;
            } else {
                isLarge = false;
                seen = iteratee ? [] : result;
            }
            outer: while (++index < length) {
                var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
                if (isCommon && value === value) {
                    var seenIndex = seen.length;
                    while (seenIndex--) {
                        if (seen[seenIndex] === computed) {
                            continue outer;
                        }
                    }
                    if (iteratee) {
                        seen.push(computed);
                    }
                    result.push(value);
                } else if (indexOf(seen, computed, 0) < 0) {
                    if (iteratee || isLarge) {
                        seen.push(computed);
                    }
                    result.push(value);
                }
            }
            return result;
        }
        function baseValues(object, props) {
            var index = -1, length = props.length, result = Array(length);
            while (++index < length) {
                result[index] = object[props[index]];
            }
            return result;
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
            var result = value;
            if (result instanceof LazyWrapper) {
                result = result.value();
            }
            var index = -1, length = actions.length;
            while (++index < length) {
                var args = [ result ], action = actions[index];
                push.apply(args, action.args);
                result = action.func.apply(action.thisArg, args);
            }
            return result;
        }
        function binaryIndex(array, value, retHighest) {
            var low = 0, high = array ? array.length : low;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                while (low < high) {
                    var mid = low + high >>> 1, computed = array[mid];
                    if (retHighest ? computed <= value : computed < value) {
                        low = mid + 1;
                    } else {
                        high = mid;
                    }
                }
                return high;
            }
            return binaryIndexBy(array, value, identity, retHighest);
        }
        function binaryIndexBy(array, value, iteratee, retHighest) {
            value = iteratee(value);
            var low = 0, high = array ? array.length : 0, valIsNaN = value !== value, valIsUndef = value === undefined;
            while (low < high) {
                var mid = floor((low + high) / 2), computed = iteratee(array[mid]), isReflexive = computed === computed;
                if (valIsNaN) {
                    var setLow = isReflexive || retHighest;
                } else if (valIsUndef) {
                    setLow = isReflexive && (retHighest || computed !== undefined);
                } else {
                    setLow = retHighest ? computed <= value : computed < value;
                }
                if (setLow) {
                    low = mid + 1;
                } else {
                    high = mid;
                }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function bindCallback(func, thisArg, argCount) {
            if (typeof func != "function") {
                return identity;
            }
            if (thisArg === undefined) {
                return func;
            }
            switch (argCount) {
              case 1:
                return function(value) {
                    return func.call(thisArg, value);
                };

              case 3:
                return function(value, index, collection) {
                    return func.call(thisArg, value, index, collection);
                };

              case 4:
                return function(accumulator, value, index, collection) {
                    return func.call(thisArg, accumulator, value, index, collection);
                };

              case 5:
                return function(value, other, key, object, source) {
                    return func.call(thisArg, value, other, key, object, source);
                };
            }
            return function() {
                return func.apply(thisArg, arguments);
            };
        }
        function bufferClone(buffer) {
            return bufferSlice.call(buffer, 0);
        }
        if (!bufferSlice) {
            bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
                var byteLength = buffer.byteLength, floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0, offset = floatLength * FLOAT64_BYTES_PER_ELEMENT, result = new ArrayBuffer(byteLength);
                if (floatLength) {
                    var view = new Float64Array(result, 0, floatLength);
                    view.set(new Float64Array(buffer, 0, floatLength));
                }
                if (byteLength != offset) {
                    view = new Uint8Array(result, offset);
                    view.set(new Uint8Array(buffer, offset));
                }
                return result;
            };
        }
        function composeArgs(args, partials, holders) {
            var holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), leftIndex = -1, leftLength = partials.length, result = Array(argsLength + leftLength);
            while (++leftIndex < leftLength) {
                result[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
                result[holders[argsIndex]] = args[argsIndex];
            }
            while (argsLength--) {
                result[leftIndex++] = args[argsIndex++];
            }
            return result;
        }
        function composeArgsRight(args, partials, holders) {
            var holdersIndex = -1, holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), rightIndex = -1, rightLength = partials.length, result = Array(argsLength + rightLength);
            while (++argsIndex < argsLength) {
                result[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
                result[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
                result[offset + holders[holdersIndex]] = args[argsIndex++];
            }
            return result;
        }
        function createAggregator(setter, initializer) {
            return function(collection, iteratee, thisArg) {
                var result = initializer ? initializer() : {};
                iteratee = getCallback(iteratee, thisArg, 3);
                if (isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        var value = collection[index];
                        setter(result, value, iteratee(value, index, collection), collection);
                    }
                } else {
                    baseEach(collection, function(value, key, collection) {
                        setter(result, value, iteratee(value, key, collection), collection);
                    });
                }
                return result;
            };
        }
        function createAssigner(assigner) {
            return restParam(function(object, sources) {
                var index = -1, length = object == null ? 0 : sources.length, customizer = length > 2 && sources[length - 2], guard = length > 2 && sources[2], thisArg = length > 1 && sources[length - 1];
                if (typeof customizer == "function") {
                    customizer = bindCallback(customizer, thisArg, 5);
                    length -= 2;
                } else {
                    customizer = typeof thisArg == "function" ? thisArg : null;
                    length -= customizer ? 1 : 0;
                }
                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? null : customizer;
                    length = 1;
                }
                while (++index < length) {
                    var source = sources[index];
                    if (source) {
                        assigner(object, source, customizer);
                    }
                }
                return object;
            });
        }
        function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee) {
                var length = collection ? getLength(collection) : 0;
                if (!isLength(length)) {
                    return eachFunc(collection, iteratee);
                }
                var index = fromRight ? length : -1, iterable = toObject(collection);
                while (fromRight ? index-- : ++index < length) {
                    if (iteratee(iterable[index], index, iterable) === false) {
                        break;
                    }
                }
                return collection;
            };
        }
        function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
                var iterable = toObject(object), props = keysFunc(object), length = props.length, index = fromRight ? length : -1;
                while (fromRight ? index-- : ++index < length) {
                    var key = props[index];
                    if (iteratee(iterable[key], key, iterable) === false) {
                        break;
                    }
                }
                return object;
            };
        }
        function createBindWrapper(func, thisArg) {
            var Ctor = createCtorWrapper(func);
            function wrapper() {
                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                return fn.apply(thisArg, arguments);
            }
            return wrapper;
        }
        var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
            return new SetCache(values);
        };
        function createCompounder(callback) {
            return function(string) {
                var index = -1, array = words(deburr(string)), length = array.length, result = "";
                while (++index < length) {
                    result = callback(result, array[index], index);
                }
                return result;
            };
        }
        function createCtorWrapper(Ctor) {
            return function() {
                var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, arguments);
                return isObject(result) ? result : thisBinding;
            };
        }
        function createCurry(flag) {
            function curryFunc(func, arity, guard) {
                if (guard && isIterateeCall(func, arity, guard)) {
                    arity = null;
                }
                var result = createWrapper(func, flag, null, null, null, null, null, arity);
                result.placeholder = curryFunc.placeholder;
                return result;
            }
            return curryFunc;
        }
        function createExtremum(arrayFunc, isMin) {
            return function(collection, iteratee, thisArg) {
                if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                    iteratee = null;
                }
                var func = getCallback(), noIteratee = iteratee == null;
                if (!(func === baseCallback && noIteratee)) {
                    noIteratee = false;
                    iteratee = func(iteratee, thisArg, 3);
                }
                if (noIteratee) {
                    var isArr = isArray(collection);
                    if (!isArr && isString(collection)) {
                        iteratee = charAtCallback;
                    } else {
                        return arrayFunc(isArr ? collection : toIterable(collection));
                    }
                }
                return extremumBy(collection, iteratee, isMin);
            };
        }
        function createFind(eachFunc, fromRight) {
            return function(collection, predicate, thisArg) {
                predicate = getCallback(predicate, thisArg, 3);
                if (isArray(collection)) {
                    var index = baseFindIndex(collection, predicate, fromRight);
                    return index > -1 ? collection[index] : undefined;
                }
                return baseFind(collection, predicate, eachFunc);
            };
        }
        function createFindIndex(fromRight) {
            return function(array, predicate, thisArg) {
                if (!(array && array.length)) {
                    return -1;
                }
                predicate = getCallback(predicate, thisArg, 3);
                return baseFindIndex(array, predicate, fromRight);
            };
        }
        function createFindKey(objectFunc) {
            return function(object, predicate, thisArg) {
                predicate = getCallback(predicate, thisArg, 3);
                return baseFind(object, predicate, objectFunc, true);
            };
        }
        function createFlow(fromRight) {
            return function() {
                var length = arguments.length;
                if (!length) {
                    return function() {
                        return arguments[0];
                    };
                }
                var wrapper, index = fromRight ? length : -1, leftIndex = 0, funcs = Array(length);
                while (fromRight ? index-- : ++index < length) {
                    var func = funcs[leftIndex++] = arguments[index];
                    if (typeof func != "function") {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    var funcName = wrapper ? "" : getFuncName(func);
                    wrapper = funcName == "wrapper" ? new LodashWrapper([]) : wrapper;
                }
                index = wrapper ? -1 : length;
                while (++index < length) {
                    func = funcs[index];
                    funcName = getFuncName(func);
                    var data = funcName == "wrapper" ? getData(func) : null;
                    if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                    } else {
                        wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                    }
                }
                return function() {
                    var args = arguments;
                    if (wrapper && args.length == 1 && isArray(args[0])) {
                        return wrapper.plant(args[0]).value();
                    }
                    var index = 0, result = funcs[index].apply(this, args);
                    while (++index < length) {
                        result = funcs[index].call(this, result);
                    }
                    return result;
                };
            };
        }
        function createForEach(arrayFunc, eachFunc) {
            return function(collection, iteratee, thisArg) {
                return typeof iteratee == "function" && thisArg === undefined && isArray(collection) ? arrayFunc(collection, iteratee) : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
            };
        }
        function createForIn(objectFunc) {
            return function(object, iteratee, thisArg) {
                if (typeof iteratee != "function" || thisArg !== undefined) {
                    iteratee = bindCallback(iteratee, thisArg, 3);
                }
                return objectFunc(object, iteratee, keysIn);
            };
        }
        function createForOwn(objectFunc) {
            return function(object, iteratee, thisArg) {
                if (typeof iteratee != "function" || thisArg !== undefined) {
                    iteratee = bindCallback(iteratee, thisArg, 3);
                }
                return objectFunc(object, iteratee);
            };
        }
        function createObjectMapper(isMapKeys) {
            return function(object, iteratee, thisArg) {
                var result = {};
                iteratee = getCallback(iteratee, thisArg, 3);
                baseForOwn(object, function(value, key, object) {
                    var mapped = iteratee(value, key, object);
                    key = isMapKeys ? mapped : key;
                    value = isMapKeys ? value : mapped;
                    result[key] = value;
                });
                return result;
            };
        }
        function createPadDir(fromRight) {
            return function(string, length, chars) {
                string = baseToString(string);
                return (fromRight ? string : "") + createPadding(string, length, chars) + (fromRight ? "" : string);
            };
        }
        function createPartial(flag) {
            var partialFunc = restParam(function(func, partials) {
                var holders = replaceHolders(partials, partialFunc.placeholder);
                return createWrapper(func, flag, null, partials, holders);
            });
            return partialFunc;
        }
        function createReduce(arrayFunc, eachFunc) {
            return function(collection, iteratee, accumulator, thisArg) {
                var initFromArray = arguments.length < 3;
                return typeof iteratee == "function" && thisArg === undefined && isArray(collection) ? arrayFunc(collection, iteratee, accumulator, initFromArray) : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
            };
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurry = bitmask & CURRY_FLAG, isCurryBound = bitmask & CURRY_BOUND_FLAG, isCurryRight = bitmask & CURRY_RIGHT_FLAG;
            var Ctor = !isBindKey && createCtorWrapper(func), key = func;
            function wrapper() {
                var length = arguments.length, index = length, args = Array(length);
                while (index--) {
                    args[index] = arguments[index];
                }
                if (partials) {
                    args = composeArgs(args, partials, holders);
                }
                if (partialsRight) {
                    args = composeArgsRight(args, partialsRight, holdersRight);
                }
                if (isCurry || isCurryRight) {
                    var placeholder = wrapper.placeholder, argsHolders = replaceHolders(args, placeholder);
                    length -= argsHolders.length;
                    if (length < arity) {
                        var newArgPos = argPos ? arrayCopy(argPos) : null, newArity = nativeMax(arity - length, 0), newsHolders = isCurry ? argsHolders : null, newHoldersRight = isCurry ? null : argsHolders, newPartials = isCurry ? args : null, newPartialsRight = isCurry ? null : args;
                        bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
                        bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                        if (!isCurryBound) {
                            bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                        }
                        var newData = [ func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity ], result = createHybridWrapper.apply(undefined, newData);
                        if (isLaziable(func)) {
                            setData(result, newData);
                        }
                        result.placeholder = placeholder;
                        return result;
                    }
                }
                var thisBinding = isBind ? thisArg : this;
                if (isBindKey) {
                    func = thisBinding[key];
                }
                if (argPos) {
                    args = reorder(args, argPos);
                }
                if (isAry && ary < args.length) {
                    args.length = ary;
                }
                var fn = this && this !== root && this instanceof wrapper ? Ctor || createCtorWrapper(func) : func;
                return fn.apply(thisBinding, args);
            }
            return wrapper;
        }
        function createPadding(string, length, chars) {
            var strLength = string.length;
            length = +length;
            if (strLength >= length || !nativeIsFinite(length)) {
                return "";
            }
            var padLength = length - strLength;
            chars = chars == null ? " " : chars + "";
            return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
            var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
            function wrapper() {
                var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(argsLength + leftLength);
                while (++leftIndex < leftLength) {
                    args[leftIndex] = partials[leftIndex];
                }
                while (argsLength--) {
                    args[leftIndex++] = arguments[++argsIndex];
                }
                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                return fn.apply(isBind ? thisArg : this, args);
            }
            return wrapper;
        }
        function createSortedIndex(retHighest) {
            return function(array, value, iteratee, thisArg) {
                var func = getCallback(iteratee);
                return func === baseCallback && iteratee == null ? binaryIndex(array, value, retHighest) : binaryIndexBy(array, value, func(iteratee, thisArg, 1), retHighest);
            };
        }
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
                bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                partials = holders = null;
            }
            length -= holders ? holders.length : 0;
            if (bitmask & PARTIAL_RIGHT_FLAG) {
                var partialsRight = partials, holdersRight = holders;
                partials = holders = null;
            }
            var data = isBindKey ? null : getData(func), newData = [ func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity ];
            if (data) {
                mergeData(newData, data);
                bitmask = newData[1];
                arity = newData[9];
            }
            newData[9] = arity == null ? isBindKey ? 0 : func.length : nativeMax(arity - length, 0) || 0;
            if (bitmask == BIND_FLAG) {
                var result = createBindWrapper(newData[0], newData[2]);
            } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
                result = createPartialWrapper.apply(undefined, newData);
            } else {
                result = createHybridWrapper.apply(undefined, newData);
            }
            var setter = data ? baseSetData : setData;
            return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var index = -1, arrLength = array.length, othLength = other.length, result = true;
            if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
                return false;
            }
            while (result && ++index < arrLength) {
                var arrValue = array[index], othValue = other[index];
                result = undefined;
                if (customizer) {
                    result = isLoose ? customizer(othValue, arrValue, index) : customizer(arrValue, othValue, index);
                }
                if (result === undefined) {
                    if (isLoose) {
                        var othIndex = othLength;
                        while (othIndex--) {
                            othValue = other[othIndex];
                            result = arrValue && arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                            if (result) {
                                break;
                            }
                        }
                    } else {
                        result = arrValue && arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                    }
                }
            }
            return !!result;
        }
        function equalByTag(object, other, tag) {
            switch (tag) {
              case boolTag:
              case dateTag:
                return +object == +other;

              case errorTag:
                return object.name == other.name && object.message == other.message;

              case numberTag:
                return object != +object ? other != +other : object == +other;

              case regexpTag:
              case stringTag:
                return object == other + "";
            }
            return false;
        }
        function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
            if (objLength != othLength && !isLoose) {
                return false;
            }
            var skipCtor = isLoose, index = -1;
            while (++index < objLength) {
                var key = objProps[index], result = isLoose ? key in other : hasOwnProperty.call(other, key);
                if (result) {
                    var objValue = object[key], othValue = other[key];
                    result = undefined;
                    if (customizer) {
                        result = isLoose ? customizer(othValue, objValue, key) : customizer(objValue, othValue, key);
                    }
                    if (result === undefined) {
                        result = objValue && objValue === othValue || equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB);
                    }
                }
                if (!result) {
                    return false;
                }
                skipCtor || (skipCtor = key == "constructor");
            }
            if (!skipCtor) {
                var objCtor = object.constructor, othCtor = other.constructor;
                if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                    return false;
                }
            }
            return true;
        }
        function extremumBy(collection, iteratee, isMin) {
            var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY, computed = exValue, result = computed;
            baseEach(collection, function(value, index, collection) {
                var current = iteratee(value, index, collection);
                if ((isMin ? current < computed : current > computed) || current === exValue && current === result) {
                    computed = current;
                    result = value;
                }
            });
            return result;
        }
        function getCallback(func, thisArg, argCount) {
            var result = lodash.callback || callback;
            result = result === callback ? baseCallback : result;
            return argCount ? result(func, thisArg, argCount) : result;
        }
        var getData = !metaMap ? noop : function(func) {
            return metaMap.get(func);
        };
        var getFuncName = function() {
            if (!support.funcNames) {
                return constant("");
            }
            if (constant.name == "constant") {
                return baseProperty("name");
            }
            return function(func) {
                var result = func.name, array = realNames[result], length = array ? array.length : 0;
                while (length--) {
                    var data = array[length], otherFunc = data.func;
                    if (otherFunc == null || otherFunc == func) {
                        return data.name;
                    }
                }
                return result;
            };
        }();
        function getIndexOf(collection, target, fromIndex) {
            var result = lodash.indexOf || indexOf;
            result = result === indexOf ? baseIndexOf : result;
            return collection ? result(collection, target, fromIndex) : result;
        }
        var getLength = baseProperty("length");
        var getSymbols = !getOwnPropertySymbols ? constant([]) : function(object) {
            return getOwnPropertySymbols(toObject(object));
        };
        function getView(start, end, transforms) {
            var index = -1, length = transforms ? transforms.length : 0;
            while (++index < length) {
                var data = transforms[index], size = data.size;
                switch (data.type) {
                  case "drop":
                    start += size;
                    break;

                  case "dropRight":
                    end -= size;
                    break;

                  case "take":
                    end = nativeMin(end, start + size);
                    break;

                  case "takeRight":
                    start = nativeMax(start, end - size);
                    break;
                }
            }
            return {
                start: start,
                end: end
            };
        }
        function initCloneArray(array) {
            var length = array.length, result = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                result.index = array.index;
                result.input = array.input;
            }
            return result;
        }
        function initCloneObject(object) {
            var Ctor = object.constructor;
            if (!(typeof Ctor == "function" && Ctor instanceof Ctor)) {
                Ctor = Object;
            }
            return new Ctor();
        }
        function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return bufferClone(object);

              case boolTag:
              case dateTag:
                return new Ctor(+object);

              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                var buffer = object.buffer;
                return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

              case numberTag:
              case stringTag:
                return new Ctor(object);

              case regexpTag:
                var result = new Ctor(object.source, reFlags.exec(object));
                result.lastIndex = object.lastIndex;
            }
            return result;
        }
        function invokePath(object, path, args) {
            if (object != null && !isKey(path, object)) {
                path = toPath(path);
                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                path = last(path);
            }
            var func = object == null ? object : object[path];
            return func == null ? undefined : func.apply(object, args);
        }
        function isArrayLike(value) {
            return value != null && isLength(getLength(value));
        }
        function isIndex(value, length) {
            value = +value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
                return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
                var other = object[index];
                return value === value ? value === other : other !== other;
            }
            return false;
        }
        function isKey(value, object) {
            var type = typeof value;
            if (type == "string" && reIsPlainProp.test(value) || type == "number") {
                return true;
            }
            if (isArray(value)) {
                return false;
            }
            var result = !reIsDeepProp.test(value);
            return result || object != null && value in toObject(object);
        }
        function isLaziable(func) {
            var funcName = getFuncName(func);
            return !!funcName && func === lodash[funcName] && funcName in LazyWrapper.prototype;
        }
        function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isStrictComparable(value) {
            return value === value && !isObject(value);
        }
        function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < ARY_FLAG;
            var isCombo = srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG || srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8] || srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG;
            if (!(isCommon || isCombo)) {
                return data;
            }
            if (srcBitmask & BIND_FLAG) {
                data[2] = source[2];
                newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
                var partials = data[3];
                data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
                data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
            }
            value = source[5];
            if (value) {
                partials = data[5];
                data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
                data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
            }
            value = source[7];
            if (value) {
                data[7] = arrayCopy(value);
            }
            if (srcBitmask & ARY_FLAG) {
                data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
                data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
        }
        function pickByArray(object, props) {
            object = toObject(object);
            var index = -1, length = props.length, result = {};
            while (++index < length) {
                var key = props[index];
                if (key in object) {
                    result[key] = object[key];
                }
            }
            return result;
        }
        function pickByCallback(object, predicate) {
            var result = {};
            baseForIn(object, function(value, key, object) {
                if (predicate(value, key, object)) {
                    result[key] = value;
                }
            });
            return result;
        }
        function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = arrayCopy(array);
            while (length--) {
                var index = indexes[length];
                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }
            return array;
        }
        var setData = function() {
            var count = 0, lastCalled = 0;
            return function(key, value) {
                var stamp = now(), remaining = HOT_SPAN - (stamp - lastCalled);
                lastCalled = stamp;
                if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                        return key;
                    }
                } else {
                    count = 0;
                }
                return baseSetData(key, value);
            };
        }();
        function shimIsPlainObject(value) {
            var Ctor, support = lodash.support;
            if (!(isObjectLike(value) && objToString.call(value) == objectTag) || !hasOwnProperty.call(value, "constructor") && (Ctor = value.constructor, 
            typeof Ctor == "function" && !(Ctor instanceof Ctor))) {
                return false;
            }
            var result;
            baseForIn(value, function(subValue, key) {
                result = key;
            });
            return result === undefined || hasOwnProperty.call(value, result);
        }
        function shimKeys(object) {
            var props = keysIn(object), propsLength = props.length, length = propsLength && object.length, support = lodash.support;
            var allowIndexes = length && isLength(length) && (isArray(object) || support.nonEnumArgs && isArguments(object));
            var index = -1, result = [];
            while (++index < propsLength) {
                var key = props[index];
                if (allowIndexes && isIndex(key, length) || hasOwnProperty.call(object, key)) {
                    result.push(key);
                }
            }
            return result;
        }
        function toIterable(value) {
            if (value == null) {
                return [];
            }
            if (!isArrayLike(value)) {
                return values(value);
            }
            return isObject(value) ? value : Object(value);
        }
        function toObject(value) {
            return isObject(value) ? value : Object(value);
        }
        function toPath(value) {
            if (isArray(value)) {
                return value;
            }
            var result = [];
            baseToString(value).replace(rePropName, function(match, number, quote, string) {
                result.push(quote ? string.replace(reEscapeChar, "$1") : number || match);
            });
            return result;
        }
        function wrapperClone(wrapper) {
            return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
        function chunk(array, size, guard) {
            if (guard ? isIterateeCall(array, size, guard) : size == null) {
                size = 1;
            } else {
                size = nativeMax(+size || 1, 1);
            }
            var index = 0, length = array ? array.length : 0, resIndex = -1, result = Array(ceil(length / size));
            while (index < length) {
                result[++resIndex] = baseSlice(array, index, index += size);
            }
            return result;
        }
        function compact(array) {
            var index = -1, length = array ? array.length : 0, resIndex = -1, result = [];
            while (++index < length) {
                var value = array[index];
                if (value) {
                    result[++resIndex] = value;
                }
            }
            return result;
        }
        var difference = restParam(function(array, values) {
            return isArrayLike(array) ? baseDifference(array, baseFlatten(values, false, true)) : [];
        });
        function drop(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
                n = 1;
            }
            return baseSlice(array, n < 0 ? 0 : n);
        }
        function dropRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
                n = 1;
            }
            n = length - (+n || 0);
            return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate, thisArg) {
            return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true) : [];
        }
        function dropWhile(array, predicate, thisArg) {
            return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), true) : [];
        }
        function fill(array, value, start, end) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
                start = 0;
                end = length;
            }
            return baseFill(array, value, start, end);
        }
        var findIndex = createFindIndex();
        var findLastIndex = createFindIndex(true);
        function first(array) {
            return array ? array[0] : undefined;
        }
        function flatten(array, isDeep, guard) {
            var length = array ? array.length : 0;
            if (guard && isIterateeCall(array, isDeep, guard)) {
                isDeep = false;
            }
            return length ? baseFlatten(array, isDeep) : [];
        }
        function flattenDeep(array) {
            var length = array ? array.length : 0;
            return length ? baseFlatten(array, true) : [];
        }
        function indexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) {
                return -1;
            }
            if (typeof fromIndex == "number") {
                fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
            } else if (fromIndex) {
                var index = binaryIndex(array, value), other = array[index];
                if (value === value ? value === other : other !== other) {
                    return index;
                }
                return -1;
            }
            return baseIndexOf(array, value, fromIndex || 0);
        }
        function initial(array) {
            return dropRight(array, 1);
        }
        function intersection() {
            var args = [], argsIndex = -1, argsLength = arguments.length, caches = [], indexOf = getIndexOf(), isCommon = indexOf == baseIndexOf, result = [];
            while (++argsIndex < argsLength) {
                var value = arguments[argsIndex];
                if (isArrayLike(value)) {
                    args.push(value);
                    caches.push(isCommon && value.length >= 120 ? createCache(argsIndex && value) : null);
                }
            }
            argsLength = args.length;
            if (argsLength < 2) {
                return result;
            }
            var array = args[0], index = -1, length = array ? array.length : 0, seen = caches[0];
            outer: while (++index < length) {
                value = array[index];
                if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
                    argsIndex = argsLength;
                    while (--argsIndex) {
                        var cache = caches[argsIndex];
                        if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value, 0)) < 0) {
                            continue outer;
                        }
                    }
                    if (seen) {
                        seen.push(value);
                    }
                    result.push(value);
                }
            }
            return result;
        }
        function last(array) {
            var length = array ? array.length : 0;
            return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) {
                return -1;
            }
            var index = length;
            if (typeof fromIndex == "number") {
                index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
            } else if (fromIndex) {
                index = binaryIndex(array, value, true) - 1;
                var other = array[index];
                if (value === value ? value === other : other !== other) {
                    return index;
                }
                return -1;
            }
            if (value !== value) {
                return indexOfNaN(array, index, true);
            }
            while (index--) {
                if (array[index] === value) {
                    return index;
                }
            }
            return -1;
        }
        function pull() {
            var args = arguments, array = args[0];
            if (!(array && array.length)) {
                return array;
            }
            var index = 0, indexOf = getIndexOf(), length = args.length;
            while (++index < length) {
                var fromIndex = 0, value = args[index];
                while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
                    splice.call(array, fromIndex, 1);
                }
            }
            return array;
        }
        var pullAt = restParam(function(array, indexes) {
            indexes = baseFlatten(indexes);
            var result = baseAt(array, indexes);
            basePullAt(array, indexes.sort(baseCompareAscending));
            return result;
        });
        function remove(array, predicate, thisArg) {
            var result = [];
            if (!(array && array.length)) {
                return result;
            }
            var index = -1, indexes = [], length = array.length;
            predicate = getCallback(predicate, thisArg, 3);
            while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                    result.push(value);
                    indexes.push(index);
                }
            }
            basePullAt(array, indexes);
            return result;
        }
        function rest(array) {
            return drop(array, 1);
        }
        function slice(array, start, end) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
                start = 0;
                end = length;
            }
            return baseSlice(array, start, end);
        }
        var sortedIndex = createSortedIndex();
        var sortedLastIndex = createSortedIndex(true);
        function take(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
                n = 1;
            }
            return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
                n = 1;
            }
            n = length - (+n || 0);
            return baseSlice(array, n < 0 ? 0 : n);
        }
        function takeRightWhile(array, predicate, thisArg) {
            return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true) : [];
        }
        function takeWhile(array, predicate, thisArg) {
            return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3)) : [];
        }
        var union = restParam(function(arrays) {
            return baseUniq(baseFlatten(arrays, false, true));
        });
        function uniq(array, isSorted, iteratee, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (isSorted != null && typeof isSorted != "boolean") {
                thisArg = iteratee;
                iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
                isSorted = false;
            }
            var func = getCallback();
            if (!(func === baseCallback && iteratee == null)) {
                iteratee = func(iteratee, thisArg, 3);
            }
            return isSorted && getIndexOf() == baseIndexOf ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
        }
        function unzip(array) {
            if (!(array && array.length)) {
                return [];
            }
            var index = -1, length = 0;
            array = arrayFilter(array, function(group) {
                if (isArrayLike(group)) {
                    length = nativeMax(group.length, length);
                    return true;
                }
            });
            var result = Array(length);
            while (++index < length) {
                result[index] = arrayMap(array, baseProperty(index));
            }
            return result;
        }
        function unzipWith(array, iteratee, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            var result = unzip(array);
            if (iteratee == null) {
                return result;
            }
            iteratee = bindCallback(iteratee, thisArg, 4);
            return arrayMap(result, function(group) {
                return arrayReduce(group, iteratee, undefined, true);
            });
        }
        var without = restParam(function(array, values) {
            return isArrayLike(array) ? baseDifference(array, values) : [];
        });
        function xor() {
            var index = -1, length = arguments.length;
            while (++index < length) {
                var array = arguments[index];
                if (isArrayLike(array)) {
                    var result = result ? baseDifference(result, array).concat(baseDifference(array, result)) : array;
                }
            }
            return result ? baseUniq(result) : [];
        }
        var zip = restParam(unzip);
        function zipObject(props, values) {
            var index = -1, length = props ? props.length : 0, result = {};
            if (length && !values && !isArray(props[0])) {
                values = [];
            }
            while (++index < length) {
                var key = props[index];
                if (values) {
                    result[key] = values[index];
                } else if (key) {
                    result[key[0]] = key[1];
                }
            }
            return result;
        }
        var zipWith = restParam(function(arrays) {
            var length = arrays.length, iteratee = arrays[length - 2], thisArg = arrays[length - 1];
            if (length > 2 && typeof iteratee == "function") {
                length -= 2;
            } else {
                iteratee = length > 1 && typeof thisArg == "function" ? (--length, thisArg) : undefined;
                thisArg = undefined;
            }
            arrays.length = length;
            return unzipWith(arrays, iteratee, thisArg);
        });
        function chain(value) {
            var result = lodash(value);
            result.__chain__ = true;
            return result;
        }
        function tap(value, interceptor, thisArg) {
            interceptor.call(thisArg, value);
            return value;
        }
        function thru(value, interceptor, thisArg) {
            return interceptor.call(thisArg, value);
        }
        function wrapperChain() {
            return chain(this);
        }
        function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperPlant(value) {
            var result, parent = this;
            while (parent instanceof baseLodash) {
                var clone = wrapperClone(parent);
                if (result) {
                    previous.__wrapped__ = clone;
                } else {
                    result = clone;
                }
                var previous = clone;
                parent = parent.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result;
        }
        function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
                if (this.__actions__.length) {
                    value = new LazyWrapper(this);
                }
                return new LodashWrapper(value.reverse(), this.__chain__);
            }
            return this.thru(function(value) {
                return value.reverse();
            });
        }
        function wrapperToString() {
            return this.value() + "";
        }
        function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var at = restParam(function(collection, props) {
            return baseAt(collection, baseFlatten(props));
        });
        var countBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? ++result[key] : result[key] = 1;
        });
        function every(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                predicate = null;
            }
            if (typeof predicate != "function" || thisArg !== undefined) {
                predicate = getCallback(predicate, thisArg, 3);
            }
            return func(collection, predicate);
        }
        function filter(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = getCallback(predicate, thisArg, 3);
            return func(collection, predicate);
        }
        var find = createFind(baseEach);
        var findLast = createFind(baseEachRight, true);
        function findWhere(collection, source) {
            return find(collection, baseMatches(source));
        }
        var forEach = createForEach(arrayEach, baseEach);
        var forEachRight = createForEach(arrayEachRight, baseEachRight);
        var groupBy = createAggregator(function(result, value, key) {
            if (hasOwnProperty.call(result, key)) {
                result[key].push(value);
            } else {
                result[key] = [ value ];
            }
        });
        function includes(collection, target, fromIndex, guard) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) {
                collection = values(collection);
                length = collection.length;
            }
            if (!length) {
                return false;
            }
            if (typeof fromIndex != "number" || guard && isIterateeCall(target, fromIndex, guard)) {
                fromIndex = 0;
            } else {
                fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex || 0;
            }
            return typeof collection == "string" || !isArray(collection) && isString(collection) ? fromIndex < length && collection.indexOf(target, fromIndex) > -1 : getIndexOf(collection, target, fromIndex) > -1;
        }
        var indexBy = createAggregator(function(result, value, key) {
            result[key] = value;
        });
        var invoke = restParam(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", isProp = isKey(path), result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function(value) {
                var func = isFunc ? path : isProp && value != null && value[path];
                result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
            });
            return result;
        });
        function map(collection, iteratee, thisArg) {
            var func = isArray(collection) ? arrayMap : baseMap;
            iteratee = getCallback(iteratee, thisArg, 3);
            return func(collection, iteratee);
        }
        var partition = createAggregator(function(result, value, key) {
            result[key ? 0 : 1].push(value);
        }, function() {
            return [ [], [] ];
        });
        function pluck(collection, path) {
            return map(collection, property(path));
        }
        var reduce = createReduce(arrayReduce, baseEach);
        var reduceRight = createReduce(arrayReduceRight, baseEachRight);
        function reject(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = getCallback(predicate, thisArg, 3);
            return func(collection, function(value, index, collection) {
                return !predicate(value, index, collection);
            });
        }
        function sample(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n == null) {
                collection = toIterable(collection);
                var length = collection.length;
                return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
            }
            var result = shuffle(collection);
            result.length = nativeMin(n < 0 ? 0 : +n || 0, result.length);
            return result;
        }
        function shuffle(collection) {
            collection = toIterable(collection);
            var index = -1, length = collection.length, result = Array(length);
            while (++index < length) {
                var rand = baseRandom(0, index);
                if (index != rand) {
                    result[index] = result[rand];
                }
                result[rand] = collection[index];
            }
            return result;
        }
        function size(collection) {
            var length = collection ? getLength(collection) : 0;
            return isLength(length) ? length : keys(collection).length;
        }
        function some(collection, predicate, thisArg) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                predicate = null;
            }
            if (typeof predicate != "function" || thisArg !== undefined) {
                predicate = getCallback(predicate, thisArg, 3);
            }
            return func(collection, predicate);
        }
        function sortBy(collection, iteratee, thisArg) {
            if (collection == null) {
                return [];
            }
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                iteratee = null;
            }
            var index = -1;
            iteratee = getCallback(iteratee, thisArg, 3);
            var result = baseMap(collection, function(value, key, collection) {
                return {
                    criteria: iteratee(value, key, collection),
                    index: ++index,
                    value: value
                };
            });
            return baseSortBy(result, compareAscending);
        }
        var sortByAll = restParam(function(collection, iteratees) {
            if (collection == null) {
                return [];
            }
            var guard = iteratees[2];
            if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
                iteratees.length = 1;
            }
            return baseSortByOrder(collection, baseFlatten(iteratees), []);
        });
        function sortByOrder(collection, iteratees, orders, guard) {
            if (collection == null) {
                return [];
            }
            if (guard && isIterateeCall(iteratees, orders, guard)) {
                orders = null;
            }
            if (!isArray(iteratees)) {
                iteratees = iteratees == null ? [] : [ iteratees ];
            }
            if (!isArray(orders)) {
                orders = orders == null ? [] : [ orders ];
            }
            return baseSortByOrder(collection, iteratees, orders);
        }
        function where(collection, source) {
            return filter(collection, baseMatches(source));
        }
        var now = nativeNow || function() {
            return new Date().getTime();
        };
        function after(n, func) {
            if (typeof func != "function") {
                if (typeof n == "function") {
                    var temp = n;
                    n = func;
                    func = temp;
                } else {
                    throw new TypeError(FUNC_ERROR_TEXT);
                }
            }
            n = nativeIsFinite(n = +n) ? n : 0;
            return function() {
                if (--n < 1) {
                    return func.apply(this, arguments);
                }
            };
        }
        function ary(func, n, guard) {
            if (guard && isIterateeCall(func, n, guard)) {
                n = null;
            }
            n = func && n == null ? func.length : nativeMax(+n || 0, 0);
            return createWrapper(func, ARY_FLAG, null, null, null, null, n);
        }
        function before(n, func) {
            var result;
            if (typeof func != "function") {
                if (typeof n == "function") {
                    var temp = n;
                    n = func;
                    func = temp;
                } else {
                    throw new TypeError(FUNC_ERROR_TEXT);
                }
            }
            return function() {
                if (--n > 0) {
                    result = func.apply(this, arguments);
                }
                if (n <= 1) {
                    func = null;
                }
                return result;
            };
        }
        var bind = restParam(function(func, thisArg, partials) {
            var bitmask = BIND_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, bind.placeholder);
                bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(func, bitmask, thisArg, partials, holders);
        });
        var bindAll = restParam(function(object, methodNames) {
            methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
            var index = -1, length = methodNames.length;
            while (++index < length) {
                var key = methodNames[index];
                object[key] = createWrapper(object[key], BIND_FLAG, object);
            }
            return object;
        });
        var bindKey = restParam(function(object, key, partials) {
            var bitmask = BIND_FLAG | BIND_KEY_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, bindKey.placeholder);
                bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(key, bitmask, object, partials, holders);
        });
        var curry = createCurry(CURRY_FLAG);
        var curryRight = createCurry(CURRY_RIGHT_FLAG);
        function debounce(func, wait, options) {
            var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            wait = wait < 0 ? 0 : +wait || 0;
            if (options === true) {
                var leading = true;
                trailing = false;
            } else if (isObject(options)) {
                leading = options.leading;
                maxWait = "maxWait" in options && nativeMax(+options.maxWait || 0, wait);
                trailing = "trailing" in options ? options.trailing : trailing;
            }
            function cancel() {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                if (maxTimeoutId) {
                    clearTimeout(maxTimeoutId);
                }
                maxTimeoutId = timeoutId = trailingCall = undefined;
            }
            function delayed() {
                var remaining = wait - (now() - stamp);
                if (remaining <= 0 || remaining > wait) {
                    if (maxTimeoutId) {
                        clearTimeout(maxTimeoutId);
                    }
                    var isCalled = trailingCall;
                    maxTimeoutId = timeoutId = trailingCall = undefined;
                    if (isCalled) {
                        lastCalled = now();
                        result = func.apply(thisArg, args);
                        if (!timeoutId && !maxTimeoutId) {
                            args = thisArg = null;
                        }
                    }
                } else {
                    timeoutId = setTimeout(delayed, remaining);
                }
            }
            function maxDelayed() {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                maxTimeoutId = timeoutId = trailingCall = undefined;
                if (trailing || maxWait !== wait) {
                    lastCalled = now();
                    result = func.apply(thisArg, args);
                    if (!timeoutId && !maxTimeoutId) {
                        args = thisArg = null;
                    }
                }
            }
            function debounced() {
                args = arguments;
                stamp = now();
                thisArg = this;
                trailingCall = trailing && (timeoutId || !leading);
                if (maxWait === false) {
                    var leadingCall = leading && !timeoutId;
                } else {
                    if (!maxTimeoutId && !leading) {
                        lastCalled = stamp;
                    }
                    var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0 || remaining > maxWait;
                    if (isCalled) {
                        if (maxTimeoutId) {
                            maxTimeoutId = clearTimeout(maxTimeoutId);
                        }
                        lastCalled = stamp;
                        result = func.apply(thisArg, args);
                    } else if (!maxTimeoutId) {
                        maxTimeoutId = setTimeout(maxDelayed, remaining);
                    }
                }
                if (isCalled && timeoutId) {
                    timeoutId = clearTimeout(timeoutId);
                } else if (!timeoutId && wait !== maxWait) {
                    timeoutId = setTimeout(delayed, wait);
                }
                if (leadingCall) {
                    isCalled = true;
                    result = func.apply(thisArg, args);
                }
                if (isCalled && !timeoutId && !maxTimeoutId) {
                    args = thisArg = null;
                }
                return result;
            }
            debounced.cancel = cancel;
            return debounced;
        }
        var defer = restParam(function(func, args) {
            return baseDelay(func, 1, args);
        });
        var delay = restParam(function(func, wait, args) {
            return baseDelay(func, wait, args);
        });
        var flow = createFlow();
        var flowRight = createFlow(true);
        function memoize(func, resolver) {
            if (typeof func != "function" || resolver && typeof resolver != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
                var args = arguments, cache = memoized.cache, key = resolver ? resolver.apply(this, args) : args[0];
                if (cache.has(key)) {
                    return cache.get(key);
                }
                var result = func.apply(this, args);
                cache.set(key, result);
                return result;
            };
            memoized.cache = new memoize.Cache();
            return memoized;
        }
        function negate(predicate) {
            if (typeof predicate != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return function() {
                return !predicate.apply(this, arguments);
            };
        }
        function once(func) {
            return before(2, func);
        }
        var partial = createPartial(PARTIAL_FLAG);
        var partialRight = createPartial(PARTIAL_RIGHT_FLAG);
        var rearg = restParam(function(func, indexes) {
            return createWrapper(func, REARG_FLAG, null, null, null, baseFlatten(indexes));
        });
        function restParam(func, start) {
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            start = nativeMax(start === undefined ? func.length - 1 : +start || 0, 0);
            return function() {
                var args = arguments, index = -1, length = nativeMax(args.length - start, 0), rest = Array(length);
                while (++index < length) {
                    rest[index] = args[start + index];
                }
                switch (start) {
                  case 0:
                    return func.call(this, rest);

                  case 1:
                    return func.call(this, args[0], rest);

                  case 2:
                    return func.call(this, args[0], args[1], rest);
                }
                var otherArgs = Array(start + 1);
                index = -1;
                while (++index < start) {
                    otherArgs[index] = args[index];
                }
                otherArgs[start] = rest;
                return func.apply(this, otherArgs);
            };
        }
        function spread(func) {
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return function(array) {
                return func.apply(this, array);
            };
        }
        function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            if (options === false) {
                leading = false;
            } else if (isObject(options)) {
                leading = "leading" in options ? !!options.leading : leading;
                trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            debounceOptions.leading = leading;
            debounceOptions.maxWait = +wait;
            debounceOptions.trailing = trailing;
            return debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
            wrapper = wrapper == null ? identity : wrapper;
            return createWrapper(wrapper, PARTIAL_FLAG, null, [ value ], []);
        }
        function clone(value, isDeep, customizer, thisArg) {
            if (isDeep && typeof isDeep != "boolean" && isIterateeCall(value, isDeep, customizer)) {
                isDeep = false;
            } else if (typeof isDeep == "function") {
                thisArg = customizer;
                customizer = isDeep;
                isDeep = false;
            }
            customizer = typeof customizer == "function" && bindCallback(customizer, thisArg, 1);
            return baseClone(value, isDeep, customizer);
        }
        function cloneDeep(value, customizer, thisArg) {
            customizer = typeof customizer == "function" && bindCallback(customizer, thisArg, 1);
            return baseClone(value, true, customizer);
        }
        function isArguments(value) {
            return isObjectLike(value) && isArrayLike(value) && objToString.call(value) == argsTag;
        }
        var isArray = nativeIsArray || function(value) {
            return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
        };
        function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag;
        }
        function isDate(value) {
            return isObjectLike(value) && objToString.call(value) == dateTag;
        }
        function isElement(value) {
            return !!value && value.nodeType === 1 && isObjectLike(value) && objToString.call(value).indexOf("Element") > -1;
        }
        if (!support.dom) {
            isElement = function(value) {
                return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
            };
        }
        function isEmpty(value) {
            if (value == null) {
                return true;
            }
            if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) || isObjectLike(value) && isFunction(value.splice))) {
                return !value.length;
            }
            return !keys(value).length;
        }
        function isEqual(value, other, customizer, thisArg) {
            customizer = typeof customizer == "function" && bindCallback(customizer, thisArg, 3);
            if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
                return value === other;
            }
            var result = customizer ? customizer(value, other) : undefined;
            return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
            return isObjectLike(value) && typeof value.message == "string" && objToString.call(value) == errorTag;
        }
        var isFinite = nativeNumIsFinite || function(value) {
            return typeof value == "number" && nativeIsFinite(value);
        };
        var isFunction = !(baseIsFunction(/x/) || Uint8Array && !baseIsFunction(Uint8Array)) ? baseIsFunction : function(value) {
            return objToString.call(value) == funcTag;
        };
        function isObject(value) {
            var type = typeof value;
            return type == "function" || !!value && type == "object";
        }
        function isMatch(object, source, customizer, thisArg) {
            var props = keys(source), length = props.length;
            if (!length) {
                return true;
            }
            if (object == null) {
                return false;
            }
            customizer = typeof customizer == "function" && bindCallback(customizer, thisArg, 3);
            object = toObject(object);
            if (!customizer && length == 1) {
                var key = props[0], value = source[key];
                if (isStrictComparable(value)) {
                    return value === object[key] && (value !== undefined || key in object);
                }
            }
            var values = Array(length), strictCompareFlags = Array(length);
            while (length--) {
                value = values[length] = source[props[length]];
                strictCompareFlags[length] = isStrictComparable(value);
            }
            return baseIsMatch(object, props, values, strictCompareFlags, customizer);
        }
        function isNaN(value) {
            return isNumber(value) && value != +value;
        }
        function isNative(value) {
            if (value == null) {
                return false;
            }
            if (objToString.call(value) == funcTag) {
                return reIsNative.test(fnToString.call(value));
            }
            return isObjectLike(value) && reIsHostCtor.test(value);
        }
        function isNull(value) {
            return value === null;
        }
        function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && objToString.call(value) == numberTag;
        }
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
            if (!(value && objToString.call(value) == objectTag)) {
                return false;
            }
            var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
            return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
        };
        function isRegExp(value) {
            return isObjectLike(value) && objToString.call(value) == regexpTag;
        }
        function isString(value) {
            return typeof value == "string" || isObjectLike(value) && objToString.call(value) == stringTag;
        }
        function isTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
        }
        function isUndefined(value) {
            return value === undefined;
        }
        function toArray(value) {
            var length = value ? getLength(value) : 0;
            if (!isLength(length)) {
                return values(value);
            }
            if (!length) {
                return [];
            }
            return arrayCopy(value);
        }
        function toPlainObject(value) {
            return baseCopy(value, keysIn(value));
        }
        var assign = createAssigner(function(object, source, customizer) {
            return customizer ? assignWith(object, source, customizer) : baseAssign(object, source);
        });
        function create(prototype, properties, guard) {
            var result = baseCreate(prototype);
            if (guard && isIterateeCall(prototype, properties, guard)) {
                properties = null;
            }
            return properties ? baseAssign(result, properties) : result;
        }
        var defaults = restParam(function(args) {
            var object = args[0];
            if (object == null) {
                return object;
            }
            args.push(assignDefaults);
            return assign.apply(undefined, args);
        });
        var findKey = createFindKey(baseForOwn);
        var findLastKey = createFindKey(baseForOwnRight);
        var forIn = createForIn(baseFor);
        var forInRight = createForIn(baseForRight);
        var forOwn = createForOwn(baseForOwn);
        var forOwnRight = createForOwn(baseForOwnRight);
        function functions(object) {
            return baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, toPath(path), path + "");
            return result === undefined ? defaultValue : result;
        }
        function has(object, path) {
            if (object == null) {
                return false;
            }
            var result = hasOwnProperty.call(object, path);
            if (!result && !isKey(path)) {
                path = toPath(path);
                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                path = last(path);
                result = object != null && hasOwnProperty.call(object, path);
            }
            return result;
        }
        function invert(object, multiValue, guard) {
            if (guard && isIterateeCall(object, multiValue, guard)) {
                multiValue = null;
            }
            var index = -1, props = keys(object), length = props.length, result = {};
            while (++index < length) {
                var key = props[index], value = object[key];
                if (multiValue) {
                    if (hasOwnProperty.call(result, value)) {
                        result[value].push(key);
                    } else {
                        result[value] = [ key ];
                    }
                } else {
                    result[value] = key;
                }
            }
            return result;
        }
        var keys = !nativeKeys ? shimKeys : function(object) {
            var Ctor = object != null && object.constructor;
            if (typeof Ctor == "function" && Ctor.prototype === object || typeof object != "function" && isArrayLike(object)) {
                return shimKeys(object);
            }
            return isObject(object) ? nativeKeys(object) : [];
        };
        function keysIn(object) {
            if (object == null) {
                return [];
            }
            if (!isObject(object)) {
                object = Object(object);
            }
            var length = object.length;
            length = length && isLength(length) && (isArray(object) || support.nonEnumArgs && isArguments(object)) && length || 0;
            var Ctor = object.constructor, index = -1, isProto = typeof Ctor == "function" && Ctor.prototype === object, result = Array(length), skipIndexes = length > 0;
            while (++index < length) {
                result[index] = index + "";
            }
            for (var key in object) {
                if (!(skipIndexes && isIndex(key, length)) && !(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                    result.push(key);
                }
            }
            return result;
        }
        var mapKeys = createObjectMapper(true);
        var mapValues = createObjectMapper();
        var merge = createAssigner(baseMerge);
        var omit = restParam(function(object, props) {
            if (object == null) {
                return {};
            }
            if (typeof props[0] != "function") {
                var props = arrayMap(baseFlatten(props), String);
                return pickByArray(object, baseDifference(keysIn(object), props));
            }
            var predicate = bindCallback(props[0], props[1], 3);
            return pickByCallback(object, function(value, key, object) {
                return !predicate(value, key, object);
            });
        });
        function pairs(object) {
            var index = -1, props = keys(object), length = props.length, result = Array(length);
            while (++index < length) {
                var key = props[index];
                result[index] = [ key, object[key] ];
            }
            return result;
        }
        var pick = restParam(function(object, props) {
            if (object == null) {
                return {};
            }
            return typeof props[0] == "function" ? pickByCallback(object, bindCallback(props[0], props[1], 3)) : pickByArray(object, baseFlatten(props));
        });
        function result(object, path, defaultValue) {
            var result = object == null ? undefined : object[path];
            if (result === undefined) {
                if (object != null && !isKey(path, object)) {
                    path = toPath(path);
                    object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                    result = object == null ? undefined : object[last(path)];
                }
                result = result === undefined ? defaultValue : result;
            }
            return isFunction(result) ? result.call(object) : result;
        }
        function set(object, path, value) {
            if (object == null) {
                return object;
            }
            var pathKey = path + "";
            path = object[pathKey] != null || isKey(path, object) ? [ pathKey ] : toPath(path);
            var index = -1, length = path.length, endIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
                var key = path[index];
                if (isObject(nested)) {
                    if (index == endIndex) {
                        nested[key] = value;
                    } else if (nested[key] == null) {
                        nested[key] = isIndex(path[index + 1]) ? [] : {};
                    }
                }
                nested = nested[key];
            }
            return object;
        }
        function transform(object, iteratee, accumulator, thisArg) {
            var isArr = isArray(object) || isTypedArray(object);
            iteratee = getCallback(iteratee, thisArg, 4);
            if (accumulator == null) {
                if (isArr || isObject(object)) {
                    var Ctor = object.constructor;
                    if (isArr) {
                        accumulator = isArray(object) ? new Ctor() : [];
                    } else {
                        accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
                    }
                } else {
                    accumulator = {};
                }
            }
            (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
                return iteratee(accumulator, value, index, object);
            });
            return accumulator;
        }
        function values(object) {
            return baseValues(object, keys(object));
        }
        function valuesIn(object) {
            return baseValues(object, keysIn(object));
        }
        function inRange(value, start, end) {
            start = +start || 0;
            if (typeof end === "undefined") {
                end = start;
                start = 0;
            } else {
                end = +end || 0;
            }
            return value >= nativeMin(start, end) && value < nativeMax(start, end);
        }
        function random(min, max, floating) {
            if (floating && isIterateeCall(min, max, floating)) {
                max = floating = null;
            }
            var noMin = min == null, noMax = max == null;
            if (floating == null) {
                if (noMax && typeof min == "boolean") {
                    floating = min;
                    min = 1;
                } else if (typeof max == "boolean") {
                    floating = max;
                    noMax = true;
                }
            }
            if (noMin && noMax) {
                max = 1;
                noMax = false;
            }
            min = +min || 0;
            if (noMax) {
                max = min;
                min = 0;
            } else {
                max = +max || 0;
            }
            if (floating || min % 1 || max % 1) {
                var rand = nativeRandom();
                return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
            }
            return baseRandom(min, max);
        }
        var camelCase = createCompounder(function(result, word, index) {
            word = word.toLowerCase();
            return result + (index ? word.charAt(0).toUpperCase() + word.slice(1) : word);
        });
        function capitalize(string) {
            string = baseToString(string);
            return string && string.charAt(0).toUpperCase() + string.slice(1);
        }
        function deburr(string) {
            string = baseToString(string);
            return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
            string = baseToString(string);
            target = target + "";
            var length = string.length;
            position = position === undefined ? length : nativeMin(position < 0 ? 0 : +position || 0, length);
            position -= target.length;
            return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
            string = baseToString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
            string = baseToString(string);
            return string && reHasRegExpChars.test(string) ? string.replace(reRegExpChars, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result, word, index) {
            return result + (index ? "-" : "") + word.toLowerCase();
        });
        function pad(string, length, chars) {
            string = baseToString(string);
            length = +length;
            var strLength = string.length;
            if (strLength >= length || !nativeIsFinite(length)) {
                return string;
            }
            var mid = (length - strLength) / 2, leftLength = floor(mid), rightLength = ceil(mid);
            chars = createPadding("", rightLength, chars);
            return chars.slice(0, leftLength) + string + chars;
        }
        var padLeft = createPadDir();
        var padRight = createPadDir(true);
        function parseInt(string, radix, guard) {
            if (guard && isIterateeCall(string, radix, guard)) {
                radix = 0;
            }
            return nativeParseInt(string, radix);
        }
        if (nativeParseInt(whitespace + "08") != 8) {
            parseInt = function(string, radix, guard) {
                if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
                    radix = 0;
                } else if (radix) {
                    radix = +radix;
                }
                string = trim(string);
                return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
            };
        }
        function repeat(string, n) {
            var result = "";
            string = baseToString(string);
            n = +n;
            if (n < 1 || !string || !nativeIsFinite(n)) {
                return result;
            }
            do {
                if (n % 2) {
                    result += string;
                }
                n = floor(n / 2);
                string += string;
            } while (n);
            return result;
        }
        var snakeCase = createCompounder(function(result, word, index) {
            return result + (index ? "_" : "") + word.toLowerCase();
        });
        var startCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + (word.charAt(0).toUpperCase() + word.slice(1));
        });
        function startsWith(string, target, position) {
            string = baseToString(string);
            position = position == null ? 0 : nativeMin(position < 0 ? 0 : +position || 0, string.length);
            return string.lastIndexOf(target, position) == position;
        }
        function template(string, options, otherOptions) {
            var settings = lodash.templateSettings;
            if (otherOptions && isIterateeCall(string, options, otherOptions)) {
                options = otherOptions = null;
            }
            string = baseToString(string);
            options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
            var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
            var sourceURL = "//# sourceURL=" + ("sourceURL" in options ? options.sourceURL : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                interpolateValue || (interpolateValue = esTemplateValue);
                source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                if (escapeValue) {
                    isEscaping = true;
                    source += "' +\n__e(" + escapeValue + ") +\n'";
                }
                if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '";
                }
                if (interpolateValue) {
                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                }
                index = offset + match.length;
                return match;
            });
            source += "';\n";
            var variable = options.variable;
            if (!variable) {
                source = "with (obj) {\n" + source + "\n}\n";
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result = attempt(function() {
                return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues);
            });
            result.source = source;
            if (isError(result)) {
                throw result;
            }
            return result;
        }
        function trim(string, chars, guard) {
            var value = string;
            string = baseToString(string);
            if (!string) {
                return string;
            }
            if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
            }
            chars = chars + "";
            return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
        function trimLeft(string, chars, guard) {
            var value = string;
            string = baseToString(string);
            if (!string) {
                return string;
            }
            if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                return string.slice(trimmedLeftIndex(string));
            }
            return string.slice(charsLeftIndex(string, chars + ""));
        }
        function trimRight(string, chars, guard) {
            var value = string;
            string = baseToString(string);
            if (!string) {
                return string;
            }
            if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                return string.slice(0, trimmedRightIndex(string) + 1);
            }
            return string.slice(0, charsRightIndex(string, chars + "") + 1);
        }
        function trunc(string, options, guard) {
            if (guard && isIterateeCall(string, options, guard)) {
                options = null;
            }
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (options != null) {
                if (isObject(options)) {
                    var separator = "separator" in options ? options.separator : separator;
                    length = "length" in options ? +options.length || 0 : length;
                    omission = "omission" in options ? baseToString(options.omission) : omission;
                } else {
                    length = +options || 0;
                }
            }
            string = baseToString(string);
            if (length >= string.length) {
                return string;
            }
            var end = length - omission.length;
            if (end < 1) {
                return omission;
            }
            var result = string.slice(0, end);
            if (separator == null) {
                return result + omission;
            }
            if (isRegExp(separator)) {
                if (string.slice(end).search(separator)) {
                    var match, newEnd, substring = string.slice(0, end);
                    if (!separator.global) {
                        separator = RegExp(separator.source, (reFlags.exec(separator) || "") + "g");
                    }
                    separator.lastIndex = 0;
                    while (match = separator.exec(substring)) {
                        newEnd = match.index;
                    }
                    result = result.slice(0, newEnd == null ? end : newEnd);
                }
            } else if (string.indexOf(separator, end) != end) {
                var index = result.lastIndexOf(separator);
                if (index > -1) {
                    result = result.slice(0, index);
                }
            }
            return result + omission;
        }
        function unescape(string) {
            string = baseToString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        function words(string, pattern, guard) {
            if (guard && isIterateeCall(string, pattern, guard)) {
                pattern = null;
            }
            string = baseToString(string);
            return string.match(pattern || reWords) || [];
        }
        var attempt = restParam(function(func, args) {
            try {
                return func.apply(undefined, args);
            } catch (e) {
                return isError(e) ? e : new Error(e);
            }
        });
        function callback(func, thisArg, guard) {
            if (guard && isIterateeCall(func, thisArg, guard)) {
                thisArg = null;
            }
            return isObjectLike(func) ? matches(func) : baseCallback(func, thisArg);
        }
        function constant(value) {
            return function() {
                return value;
            };
        }
        function identity(value) {
            return value;
        }
        function matches(source) {
            return baseMatches(baseClone(source, true));
        }
        function matchesProperty(path, value) {
            return baseMatchesProperty(path, baseClone(value, true));
        }
        var method = restParam(function(path, args) {
            return function(object) {
                return invokePath(object, path, args);
            };
        });
        var methodOf = restParam(function(object, args) {
            return function(path) {
                return invokePath(object, path, args);
            };
        });
        function mixin(object, source, options) {
            if (options == null) {
                var isObj = isObject(source), props = isObj && keys(source), methodNames = props && props.length && baseFunctions(source, props);
                if (!(methodNames ? methodNames.length : isObj)) {
                    methodNames = false;
                    options = source;
                    source = object;
                    object = this;
                }
            }
            if (!methodNames) {
                methodNames = baseFunctions(source, keys(source));
            }
            var chain = true, index = -1, isFunc = isFunction(object), length = methodNames.length;
            if (options === false) {
                chain = false;
            } else if (isObject(options) && "chain" in options) {
                chain = options.chain;
            }
            while (++index < length) {
                var methodName = methodNames[index], func = source[methodName];
                object[methodName] = func;
                if (isFunc) {
                    object.prototype[methodName] = function(func) {
                        return function() {
                            var chainAll = this.__chain__;
                            if (chain || chainAll) {
                                var result = object(this.__wrapped__), actions = result.__actions__ = arrayCopy(this.__actions__);
                                actions.push({
                                    func: func,
                                    args: arguments,
                                    thisArg: object
                                });
                                result.__chain__ = chainAll;
                                return result;
                            }
                            var args = [ this.value() ];
                            push.apply(args, arguments);
                            return func.apply(object, args);
                        };
                    }(func);
                }
            }
            return object;
        }
        function noConflict() {
            context._ = oldDash;
            return this;
        }
        function noop() {}
        function property(path) {
            return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
        }
        function propertyOf(object) {
            return function(path) {
                return baseGet(object, toPath(path), path + "");
            };
        }
        function range(start, end, step) {
            if (step && isIterateeCall(start, end, step)) {
                end = step = null;
            }
            start = +start || 0;
            step = step == null ? 1 : +step || 0;
            if (end == null) {
                end = start;
                start = 0;
            } else {
                end = +end || 0;
            }
            var index = -1, length = nativeMax(ceil((end - start) / (step || 1)), 0), result = Array(length);
            while (++index < length) {
                result[index] = start;
                start += step;
            }
            return result;
        }
        function times(n, iteratee, thisArg) {
            n = floor(n);
            if (n < 1 || !nativeIsFinite(n)) {
                return [];
            }
            var index = -1, result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
            iteratee = bindCallback(iteratee, thisArg, 1);
            while (++index < n) {
                if (index < MAX_ARRAY_LENGTH) {
                    result[index] = iteratee(index);
                } else {
                    iteratee(index);
                }
            }
            return result;
        }
        function uniqueId(prefix) {
            var id = ++idCounter;
            return baseToString(prefix) + id;
        }
        function add(augend, addend) {
            return (+augend || 0) + (+addend || 0);
        }
        var max = createExtremum(arrayMax);
        var min = createExtremum(arrayMin, true);
        function sum(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                iteratee = null;
            }
            var func = getCallback(), noIteratee = iteratee == null;
            if (!(func === baseCallback && noIteratee)) {
                noIteratee = false;
                iteratee = func(iteratee, thisArg, 3);
            }
            return noIteratee ? arraySum(isArray(collection) ? collection : toIterable(collection)) : baseSum(collection, iteratee);
        }
        lodash.prototype = baseLodash.prototype;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        MapCache.prototype["delete"] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
        SetCache.prototype.push = cachePush;
        memoize.Cache = MapCache;
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.restParam = restParam;
        lodash.set = set;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.sortByOrder = sortByOrder;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipWith = zipWith;
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.get = get;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.sum = sum;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
        mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
                if (!lodash.prototype[methodName]) {
                    source[methodName] = func;
                }
            });
            return source;
        }(), false);
        lodash.sample = sample;
        lodash.prototype.sample = function(n) {
            if (!this.__chain__ && n == null) {
                return sample(this.value());
            }
            return this.thru(function(value) {
                return sample(value, n);
            });
        };
        lodash.VERSION = VERSION;
        arrayEach([ "bind", "bindKey", "curry", "curryRight", "partial", "partialRight" ], function(methodName) {
            lodash[methodName].placeholder = lodash;
        });
        arrayEach([ "dropWhile", "filter", "map", "takeWhile" ], function(methodName, type) {
            var isFilter = type != LAZY_MAP_FLAG, isDropWhile = type == LAZY_DROP_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
                var filtered = this.__filtered__, result = filtered && isDropWhile ? new LazyWrapper(this) : this.clone(), iteratees = result.__iteratees__ || (result.__iteratees__ = []);
                iteratees.push({
                    done: false,
                    count: 0,
                    index: 0,
                    iteratee: getCallback(iteratee, thisArg, 1),
                    limit: -1,
                    type: type
                });
                result.__filtered__ = filtered || isFilter;
                return result;
            };
        });
        arrayEach([ "drop", "take" ], function(methodName, index) {
            var whileName = methodName + "While";
            LazyWrapper.prototype[methodName] = function(n) {
                var filtered = this.__filtered__, result = filtered && !index ? this.dropWhile() : this.clone();
                n = n == null ? 1 : nativeMax(floor(n) || 0, 0);
                if (filtered) {
                    if (index) {
                        result.__takeCount__ = nativeMin(result.__takeCount__, n);
                    } else {
                        last(result.__iteratees__).limit = n;
                    }
                } else {
                    var views = result.__views__ || (result.__views__ = []);
                    views.push({
                        size: n,
                        type: methodName + (result.__dir__ < 0 ? "Right" : "")
                    });
                }
                return result;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
                return this.reverse()[methodName](n).reverse();
            };
            LazyWrapper.prototype[methodName + "RightWhile"] = function(predicate, thisArg) {
                return this.reverse()[whileName](predicate, thisArg).reverse();
            };
        });
        arrayEach([ "first", "last" ], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
                return this[takeName](1).value()[0];
            };
        });
        arrayEach([ "initial", "rest" ], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
                return this[dropName](1);
            };
        });
        arrayEach([ "pluck", "where" ], function(methodName, index) {
            var operationName = index ? "filter" : "map", createCallback = index ? baseMatches : property;
            LazyWrapper.prototype[methodName] = function(value) {
                return this[operationName](createCallback(value));
            };
        });
        LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
        };
        LazyWrapper.prototype.reject = function(predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 1);
            return this.filter(function(value) {
                return !predicate(value);
            });
        };
        LazyWrapper.prototype.slice = function(start, end) {
            start = start == null ? 0 : +start || 0;
            var result = this;
            if (start < 0) {
                result = this.takeRight(-start);
            } else if (start) {
                result = this.drop(start);
            }
            if (end !== undefined) {
                end = +end || 0;
                result = end < 0 ? result.dropRight(-end) : result.take(end - start);
            }
            return result;
        };
        LazyWrapper.prototype.toArray = function() {
            return this.drop(0);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (!lodashFunc) {
                return;
            }
            var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName), retUnwrapped = /^(?:first|last)$/.test(methodName);
            lodash.prototype[methodName] = function() {
                var args = arguments, chainAll = this.__chain__, value = this.__wrapped__, isHybrid = !!this.__actions__.length, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
                if (useLazy && checkIteratee && typeof iteratee == "function" && iteratee.length != 1) {
                    isLazy = useLazy = false;
                }
                var onlyLazy = isLazy && !isHybrid;
                if (retUnwrapped && !chainAll) {
                    return onlyLazy ? func.call(value) : lodashFunc.call(lodash, this.value());
                }
                var interceptor = function(value) {
                    var otherArgs = [ value ];
                    push.apply(otherArgs, args);
                    return lodashFunc.apply(lodash, otherArgs);
                };
                if (useLazy) {
                    var wrapper = onlyLazy ? value : new LazyWrapper(this), result = func.apply(wrapper, args);
                    if (!retUnwrapped && (isHybrid || result.__actions__)) {
                        var actions = result.__actions__ || (result.__actions__ = []);
                        actions.push({
                            func: thru,
                            args: [ interceptor ],
                            thisArg: lodash
                        });
                    }
                    return new LodashWrapper(result, chainAll);
                }
                return this.thru(interceptor);
            };
        });
        arrayEach([ "concat", "join", "pop", "push", "replace", "shift", "sort", "splice", "split", "unshift" ], function(methodName) {
            var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
                var args = arguments;
                if (retUnwrapped && !this.__chain__) {
                    return func.apply(this.value(), args);
                }
                return this[chainName](function(value) {
                    return func.apply(value, args);
                });
            };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
                var key = lodashFunc.name, names = realNames[key] || (realNames[key] = []);
                names.push({
                    name: methodName,
                    func: lodashFunc
                });
            }
        });
        realNames[createHybridWrapper(null, BIND_KEY_FLAG).name] = [ {
            name: "wrapper",
            func: null
        } ];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
        return lodash;
    }
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
            return _;
        });
    } else if (freeExports && freeModule) {
        if (moduleExports) {
            (freeModule.exports = _)._ = _;
        } else {
            freeExports._ = _;
        }
    } else {
        root._ = _;
    }
}).call(this);

jQuery.migrateMute === void 0 && (jQuery.migrateMute = !0), function(e, t, n) {
    function r(n) {
        var r = t.console;
        i[n] || (i[n] = !0, e.migrateWarnings.push(n), r && r.warn && !e.migrateMute && (r.warn("JQMIGRATE: " + n), 
        e.migrateTrace && r.trace && r.trace()));
    }
    function a(t, a, i, o) {
        if (Object.defineProperty) try {
            return Object.defineProperty(t, a, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    return r(o), i;
                },
                set: function(e) {
                    r(o), i = e;
                }
            }), n;
        } catch (s) {}
        e._definePropertyBroken = !0, t[a] = i;
    }
    var i = {};
    e.migrateWarnings = [], !e.migrateMute && t.console && t.console.log && t.console.log("JQMIGRATE: Logging is active"), 
    e.migrateTrace === n && (e.migrateTrace = !0), e.migrateReset = function() {
        i = {}, e.migrateWarnings.length = 0;
    }, "BackCompat" === document.compatMode && r("jQuery is not compatible with Quirks Mode");
    var o = e("<input/>", {
        size: 1
    }).attr("size") && e.attrFn, s = e.attr, u = e.attrHooks.value && e.attrHooks.value.get || function() {
        return null;
    }, c = e.attrHooks.value && e.attrHooks.value.set || function() {
        return n;
    }, l = /^(?:input|button)$/i, d = /^[238]$/, p = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i, f = /^(?:checked|selected)$/i;
    a(e, "attrFn", o || {}, "jQuery.attrFn is deprecated"), e.attr = function(t, a, i, u) {
        var c = a.toLowerCase(), g = t && t.nodeType;
        return u && (4 > s.length && r("jQuery.fn.attr( props, pass ) is deprecated"), t && !d.test(g) && (o ? a in o : e.isFunction(e.fn[a]))) ? e(t)[a](i) : ("type" === a && i !== n && l.test(t.nodeName) && t.parentNode && r("Can't change the 'type' of an input or button in IE 6/7/8"), 
        !e.attrHooks[c] && p.test(c) && (e.attrHooks[c] = {
            get: function(t, r) {
                var a, i = e.prop(t, r);
                return i === !0 || "boolean" != typeof i && (a = t.getAttributeNode(r)) && a.nodeValue !== !1 ? r.toLowerCase() : n;
            },
            set: function(t, n, r) {
                var a;
                return n === !1 ? e.removeAttr(t, r) : (a = e.propFix[r] || r, a in t && (t[a] = !0), 
                t.setAttribute(r, r.toLowerCase())), r;
            }
        }, f.test(c) && r("jQuery.fn.attr('" + c + "') may use property instead of attribute")), 
        s.call(e, t, a, i));
    }, e.attrHooks.value = {
        get: function(e, t) {
            var n = (e.nodeName || "").toLowerCase();
            return "button" === n ? u.apply(this, arguments) : ("input" !== n && "option" !== n && r("jQuery.fn.attr('value') no longer gets properties"), 
            t in e ? e.value : null);
        },
        set: function(e, t) {
            var a = (e.nodeName || "").toLowerCase();
            return "button" === a ? c.apply(this, arguments) : ("input" !== a && "option" !== a && r("jQuery.fn.attr('value', val) no longer sets properties"), 
            e.value = t, n);
        }
    };
    var g, h, v = e.fn.init, m = e.parseJSON, y = /^([^<]*)(<[\w\W]+>)([^>]*)$/;
    e.fn.init = function(t, n, a) {
        var i;
        return t && "string" == typeof t && !e.isPlainObject(n) && (i = y.exec(e.trim(t))) && i[0] && ("<" !== t.charAt(0) && r("$(html) HTML strings must start with '<' character"), 
        i[3] && r("$(html) HTML text after last tag is ignored"), "#" === i[0].charAt(0) && (r("HTML string cannot start with a '#' character"), 
        e.error("JQMIGRATE: Invalid selector string (XSS)")), n && n.context && (n = n.context), 
        e.parseHTML) ? v.call(this, e.parseHTML(i[2], n, !0), n, a) : v.apply(this, arguments);
    }, e.fn.init.prototype = e.fn, e.parseJSON = function(e) {
        return e || null === e ? m.apply(this, arguments) : (r("jQuery.parseJSON requires a valid JSON string"), 
        null);
    }, e.uaMatch = function(e) {
        e = e.toLowerCase();
        var t = /(chrome)[ \/]([\w.]+)/.exec(e) || /(webkit)[ \/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e) || /(msie) ([\w.]+)/.exec(e) || 0 > e.indexOf("compatible") && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e) || [];
        return {
            browser: t[1] || "",
            version: t[2] || "0"
        };
    }, e.browser || (g = e.uaMatch(navigator.userAgent), h = {}, g.browser && (h[g.browser] = !0, 
    h.version = g.version), h.chrome ? h.webkit = !0 : h.webkit && (h.safari = !0), 
    e.browser = h), a(e, "browser", e.browser, "jQuery.browser is deprecated"), e.sub = function() {
        function t(e, n) {
            return new t.fn.init(e, n);
        }
        e.extend(!0, t, this), t.superclass = this, t.fn = t.prototype = this(), t.fn.constructor = t, 
        t.sub = this.sub, t.fn.init = function(r, a) {
            return a && a instanceof e && !(a instanceof t) && (a = t(a)), e.fn.init.call(this, r, a, n);
        }, t.fn.init.prototype = t.fn;
        var n = t(document);
        return r("jQuery.sub() is deprecated"), t;
    }, e.ajaxSetup({
        converters: {
            "text json": e.parseJSON
        }
    });
    var b = e.fn.data;
    e.fn.data = function(t) {
        var a, i, o = this[0];
        return !o || "events" !== t || 1 !== arguments.length || (a = e.data(o, t), i = e._data(o, t), 
        a !== n && a !== i || i === n) ? b.apply(this, arguments) : (r("Use of jQuery.fn.data('events') is deprecated"), 
        i);
    };
    var j = /\/(java|ecma)script/i, w = e.fn.andSelf || e.fn.addBack;
    e.fn.andSelf = function() {
        return r("jQuery.fn.andSelf() replaced by jQuery.fn.addBack()"), w.apply(this, arguments);
    }, e.clean || (e.clean = function(t, a, i, o) {
        a = a || document, a = !a.nodeType && a[0] || a, a = a.ownerDocument || a, r("jQuery.clean() is deprecated");
        var s, u, c, l, d = [];
        if (e.merge(d, e.buildFragment(t, a).childNodes), i) for (c = function(e) {
            return !e.type || j.test(e.type) ? o ? o.push(e.parentNode ? e.parentNode.removeChild(e) : e) : i.appendChild(e) : n;
        }, s = 0; null != (u = d[s]); s++) e.nodeName(u, "script") && c(u) || (i.appendChild(u), 
        u.getElementsByTagName !== n && (l = e.grep(e.merge([], u.getElementsByTagName("script")), c), 
        d.splice.apply(d, [ s + 1, 0 ].concat(l)), s += l.length));
        return d;
    });
    var Q = e.event.add, x = e.event.remove, k = e.event.trigger, N = e.fn.toggle, T = e.fn.live, M = e.fn.die, S = "ajaxStart|ajaxStop|ajaxSend|ajaxComplete|ajaxError|ajaxSuccess", C = RegExp("\\b(?:" + S + ")\\b"), H = /(?:^|\s)hover(\.\S+|)\b/, A = function(t) {
        return "string" != typeof t || e.event.special.hover ? t : (H.test(t) && r("'hover' pseudo-event is deprecated, use 'mouseenter mouseleave'"), 
        t && t.replace(H, "mouseenter$1 mouseleave$1"));
    };
    e.event.props && "attrChange" !== e.event.props[0] && e.event.props.unshift("attrChange", "attrName", "relatedNode", "srcElement"), 
    e.event.dispatch && a(e.event, "handle", e.event.dispatch, "jQuery.event.handle is undocumented and deprecated"), 
    e.event.add = function(e, t, n, a, i) {
        e !== document && C.test(t) && r("AJAX events should be attached to document: " + t), 
        Q.call(this, e, A(t || ""), n, a, i);
    }, e.event.remove = function(e, t, n, r, a) {
        x.call(this, e, A(t) || "", n, r, a);
    }, e.fn.error = function() {
        var e = Array.prototype.slice.call(arguments, 0);
        return r("jQuery.fn.error() is deprecated"), e.splice(0, 0, "error"), arguments.length ? this.bind.apply(this, e) : (this.triggerHandler.apply(this, e), 
        this);
    }, e.fn.toggle = function(t, n) {
        if (!e.isFunction(t) || !e.isFunction(n)) return N.apply(this, arguments);
        r("jQuery.fn.toggle(handler, handler...) is deprecated");
        var a = arguments, i = t.guid || e.guid++, o = 0, s = function(n) {
            var r = (e._data(this, "lastToggle" + t.guid) || 0) % o;
            return e._data(this, "lastToggle" + t.guid, r + 1), n.preventDefault(), a[r].apply(this, arguments) || !1;
        };
        for (s.guid = i; a.length > o; ) a[o++].guid = i;
        return this.click(s);
    }, e.fn.live = function(t, n, a) {
        return r("jQuery.fn.live() is deprecated"), T ? T.apply(this, arguments) : (e(this.context).on(t, this.selector, n, a), 
        this);
    }, e.fn.die = function(t, n) {
        return r("jQuery.fn.die() is deprecated"), M ? M.apply(this, arguments) : (e(this.context).off(t, this.selector || "**", n), 
        this);
    }, e.event.trigger = function(e, t, n, a) {
        return n || C.test(e) || r("Global events are undocumented and deprecated"), k.call(this, e, t, n || document, a);
    }, e.each(S.split("|"), function(t, n) {
        e.event.special[n] = {
            setup: function() {
                var t = this;
                return t !== document && (e.event.add(document, n + "." + e.guid, function() {
                    e.event.trigger(n, null, t, !0);
                }), e._data(this, n, e.guid++)), !1;
            },
            teardown: function() {
                return this !== document && e.event.remove(document, n + "." + e._data(this, n)), 
                !1;
            }
        };
    });
}(jQuery, window);

if (typeof jQuery === "undefined") {
    throw new Error("Bootstrap's JavaScript requires jQuery");
}

+function($) {
    "use strict";
    var version = $.fn.jquery.split(" ")[0].split(".");
    if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1 || version[0] > 3) {
        throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4");
    }
}(jQuery);

+function($) {
    "use strict";
    function transitionEnd() {
        var el = document.createElement("bootstrap");
        var transEndEventNames = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };
        for (var name in transEndEventNames) {
            if (el.style[name] !== undefined) {
                return {
                    end: transEndEventNames[name]
                };
            }
        }
        return false;
    }
    $.fn.emulateTransitionEnd = function(duration) {
        var called = false;
        var $el = this;
        $(this).one("bsTransitionEnd", function() {
            called = true;
        });
        var callback = function() {
            if (!called) $($el).trigger($.support.transition.end);
        };
        setTimeout(callback, duration);
        return this;
    };
    $(function() {
        $.support.transition = transitionEnd();
        if (!$.support.transition) return;
        $.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function(e) {
                if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
            }
        };
    });
}(jQuery);

+function($) {
    "use strict";
    var dismiss = '[data-dismiss="alert"]';
    var Alert = function(el) {
        $(el).on("click", dismiss, this.close);
    };
    Alert.VERSION = "3.3.7";
    Alert.TRANSITION_DURATION = 150;
    Alert.prototype.close = function(e) {
        var $this = $(this);
        var selector = $this.attr("data-target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        var $parent = $(selector === "#" ? [] : selector);
        if (e) e.preventDefault();
        if (!$parent.length) {
            $parent = $this.closest(".alert");
        }
        $parent.trigger(e = $.Event("close.bs.alert"));
        if (e.isDefaultPrevented()) return;
        $parent.removeClass("in");
        function removeElement() {
            $parent.detach().trigger("closed.bs.alert").remove();
        }
        $.support.transition && $parent.hasClass("fade") ? $parent.one("bsTransitionEnd", removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.alert");
            if (!data) $this.data("bs.alert", data = new Alert(this));
            if (typeof option == "string") data[option].call($this);
        });
    }
    var old = $.fn.alert;
    $.fn.alert = Plugin;
    $.fn.alert.Constructor = Alert;
    $.fn.alert.noConflict = function() {
        $.fn.alert = old;
        return this;
    };
    $(document).on("click.bs.alert.data-api", dismiss, Alert.prototype.close);
}(jQuery);

+function($) {
    "use strict";
    var Button = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Button.DEFAULTS, options);
        this.isLoading = false;
    };
    Button.VERSION = "3.3.7";
    Button.DEFAULTS = {
        loadingText: "loading..."
    };
    Button.prototype.setState = function(state) {
        var d = "disabled";
        var $el = this.$element;
        var val = $el.is("input") ? "val" : "html";
        var data = $el.data();
        state += "Text";
        if (data.resetText == null) $el.data("resetText", $el[val]());
        setTimeout($.proxy(function() {
            $el[val](data[state] == null ? this.options[state] : data[state]);
            if (state == "loadingText") {
                this.isLoading = true;
                $el.addClass(d).attr(d, d).prop(d, true);
            } else if (this.isLoading) {
                this.isLoading = false;
                $el.removeClass(d).removeAttr(d).prop(d, false);
            }
        }, this), 0);
    };
    Button.prototype.toggle = function() {
        var changed = true;
        var $parent = this.$element.closest('[data-toggle="buttons"]');
        if ($parent.length) {
            var $input = this.$element.find("input");
            if ($input.prop("type") == "radio") {
                if ($input.prop("checked")) changed = false;
                $parent.find(".active").removeClass("active");
                this.$element.addClass("active");
            } else if ($input.prop("type") == "checkbox") {
                if ($input.prop("checked") !== this.$element.hasClass("active")) changed = false;
                this.$element.toggleClass("active");
            }
            $input.prop("checked", this.$element.hasClass("active"));
            if (changed) $input.trigger("change");
        } else {
            this.$element.attr("aria-pressed", !this.$element.hasClass("active"));
            this.$element.toggleClass("active");
        }
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.button");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.button", data = new Button(this, options));
            if (option == "toggle") data.toggle(); else if (option) data.setState(option);
        });
    }
    var old = $.fn.button;
    $.fn.button = Plugin;
    $.fn.button.Constructor = Button;
    $.fn.button.noConflict = function() {
        $.fn.button = old;
        return this;
    };
    $(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        var $btn = $(e.target).closest(".btn");
        Plugin.call($btn, "toggle");
        if (!$(e.target).is('input[type="radio"], input[type="checkbox"]')) {
            e.preventDefault();
            if ($btn.is("input,button")) $btn.trigger("focus"); else $btn.find("input:visible,button:visible").first().trigger("focus");
        }
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        $(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type));
    });
}(jQuery);

+function($) {
    "use strict";
    var Carousel = function(element, options) {
        this.$element = $(element);
        this.$indicators = this.$element.find(".carousel-indicators");
        this.options = options;
        this.paused = null;
        this.sliding = null;
        this.interval = null;
        this.$active = null;
        this.$items = null;
        this.options.keyboard && this.$element.on("keydown.bs.carousel", $.proxy(this.keydown, this));
        this.options.pause == "hover" && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", $.proxy(this.pause, this)).on("mouseleave.bs.carousel", $.proxy(this.cycle, this));
    };
    Carousel.VERSION = "3.3.7";
    Carousel.TRANSITION_DURATION = 600;
    Carousel.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: true,
        keyboard: true
    };
    Carousel.prototype.keydown = function(e) {
        if (/input|textarea/i.test(e.target.tagName)) return;
        switch (e.which) {
          case 37:
            this.prev();
            break;

          case 39:
            this.next();
            break;

          default:
            return;
        }
        e.preventDefault();
    };
    Carousel.prototype.cycle = function(e) {
        e || (this.paused = false);
        this.interval && clearInterval(this.interval);
        this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
        return this;
    };
    Carousel.prototype.getItemIndex = function(item) {
        this.$items = item.parent().children(".item");
        return this.$items.index(item || this.$active);
    };
    Carousel.prototype.getItemForDirection = function(direction, active) {
        var activeIndex = this.getItemIndex(active);
        var willWrap = direction == "prev" && activeIndex === 0 || direction == "next" && activeIndex == this.$items.length - 1;
        if (willWrap && !this.options.wrap) return active;
        var delta = direction == "prev" ? -1 : 1;
        var itemIndex = (activeIndex + delta) % this.$items.length;
        return this.$items.eq(itemIndex);
    };
    Carousel.prototype.to = function(pos) {
        var that = this;
        var activeIndex = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        if (pos > this.$items.length - 1 || pos < 0) return;
        if (this.sliding) return this.$element.one("slid.bs.carousel", function() {
            that.to(pos);
        });
        if (activeIndex == pos) return this.pause().cycle();
        return this.slide(pos > activeIndex ? "next" : "prev", this.$items.eq(pos));
    };
    Carousel.prototype.pause = function(e) {
        e || (this.paused = true);
        if (this.$element.find(".next, .prev").length && $.support.transition) {
            this.$element.trigger($.support.transition.end);
            this.cycle(true);
        }
        this.interval = clearInterval(this.interval);
        return this;
    };
    Carousel.prototype.next = function() {
        if (this.sliding) return;
        return this.slide("next");
    };
    Carousel.prototype.prev = function() {
        if (this.sliding) return;
        return this.slide("prev");
    };
    Carousel.prototype.slide = function(type, next) {
        var $active = this.$element.find(".item.active");
        var $next = next || this.getItemForDirection(type, $active);
        var isCycling = this.interval;
        var direction = type == "next" ? "left" : "right";
        var that = this;
        if ($next.hasClass("active")) return this.sliding = false;
        var relatedTarget = $next[0];
        var slideEvent = $.Event("slide.bs.carousel", {
            relatedTarget: relatedTarget,
            direction: direction
        });
        this.$element.trigger(slideEvent);
        if (slideEvent.isDefaultPrevented()) return;
        this.sliding = true;
        isCycling && this.pause();
        if (this.$indicators.length) {
            this.$indicators.find(".active").removeClass("active");
            var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
            $nextIndicator && $nextIndicator.addClass("active");
        }
        var slidEvent = $.Event("slid.bs.carousel", {
            relatedTarget: relatedTarget,
            direction: direction
        });
        if ($.support.transition && this.$element.hasClass("slide")) {
            $next.addClass(type);
            $next[0].offsetWidth;
            $active.addClass(direction);
            $next.addClass(direction);
            $active.one("bsTransitionEnd", function() {
                $next.removeClass([ type, direction ].join(" ")).addClass("active");
                $active.removeClass([ "active", direction ].join(" "));
                that.sliding = false;
                setTimeout(function() {
                    that.$element.trigger(slidEvent);
                }, 0);
            }).emulateTransitionEnd(Carousel.TRANSITION_DURATION);
        } else {
            $active.removeClass("active");
            $next.addClass("active");
            this.sliding = false;
            this.$element.trigger(slidEvent);
        }
        isCycling && this.cycle();
        return this;
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.carousel");
            var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == "object" && option);
            var action = typeof option == "string" ? option : options.slide;
            if (!data) $this.data("bs.carousel", data = new Carousel(this, options));
            if (typeof option == "number") data.to(option); else if (action) data[action](); else if (options.interval) data.pause().cycle();
        });
    }
    var old = $.fn.carousel;
    $.fn.carousel = Plugin;
    $.fn.carousel.Constructor = Carousel;
    $.fn.carousel.noConflict = function() {
        $.fn.carousel = old;
        return this;
    };
    var clickHandler = function(e) {
        var href;
        var $this = $(this);
        var $target = $($this.attr("data-target") || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""));
        if (!$target.hasClass("carousel")) return;
        var options = $.extend({}, $target.data(), $this.data());
        var slideIndex = $this.attr("data-slide-to");
        if (slideIndex) options.interval = false;
        Plugin.call($target, options);
        if (slideIndex) {
            $target.data("bs.carousel").to(slideIndex);
        }
        e.preventDefault();
    };
    $(document).on("click.bs.carousel.data-api", "[data-slide]", clickHandler).on("click.bs.carousel.data-api", "[data-slide-to]", clickHandler);
    $(window).on("load", function() {
        $('[data-ride="carousel"]').each(function() {
            var $carousel = $(this);
            Plugin.call($carousel, $carousel.data());
        });
    });
}(jQuery);

+function($) {
    "use strict";
    var Collapse = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Collapse.DEFAULTS, options);
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]');
        this.transitioning = null;
        if (this.options.parent) {
            this.$parent = this.getParent();
        } else {
            this.addAriaAndCollapsedClass(this.$element, this.$trigger);
        }
        if (this.options.toggle) this.toggle();
    };
    Collapse.VERSION = "3.3.7";
    Collapse.TRANSITION_DURATION = 350;
    Collapse.DEFAULTS = {
        toggle: true
    };
    Collapse.prototype.dimension = function() {
        var hasWidth = this.$element.hasClass("width");
        return hasWidth ? "width" : "height";
    };
    Collapse.prototype.show = function() {
        if (this.transitioning || this.$element.hasClass("in")) return;
        var activesData;
        var actives = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
        if (actives && actives.length) {
            activesData = actives.data("bs.collapse");
            if (activesData && activesData.transitioning) return;
        }
        var startEvent = $.Event("show.bs.collapse");
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;
        if (actives && actives.length) {
            Plugin.call(actives, "hide");
            activesData || actives.data("bs.collapse", null);
        }
        var dimension = this.dimension();
        this.$element.removeClass("collapse").addClass("collapsing")[dimension](0).attr("aria-expanded", true);
        this.$trigger.removeClass("collapsed").attr("aria-expanded", true);
        this.transitioning = 1;
        var complete = function() {
            this.$element.removeClass("collapsing").addClass("collapse in")[dimension]("");
            this.transitioning = 0;
            this.$element.trigger("shown.bs.collapse");
        };
        if (!$.support.transition) return complete.call(this);
        var scrollSize = $.camelCase([ "scroll", dimension ].join("-"));
        this.$element.one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
    };
    Collapse.prototype.hide = function() {
        if (this.transitioning || !this.$element.hasClass("in")) return;
        var startEvent = $.Event("hide.bs.collapse");
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;
        var dimension = this.dimension();
        this.$element[dimension](this.$element[dimension]())[0].offsetHeight;
        this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", false);
        this.$trigger.addClass("collapsed").attr("aria-expanded", false);
        this.transitioning = 1;
        var complete = function() {
            this.transitioning = 0;
            this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse");
        };
        if (!$.support.transition) return complete.call(this);
        this.$element[dimension](0).one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
    };
    Collapse.prototype.toggle = function() {
        this[this.$element.hasClass("in") ? "hide" : "show"]();
    };
    Collapse.prototype.getParent = function() {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function(i, element) {
            var $element = $(element);
            this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
        }, this)).end();
    };
    Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
        var isOpen = $element.hasClass("in");
        $element.attr("aria-expanded", isOpen);
        $trigger.toggleClass("collapsed", !isOpen).attr("aria-expanded", isOpen);
    };
    function getTargetFromTrigger($trigger) {
        var href;
        var target = $trigger.attr("data-target") || (href = $trigger.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "");
        return $(target);
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.collapse");
            var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == "object" && option);
            if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false;
            if (!data) $this.data("bs.collapse", data = new Collapse(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.collapse;
    $.fn.collapse = Plugin;
    $.fn.collapse.Constructor = Collapse;
    $.fn.collapse.noConflict = function() {
        $.fn.collapse = old;
        return this;
    };
    $(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function(e) {
        var $this = $(this);
        if (!$this.attr("data-target")) e.preventDefault();
        var $target = getTargetFromTrigger($this);
        var data = $target.data("bs.collapse");
        var option = data ? "toggle" : $this.data();
        Plugin.call($target, option);
    });
}(jQuery);

+function($) {
    "use strict";
    var backdrop = ".dropdown-backdrop";
    var toggle = '[data-toggle="dropdown"]';
    var Dropdown = function(element) {
        $(element).on("click.bs.dropdown", this.toggle);
    };
    Dropdown.VERSION = "3.3.7";
    function getParent($this) {
        var selector = $this.attr("data-target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        var $parent = selector && $(selector);
        return $parent && $parent.length ? $parent : $this.parent();
    }
    function clearMenus(e) {
        if (e && e.which === 3) return;
        $(backdrop).remove();
        $(toggle).each(function() {
            var $this = $(this);
            var $parent = getParent($this);
            var relatedTarget = {
                relatedTarget: this
            };
            if (!$parent.hasClass("open")) return;
            if (e && e.type == "click" && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return;
            $parent.trigger(e = $.Event("hide.bs.dropdown", relatedTarget));
            if (e.isDefaultPrevented()) return;
            $this.attr("aria-expanded", "false");
            $parent.removeClass("open").trigger($.Event("hidden.bs.dropdown", relatedTarget));
        });
    }
    Dropdown.prototype.toggle = function(e) {
        var $this = $(this);
        if ($this.is(".disabled, :disabled")) return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass("open");
        clearMenus();
        if (!isActive) {
            if ("ontouchstart" in document.documentElement && !$parent.closest(".navbar-nav").length) {
                $(document.createElement("div")).addClass("dropdown-backdrop").insertAfter($(this)).on("click", clearMenus);
            }
            var relatedTarget = {
                relatedTarget: this
            };
            $parent.trigger(e = $.Event("show.bs.dropdown", relatedTarget));
            if (e.isDefaultPrevented()) return;
            $this.trigger("focus").attr("aria-expanded", "true");
            $parent.toggleClass("open").trigger($.Event("shown.bs.dropdown", relatedTarget));
        }
        return false;
    };
    Dropdown.prototype.keydown = function(e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return;
        var $this = $(this);
        e.preventDefault();
        e.stopPropagation();
        if ($this.is(".disabled, :disabled")) return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass("open");
        if (!isActive && e.which != 27 || isActive && e.which == 27) {
            if (e.which == 27) $parent.find(toggle).trigger("focus");
            return $this.trigger("click");
        }
        var desc = " li:not(.disabled):visible a";
        var $items = $parent.find(".dropdown-menu" + desc);
        if (!$items.length) return;
        var index = $items.index(e.target);
        if (e.which == 38 && index > 0) index--;
        if (e.which == 40 && index < $items.length - 1) index++;
        if (!~index) index = 0;
        $items.eq(index).trigger("focus");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.dropdown");
            if (!data) $this.data("bs.dropdown", data = new Dropdown(this));
            if (typeof option == "string") data[option].call($this);
        });
    }
    var old = $.fn.dropdown;
    $.fn.dropdown = Plugin;
    $.fn.dropdown.Constructor = Dropdown;
    $.fn.dropdown.noConflict = function() {
        $.fn.dropdown = old;
        return this;
    };
    $(document).on("click.bs.dropdown.data-api", clearMenus).on("click.bs.dropdown.data-api", ".dropdown form", function(e) {
        e.stopPropagation();
    }).on("click.bs.dropdown.data-api", toggle, Dropdown.prototype.toggle).on("keydown.bs.dropdown.data-api", toggle, Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", Dropdown.prototype.keydown);
}(jQuery);

+function($) {
    "use strict";
    var Modal = function(element, options) {
        this.options = options;
        this.$body = $(document.body);
        this.$element = $(element);
        this.$dialog = this.$element.find(".modal-dialog");
        this.$backdrop = null;
        this.isShown = null;
        this.originalBodyPad = null;
        this.scrollbarWidth = 0;
        this.ignoreBackdropClick = false;
        if (this.options.remote) {
            this.$element.find(".modal-content").load(this.options.remote, $.proxy(function() {
                this.$element.trigger("loaded.bs.modal");
            }, this));
        }
    };
    Modal.VERSION = "3.3.7";
    Modal.TRANSITION_DURATION = 300;
    Modal.BACKDROP_TRANSITION_DURATION = 150;
    Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
    };
    Modal.prototype.toggle = function(_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget);
    };
    Modal.prototype.show = function(_relatedTarget) {
        var that = this;
        var e = $.Event("show.bs.modal", {
            relatedTarget: _relatedTarget
        });
        this.$element.trigger(e);
        if (this.isShown || e.isDefaultPrevented()) return;
        this.isShown = true;
        this.checkScrollbar();
        this.setScrollbar();
        this.$body.addClass("modal-open");
        this.escape();
        this.resize();
        this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', $.proxy(this.hide, this));
        this.$dialog.on("mousedown.dismiss.bs.modal", function() {
            that.$element.one("mouseup.dismiss.bs.modal", function(e) {
                if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;
            });
        });
        this.backdrop(function() {
            var transition = $.support.transition && that.$element.hasClass("fade");
            if (!that.$element.parent().length) {
                that.$element.appendTo(that.$body);
            }
            that.$element.show().scrollTop(0);
            that.adjustDialog();
            if (transition) {
                that.$element[0].offsetWidth;
            }
            that.$element.addClass("in");
            that.enforceFocus();
            var e = $.Event("shown.bs.modal", {
                relatedTarget: _relatedTarget
            });
            transition ? that.$dialog.one("bsTransitionEnd", function() {
                that.$element.trigger("focus").trigger(e);
            }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger("focus").trigger(e);
        });
    };
    Modal.prototype.hide = function(e) {
        if (e) e.preventDefault();
        e = $.Event("hide.bs.modal");
        this.$element.trigger(e);
        if (!this.isShown || e.isDefaultPrevented()) return;
        this.isShown = false;
        this.escape();
        this.resize();
        $(document).off("focusin.bs.modal");
        this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal");
        this.$dialog.off("mousedown.dismiss.bs.modal");
        $.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
    };
    Modal.prototype.enforceFocus = function() {
        $(document).off("focusin.bs.modal").on("focusin.bs.modal", $.proxy(function(e) {
            if (document !== e.target && this.$element[0] !== e.target && !this.$element.has(e.target).length) {
                this.$element.trigger("focus");
            }
        }, this));
    };
    Modal.prototype.escape = function() {
        if (this.isShown && this.options.keyboard) {
            this.$element.on("keydown.dismiss.bs.modal", $.proxy(function(e) {
                e.which == 27 && this.hide();
            }, this));
        } else if (!this.isShown) {
            this.$element.off("keydown.dismiss.bs.modal");
        }
    };
    Modal.prototype.resize = function() {
        if (this.isShown) {
            $(window).on("resize.bs.modal", $.proxy(this.handleUpdate, this));
        } else {
            $(window).off("resize.bs.modal");
        }
    };
    Modal.prototype.hideModal = function() {
        var that = this;
        this.$element.hide();
        this.backdrop(function() {
            that.$body.removeClass("modal-open");
            that.resetAdjustments();
            that.resetScrollbar();
            that.$element.trigger("hidden.bs.modal");
        });
    };
    Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove();
        this.$backdrop = null;
    };
    Modal.prototype.backdrop = function(callback) {
        var that = this;
        var animate = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate;
            this.$backdrop = $(document.createElement("div")).addClass("modal-backdrop " + animate).appendTo(this.$body);
            this.$element.on("click.dismiss.bs.modal", $.proxy(function(e) {
                if (this.ignoreBackdropClick) {
                    this.ignoreBackdropClick = false;
                    return;
                }
                if (e.target !== e.currentTarget) return;
                this.options.backdrop == "static" ? this.$element[0].focus() : this.hide();
            }, this));
            if (doAnimate) this.$backdrop[0].offsetWidth;
            this.$backdrop.addClass("in");
            if (!callback) return;
            doAnimate ? this.$backdrop.one("bsTransitionEnd", callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var callbackRemove = function() {
                that.removeBackdrop();
                callback && callback();
            };
            $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
        } else if (callback) {
            callback();
        }
    };
    Modal.prototype.handleUpdate = function() {
        this.adjustDialog();
    };
    Modal.prototype.adjustDialog = function() {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ""
        });
    };
    Modal.prototype.resetAdjustments = function() {
        this.$element.css({
            paddingLeft: "",
            paddingRight: ""
        });
    };
    Modal.prototype.checkScrollbar = function() {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
            var documentElementRect = document.documentElement.getBoundingClientRect();
            fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
        this.scrollbarWidth = this.measureScrollbar();
    };
    Modal.prototype.setScrollbar = function() {
        var bodyPad = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "";
        if (this.bodyIsOverflowing) this.$body.css("padding-right", bodyPad + this.scrollbarWidth);
    };
    Modal.prototype.resetScrollbar = function() {
        this.$body.css("padding-right", this.originalBodyPad);
    };
    Modal.prototype.measureScrollbar = function() {
        var scrollDiv = document.createElement("div");
        scrollDiv.className = "modal-scrollbar-measure";
        this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this.$body[0].removeChild(scrollDiv);
        return scrollbarWidth;
    };
    function Plugin(option, _relatedTarget) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.modal");
            var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == "object" && option);
            if (!data) $this.data("bs.modal", data = new Modal(this, options));
            if (typeof option == "string") data[option](_relatedTarget); else if (options.show) data.show(_relatedTarget);
        });
    }
    var old = $.fn.modal;
    $.fn.modal = Plugin;
    $.fn.modal.Constructor = Modal;
    $.fn.modal.noConflict = function() {
        $.fn.modal = old;
        return this;
    };
    $(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(e) {
        var $this = $(this);
        var href = $this.attr("href");
        var $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, ""));
        var option = $target.data("bs.modal") ? "toggle" : $.extend({
            remote: !/#/.test(href) && href
        }, $target.data(), $this.data());
        if ($this.is("a")) e.preventDefault();
        $target.one("show.bs.modal", function(showEvent) {
            if (showEvent.isDefaultPrevented()) return;
            $target.one("hidden.bs.modal", function() {
                $this.is(":visible") && $this.trigger("focus");
            });
        });
        Plugin.call($target, option, this);
    });
}(jQuery);

+function($) {
    "use strict";
    var Tooltip = function(element, options) {
        this.type = null;
        this.options = null;
        this.enabled = null;
        this.timeout = null;
        this.hoverState = null;
        this.$element = null;
        this.inState = null;
        this.init("tooltip", element, options);
    };
    Tooltip.VERSION = "3.3.7";
    Tooltip.TRANSITION_DURATION = 150;
    Tooltip.DEFAULTS = {
        animation: true,
        placement: "top",
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: false,
        container: false,
        viewport: {
            selector: "body",
            padding: 0
        }
    };
    Tooltip.prototype.init = function(type, element, options) {
        this.enabled = true;
        this.type = type;
        this.$element = $(element);
        this.options = this.getOptions(options);
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport);
        this.inState = {
            click: false,
            hover: false,
            focus: false
        };
        if (this.$element[0] instanceof document.constructor && !this.options.selector) {
            throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        }
        var triggers = this.options.trigger.split(" ");
        for (var i = triggers.length; i--; ) {
            var trigger = triggers[i];
            if (trigger == "click") {
                this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this));
            } else if (trigger != "manual") {
                var eventIn = trigger == "hover" ? "mouseenter" : "focusin";
                var eventOut = trigger == "hover" ? "mouseleave" : "focusout";
                this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this));
                this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this));
            }
        }
        this.options.selector ? this._options = $.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle();
    };
    Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS;
    };
    Tooltip.prototype.getOptions = function(options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options);
        if (options.delay && typeof options.delay == "number") {
            options.delay = {
                show: options.delay,
                hide: options.delay
            };
        }
        return options;
    };
    Tooltip.prototype.getDelegateOptions = function() {
        var options = {};
        var defaults = this.getDefaults();
        this._options && $.each(this._options, function(key, value) {
            if (defaults[key] != value) options[key] = value;
        });
        return options;
    };
    Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
            $(obj.currentTarget).data("bs." + this.type, self);
        }
        if (obj instanceof $.Event) {
            self.inState[obj.type == "focusin" ? "focus" : "hover"] = true;
        }
        if (self.tip().hasClass("in") || self.hoverState == "in") {
            self.hoverState = "in";
            return;
        }
        clearTimeout(self.timeout);
        self.hoverState = "in";
        if (!self.options.delay || !self.options.delay.show) return self.show();
        self.timeout = setTimeout(function() {
            if (self.hoverState == "in") self.show();
        }, self.options.delay.show);
    };
    Tooltip.prototype.isInStateTrue = function() {
        for (var key in this.inState) {
            if (this.inState[key]) return true;
        }
        return false;
    };
    Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
            $(obj.currentTarget).data("bs." + this.type, self);
        }
        if (obj instanceof $.Event) {
            self.inState[obj.type == "focusout" ? "focus" : "hover"] = false;
        }
        if (self.isInStateTrue()) return;
        clearTimeout(self.timeout);
        self.hoverState = "out";
        if (!self.options.delay || !self.options.delay.hide) return self.hide();
        self.timeout = setTimeout(function() {
            if (self.hoverState == "out") self.hide();
        }, self.options.delay.hide);
    };
    Tooltip.prototype.show = function() {
        var e = $.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(e);
            var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (e.isDefaultPrevented() || !inDom) return;
            var that = this;
            var $tip = this.tip();
            var tipId = this.getUID(this.type);
            this.setContent();
            $tip.attr("id", tipId);
            this.$element.attr("aria-describedby", tipId);
            if (this.options.animation) $tip.addClass("fade");
            var placement = typeof this.options.placement == "function" ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
            var autoToken = /\s?auto?\s?/i;
            var autoPlace = autoToken.test(placement);
            if (autoPlace) placement = placement.replace(autoToken, "") || "top";
            $tip.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(placement).data("bs." + this.type, this);
            this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
            this.$element.trigger("inserted.bs." + this.type);
            var pos = this.getPosition();
            var actualWidth = $tip[0].offsetWidth;
            var actualHeight = $tip[0].offsetHeight;
            if (autoPlace) {
                var orgPlacement = placement;
                var viewportDim = this.getPosition(this.$viewport);
                placement = placement == "bottom" && pos.bottom + actualHeight > viewportDim.bottom ? "top" : placement == "top" && pos.top - actualHeight < viewportDim.top ? "bottom" : placement == "right" && pos.right + actualWidth > viewportDim.width ? "left" : placement == "left" && pos.left - actualWidth < viewportDim.left ? "right" : placement;
                $tip.removeClass(orgPlacement).addClass(placement);
            }
            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
            this.applyPlacement(calculatedOffset, placement);
            var complete = function() {
                var prevHoverState = that.hoverState;
                that.$element.trigger("shown.bs." + that.type);
                that.hoverState = null;
                if (prevHoverState == "out") that.leave(that);
            };
            $.support.transition && this.$tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        }
    };
    Tooltip.prototype.applyPlacement = function(offset, placement) {
        var $tip = this.tip();
        var width = $tip[0].offsetWidth;
        var height = $tip[0].offsetHeight;
        var marginTop = parseInt($tip.css("margin-top"), 10);
        var marginLeft = parseInt($tip.css("margin-left"), 10);
        if (isNaN(marginTop)) marginTop = 0;
        if (isNaN(marginLeft)) marginLeft = 0;
        offset.top += marginTop;
        offset.left += marginLeft;
        $.offset.setOffset($tip[0], $.extend({
            using: function(props) {
                $tip.css({
                    top: Math.round(props.top),
                    left: Math.round(props.left)
                });
            }
        }, offset), 0);
        $tip.addClass("in");
        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;
        if (placement == "top" && actualHeight != height) {
            offset.top = offset.top + height - actualHeight;
        }
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
        if (delta.left) offset.left += delta.left; else offset.top += delta.top;
        var isVertical = /top|bottom/.test(placement);
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
        var arrowOffsetPosition = isVertical ? "offsetWidth" : "offsetHeight";
        $tip.offset(offset);
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
    };
    Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
        this.arrow().css(isVertical ? "left" : "top", 50 * (1 - delta / dimension) + "%").css(isVertical ? "top" : "left", "");
    };
    Tooltip.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title);
        $tip.removeClass("fade in top bottom left right");
    };
    Tooltip.prototype.hide = function(callback) {
        var that = this;
        var $tip = $(this.$tip);
        var e = $.Event("hide.bs." + this.type);
        function complete() {
            if (that.hoverState != "in") $tip.detach();
            if (that.$element) {
                that.$element.removeAttr("aria-describedby").trigger("hidden.bs." + that.type);
            }
            callback && callback();
        }
        this.$element.trigger(e);
        if (e.isDefaultPrevented()) return;
        $tip.removeClass("in");
        $.support.transition && $tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        this.hoverState = null;
        return this;
    };
    Tooltip.prototype.fixTitle = function() {
        var $e = this.$element;
        if ($e.attr("title") || typeof $e.attr("data-original-title") != "string") {
            $e.attr("data-original-title", $e.attr("title") || "").attr("title", "");
        }
    };
    Tooltip.prototype.hasContent = function() {
        return this.getTitle();
    };
    Tooltip.prototype.getPosition = function($element) {
        $element = $element || this.$element;
        var el = $element[0];
        var isBody = el.tagName == "BODY";
        var elRect = el.getBoundingClientRect();
        if (elRect.width == null) {
            elRect = $.extend({}, elRect, {
                width: elRect.right - elRect.left,
                height: elRect.bottom - elRect.top
            });
        }
        var isSvg = window.SVGElement && el instanceof window.SVGElement;
        var elOffset = isBody ? {
            top: 0,
            left: 0
        } : isSvg ? null : $element.offset();
        var scroll = {
            scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
        };
        var outerDims = isBody ? {
            width: $(window).width(),
            height: $(window).height()
        } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset);
    };
    Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        return placement == "bottom" ? {
            top: pos.top + pos.height,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == "top" ? {
            top: pos.top - actualHeight,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == "left" ? {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left - actualWidth
        } : {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left + pos.width
        };
    };
    Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
        var delta = {
            top: 0,
            left: 0
        };
        if (!this.$viewport) return delta;
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
        var viewportDimensions = this.getPosition(this.$viewport);
        if (/right|left/.test(placement)) {
            var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
            var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
            if (topEdgeOffset < viewportDimensions.top) {
                delta.top = viewportDimensions.top - topEdgeOffset;
            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
                delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
            }
        } else {
            var leftEdgeOffset = pos.left - viewportPadding;
            var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
            if (leftEdgeOffset < viewportDimensions.left) {
                delta.left = viewportDimensions.left - leftEdgeOffset;
            } else if (rightEdgeOffset > viewportDimensions.right) {
                delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
            }
        }
        return delta;
    };
    Tooltip.prototype.getTitle = function() {
        var title;
        var $e = this.$element;
        var o = this.options;
        title = $e.attr("data-original-title") || (typeof o.title == "function" ? o.title.call($e[0]) : o.title);
        return title;
    };
    Tooltip.prototype.getUID = function(prefix) {
        do {
            prefix += ~~(Math.random() * 1e6);
        } while (document.getElementById(prefix));
        return prefix;
    };
    Tooltip.prototype.tip = function() {
        if (!this.$tip) {
            this.$tip = $(this.options.template);
            if (this.$tip.length != 1) {
                throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");
            }
        }
        return this.$tip;
    };
    Tooltip.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
    };
    Tooltip.prototype.enable = function() {
        this.enabled = true;
    };
    Tooltip.prototype.disable = function() {
        this.enabled = false;
    };
    Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled;
    };
    Tooltip.prototype.toggle = function(e) {
        var self = this;
        if (e) {
            self = $(e.currentTarget).data("bs." + this.type);
            if (!self) {
                self = new this.constructor(e.currentTarget, this.getDelegateOptions());
                $(e.currentTarget).data("bs." + this.type, self);
            }
        }
        if (e) {
            self.inState.click = !self.inState.click;
            if (self.isInStateTrue()) self.enter(self); else self.leave(self);
        } else {
            self.tip().hasClass("in") ? self.leave(self) : self.enter(self);
        }
    };
    Tooltip.prototype.destroy = function() {
        var that = this;
        clearTimeout(this.timeout);
        this.hide(function() {
            that.$element.off("." + that.type).removeData("bs." + that.type);
            if (that.$tip) {
                that.$tip.detach();
            }
            that.$tip = null;
            that.$arrow = null;
            that.$viewport = null;
            that.$element = null;
        });
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.tooltip");
            var options = typeof option == "object" && option;
            if (!data && /destroy|hide/.test(option)) return;
            if (!data) $this.data("bs.tooltip", data = new Tooltip(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.tooltip;
    $.fn.tooltip = Plugin;
    $.fn.tooltip.Constructor = Tooltip;
    $.fn.tooltip.noConflict = function() {
        $.fn.tooltip = old;
        return this;
    };
}(jQuery);

+function($) {
    "use strict";
    var Popover = function(element, options) {
        this.init("popover", element, options);
    };
    if (!$.fn.tooltip) throw new Error("Popover requires tooltip.js");
    Popover.VERSION = "3.3.7";
    Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    });
    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);
    Popover.prototype.constructor = Popover;
    Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS;
    };
    Popover.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        var content = this.getContent();
        $tip.find(".popover-title")[this.options.html ? "html" : "text"](title);
        $tip.find(".popover-content").children().detach().end()[this.options.html ? typeof content == "string" ? "html" : "append" : "text"](content);
        $tip.removeClass("fade top bottom left right in");
        if (!$tip.find(".popover-title").html()) $tip.find(".popover-title").hide();
    };
    Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent();
    };
    Popover.prototype.getContent = function() {
        var $e = this.$element;
        var o = this.options;
        return $e.attr("data-content") || (typeof o.content == "function" ? o.content.call($e[0]) : o.content);
    };
    Popover.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".arrow");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.popover");
            var options = typeof option == "object" && option;
            if (!data && /destroy|hide/.test(option)) return;
            if (!data) $this.data("bs.popover", data = new Popover(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.popover;
    $.fn.popover = Plugin;
    $.fn.popover.Constructor = Popover;
    $.fn.popover.noConflict = function() {
        $.fn.popover = old;
        return this;
    };
}(jQuery);

+function($) {
    "use strict";
    function ScrollSpy(element, options) {
        this.$body = $(document.body);
        this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
        this.selector = (this.options.target || "") + " .nav li > a";
        this.offsets = [];
        this.targets = [];
        this.activeTarget = null;
        this.scrollHeight = 0;
        this.$scrollElement.on("scroll.bs.scrollspy", $.proxy(this.process, this));
        this.refresh();
        this.process();
    }
    ScrollSpy.VERSION = "3.3.7";
    ScrollSpy.DEFAULTS = {
        offset: 10
    };
    ScrollSpy.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
    };
    ScrollSpy.prototype.refresh = function() {
        var that = this;
        var offsetMethod = "offset";
        var offsetBase = 0;
        this.offsets = [];
        this.targets = [];
        this.scrollHeight = this.getScrollHeight();
        if (!$.isWindow(this.$scrollElement[0])) {
            offsetMethod = "position";
            offsetBase = this.$scrollElement.scrollTop();
        }
        this.$body.find(this.selector).map(function() {
            var $el = $(this);
            var href = $el.data("target") || $el.attr("href");
            var $href = /^#./.test(href) && $(href);
            return $href && $href.length && $href.is(":visible") && [ [ $href[offsetMethod]().top + offsetBase, href ] ] || null;
        }).sort(function(a, b) {
            return a[0] - b[0];
        }).each(function() {
            that.offsets.push(this[0]);
            that.targets.push(this[1]);
        });
    };
    ScrollSpy.prototype.process = function() {
        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
        var scrollHeight = this.getScrollHeight();
        var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();
        var offsets = this.offsets;
        var targets = this.targets;
        var activeTarget = this.activeTarget;
        var i;
        if (this.scrollHeight != scrollHeight) {
            this.refresh();
        }
        if (scrollTop >= maxScroll) {
            return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        }
        if (activeTarget && scrollTop < offsets[0]) {
            this.activeTarget = null;
            return this.clear();
        }
        for (i = offsets.length; i--; ) {
            activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
        }
    };
    ScrollSpy.prototype.activate = function(target) {
        this.activeTarget = target;
        this.clear();
        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';
        var active = $(selector).parents("li").addClass("active");
        if (active.parent(".dropdown-menu").length) {
            active = active.closest("li.dropdown").addClass("active");
        }
        active.trigger("activate.bs.scrollspy");
    };
    ScrollSpy.prototype.clear = function() {
        $(this.selector).parentsUntil(this.options.target, ".active").removeClass("active");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.scrollspy");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.scrollspy", data = new ScrollSpy(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.scrollspy;
    $.fn.scrollspy = Plugin;
    $.fn.scrollspy.Constructor = ScrollSpy;
    $.fn.scrollspy.noConflict = function() {
        $.fn.scrollspy = old;
        return this;
    };
    $(window).on("load.bs.scrollspy.data-api", function() {
        $('[data-spy="scroll"]').each(function() {
            var $spy = $(this);
            Plugin.call($spy, $spy.data());
        });
    });
}(jQuery);

+function($) {
    "use strict";
    var Tab = function(element) {
        this.element = $(element);
    };
    Tab.VERSION = "3.3.7";
    Tab.TRANSITION_DURATION = 150;
    Tab.prototype.show = function() {
        var $this = this.element;
        var $ul = $this.closest("ul:not(.dropdown-menu)");
        var selector = $this.data("target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        if ($this.parent("li").hasClass("active")) return;
        var $previous = $ul.find(".active:last a");
        var hideEvent = $.Event("hide.bs.tab", {
            relatedTarget: $this[0]
        });
        var showEvent = $.Event("show.bs.tab", {
            relatedTarget: $previous[0]
        });
        $previous.trigger(hideEvent);
        $this.trigger(showEvent);
        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return;
        var $target = $(selector);
        this.activate($this.closest("li"), $ul);
        this.activate($target, $target.parent(), function() {
            $previous.trigger({
                type: "hidden.bs.tab",
                relatedTarget: $this[0]
            });
            $this.trigger({
                type: "shown.bs.tab",
                relatedTarget: $previous[0]
            });
        });
    };
    Tab.prototype.activate = function(element, container, callback) {
        var $active = container.find("> .active");
        var transition = callback && $.support.transition && ($active.length && $active.hasClass("fade") || !!container.find("> .fade").length);
        function next() {
            $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", false);
            element.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", true);
            if (transition) {
                element[0].offsetWidth;
                element.addClass("in");
            } else {
                element.removeClass("fade");
            }
            if (element.parent(".dropdown-menu").length) {
                element.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", true);
            }
            callback && callback();
        }
        $active.length && transition ? $active.one("bsTransitionEnd", next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();
        $active.removeClass("in");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.tab");
            if (!data) $this.data("bs.tab", data = new Tab(this));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.tab;
    $.fn.tab = Plugin;
    $.fn.tab.Constructor = Tab;
    $.fn.tab.noConflict = function() {
        $.fn.tab = old;
        return this;
    };
    var clickHandler = function(e) {
        e.preventDefault();
        Plugin.call($(this), "show");
    };
    $(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler).on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler);
}(jQuery);

+function($) {
    "use strict";
    var Affix = function(element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options);
        this.$target = $(this.options.target).on("scroll.bs.affix.data-api", $.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", $.proxy(this.checkPositionWithEventLoop, this));
        this.$element = $(element);
        this.affixed = null;
        this.unpin = null;
        this.pinnedOffset = null;
        this.checkPosition();
    };
    Affix.VERSION = "3.3.7";
    Affix.RESET = "affix affix-top affix-bottom";
    Affix.DEFAULTS = {
        offset: 0,
        target: window
    };
    Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        var targetHeight = this.$target.height();
        if (offsetTop != null && this.affixed == "top") return scrollTop < offsetTop ? "top" : false;
        if (this.affixed == "bottom") {
            if (offsetTop != null) return scrollTop + this.unpin <= position.top ? false : "bottom";
            return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : "bottom";
        }
        var initializing = this.affixed == null;
        var colliderTop = initializing ? scrollTop : position.top;
        var colliderHeight = initializing ? targetHeight : height;
        if (offsetTop != null && scrollTop <= offsetTop) return "top";
        if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom) return "bottom";
        return false;
    };
    Affix.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass("affix");
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        return this.pinnedOffset = position.top - scrollTop;
    };
    Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1);
    };
    Affix.prototype.checkPosition = function() {
        if (!this.$element.is(":visible")) return;
        var height = this.$element.height();
        var offset = this.options.offset;
        var offsetTop = offset.top;
        var offsetBottom = offset.bottom;
        var scrollHeight = Math.max($(document).height(), $(document.body).height());
        if (typeof offset != "object") offsetBottom = offsetTop = offset;
        if (typeof offsetTop == "function") offsetTop = offset.top(this.$element);
        if (typeof offsetBottom == "function") offsetBottom = offset.bottom(this.$element);
        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);
        if (this.affixed != affix) {
            if (this.unpin != null) this.$element.css("top", "");
            var affixType = "affix" + (affix ? "-" + affix : "");
            var e = $.Event(affixType + ".bs.affix");
            this.$element.trigger(e);
            if (e.isDefaultPrevented()) return;
            this.affixed = affix;
            this.unpin = affix == "bottom" ? this.getPinnedOffset() : null;
            this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace("affix", "affixed") + ".bs.affix");
        }
        if (affix == "bottom") {
            this.$element.offset({
                top: scrollHeight - height - offsetBottom
            });
        }
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.affix");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.affix", data = new Affix(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.affix;
    $.fn.affix = Plugin;
    $.fn.affix.Constructor = Affix;
    $.fn.affix.noConflict = function() {
        $.fn.affix = old;
        return this;
    };
    $(window).on("load", function() {
        $('[data-spy="affix"]').each(function() {
            var $spy = $(this);
            var data = $spy.data();
            data.offset = data.offset || {};
            if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom;
            if (data.offsetTop != null) data.offset.top = data.offsetTop;
            Plugin.call($spy, data);
        });
    });
}(jQuery);

(function($, window, undefined) {
    var $allDropdowns = $();
    $.fn.dropdownHover = function(options) {
        if ("ontouchstart" in document) return this;
        $allDropdowns = $allDropdowns.add(this.parent());
        return this.each(function() {
            var $this = $(this), $parent = $this.parent(), defaults = {
                delay: 500,
                hoverDelay: 0,
                instantlyCloseOthers: true
            }, data = {
                delay: $(this).data("delay"),
                hoverDelay: $(this).data("hover-delay"),
                instantlyCloseOthers: $(this).data("close-others")
            }, showEvent = "show.bs.dropdown", hideEvent = "hide.bs.dropdown", settings = $.extend(true, {}, defaults, options, data), timeout, timeoutHover;
            $parent.hover(function(event) {
                if (!$parent.hasClass("open") && !$this.is(event.target)) {
                    return true;
                }
                openDropdown(event);
            }, function() {
                window.clearTimeout(timeoutHover);
                timeout = window.setTimeout(function() {
                    $this.attr("aria-expanded", "false");
                    $parent.removeClass("open");
                    $this.trigger(hideEvent);
                }, settings.delay);
            });
            $this.hover(function(event) {
                if (!$parent.hasClass("open") && !$parent.is(event.target)) {
                    return true;
                }
                openDropdown(event);
            });
            $parent.find(".dropdown-submenu").each(function() {
                var $this = $(this);
                var subTimeout;
                $this.hover(function() {
                    window.clearTimeout(subTimeout);
                    $this.children(".dropdown-menu").show();
                    $this.siblings().children(".dropdown-menu").hide();
                }, function() {
                    var $submenu = $this.children(".dropdown-menu");
                    subTimeout = window.setTimeout(function() {
                        $submenu.hide();
                    }, settings.delay);
                });
            });
            function openDropdown(event) {
                window.clearTimeout(timeout);
                window.clearTimeout(timeoutHover);
                timeoutHover = window.setTimeout(function() {
                    $allDropdowns.find(":focus").blur();
                    if (settings.instantlyCloseOthers === true) $allDropdowns.removeClass("open");
                    window.clearTimeout(timeoutHover);
                    $this.attr("aria-expanded", "true");
                    $parent.addClass("open");
                    $this.trigger(showEvent);
                }, settings.hoverDelay);
            }
        });
    };
    $(document).ready(function() {
        $('[data-hover="dropdown"]').dropdownHover();
    });
})(jQuery, window);

(function($) {
    $.fn.extend({
        slimScroll: function(options) {
            var defaults = {
                width: "auto",
                height: "250px",
                size: "7px",
                color: "#000",
                position: "right",
                distance: "1px",
                start: "top",
                opacity: .4,
                alwaysVisible: false,
                disableFadeOut: false,
                railVisible: false,
                railColor: "#333",
                railOpacity: .2,
                railDraggable: true,
                railClass: "slimScrollRail",
                barClass: "slimScrollBar",
                wrapperClass: "slimScrollDiv",
                allowPageScroll: false,
                wheelStep: 20,
                touchScrollStep: 200,
                borderRadius: "7px",
                railBorderRadius: "7px"
            };
            var o = $.extend(defaults, options);
            this.each(function() {
                var isOverPanel, isOverBar, isDragg, queueHide, touchDif, barHeight, percentScroll, lastScroll, divS = "<div></div>", minBarHeight = 30, releaseScroll = false;
                var me = $(this);
                if (me.parent().hasClass(o.wrapperClass)) {
                    var offset = me.scrollTop();
                    bar = me.siblings("." + o.barClass);
                    rail = me.siblings("." + o.railClass);
                    getBarHeight();
                    if ($.isPlainObject(options)) {
                        if ("height" in options && options.height == "auto") {
                            me.parent().css("height", "auto");
                            me.css("height", "auto");
                            var height = me.parent().parent().height();
                            me.parent().css("height", height);
                            me.css("height", height);
                        } else if ("height" in options) {
                            var h = options.height;
                            me.parent().css("height", h);
                            me.css("height", h);
                        }
                        if ("scrollTo" in options) {
                            offset = parseInt(o.scrollTo);
                        } else if ("scrollBy" in options) {
                            offset += parseInt(o.scrollBy);
                        } else if ("destroy" in options) {
                            bar.remove();
                            rail.remove();
                            me.unwrap();
                            return;
                        }
                        scrollContent(offset, false, true);
                    }
                    return;
                } else if ($.isPlainObject(options)) {
                    if ("destroy" in options) {
                        return;
                    }
                }
                o.height = o.height == "auto" ? me.parent().height() : o.height;
                var wrapper = $(divS).addClass(o.wrapperClass).css({
                    position: "relative",
                    overflow: "hidden",
                    width: o.width,
                    height: o.height
                });
                me.css({
                    overflow: "hidden",
                    width: o.width,
                    height: o.height
                });
                var rail = $(divS).addClass(o.railClass).css({
                    width: o.size,
                    height: "100%",
                    position: "absolute",
                    top: 0,
                    display: o.alwaysVisible && o.railVisible ? "block" : "none",
                    "border-radius": o.railBorderRadius,
                    background: o.railColor,
                    opacity: o.railOpacity,
                    zIndex: 90
                });
                var bar = $(divS).addClass(o.barClass).css({
                    background: o.color,
                    width: o.size,
                    position: "absolute",
                    top: 0,
                    opacity: o.opacity,
                    display: o.alwaysVisible ? "block" : "none",
                    "border-radius": o.borderRadius,
                    BorderRadius: o.borderRadius,
                    MozBorderRadius: o.borderRadius,
                    WebkitBorderRadius: o.borderRadius,
                    zIndex: 99
                });
                var posCss = o.position == "right" ? {
                    right: o.distance
                } : {
                    left: o.distance
                };
                rail.css(posCss);
                bar.css(posCss);
                me.wrap(wrapper);
                me.parent().append(bar);
                me.parent().append(rail);
                if (o.railDraggable) {
                    bar.bind("mousedown", function(e) {
                        var $doc = $(document);
                        isDragg = true;
                        t = parseFloat(bar.css("top"));
                        pageY = e.pageY;
                        $doc.bind("mousemove.slimscroll", function(e) {
                            currTop = t + e.pageY - pageY;
                            bar.css("top", currTop);
                            scrollContent(0, bar.position().top, false);
                        });
                        $doc.bind("mouseup.slimscroll", function(e) {
                            isDragg = false;
                            hideBar();
                            $doc.unbind(".slimscroll");
                        });
                        return false;
                    }).bind("selectstart.slimscroll", function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        return false;
                    });
                }
                rail.hover(function() {
                    showBar();
                }, function() {
                    hideBar();
                });
                bar.hover(function() {
                    isOverBar = true;
                }, function() {
                    isOverBar = false;
                });
                me.hover(function() {
                    isOverPanel = true;
                    showBar();
                    hideBar();
                }, function() {
                    isOverPanel = false;
                    hideBar();
                });
                me.bind("touchstart", function(e, b) {
                    if (e.originalEvent.touches.length) {
                        touchDif = e.originalEvent.touches[0].pageY;
                    }
                });
                me.bind("touchmove", function(e) {
                    if (!releaseScroll) {
                        e.originalEvent.preventDefault();
                    }
                    if (e.originalEvent.touches.length) {
                        var diff = (touchDif - e.originalEvent.touches[0].pageY) / o.touchScrollStep;
                        scrollContent(diff, true);
                        touchDif = e.originalEvent.touches[0].pageY;
                    }
                });
                getBarHeight();
                if (o.start === "bottom") {
                    bar.css({
                        top: me.outerHeight() - bar.outerHeight()
                    });
                    scrollContent(0, true);
                } else if (o.start !== "top") {
                    scrollContent($(o.start).position().top, null, true);
                    if (!o.alwaysVisible) {
                        bar.hide();
                    }
                }
                attachWheel(this);
                function _onWheel(e) {
                    if (!isOverPanel) {
                        return;
                    }
                    var e = e || window.event;
                    var delta = 0;
                    if (e.wheelDelta) {
                        delta = -e.wheelDelta / 120;
                    }
                    if (e.detail) {
                        delta = e.detail / 3;
                    }
                    var target = e.target || e.srcTarget || e.srcElement;
                    if ($(target).closest("." + o.wrapperClass).is(me.parent())) {
                        scrollContent(delta, true);
                    }
                    if (e.preventDefault && !releaseScroll) {
                        e.preventDefault();
                    }
                    if (!releaseScroll) {
                        e.returnValue = false;
                    }
                }
                function scrollContent(y, isWheel, isJump) {
                    releaseScroll = false;
                    var delta = y;
                    var maxTop = me.outerHeight() - bar.outerHeight();
                    if (isWheel) {
                        delta = parseInt(bar.css("top")) + y * parseInt(o.wheelStep) / 100 * bar.outerHeight();
                        delta = Math.min(Math.max(delta, 0), maxTop);
                        delta = y > 0 ? Math.ceil(delta) : Math.floor(delta);
                        bar.css({
                            top: delta + "px"
                        });
                    }
                    percentScroll = parseInt(bar.css("top")) / (me.outerHeight() - bar.outerHeight());
                    delta = percentScroll * (me[0].scrollHeight - me.outerHeight());
                    if (isJump) {
                        delta = y;
                        var offsetTop = delta / me[0].scrollHeight * me.outerHeight();
                        offsetTop = Math.min(Math.max(offsetTop, 0), maxTop);
                        bar.css({
                            top: offsetTop + "px"
                        });
                    }
                    me.scrollTop(delta);
                    me.trigger("slimscrolling", ~~delta);
                    showBar();
                    hideBar();
                }
                function attachWheel(target) {
                    if (window.addEventListener) {
                        target.addEventListener("DOMMouseScroll", _onWheel, false);
                        target.addEventListener("mousewheel", _onWheel, false);
                    } else {
                        document.attachEvent("onmousewheel", _onWheel);
                    }
                }
                function getBarHeight() {
                    barHeight = Math.max(me.outerHeight() / me[0].scrollHeight * me.outerHeight(), minBarHeight);
                    bar.css({
                        height: barHeight + "px"
                    });
                    var display = barHeight == me.outerHeight() ? "none" : "block";
                    bar.css({
                        display: display
                    });
                }
                function showBar() {
                    getBarHeight();
                    clearTimeout(queueHide);
                    if (percentScroll == ~~percentScroll) {
                        releaseScroll = o.allowPageScroll;
                        if (lastScroll != percentScroll) {
                            var msg = ~~percentScroll == 0 ? "top" : "bottom";
                            me.trigger("slimscroll", msg);
                        }
                    } else {
                        releaseScroll = false;
                    }
                    lastScroll = percentScroll;
                    if (barHeight >= me.outerHeight()) {
                        releaseScroll = true;
                        return;
                    }
                    bar.stop(true, true).fadeIn("fast");
                    if (o.railVisible) {
                        rail.stop(true, true).fadeIn("fast");
                    }
                }
                function hideBar() {
                    if (!o.alwaysVisible) {
                        queueHide = setTimeout(function() {
                            if (!(o.disableFadeOut && isOverPanel) && !isOverBar && !isDragg) {
                                bar.fadeOut("slow");
                                rail.fadeOut("slow");
                            }
                        }, 1e3);
                    }
                }
            });
            return this;
        }
    });
    $.fn.extend({
        slimscroll: $.fn.slimScroll
    });
})(jQuery);

(function(e) {
    e.fn.extend({
        slimScroll: function(f) {
            var a = e.extend({
                width: "auto",
                height: "250px",
                size: "7px",
                color: "#000",
                position: "right",
                distance: "1px",
                start: "top",
                opacity: .4,
                alwaysVisible: !1,
                disableFadeOut: !1,
                railVisible: !1,
                railColor: "#333",
                railOpacity: .2,
                railDraggable: !0,
                railClass: "slimScrollRail",
                barClass: "slimScrollBar",
                wrapperClass: "slimScrollDiv",
                allowPageScroll: !1,
                wheelStep: 20,
                touchScrollStep: 200,
                borderRadius: "7px",
                railBorderRadius: "7px"
            }, f);
            this.each(function() {
                function v(d) {
                    if (r) {
                        d = d || window.event;
                        var c = 0;
                        d.wheelDelta && (c = -d.wheelDelta / 120);
                        d.detail && (c = d.detail / 3);
                        e(d.target || d.srcTarget || d.srcElement).closest("." + a.wrapperClass).is(b.parent()) && n(c, !0);
                        d.preventDefault && !k && d.preventDefault();
                        k || (d.returnValue = !1);
                    }
                }
                function n(d, g, e) {
                    k = !1;
                    var f = b.outerHeight() - c.outerHeight();
                    g && (g = parseInt(c.css("top")) + d * parseInt(a.wheelStep) / 100 * c.outerHeight(), 
                    g = Math.min(Math.max(g, 0), f), g = 0 < d ? Math.ceil(g) : Math.floor(g), c.css({
                        top: g + "px"
                    }));
                    l = parseInt(c.css("top")) / (b.outerHeight() - c.outerHeight());
                    g = l * (b[0].scrollHeight - b.outerHeight());
                    e && (g = d, d = g / b[0].scrollHeight * b.outerHeight(), d = Math.min(Math.max(d, 0), f), 
                    c.css({
                        top: d + "px"
                    }));
                    b.scrollTop(g);
                    b.trigger("slimscrolling", ~~g);
                    w();
                    p();
                }
                function x() {
                    u = Math.max(b.outerHeight() / b[0].scrollHeight * b.outerHeight(), 30);
                    c.css({
                        height: u + "px"
                    });
                    var a = u == b.outerHeight() ? "none" : "block";
                    c.css({
                        display: a
                    });
                }
                function w() {
                    x();
                    clearTimeout(B);
                    l == ~~l ? (k = a.allowPageScroll, C != l && b.trigger("slimscroll", 0 == ~~l ? "top" : "bottom")) : k = !1;
                    C = l;
                    u >= b.outerHeight() ? k = !0 : (c.stop(!0, !0).fadeIn("fast"), a.railVisible && m.stop(!0, !0).fadeIn("fast"));
                }
                function p() {
                    a.alwaysVisible || (B = setTimeout(function() {
                        a.disableFadeOut && r || y || z || (c.fadeOut("slow"), m.fadeOut("slow"));
                    }, 1e3));
                }
                var r, y, z, B, A, u, l, C, k = !1, b = e(this);
                if (b.parent().hasClass(a.wrapperClass)) {
                    var q = b.scrollTop(), c = b.siblings("." + a.barClass), m = b.siblings("." + a.railClass);
                    x();
                    if (e.isPlainObject(f)) {
                        if ("height" in f && "auto" == f.height) {
                            b.parent().css("height", "auto");
                            b.css("height", "auto");
                            var h = b.parent().parent().height();
                            b.parent().css("height", h);
                            b.css("height", h);
                        } else "height" in f && (h = f.height, b.parent().css("height", h), b.css("height", h));
                        if ("scrollTo" in f) q = parseInt(a.scrollTo); else if ("scrollBy" in f) q += parseInt(a.scrollBy); else if ("destroy" in f) {
                            c.remove();
                            m.remove();
                            b.unwrap();
                            return;
                        }
                        n(q, !1, !0);
                    }
                } else if (!(e.isPlainObject(f) && "destroy" in f)) {
                    a.height = "auto" == a.height ? b.parent().height() : a.height;
                    q = e("<div></div>").addClass(a.wrapperClass).css({
                        position: "relative",
                        overflow: "hidden",
                        width: a.width,
                        height: a.height
                    });
                    b.css({
                        overflow: "hidden",
                        width: a.width,
                        height: a.height
                    });
                    var m = e("<div></div>").addClass(a.railClass).css({
                        width: a.size,
                        height: "100%",
                        position: "absolute",
                        top: 0,
                        display: a.alwaysVisible && a.railVisible ? "block" : "none",
                        "border-radius": a.railBorderRadius,
                        background: a.railColor,
                        opacity: a.railOpacity,
                        zIndex: 90
                    }), c = e("<div></div>").addClass(a.barClass).css({
                        background: a.color,
                        width: a.size,
                        position: "absolute",
                        top: 0,
                        opacity: a.opacity,
                        display: a.alwaysVisible ? "block" : "none",
                        "border-radius": a.borderRadius,
                        BorderRadius: a.borderRadius,
                        MozBorderRadius: a.borderRadius,
                        WebkitBorderRadius: a.borderRadius,
                        zIndex: 99
                    }), h = "right" == a.position ? {
                        right: a.distance
                    } : {
                        left: a.distance
                    };
                    m.css(h);
                    c.css(h);
                    b.wrap(q);
                    b.parent().append(c);
                    b.parent().append(m);
                    a.railDraggable && c.bind("mousedown", function(a) {
                        var b = e(document);
                        z = !0;
                        t = parseFloat(c.css("top"));
                        pageY = a.pageY;
                        b.bind("mousemove.slimscroll", function(a) {
                            currTop = t + a.pageY - pageY;
                            c.css("top", currTop);
                            n(0, c.position().top, !1);
                        });
                        b.bind("mouseup.slimscroll", function(a) {
                            z = !1;
                            p();
                            b.unbind(".slimscroll");
                        });
                        return !1;
                    }).bind("selectstart.slimscroll", function(a) {
                        a.stopPropagation();
                        a.preventDefault();
                        return !1;
                    });
                    m.hover(function() {
                        w();
                    }, function() {
                        p();
                    });
                    c.hover(function() {
                        y = !0;
                    }, function() {
                        y = !1;
                    });
                    b.hover(function() {
                        r = !0;
                        w();
                        p();
                    }, function() {
                        r = !1;
                        p();
                    });
                    b.bind("touchstart", function(a, b) {
                        a.originalEvent.touches.length && (A = a.originalEvent.touches[0].pageY);
                    });
                    b.bind("touchmove", function(b) {
                        k || b.originalEvent.preventDefault();
                        b.originalEvent.touches.length && (n((A - b.originalEvent.touches[0].pageY) / a.touchScrollStep, !0), 
                        A = b.originalEvent.touches[0].pageY);
                    });
                    x();
                    "bottom" === a.start ? (c.css({
                        top: b.outerHeight() - c.outerHeight()
                    }), n(0, !0)) : "top" !== a.start && (n(e(a.start).position().top, null, !0), a.alwaysVisible || c.hide());
                    window.addEventListener ? (this.addEventListener("DOMMouseScroll", v, !1), this.addEventListener("mousewheel", v, !1)) : document.attachEvent("onmousewheel", v);
                }
            });
            return this;
        }
    });
    e.fn.extend({
        slimscroll: e.fn.slimScroll
    });
})(jQuery);

(function() {
    "use strict";
    function setup($) {
        $.fn._fadeIn = $.fn.fadeIn;
        var noOp = $.noop || function() {};
        var msie = /MSIE/.test(navigator.userAgent);
        var ie6 = /MSIE 6.0/.test(navigator.userAgent) && !/MSIE 8.0/.test(navigator.userAgent);
        var mode = document.documentMode || 0;
        var setExpr = $.isFunction(document.createElement("div").style.setExpression);
        $.blockUI = function(opts) {
            install(window, opts);
        };
        $.unblockUI = function(opts) {
            remove(window, opts);
        };
        $.growlUI = function(title, message, timeout, onClose) {
            var $m = $('<div class="growlUI"></div>');
            if (title) $m.append("<h1>" + title + "</h1>");
            if (message) $m.append("<h2>" + message + "</h2>");
            if (timeout === undefined) timeout = 3e3;
            var callBlock = function(opts) {
                opts = opts || {};
                $.blockUI({
                    message: $m,
                    fadeIn: typeof opts.fadeIn !== "undefined" ? opts.fadeIn : 700,
                    fadeOut: typeof opts.fadeOut !== "undefined" ? opts.fadeOut : 1e3,
                    timeout: typeof opts.timeout !== "undefined" ? opts.timeout : timeout,
                    centerY: false,
                    showOverlay: false,
                    onUnblock: onClose,
                    css: $.blockUI.defaults.growlCSS
                });
            };
            callBlock();
            var nonmousedOpacity = $m.css("opacity");
            $m.mouseover(function() {
                callBlock({
                    fadeIn: 0,
                    timeout: 3e4
                });
                var displayBlock = $(".blockMsg");
                displayBlock.stop();
                displayBlock.fadeTo(300, 1);
            }).mouseout(function() {
                $(".blockMsg").fadeOut(1e3);
            });
        };
        $.fn.block = function(opts) {
            if (this[0] === window) {
                $.blockUI(opts);
                return this;
            }
            var fullOpts = $.extend({}, $.blockUI.defaults, opts || {});
            this.each(function() {
                var $el = $(this);
                if (fullOpts.ignoreIfBlocked && $el.data("blockUI.isBlocked")) return;
                $el.unblock({
                    fadeOut: 0
                });
            });
            return this.each(function() {
                if ($.css(this, "position") == "static") {
                    this.style.position = "relative";
                    $(this).data("blockUI.static", true);
                }
                this.style.zoom = 1;
                install(this, opts);
            });
        };
        $.fn.unblock = function(opts) {
            if (this[0] === window) {
                $.unblockUI(opts);
                return this;
            }
            return this.each(function() {
                remove(this, opts);
            });
        };
        $.blockUI.version = 2.7;
        $.blockUI.defaults = {
            message: "<h1>Please wait...</h1>",
            title: null,
            draggable: true,
            theme: false,
            css: {
                padding: 0,
                margin: 0,
                width: "30%",
                top: "40%",
                left: "35%",
                textAlign: "center",
                color: "#000",
                border: "3px solid #aaa",
                backgroundColor: "#fff",
                cursor: "wait"
            },
            themedCSS: {
                width: "30%",
                top: "40%",
                left: "35%"
            },
            overlayCSS: {
                backgroundColor: "#000",
                opacity: .6,
                cursor: "wait"
            },
            cursorReset: "default",
            growlCSS: {
                width: "350px",
                top: "10px",
                left: "",
                right: "10px",
                border: "none",
                padding: "5px",
                opacity: .6,
                cursor: "default",
                color: "#fff",
                backgroundColor: "#000",
                "-webkit-border-radius": "10px",
                "-moz-border-radius": "10px",
                "border-radius": "10px"
            },
            iframeSrc: /^https/i.test(window.location.href || "") ? "javascript:false" : "about:blank",
            forceIframe: false,
            baseZ: 1e3,
            centerX: true,
            centerY: true,
            allowBodyStretch: true,
            bindEvents: true,
            constrainTabKey: true,
            fadeIn: 200,
            fadeOut: 400,
            timeout: 0,
            showOverlay: true,
            focusInput: true,
            focusableElements: ":input:enabled:visible",
            onBlock: null,
            onUnblock: null,
            onOverlayClick: null,
            quirksmodeOffsetHack: 4,
            blockMsgClass: "blockMsg",
            ignoreIfBlocked: false
        };
        var pageBlock = null;
        var pageBlockEls = [];
        function install(el, opts) {
            var css, themedCSS;
            var full = el == window;
            var msg = opts && opts.message !== undefined ? opts.message : undefined;
            opts = $.extend({}, $.blockUI.defaults, opts || {});
            if (opts.ignoreIfBlocked && $(el).data("blockUI.isBlocked")) return;
            opts.overlayCSS = $.extend({}, $.blockUI.defaults.overlayCSS, opts.overlayCSS || {});
            css = $.extend({}, $.blockUI.defaults.css, opts.css || {});
            if (opts.onOverlayClick) opts.overlayCSS.cursor = "pointer";
            themedCSS = $.extend({}, $.blockUI.defaults.themedCSS, opts.themedCSS || {});
            msg = msg === undefined ? opts.message : msg;
            if (full && pageBlock) remove(window, {
                fadeOut: 0
            });
            if (msg && typeof msg != "string" && (msg.parentNode || msg.jquery)) {
                var node = msg.jquery ? msg[0] : msg;
                var data = {};
                $(el).data("blockUI.history", data);
                data.el = node;
                data.parent = node.parentNode;
                data.display = node.style.display;
                data.position = node.style.position;
                if (data.parent) data.parent.removeChild(node);
            }
            $(el).data("blockUI.onUnblock", opts.onUnblock);
            var z = opts.baseZ;
            var lyr1, lyr2, lyr3, s;
            if (msie || opts.forceIframe) lyr1 = $('<iframe class="blockUI" style="z-index:' + z++ + ';display:none;border:none;margin:0;padding:0;position:absolute;width:100%;height:100%;top:0;left:0" src="' + opts.iframeSrc + '"></iframe>'); else lyr1 = $('<div class="blockUI" style="display:none"></div>');
            if (opts.theme) lyr2 = $('<div class="blockUI blockOverlay ui-widget-overlay" style="z-index:' + z++ + ';display:none"></div>'); else lyr2 = $('<div class="blockUI blockOverlay" style="z-index:' + z++ + ';display:none;border:none;margin:0;padding:0;width:100%;height:100%;top:0;left:0"></div>');
            if (opts.theme && full) {
                s = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage ui-dialog ui-widget ui-corner-all" style="z-index:' + (z + 10) + ';display:none;position:fixed">';
                if (opts.title) {
                    s += '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">' + (opts.title || "&nbsp;") + "</div>";
                }
                s += '<div class="ui-widget-content ui-dialog-content"></div>';
                s += "</div>";
            } else if (opts.theme) {
                s = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement ui-dialog ui-widget ui-corner-all" style="z-index:' + (z + 10) + ';display:none;position:absolute">';
                if (opts.title) {
                    s += '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">' + (opts.title || "&nbsp;") + "</div>";
                }
                s += '<div class="ui-widget-content ui-dialog-content"></div>';
                s += "</div>";
            } else if (full) {
                s = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage" style="z-index:' + (z + 10) + ';display:none;position:fixed"></div>';
            } else {
                s = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement" style="z-index:' + (z + 10) + ';display:none;position:absolute"></div>';
            }
            lyr3 = $(s);
            if (msg) {
                if (opts.theme) {
                    lyr3.css(themedCSS);
                    lyr3.addClass("ui-widget-content");
                } else lyr3.css(css);
            }
            if (!opts.theme) lyr2.css(opts.overlayCSS);
            lyr2.css("position", full ? "fixed" : "absolute");
            if (msie || opts.forceIframe) lyr1.css("opacity", 0);
            var layers = [ lyr1, lyr2, lyr3 ], $par = full ? $("body") : $(el);
            $.each(layers, function() {
                this.appendTo($par);
            });
            if (opts.theme && opts.draggable && $.fn.draggable) {
                lyr3.draggable({
                    handle: ".ui-dialog-titlebar",
                    cancel: "li"
                });
            }
            var expr = setExpr && (!$.support.boxModel || $("object,embed", full ? null : el).length > 0);
            if (ie6 || expr) {
                if (full && opts.allowBodyStretch && $.support.boxModel) $("html,body").css("height", "100%");
                if ((ie6 || !$.support.boxModel) && !full) {
                    var t = sz(el, "borderTopWidth"), l = sz(el, "borderLeftWidth");
                    var fixT = t ? "(0 - " + t + ")" : 0;
                    var fixL = l ? "(0 - " + l + ")" : 0;
                }
                $.each(layers, function(i, o) {
                    var s = o[0].style;
                    s.position = "absolute";
                    if (i < 2) {
                        if (full) s.setExpression("height", "Math.max(document.body.scrollHeight, document.body.offsetHeight) - (jQuery.support.boxModel?0:" + opts.quirksmodeOffsetHack + ') + "px"'); else s.setExpression("height", 'this.parentNode.offsetHeight + "px"');
                        if (full) s.setExpression("width", 'jQuery.support.boxModel && document.documentElement.clientWidth || document.body.clientWidth + "px"'); else s.setExpression("width", 'this.parentNode.offsetWidth + "px"');
                        if (fixL) s.setExpression("left", fixL);
                        if (fixT) s.setExpression("top", fixT);
                    } else if (opts.centerY) {
                        if (full) s.setExpression("top", '(document.documentElement.clientHeight || document.body.clientHeight) / 2 - (this.offsetHeight / 2) + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "px"');
                        s.marginTop = 0;
                    } else if (!opts.centerY && full) {
                        var top = opts.css && opts.css.top ? parseInt(opts.css.top, 10) : 0;
                        var expression = "((document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + " + top + ') + "px"';
                        s.setExpression("top", expression);
                    }
                });
            }
            if (msg) {
                if (opts.theme) lyr3.find(".ui-widget-content").append(msg); else lyr3.append(msg);
                if (msg.jquery || msg.nodeType) $(msg).show();
            }
            if ((msie || opts.forceIframe) && opts.showOverlay) lyr1.show();
            if (opts.fadeIn) {
                var cb = opts.onBlock ? opts.onBlock : noOp;
                var cb1 = opts.showOverlay && !msg ? cb : noOp;
                var cb2 = msg ? cb : noOp;
                if (opts.showOverlay) lyr2._fadeIn(opts.fadeIn, cb1);
                if (msg) lyr3._fadeIn(opts.fadeIn, cb2);
            } else {
                if (opts.showOverlay) lyr2.show();
                if (msg) lyr3.show();
                if (opts.onBlock) opts.onBlock.bind(lyr3)();
            }
            bind(1, el, opts);
            if (full) {
                pageBlock = lyr3[0];
                pageBlockEls = $(opts.focusableElements, pageBlock);
                if (opts.focusInput) setTimeout(focus, 20);
            } else center(lyr3[0], opts.centerX, opts.centerY);
            if (opts.timeout) {
                var to = setTimeout(function() {
                    if (full) $.unblockUI(opts); else $(el).unblock(opts);
                }, opts.timeout);
                $(el).data("blockUI.timeout", to);
            }
        }
        function remove(el, opts) {
            var count;
            var full = el == window;
            var $el = $(el);
            var data = $el.data("blockUI.history");
            var to = $el.data("blockUI.timeout");
            if (to) {
                clearTimeout(to);
                $el.removeData("blockUI.timeout");
            }
            opts = $.extend({}, $.blockUI.defaults, opts || {});
            bind(0, el, opts);
            if (opts.onUnblock === null) {
                opts.onUnblock = $el.data("blockUI.onUnblock");
                $el.removeData("blockUI.onUnblock");
            }
            var els;
            if (full) els = $("body").children().filter(".blockUI").add("body > .blockUI"); else els = $el.find(">.blockUI");
            if (opts.cursorReset) {
                if (els.length > 1) els[1].style.cursor = opts.cursorReset;
                if (els.length > 2) els[2].style.cursor = opts.cursorReset;
            }
            if (full) pageBlock = pageBlockEls = null;
            if (opts.fadeOut) {
                count = els.length;
                els.stop().fadeOut(opts.fadeOut, function() {
                    if (--count === 0) reset(els, data, opts, el);
                });
            } else reset(els, data, opts, el);
        }
        function reset(els, data, opts, el) {
            var $el = $(el);
            if ($el.data("blockUI.isBlocked")) return;
            els.each(function(i, o) {
                if (this.parentNode) this.parentNode.removeChild(this);
            });
            if (data && data.el) {
                data.el.style.display = data.display;
                data.el.style.position = data.position;
                data.el.style.cursor = "default";
                if (data.parent) data.parent.appendChild(data.el);
                $el.removeData("blockUI.history");
            }
            if ($el.data("blockUI.static")) {
                $el.css("position", "static");
            }
            if (typeof opts.onUnblock == "function") opts.onUnblock(el, opts);
            var body = $(document.body), w = body.width(), cssW = body[0].style.width;
            body.width(w - 1).width(w);
            body[0].style.width = cssW;
        }
        function bind(b, el, opts) {
            var full = el == window, $el = $(el);
            if (!b && (full && !pageBlock || !full && !$el.data("blockUI.isBlocked"))) return;
            $el.data("blockUI.isBlocked", b);
            if (!full || !opts.bindEvents || b && !opts.showOverlay) return;
            var events = "mousedown mouseup keydown keypress keyup touchstart touchend touchmove";
            if (b) $(document).bind(events, opts, handler); else $(document).unbind(events, handler);
        }
        function handler(e) {
            if (e.type === "keydown" && e.keyCode && e.keyCode == 9) {
                if (pageBlock && e.data.constrainTabKey) {
                    var els = pageBlockEls;
                    var fwd = !e.shiftKey && e.target === els[els.length - 1];
                    var back = e.shiftKey && e.target === els[0];
                    if (fwd || back) {
                        setTimeout(function() {
                            focus(back);
                        }, 10);
                        return false;
                    }
                }
            }
            var opts = e.data;
            var target = $(e.target);
            if (target.hasClass("blockOverlay") && opts.onOverlayClick) opts.onOverlayClick(e);
            if (target.parents("div." + opts.blockMsgClass).length > 0) return true;
            return target.parents().children().filter("div.blockUI").length === 0;
        }
        function focus(back) {
            if (!pageBlockEls) return;
            var e = pageBlockEls[back === true ? pageBlockEls.length - 1 : 0];
            if (e) e.focus();
        }
        function center(el, x, y) {
            var p = el.parentNode, s = el.style;
            var l = (p.offsetWidth - el.offsetWidth) / 2 - sz(p, "borderLeftWidth");
            var t = (p.offsetHeight - el.offsetHeight) / 2 - sz(p, "borderTopWidth");
            if (x) s.left = l > 0 ? l + "px" : "0";
            if (y) s.top = t > 0 ? t + "px" : "0";
        }
        function sz(el, p) {
            return parseInt($.css(el, p), 10) || 0;
        }
    }
    if (typeof define === "function" && define.amd && define.amd.jQuery) {
        define([ "jquery" ], setup);
    } else {
        setup(jQuery);
    }
})();

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof module === "object" && module.exports) {
        module.exports = function(root, jQuery) {
            if (jQuery === undefined) {
                if (typeof window !== "undefined") {
                    jQuery = require("jquery");
                } else {
                    jQuery = require("jquery")(root);
                }
            }
            factory(jQuery);
            return jQuery;
        };
    } else {
        factory(jQuery);
    }
})(function(jQuery) {
    var S2 = function() {
        if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
            var S2 = jQuery.fn.select2.amd;
        }
        var S2;
        (function() {
            if (!S2 || !S2.requirejs) {
                if (!S2) {
                    S2 = {};
                } else {
                    require = S2;
                }
                var requirejs, require, define;
                (function(undef) {
                    var main, req, makeMap, handlers, defined = {}, waiting = {}, config = {}, defining = {}, hasOwn = Object.prototype.hasOwnProperty, aps = [].slice, jsSuffixRegExp = /\.js$/;
                    function hasProp(obj, prop) {
                        return hasOwn.call(obj, prop);
                    }
                    function normalize(name, baseName) {
                        var nameParts, nameSegment, mapValue, foundMap, lastIndex, foundI, foundStarMap, starI, i, j, part, normalizedBaseParts, baseParts = baseName && baseName.split("/"), map = config.map, starMap = map && map["*"] || {};
                        if (name) {
                            name = name.split("/");
                            lastIndex = name.length - 1;
                            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, "");
                            }
                            if (name[0].charAt(0) === "." && baseParts) {
                                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                                name = normalizedBaseParts.concat(name);
                            }
                            for (i = 0; i < name.length; i++) {
                                part = name[i];
                                if (part === ".") {
                                    name.splice(i, 1);
                                    i -= 1;
                                } else if (part === "..") {
                                    if (i === 0 || i === 1 && name[2] === ".." || name[i - 1] === "..") {
                                        continue;
                                    } else if (i > 0) {
                                        name.splice(i - 1, 2);
                                        i -= 2;
                                    }
                                }
                            }
                            name = name.join("/");
                        }
                        if ((baseParts || starMap) && map) {
                            nameParts = name.split("/");
                            for (i = nameParts.length; i > 0; i -= 1) {
                                nameSegment = nameParts.slice(0, i).join("/");
                                if (baseParts) {
                                    for (j = baseParts.length; j > 0; j -= 1) {
                                        mapValue = map[baseParts.slice(0, j).join("/")];
                                        if (mapValue) {
                                            mapValue = mapValue[nameSegment];
                                            if (mapValue) {
                                                foundMap = mapValue;
                                                foundI = i;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (foundMap) {
                                    break;
                                }
                                if (!foundStarMap && starMap && starMap[nameSegment]) {
                                    foundStarMap = starMap[nameSegment];
                                    starI = i;
                                }
                            }
                            if (!foundMap && foundStarMap) {
                                foundMap = foundStarMap;
                                foundI = starI;
                            }
                            if (foundMap) {
                                nameParts.splice(0, foundI, foundMap);
                                name = nameParts.join("/");
                            }
                        }
                        return name;
                    }
                    function makeRequire(relName, forceSync) {
                        return function() {
                            var args = aps.call(arguments, 0);
                            if (typeof args[0] !== "string" && args.length === 1) {
                                args.push(null);
                            }
                            return req.apply(undef, args.concat([ relName, forceSync ]));
                        };
                    }
                    function makeNormalize(relName) {
                        return function(name) {
                            return normalize(name, relName);
                        };
                    }
                    function makeLoad(depName) {
                        return function(value) {
                            defined[depName] = value;
                        };
                    }
                    function callDep(name) {
                        if (hasProp(waiting, name)) {
                            var args = waiting[name];
                            delete waiting[name];
                            defining[name] = true;
                            main.apply(undef, args);
                        }
                        if (!hasProp(defined, name) && !hasProp(defining, name)) {
                            throw new Error("No " + name);
                        }
                        return defined[name];
                    }
                    function splitPrefix(name) {
                        var prefix, index = name ? name.indexOf("!") : -1;
                        if (index > -1) {
                            prefix = name.substring(0, index);
                            name = name.substring(index + 1, name.length);
                        }
                        return [ prefix, name ];
                    }
                    function makeRelParts(relName) {
                        return relName ? splitPrefix(relName) : [];
                    }
                    makeMap = function(name, relParts) {
                        var plugin, parts = splitPrefix(name), prefix = parts[0], relResourceName = relParts[1];
                        name = parts[1];
                        if (prefix) {
                            prefix = normalize(prefix, relResourceName);
                            plugin = callDep(prefix);
                        }
                        if (prefix) {
                            if (plugin && plugin.normalize) {
                                name = plugin.normalize(name, makeNormalize(relResourceName));
                            } else {
                                name = normalize(name, relResourceName);
                            }
                        } else {
                            name = normalize(name, relResourceName);
                            parts = splitPrefix(name);
                            prefix = parts[0];
                            name = parts[1];
                            if (prefix) {
                                plugin = callDep(prefix);
                            }
                        }
                        return {
                            f: prefix ? prefix + "!" + name : name,
                            n: name,
                            pr: prefix,
                            p: plugin
                        };
                    };
                    function makeConfig(name) {
                        return function() {
                            return config && config.config && config.config[name] || {};
                        };
                    }
                    handlers = {
                        require: function(name) {
                            return makeRequire(name);
                        },
                        exports: function(name) {
                            var e = defined[name];
                            if (typeof e !== "undefined") {
                                return e;
                            } else {
                                return defined[name] = {};
                            }
                        },
                        module: function(name) {
                            return {
                                id: name,
                                uri: "",
                                exports: defined[name],
                                config: makeConfig(name)
                            };
                        }
                    };
                    main = function(name, deps, callback, relName) {
                        var cjsModule, depName, ret, map, i, relParts, args = [], callbackType = typeof callback, usingExports;
                        relName = relName || name;
                        relParts = makeRelParts(relName);
                        if (callbackType === "undefined" || callbackType === "function") {
                            deps = !deps.length && callback.length ? [ "require", "exports", "module" ] : deps;
                            for (i = 0; i < deps.length; i += 1) {
                                map = makeMap(deps[i], relParts);
                                depName = map.f;
                                if (depName === "require") {
                                    args[i] = handlers.require(name);
                                } else if (depName === "exports") {
                                    args[i] = handlers.exports(name);
                                    usingExports = true;
                                } else if (depName === "module") {
                                    cjsModule = args[i] = handlers.module(name);
                                } else if (hasProp(defined, depName) || hasProp(waiting, depName) || hasProp(defining, depName)) {
                                    args[i] = callDep(depName);
                                } else if (map.p) {
                                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                                    args[i] = defined[depName];
                                } else {
                                    throw new Error(name + " missing " + depName);
                                }
                            }
                            ret = callback ? callback.apply(defined[name], args) : undefined;
                            if (name) {
                                if (cjsModule && cjsModule.exports !== undef && cjsModule.exports !== defined[name]) {
                                    defined[name] = cjsModule.exports;
                                } else if (ret !== undef || !usingExports) {
                                    defined[name] = ret;
                                }
                            }
                        } else if (name) {
                            defined[name] = callback;
                        }
                    };
                    requirejs = require = req = function(deps, callback, relName, forceSync, alt) {
                        if (typeof deps === "string") {
                            if (handlers[deps]) {
                                return handlers[deps](callback);
                            }
                            return callDep(makeMap(deps, makeRelParts(callback)).f);
                        } else if (!deps.splice) {
                            config = deps;
                            if (config.deps) {
                                req(config.deps, config.callback);
                            }
                            if (!callback) {
                                return;
                            }
                            if (callback.splice) {
                                deps = callback;
                                callback = relName;
                                relName = null;
                            } else {
                                deps = undef;
                            }
                        }
                        callback = callback || function() {};
                        if (typeof relName === "function") {
                            relName = forceSync;
                            forceSync = alt;
                        }
                        if (forceSync) {
                            main(undef, deps, callback, relName);
                        } else {
                            setTimeout(function() {
                                main(undef, deps, callback, relName);
                            }, 4);
                        }
                        return req;
                    };
                    req.config = function(cfg) {
                        return req(cfg);
                    };
                    requirejs._defined = defined;
                    define = function(name, deps, callback) {
                        if (typeof name !== "string") {
                            throw new Error("See almond README: incorrect module build, no module name");
                        }
                        if (!deps.splice) {
                            callback = deps;
                            deps = [];
                        }
                        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
                            waiting[name] = [ name, deps, callback ];
                        }
                    };
                    define.amd = {
                        jQuery: true
                    };
                })();
                S2.requirejs = requirejs;
                S2.require = require;
                S2.define = define;
            }
        })();
        S2.define("almond", function() {});
        S2.define("jquery", [], function() {
            var _$ = jQuery || $;
            if (_$ == null && console && console.error) {
                console.error("Select2: An instance of jQuery or a jQuery-compatible library was not " + "found. Make sure that you are including jQuery before Select2 on your " + "web page.");
            }
            return _$;
        });
        S2.define("select2/utils", [ "jquery" ], function($) {
            var Utils = {};
            Utils.Extend = function(ChildClass, SuperClass) {
                var __hasProp = {}.hasOwnProperty;
                function BaseConstructor() {
                    this.constructor = ChildClass;
                }
                for (var key in SuperClass) {
                    if (__hasProp.call(SuperClass, key)) {
                        ChildClass[key] = SuperClass[key];
                    }
                }
                BaseConstructor.prototype = SuperClass.prototype;
                ChildClass.prototype = new BaseConstructor();
                ChildClass.__super__ = SuperClass.prototype;
                return ChildClass;
            };
            function getMethods(theClass) {
                var proto = theClass.prototype;
                var methods = [];
                for (var methodName in proto) {
                    var m = proto[methodName];
                    if (typeof m !== "function") {
                        continue;
                    }
                    if (methodName === "constructor") {
                        continue;
                    }
                    methods.push(methodName);
                }
                return methods;
            }
            Utils.Decorate = function(SuperClass, DecoratorClass) {
                var decoratedMethods = getMethods(DecoratorClass);
                var superMethods = getMethods(SuperClass);
                function DecoratedClass() {
                    var unshift = Array.prototype.unshift;
                    var argCount = DecoratorClass.prototype.constructor.length;
                    var calledConstructor = SuperClass.prototype.constructor;
                    if (argCount > 0) {
                        unshift.call(arguments, SuperClass.prototype.constructor);
                        calledConstructor = DecoratorClass.prototype.constructor;
                    }
                    calledConstructor.apply(this, arguments);
                }
                DecoratorClass.displayName = SuperClass.displayName;
                function ctr() {
                    this.constructor = DecoratedClass;
                }
                DecoratedClass.prototype = new ctr();
                for (var m = 0; m < superMethods.length; m++) {
                    var superMethod = superMethods[m];
                    DecoratedClass.prototype[superMethod] = SuperClass.prototype[superMethod];
                }
                var calledMethod = function(methodName) {
                    var originalMethod = function() {};
                    if (methodName in DecoratedClass.prototype) {
                        originalMethod = DecoratedClass.prototype[methodName];
                    }
                    var decoratedMethod = DecoratorClass.prototype[methodName];
                    return function() {
                        var unshift = Array.prototype.unshift;
                        unshift.call(arguments, originalMethod);
                        return decoratedMethod.apply(this, arguments);
                    };
                };
                for (var d = 0; d < decoratedMethods.length; d++) {
                    var decoratedMethod = decoratedMethods[d];
                    DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
                }
                return DecoratedClass;
            };
            var Observable = function() {
                this.listeners = {};
            };
            Observable.prototype.on = function(event, callback) {
                this.listeners = this.listeners || {};
                if (event in this.listeners) {
                    this.listeners[event].push(callback);
                } else {
                    this.listeners[event] = [ callback ];
                }
            };
            Observable.prototype.trigger = function(event) {
                var slice = Array.prototype.slice;
                var params = slice.call(arguments, 1);
                this.listeners = this.listeners || {};
                if (params == null) {
                    params = [];
                }
                if (params.length === 0) {
                    params.push({});
                }
                params[0]._type = event;
                if (event in this.listeners) {
                    this.invoke(this.listeners[event], slice.call(arguments, 1));
                }
                if ("*" in this.listeners) {
                    this.invoke(this.listeners["*"], arguments);
                }
            };
            Observable.prototype.invoke = function(listeners, params) {
                for (var i = 0, len = listeners.length; i < len; i++) {
                    listeners[i].apply(this, params);
                }
            };
            Utils.Observable = Observable;
            Utils.generateChars = function(length) {
                var chars = "";
                for (var i = 0; i < length; i++) {
                    var randomChar = Math.floor(Math.random() * 36);
                    chars += randomChar.toString(36);
                }
                return chars;
            };
            Utils.bind = function(func, context) {
                return function() {
                    func.apply(context, arguments);
                };
            };
            Utils._convertData = function(data) {
                for (var originalKey in data) {
                    var keys = originalKey.split("-");
                    var dataLevel = data;
                    if (keys.length === 1) {
                        continue;
                    }
                    for (var k = 0; k < keys.length; k++) {
                        var key = keys[k];
                        key = key.substring(0, 1).toLowerCase() + key.substring(1);
                        if (!(key in dataLevel)) {
                            dataLevel[key] = {};
                        }
                        if (k == keys.length - 1) {
                            dataLevel[key] = data[originalKey];
                        }
                        dataLevel = dataLevel[key];
                    }
                    delete data[originalKey];
                }
                return data;
            };
            Utils.hasScroll = function(index, el) {
                var $el = $(el);
                var overflowX = el.style.overflowX;
                var overflowY = el.style.overflowY;
                if (overflowX === overflowY && (overflowY === "hidden" || overflowY === "visible")) {
                    return false;
                }
                if (overflowX === "scroll" || overflowY === "scroll") {
                    return true;
                }
                return $el.innerHeight() < el.scrollHeight || $el.innerWidth() < el.scrollWidth;
            };
            Utils.escapeMarkup = function(markup) {
                var replaceMap = {
                    "\\": "&#92;",
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#39;",
                    "/": "&#47;"
                };
                if (typeof markup !== "string") {
                    return markup;
                }
                return String(markup).replace(/[&<>"'\/\\]/g, function(match) {
                    return replaceMap[match];
                });
            };
            Utils.appendMany = function($element, $nodes) {
                if ($.fn.jquery.substr(0, 3) === "1.7") {
                    var $jqNodes = $();
                    $.map($nodes, function(node) {
                        $jqNodes = $jqNodes.add(node);
                    });
                    $nodes = $jqNodes;
                }
                $element.append($nodes);
            };
            Utils.__cache = {};
            var id = 0;
            Utils.GetUniqueElementId = function(element) {
                var select2Id = element.getAttribute("data-select2-id");
                if (select2Id == null) {
                    if (element.id) {
                        select2Id = element.id;
                        element.setAttribute("data-select2-id", select2Id);
                    } else {
                        element.setAttribute("data-select2-id", ++id);
                        select2Id = id.toString();
                    }
                }
                return select2Id;
            };
            Utils.StoreData = function(element, name, value) {
                var id = Utils.GetUniqueElementId(element);
                if (!Utils.__cache[id]) {
                    Utils.__cache[id] = {};
                }
                Utils.__cache[id][name] = value;
            };
            Utils.GetData = function(element, name) {
                var id = Utils.GetUniqueElementId(element);
                if (name) {
                    if (Utils.__cache[id]) {
                        if (Utils.__cache[id][name] != null) {
                            return Utils.__cache[id][name];
                        }
                        return $(element).data(name);
                    }
                    return $(element).data(name);
                } else {
                    return Utils.__cache[id];
                }
            };
            Utils.RemoveData = function(element) {
                var id = Utils.GetUniqueElementId(element);
                if (Utils.__cache[id] != null) {
                    delete Utils.__cache[id];
                }
                element.removeAttribute("data-select2-id");
            };
            return Utils;
        });
        S2.define("select2/results", [ "jquery", "./utils" ], function($, Utils) {
            function Results($element, options, dataAdapter) {
                this.$element = $element;
                this.data = dataAdapter;
                this.options = options;
                Results.__super__.constructor.call(this);
            }
            Utils.Extend(Results, Utils.Observable);
            Results.prototype.render = function() {
                var $results = $('<ul class="select2-results__options" role="listbox"></ul>');
                if (this.options.get("multiple")) {
                    $results.attr("aria-multiselectable", "true");
                }
                this.$results = $results;
                return $results;
            };
            Results.prototype.clear = function() {
                this.$results.empty();
            };
            Results.prototype.displayMessage = function(params) {
                var escapeMarkup = this.options.get("escapeMarkup");
                this.clear();
                this.hideLoading();
                var $message = $('<li role="alert" aria-live="assertive"' + ' class="select2-results__option"></li>');
                var message = this.options.get("translations").get(params.message);
                $message.append(escapeMarkup(message(params.args)));
                $message[0].className += " select2-results__message";
                this.$results.append($message);
            };
            Results.prototype.hideMessages = function() {
                this.$results.find(".select2-results__message").remove();
            };
            Results.prototype.append = function(data) {
                this.hideLoading();
                var $options = [];
                if (data.results == null || data.results.length === 0) {
                    if (this.$results.children().length === 0) {
                        this.trigger("results:message", {
                            message: "noResults"
                        });
                    }
                    return;
                }
                data.results = this.sort(data.results);
                for (var d = 0; d < data.results.length; d++) {
                    var item = data.results[d];
                    var $option = this.option(item);
                    $options.push($option);
                }
                this.$results.append($options);
            };
            Results.prototype.position = function($results, $dropdown) {
                var $resultsContainer = $dropdown.find(".select2-results");
                $resultsContainer.append($results);
            };
            Results.prototype.sort = function(data) {
                var sorter = this.options.get("sorter");
                return sorter(data);
            };
            Results.prototype.highlightFirstItem = function() {
                var $options = this.$results.find(".select2-results__option[aria-selected]");
                var $selected = $options.filter("[aria-selected=true]");
                if ($selected.length > 0) {
                    $selected.first().trigger("mouseenter");
                } else {
                    $options.first().trigger("mouseenter");
                }
                this.ensureHighlightVisible();
            };
            Results.prototype.setClasses = function() {
                var self = this;
                this.data.current(function(selected) {
                    var selectedIds = $.map(selected, function(s) {
                        return s.id.toString();
                    });
                    var $options = self.$results.find(".select2-results__option[aria-selected]");
                    $options.each(function() {
                        var $option = $(this);
                        var item = Utils.GetData(this, "data");
                        var id = "" + item.id;
                        if (item.element != null && item.element.selected || item.element == null && $.inArray(id, selectedIds) > -1) {
                            $option.attr("aria-selected", "true");
                        } else {
                            $option.attr("aria-selected", "false");
                        }
                    });
                });
            };
            Results.prototype.showLoading = function(params) {
                this.hideLoading();
                var loadingMore = this.options.get("translations").get("searching");
                var loading = {
                    disabled: true,
                    loading: true,
                    text: loadingMore(params)
                };
                var $loading = this.option(loading);
                $loading.className += " loading-results";
                this.$results.prepend($loading);
            };
            Results.prototype.hideLoading = function() {
                this.$results.find(".loading-results").remove();
            };
            Results.prototype.option = function(data) {
                var option = document.createElement("li");
                option.className = "select2-results__option";
                var attrs = {
                    role: "option",
                    "aria-selected": "false"
                };
                var matches = window.Element.prototype.matches || window.Element.prototype.msMatchesSelector || window.Element.prototype.webkitMatchesSelector;
                if (data.element != null && matches.call(data.element, ":disabled") || data.element == null && data.disabled) {
                    delete attrs["aria-selected"];
                    attrs["aria-disabled"] = "true";
                }
                if (data.id == null) {
                    delete attrs["aria-selected"];
                }
                if (data._resultId != null) {
                    option.id = data._resultId;
                }
                if (data.title) {
                    option.title = data.title;
                }
                if (data.children) {
                    attrs.role = "group";
                    attrs["aria-label"] = data.text;
                    delete attrs["aria-selected"];
                }
                for (var attr in attrs) {
                    var val = attrs[attr];
                    option.setAttribute(attr, val);
                }
                if (data.children) {
                    var $option = $(option);
                    var label = document.createElement("strong");
                    label.className = "select2-results__group";
                    var $label = $(label);
                    this.template(data, label);
                    var $children = [];
                    for (var c = 0; c < data.children.length; c++) {
                        var child = data.children[c];
                        var $child = this.option(child);
                        $children.push($child);
                    }
                    var $childrenContainer = $("<ul></ul>", {
                        class: "select2-results__options select2-results__options--nested"
                    });
                    $childrenContainer.append($children);
                    $option.append(label);
                    $option.append($childrenContainer);
                } else {
                    this.template(data, option);
                }
                Utils.StoreData(option, "data", data);
                return option;
            };
            Results.prototype.bind = function(container, $container) {
                var self = this;
                var id = container.id + "-results";
                this.$results.attr("id", id);
                container.on("results:all", function(params) {
                    self.clear();
                    self.append(params.data);
                    if (container.isOpen()) {
                        self.setClasses();
                        self.highlightFirstItem();
                    }
                });
                container.on("results:append", function(params) {
                    self.append(params.data);
                    if (container.isOpen()) {
                        self.setClasses();
                    }
                });
                container.on("query", function(params) {
                    self.hideMessages();
                    self.showLoading(params);
                });
                container.on("select", function() {
                    if (!container.isOpen()) {
                        return;
                    }
                    self.setClasses();
                    if (self.options.get("scrollAfterSelect")) {
                        self.highlightFirstItem();
                    }
                });
                container.on("unselect", function() {
                    if (!container.isOpen()) {
                        return;
                    }
                    self.setClasses();
                    if (self.options.get("scrollAfterSelect")) {
                        self.highlightFirstItem();
                    }
                });
                container.on("open", function() {
                    self.$results.attr("aria-expanded", "true");
                    self.$results.attr("aria-hidden", "false");
                    self.setClasses();
                    self.ensureHighlightVisible();
                });
                container.on("close", function() {
                    self.$results.attr("aria-expanded", "false");
                    self.$results.attr("aria-hidden", "true");
                    self.$results.removeAttr("aria-activedescendant");
                });
                container.on("results:toggle", function() {
                    var $highlighted = self.getHighlightedResults();
                    if ($highlighted.length === 0) {
                        return;
                    }
                    $highlighted.trigger("mouseup");
                });
                container.on("results:select", function() {
                    var $highlighted = self.getHighlightedResults();
                    if ($highlighted.length === 0) {
                        return;
                    }
                    var data = Utils.GetData($highlighted[0], "data");
                    if ($highlighted.attr("aria-selected") == "true") {
                        self.trigger("close", {});
                    } else {
                        self.trigger("select", {
                            data: data
                        });
                    }
                });
                container.on("results:previous", function() {
                    var $highlighted = self.getHighlightedResults();
                    var $options = self.$results.find("[aria-selected]");
                    var currentIndex = $options.index($highlighted);
                    if (currentIndex <= 0) {
                        return;
                    }
                    var nextIndex = currentIndex - 1;
                    if ($highlighted.length === 0) {
                        nextIndex = 0;
                    }
                    var $next = $options.eq(nextIndex);
                    $next.trigger("mouseenter");
                    var currentOffset = self.$results.offset().top;
                    var nextTop = $next.offset().top;
                    var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);
                    if (nextIndex === 0) {
                        self.$results.scrollTop(0);
                    } else if (nextTop - currentOffset < 0) {
                        self.$results.scrollTop(nextOffset);
                    }
                });
                container.on("results:next", function() {
                    var $highlighted = self.getHighlightedResults();
                    var $options = self.$results.find("[aria-selected]");
                    var currentIndex = $options.index($highlighted);
                    var nextIndex = currentIndex + 1;
                    if (nextIndex >= $options.length) {
                        return;
                    }
                    var $next = $options.eq(nextIndex);
                    $next.trigger("mouseenter");
                    var currentOffset = self.$results.offset().top + self.$results.outerHeight(false);
                    var nextBottom = $next.offset().top + $next.outerHeight(false);
                    var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;
                    if (nextIndex === 0) {
                        self.$results.scrollTop(0);
                    } else if (nextBottom > currentOffset) {
                        self.$results.scrollTop(nextOffset);
                    }
                });
                container.on("results:focus", function(params) {
                    params.element.addClass("select2-results__option--highlighted");
                });
                container.on("results:message", function(params) {
                    self.displayMessage(params);
                });
                if ($.fn.mousewheel) {
                    this.$results.on("mousewheel", function(e) {
                        var top = self.$results.scrollTop();
                        var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;
                        var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
                        var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();
                        if (isAtTop) {
                            self.$results.scrollTop(0);
                            e.preventDefault();
                            e.stopPropagation();
                        } else if (isAtBottom) {
                            self.$results.scrollTop(self.$results.get(0).scrollHeight - self.$results.height());
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    });
                }
                this.$results.on("mouseup", ".select2-results__option[aria-selected]", function(evt) {
                    var $this = $(this);
                    var data = Utils.GetData(this, "data");
                    if ($this.attr("aria-selected") === "true") {
                        if (self.options.get("multiple")) {
                            self.trigger("unselect", {
                                originalEvent: evt,
                                data: data
                            });
                        } else {
                            self.trigger("close", {});
                        }
                        return;
                    }
                    self.trigger("select", {
                        originalEvent: evt,
                        data: data
                    });
                });
                this.$results.on("mouseenter", ".select2-results__option[aria-selected]", function(evt) {
                    var data = Utils.GetData(this, "data");
                    self.getHighlightedResults().removeClass("select2-results__option--highlighted");
                    self.trigger("results:focus", {
                        data: data,
                        element: $(this)
                    });
                });
            };
            Results.prototype.getHighlightedResults = function() {
                var $highlighted = this.$results.find(".select2-results__option--highlighted");
                return $highlighted;
            };
            Results.prototype.destroy = function() {
                this.$results.remove();
            };
            Results.prototype.ensureHighlightVisible = function() {
                var $highlighted = this.getHighlightedResults();
                if ($highlighted.length === 0) {
                    return;
                }
                var $options = this.$results.find("[aria-selected]");
                var currentIndex = $options.index($highlighted);
                var currentOffset = this.$results.offset().top;
                var nextTop = $highlighted.offset().top;
                var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);
                var offsetDelta = nextTop - currentOffset;
                nextOffset -= $highlighted.outerHeight(false) * 2;
                if (currentIndex <= 2) {
                    this.$results.scrollTop(0);
                } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
                    this.$results.scrollTop(nextOffset);
                }
            };
            Results.prototype.template = function(result, container) {
                var template = this.options.get("templateResult");
                var escapeMarkup = this.options.get("escapeMarkup");
                var content = template(result, container);
                if (content == null) {
                    container.style.display = "none";
                } else if (typeof content === "string") {
                    container.innerHTML = escapeMarkup(content);
                } else {
                    $(container).append(content);
                }
            };
            return Results;
        });
        S2.define("select2/keys", [], function() {
            var KEYS = {
                BACKSPACE: 8,
                TAB: 9,
                ENTER: 13,
                SHIFT: 16,
                CTRL: 17,
                ALT: 18,
                ESC: 27,
                SPACE: 32,
                PAGE_UP: 33,
                PAGE_DOWN: 34,
                END: 35,
                HOME: 36,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40,
                DELETE: 46
            };
            return KEYS;
        });
        S2.define("select2/selection/base", [ "jquery", "../utils", "../keys" ], function($, Utils, KEYS) {
            function BaseSelection($element, options) {
                this.$element = $element;
                this.options = options;
                BaseSelection.__super__.constructor.call(this);
            }
            Utils.Extend(BaseSelection, Utils.Observable);
            BaseSelection.prototype.render = function() {
                var $selection = $('<span class="select2-selection" role="combobox" ' + ' aria-haspopup="true" aria-expanded="false">' + "</span>");
                this._tabindex = 0;
                if (Utils.GetData(this.$element[0], "old-tabindex") != null) {
                    this._tabindex = Utils.GetData(this.$element[0], "old-tabindex");
                } else if (this.$element.attr("tabindex") != null) {
                    this._tabindex = this.$element.attr("tabindex");
                }
                $selection.attr("title", this.$element.attr("title"));
                $selection.attr("tabindex", this._tabindex);
                $selection.attr("aria-disabled", "false");
                this.$selection = $selection;
                return $selection;
            };
            BaseSelection.prototype.bind = function(container, $container) {
                var self = this;
                var resultsId = container.id + "-results";
                this.container = container;
                this.$selection.on("focus", function(evt) {
                    self.trigger("focus", evt);
                });
                this.$selection.on("blur", function(evt) {
                    self._handleBlur(evt);
                });
                this.$selection.on("keydown", function(evt) {
                    self.trigger("keypress", evt);
                    if (evt.which === KEYS.SPACE) {
                        evt.preventDefault();
                    }
                });
                container.on("results:focus", function(params) {
                    self.$selection.attr("aria-activedescendant", params.data._resultId);
                });
                container.on("selection:update", function(params) {
                    self.update(params.data);
                });
                container.on("open", function() {
                    self.$selection.attr("aria-expanded", "true");
                    self.$selection.attr("aria-owns", resultsId);
                    self._attachCloseHandler(container);
                });
                container.on("close", function() {
                    self.$selection.attr("aria-expanded", "false");
                    self.$selection.removeAttr("aria-activedescendant");
                    self.$selection.removeAttr("aria-owns");
                    self.$selection.trigger("focus");
                    self._detachCloseHandler(container);
                });
                container.on("enable", function() {
                    self.$selection.attr("tabindex", self._tabindex);
                    self.$selection.attr("aria-disabled", "false");
                });
                container.on("disable", function() {
                    self.$selection.attr("tabindex", "-1");
                    self.$selection.attr("aria-disabled", "true");
                });
            };
            BaseSelection.prototype._handleBlur = function(evt) {
                var self = this;
                window.setTimeout(function() {
                    if (document.activeElement == self.$selection[0] || $.contains(self.$selection[0], document.activeElement)) {
                        return;
                    }
                    self.trigger("blur", evt);
                }, 1);
            };
            BaseSelection.prototype._attachCloseHandler = function(container) {
                $(document.body).on("mousedown.select2." + container.id, function(e) {
                    var $target = $(e.target);
                    var $select = $target.closest(".select2");
                    var $all = $(".select2.select2-container--open");
                    $all.each(function() {
                        if (this == $select[0]) {
                            return;
                        }
                        var $element = Utils.GetData(this, "element");
                        $element.select2("close");
                    });
                });
            };
            BaseSelection.prototype._detachCloseHandler = function(container) {
                $(document.body).off("mousedown.select2." + container.id);
            };
            BaseSelection.prototype.position = function($selection, $container) {
                var $selectionContainer = $container.find(".selection");
                $selectionContainer.append($selection);
            };
            BaseSelection.prototype.destroy = function() {
                this._detachCloseHandler(this.container);
            };
            BaseSelection.prototype.update = function(data) {
                throw new Error("The `update` method must be defined in child classes.");
            };
            return BaseSelection;
        });
        S2.define("select2/selection/single", [ "jquery", "./base", "../utils", "../keys" ], function($, BaseSelection, Utils, KEYS) {
            function SingleSelection() {
                SingleSelection.__super__.constructor.apply(this, arguments);
            }
            Utils.Extend(SingleSelection, BaseSelection);
            SingleSelection.prototype.render = function() {
                var $selection = SingleSelection.__super__.render.call(this);
                $selection.addClass("select2-selection--single");
                $selection.html('<span class="select2-selection__rendered"></span>' + '<span class="select2-selection__arrow" role="presentation">' + '<b role="presentation"></b>' + "</span>");
                return $selection;
            };
            SingleSelection.prototype.bind = function(container, $container) {
                var self = this;
                SingleSelection.__super__.bind.apply(this, arguments);
                var id = container.id + "-container";
                this.$selection.find(".select2-selection__rendered").attr("id", id).attr("role", "textbox").attr("aria-readonly", "true");
                this.$selection.attr("aria-labelledby", id);
                this.$selection.on("mousedown", function(evt) {
                    if (evt.which !== 1) {
                        return;
                    }
                    self.trigger("toggle", {
                        originalEvent: evt
                    });
                });
                this.$selection.on("focus", function(evt) {});
                this.$selection.on("blur", function(evt) {});
                container.on("focus", function(evt) {
                    if (!container.isOpen()) {
                        self.$selection.trigger("focus");
                    }
                });
            };
            SingleSelection.prototype.clear = function() {
                var $rendered = this.$selection.find(".select2-selection__rendered");
                $rendered.empty();
                $rendered.removeAttr("title");
            };
            SingleSelection.prototype.display = function(data, container) {
                var template = this.options.get("templateSelection");
                var escapeMarkup = this.options.get("escapeMarkup");
                return escapeMarkup(template(data, container));
            };
            SingleSelection.prototype.selectionContainer = function() {
                return $("<span></span>");
            };
            SingleSelection.prototype.update = function(data) {
                if (data.length === 0) {
                    this.clear();
                    return;
                }
                var selection = data[0];
                var $rendered = this.$selection.find(".select2-selection__rendered");
                var formatted = this.display(selection, $rendered);
                $rendered.empty().append(formatted);
                var title = selection.title || selection.text;
                if (title) {
                    $rendered.attr("title", title);
                } else {
                    $rendered.removeAttr("title");
                }
            };
            return SingleSelection;
        });
        S2.define("select2/selection/multiple", [ "jquery", "./base", "../utils" ], function($, BaseSelection, Utils) {
            function MultipleSelection($element, options) {
                MultipleSelection.__super__.constructor.apply(this, arguments);
            }
            Utils.Extend(MultipleSelection, BaseSelection);
            MultipleSelection.prototype.render = function() {
                var $selection = MultipleSelection.__super__.render.call(this);
                $selection.addClass("select2-selection--multiple");
                $selection.html('<ul class="select2-selection__rendered"></ul>');
                return $selection;
            };
            MultipleSelection.prototype.bind = function(container, $container) {
                var self = this;
                MultipleSelection.__super__.bind.apply(this, arguments);
                this.$selection.on("click", function(evt) {
                    self.trigger("toggle", {
                        originalEvent: evt
                    });
                });
                this.$selection.on("click", ".select2-selection__choice__remove", function(evt) {
                    if (self.options.get("disabled")) {
                        return;
                    }
                    var $remove = $(this);
                    var $selection = $remove.parent();
                    var data = Utils.GetData($selection[0], "data");
                    self.trigger("unselect", {
                        originalEvent: evt,
                        data: data
                    });
                });
            };
            MultipleSelection.prototype.clear = function() {
                var $rendered = this.$selection.find(".select2-selection__rendered");
                $rendered.empty();
                $rendered.removeAttr("title");
            };
            MultipleSelection.prototype.display = function(data, container) {
                var template = this.options.get("templateSelection");
                var escapeMarkup = this.options.get("escapeMarkup");
                return escapeMarkup(template(data, container));
            };
            MultipleSelection.prototype.selectionContainer = function() {
                var $container = $('<li class="select2-selection__choice">' + '<span class="select2-selection__choice__remove" role="presentation">' + "&times;" + "</span>" + "</li>");
                return $container;
            };
            MultipleSelection.prototype.update = function(data) {
                this.clear();
                if (data.length === 0) {
                    return;
                }
                var $selections = [];
                for (var d = 0; d < data.length; d++) {
                    var selection = data[d];
                    var $selection = this.selectionContainer();
                    var formatted = this.display(selection, $selection);
                    $selection.append(formatted);
                    var title = selection.title || selection.text;
                    if (title) {
                        $selection.attr("title", title);
                    }
                    Utils.StoreData($selection[0], "data", selection);
                    $selections.push($selection);
                }
                var $rendered = this.$selection.find(".select2-selection__rendered");
                Utils.appendMany($rendered, $selections);
            };
            return MultipleSelection;
        });
        S2.define("select2/selection/placeholder", [ "../utils" ], function(Utils) {
            function Placeholder(decorated, $element, options) {
                this.placeholder = this.normalizePlaceholder(options.get("placeholder"));
                decorated.call(this, $element, options);
            }
            Placeholder.prototype.normalizePlaceholder = function(_, placeholder) {
                if (typeof placeholder === "string") {
                    placeholder = {
                        id: "",
                        text: placeholder
                    };
                }
                return placeholder;
            };
            Placeholder.prototype.createPlaceholder = function(decorated, placeholder) {
                var $placeholder = this.selectionContainer();
                $placeholder.html(this.display(placeholder));
                $placeholder.addClass("select2-selection__placeholder").removeClass("select2-selection__choice");
                return $placeholder;
            };
            Placeholder.prototype.update = function(decorated, data) {
                var singlePlaceholder = data.length == 1 && data[0].id != this.placeholder.id;
                var multipleSelections = data.length > 1;
                if (multipleSelections || singlePlaceholder) {
                    return decorated.call(this, data);
                }
                this.clear();
                var $placeholder = this.createPlaceholder(this.placeholder);
                this.$selection.find(".select2-selection__rendered").append($placeholder);
            };
            return Placeholder;
        });
        S2.define("select2/selection/allowClear", [ "jquery", "../keys", "../utils" ], function($, KEYS, Utils) {
            function AllowClear() {}
            AllowClear.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container);
                if (this.placeholder == null) {
                    if (this.options.get("debug") && window.console && console.error) {
                        console.error("Select2: The `allowClear` option should be used in combination " + "with the `placeholder` option.");
                    }
                }
                this.$selection.on("mousedown", ".select2-selection__clear", function(evt) {
                    self._handleClear(evt);
                });
                container.on("keypress", function(evt) {
                    self._handleKeyboardClear(evt, container);
                });
            };
            AllowClear.prototype._handleClear = function(_, evt) {
                if (this.options.get("disabled")) {
                    return;
                }
                var $clear = this.$selection.find(".select2-selection__clear");
                if ($clear.length === 0) {
                    return;
                }
                evt.stopPropagation();
                var data = Utils.GetData($clear[0], "data");
                var previousVal = this.$element.val();
                this.$element.val(this.placeholder.id);
                var unselectData = {
                    data: data
                };
                this.trigger("clear", unselectData);
                if (unselectData.prevented) {
                    this.$element.val(previousVal);
                    return;
                }
                for (var d = 0; d < data.length; d++) {
                    unselectData = {
                        data: data[d]
                    };
                    this.trigger("unselect", unselectData);
                    if (unselectData.prevented) {
                        this.$element.val(previousVal);
                        return;
                    }
                }
                this.$element.trigger("change");
                this.trigger("toggle", {});
            };
            AllowClear.prototype._handleKeyboardClear = function(_, evt, container) {
                if (container.isOpen()) {
                    return;
                }
                if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
                    this._handleClear(evt);
                }
            };
            AllowClear.prototype.update = function(decorated, data) {
                decorated.call(this, data);
                if (this.$selection.find(".select2-selection__placeholder").length > 0 || data.length === 0) {
                    return;
                }
                var removeAll = this.options.get("translations").get("removeAllItems");
                var $remove = $('<span class="select2-selection__clear" title="' + removeAll() + '">' + "&times;" + "</span>");
                Utils.StoreData($remove[0], "data", data);
                this.$selection.find(".select2-selection__rendered").prepend($remove);
            };
            return AllowClear;
        });
        S2.define("select2/selection/search", [ "jquery", "../utils", "../keys" ], function($, Utils, KEYS) {
            function Search(decorated, $element, options) {
                decorated.call(this, $element, options);
            }
            Search.prototype.render = function(decorated) {
                var $search = $('<li class="select2-search select2-search--inline">' + '<input class="select2-search__field" type="search" tabindex="-1"' + ' autocomplete="off" autocorrect="off" autocapitalize="none"' + ' spellcheck="false" role="searchbox" aria-autocomplete="list" />' + "</li>");
                this.$searchContainer = $search;
                this.$search = $search.find("input");
                var $rendered = decorated.call(this);
                this._transferTabIndex();
                return $rendered;
            };
            Search.prototype.bind = function(decorated, container, $container) {
                var self = this;
                var resultsId = container.id + "-results";
                decorated.call(this, container, $container);
                container.on("open", function() {
                    self.$search.attr("aria-controls", resultsId);
                    self.$search.trigger("focus");
                });
                container.on("close", function() {
                    self.$search.val("");
                    self.$search.removeAttr("aria-controls");
                    self.$search.removeAttr("aria-activedescendant");
                    self.$search.trigger("focus");
                });
                container.on("enable", function() {
                    self.$search.prop("disabled", false);
                    self._transferTabIndex();
                });
                container.on("disable", function() {
                    self.$search.prop("disabled", true);
                });
                container.on("focus", function(evt) {
                    self.$search.trigger("focus");
                });
                container.on("results:focus", function(params) {
                    if (params.data._resultId) {
                        self.$search.attr("aria-activedescendant", params.data._resultId);
                    } else {
                        self.$search.removeAttr("aria-activedescendant");
                    }
                });
                this.$selection.on("focusin", ".select2-search--inline", function(evt) {
                    self.trigger("focus", evt);
                });
                this.$selection.on("focusout", ".select2-search--inline", function(evt) {
                    self._handleBlur(evt);
                });
                this.$selection.on("keydown", ".select2-search--inline", function(evt) {
                    evt.stopPropagation();
                    self.trigger("keypress", evt);
                    self._keyUpPrevented = evt.isDefaultPrevented();
                    var key = evt.which;
                    if (key === KEYS.BACKSPACE && self.$search.val() === "") {
                        var $previousChoice = self.$searchContainer.prev(".select2-selection__choice");
                        if ($previousChoice.length > 0) {
                            var item = Utils.GetData($previousChoice[0], "data");
                            self.searchRemoveChoice(item);
                            evt.preventDefault();
                        }
                    }
                });
                this.$selection.on("click", ".select2-search--inline", function(evt) {
                    if (self.$search.val()) {
                        evt.stopPropagation();
                    }
                });
                var msie = document.documentMode;
                var disableInputEvents = msie && msie <= 11;
                this.$selection.on("input.searchcheck", ".select2-search--inline", function(evt) {
                    if (disableInputEvents) {
                        self.$selection.off("input.search input.searchcheck");
                        return;
                    }
                    self.$selection.off("keyup.search");
                });
                this.$selection.on("keyup.search input.search", ".select2-search--inline", function(evt) {
                    if (disableInputEvents && evt.type === "input") {
                        self.$selection.off("input.search input.searchcheck");
                        return;
                    }
                    var key = evt.which;
                    if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
                        return;
                    }
                    if (key == KEYS.TAB) {
                        return;
                    }
                    self.handleSearch(evt);
                });
            };
            Search.prototype._transferTabIndex = function(decorated) {
                this.$search.attr("tabindex", this.$selection.attr("tabindex"));
                this.$selection.attr("tabindex", "-1");
            };
            Search.prototype.createPlaceholder = function(decorated, placeholder) {
                this.$search.attr("placeholder", placeholder.text);
            };
            Search.prototype.update = function(decorated, data) {
                var searchHadFocus = this.$search[0] == document.activeElement;
                this.$search.attr("placeholder", "");
                decorated.call(this, data);
                this.$selection.find(".select2-selection__rendered").append(this.$searchContainer);
                this.resizeSearch();
                if (searchHadFocus) {
                    this.$search.trigger("focus");
                }
            };
            Search.prototype.handleSearch = function() {
                this.resizeSearch();
                if (!this._keyUpPrevented) {
                    var input = this.$search.val();
                    this.trigger("query", {
                        term: input
                    });
                }
                this._keyUpPrevented = false;
            };
            Search.prototype.searchRemoveChoice = function(decorated, item) {
                this.trigger("unselect", {
                    data: item
                });
                this.$search.val(item.text);
                this.handleSearch();
            };
            Search.prototype.resizeSearch = function() {
                this.$search.css("width", "25px");
                var width = "";
                if (this.$search.attr("placeholder") !== "") {
                    width = this.$selection.find(".select2-selection__rendered").width();
                } else {
                    var minimumWidth = this.$search.val().length + 1;
                    width = minimumWidth * .75 + "em";
                }
                this.$search.css("width", width);
            };
            return Search;
        });
        S2.define("select2/selection/eventRelay", [ "jquery" ], function($) {
            function EventRelay() {}
            EventRelay.prototype.bind = function(decorated, container, $container) {
                var self = this;
                var relayEvents = [ "open", "opening", "close", "closing", "select", "selecting", "unselect", "unselecting", "clear", "clearing" ];
                var preventableEvents = [ "opening", "closing", "selecting", "unselecting", "clearing" ];
                decorated.call(this, container, $container);
                container.on("*", function(name, params) {
                    if ($.inArray(name, relayEvents) === -1) {
                        return;
                    }
                    params = params || {};
                    var evt = $.Event("select2:" + name, {
                        params: params
                    });
                    self.$element.trigger(evt);
                    if ($.inArray(name, preventableEvents) === -1) {
                        return;
                    }
                    params.prevented = evt.isDefaultPrevented();
                });
            };
            return EventRelay;
        });
        S2.define("select2/translation", [ "jquery", "require" ], function($, require) {
            function Translation(dict) {
                this.dict = dict || {};
            }
            Translation.prototype.all = function() {
                return this.dict;
            };
            Translation.prototype.get = function(key) {
                return this.dict[key];
            };
            Translation.prototype.extend = function(translation) {
                this.dict = $.extend({}, translation.all(), this.dict);
            };
            Translation._cache = {};
            Translation.loadPath = function(path) {
                if (!(path in Translation._cache)) {
                    var translations = require(path);
                    Translation._cache[path] = translations;
                }
                return new Translation(Translation._cache[path]);
            };
            return Translation;
        });
        S2.define("select2/diacritics", [], function() {
            var diacritics = {
                "Ⓐ": "A",
                "Ａ": "A",
                "À": "A",
                "Á": "A",
                "Â": "A",
                "Ầ": "A",
                "Ấ": "A",
                "Ẫ": "A",
                "Ẩ": "A",
                "Ã": "A",
                "Ā": "A",
                "Ă": "A",
                "Ằ": "A",
                "Ắ": "A",
                "Ẵ": "A",
                "Ẳ": "A",
                "Ȧ": "A",
                "Ǡ": "A",
                "Ä": "A",
                "Ǟ": "A",
                "Ả": "A",
                "Å": "A",
                "Ǻ": "A",
                "Ǎ": "A",
                "Ȁ": "A",
                "Ȃ": "A",
                "Ạ": "A",
                "Ậ": "A",
                "Ặ": "A",
                "Ḁ": "A",
                "Ą": "A",
                "Ⱥ": "A",
                "Ɐ": "A",
                "Ꜳ": "AA",
                "Æ": "AE",
                "Ǽ": "AE",
                "Ǣ": "AE",
                "Ꜵ": "AO",
                "Ꜷ": "AU",
                "Ꜹ": "AV",
                "Ꜻ": "AV",
                "Ꜽ": "AY",
                "Ⓑ": "B",
                "Ｂ": "B",
                "Ḃ": "B",
                "Ḅ": "B",
                "Ḇ": "B",
                "Ƀ": "B",
                "Ƃ": "B",
                "Ɓ": "B",
                "Ⓒ": "C",
                "Ｃ": "C",
                "Ć": "C",
                "Ĉ": "C",
                "Ċ": "C",
                "Č": "C",
                "Ç": "C",
                "Ḉ": "C",
                "Ƈ": "C",
                "Ȼ": "C",
                "Ꜿ": "C",
                "Ⓓ": "D",
                "Ｄ": "D",
                "Ḋ": "D",
                "Ď": "D",
                "Ḍ": "D",
                "Ḑ": "D",
                "Ḓ": "D",
                "Ḏ": "D",
                "Đ": "D",
                "Ƌ": "D",
                "Ɗ": "D",
                "Ɖ": "D",
                "Ꝺ": "D",
                "Ǳ": "DZ",
                "Ǆ": "DZ",
                "ǲ": "Dz",
                "ǅ": "Dz",
                "Ⓔ": "E",
                "Ｅ": "E",
                "È": "E",
                "É": "E",
                "Ê": "E",
                "Ề": "E",
                "Ế": "E",
                "Ễ": "E",
                "Ể": "E",
                "Ẽ": "E",
                "Ē": "E",
                "Ḕ": "E",
                "Ḗ": "E",
                "Ĕ": "E",
                "Ė": "E",
                "Ë": "E",
                "Ẻ": "E",
                "Ě": "E",
                "Ȅ": "E",
                "Ȇ": "E",
                "Ẹ": "E",
                "Ệ": "E",
                "Ȩ": "E",
                "Ḝ": "E",
                "Ę": "E",
                "Ḙ": "E",
                "Ḛ": "E",
                "Ɛ": "E",
                "Ǝ": "E",
                "Ⓕ": "F",
                "Ｆ": "F",
                "Ḟ": "F",
                "Ƒ": "F",
                "Ꝼ": "F",
                "Ⓖ": "G",
                "Ｇ": "G",
                "Ǵ": "G",
                "Ĝ": "G",
                "Ḡ": "G",
                "Ğ": "G",
                "Ġ": "G",
                "Ǧ": "G",
                "Ģ": "G",
                "Ǥ": "G",
                "Ɠ": "G",
                "Ꞡ": "G",
                "Ᵹ": "G",
                "Ꝿ": "G",
                "Ⓗ": "H",
                "Ｈ": "H",
                "Ĥ": "H",
                "Ḣ": "H",
                "Ḧ": "H",
                "Ȟ": "H",
                "Ḥ": "H",
                "Ḩ": "H",
                "Ḫ": "H",
                "Ħ": "H",
                "Ⱨ": "H",
                "Ⱶ": "H",
                "Ɥ": "H",
                "Ⓘ": "I",
                "Ｉ": "I",
                "Ì": "I",
                "Í": "I",
                "Î": "I",
                "Ĩ": "I",
                "Ī": "I",
                "Ĭ": "I",
                "İ": "I",
                "Ï": "I",
                "Ḯ": "I",
                "Ỉ": "I",
                "Ǐ": "I",
                "Ȉ": "I",
                "Ȋ": "I",
                "Ị": "I",
                "Į": "I",
                "Ḭ": "I",
                "Ɨ": "I",
                "Ⓙ": "J",
                "Ｊ": "J",
                "Ĵ": "J",
                "Ɉ": "J",
                "Ⓚ": "K",
                "Ｋ": "K",
                "Ḱ": "K",
                "Ǩ": "K",
                "Ḳ": "K",
                "Ķ": "K",
                "Ḵ": "K",
                "Ƙ": "K",
                "Ⱪ": "K",
                "Ꝁ": "K",
                "Ꝃ": "K",
                "Ꝅ": "K",
                "Ꞣ": "K",
                "Ⓛ": "L",
                "Ｌ": "L",
                "Ŀ": "L",
                "Ĺ": "L",
                "Ľ": "L",
                "Ḷ": "L",
                "Ḹ": "L",
                "Ļ": "L",
                "Ḽ": "L",
                "Ḻ": "L",
                "Ł": "L",
                "Ƚ": "L",
                "Ɫ": "L",
                "Ⱡ": "L",
                "Ꝉ": "L",
                "Ꝇ": "L",
                "Ꞁ": "L",
                "Ǉ": "LJ",
                "ǈ": "Lj",
                "Ⓜ": "M",
                "Ｍ": "M",
                "Ḿ": "M",
                "Ṁ": "M",
                "Ṃ": "M",
                "Ɱ": "M",
                "Ɯ": "M",
                "Ⓝ": "N",
                "Ｎ": "N",
                "Ǹ": "N",
                "Ń": "N",
                "Ñ": "N",
                "Ṅ": "N",
                "Ň": "N",
                "Ṇ": "N",
                "Ņ": "N",
                "Ṋ": "N",
                "Ṉ": "N",
                "Ƞ": "N",
                "Ɲ": "N",
                "Ꞑ": "N",
                "Ꞥ": "N",
                "Ǌ": "NJ",
                "ǋ": "Nj",
                "Ⓞ": "O",
                "Ｏ": "O",
                "Ò": "O",
                "Ó": "O",
                "Ô": "O",
                "Ồ": "O",
                "Ố": "O",
                "Ỗ": "O",
                "Ổ": "O",
                "Õ": "O",
                "Ṍ": "O",
                "Ȭ": "O",
                "Ṏ": "O",
                "Ō": "O",
                "Ṑ": "O",
                "Ṓ": "O",
                "Ŏ": "O",
                "Ȯ": "O",
                "Ȱ": "O",
                "Ö": "O",
                "Ȫ": "O",
                "Ỏ": "O",
                "Ő": "O",
                "Ǒ": "O",
                "Ȍ": "O",
                "Ȏ": "O",
                "Ơ": "O",
                "Ờ": "O",
                "Ớ": "O",
                "Ỡ": "O",
                "Ở": "O",
                "Ợ": "O",
                "Ọ": "O",
                "Ộ": "O",
                "Ǫ": "O",
                "Ǭ": "O",
                "Ø": "O",
                "Ǿ": "O",
                "Ɔ": "O",
                "Ɵ": "O",
                "Ꝋ": "O",
                "Ꝍ": "O",
                "Œ": "OE",
                "Ƣ": "OI",
                "Ꝏ": "OO",
                "Ȣ": "OU",
                "Ⓟ": "P",
                "Ｐ": "P",
                "Ṕ": "P",
                "Ṗ": "P",
                "Ƥ": "P",
                "Ᵽ": "P",
                "Ꝑ": "P",
                "Ꝓ": "P",
                "Ꝕ": "P",
                "Ⓠ": "Q",
                "Ｑ": "Q",
                "Ꝗ": "Q",
                "Ꝙ": "Q",
                "Ɋ": "Q",
                "Ⓡ": "R",
                "Ｒ": "R",
                "Ŕ": "R",
                "Ṙ": "R",
                "Ř": "R",
                "Ȑ": "R",
                "Ȓ": "R",
                "Ṛ": "R",
                "Ṝ": "R",
                "Ŗ": "R",
                "Ṟ": "R",
                "Ɍ": "R",
                "Ɽ": "R",
                "Ꝛ": "R",
                "Ꞧ": "R",
                "Ꞃ": "R",
                "Ⓢ": "S",
                "Ｓ": "S",
                "ẞ": "S",
                "Ś": "S",
                "Ṥ": "S",
                "Ŝ": "S",
                "Ṡ": "S",
                "Š": "S",
                "Ṧ": "S",
                "Ṣ": "S",
                "Ṩ": "S",
                "Ș": "S",
                "Ş": "S",
                "Ȿ": "S",
                "Ꞩ": "S",
                "Ꞅ": "S",
                "Ⓣ": "T",
                "Ｔ": "T",
                "Ṫ": "T",
                "Ť": "T",
                "Ṭ": "T",
                "Ț": "T",
                "Ţ": "T",
                "Ṱ": "T",
                "Ṯ": "T",
                "Ŧ": "T",
                "Ƭ": "T",
                "Ʈ": "T",
                "Ⱦ": "T",
                "Ꞇ": "T",
                "Ꜩ": "TZ",
                "Ⓤ": "U",
                "Ｕ": "U",
                "Ù": "U",
                "Ú": "U",
                "Û": "U",
                "Ũ": "U",
                "Ṹ": "U",
                "Ū": "U",
                "Ṻ": "U",
                "Ŭ": "U",
                "Ü": "U",
                "Ǜ": "U",
                "Ǘ": "U",
                "Ǖ": "U",
                "Ǚ": "U",
                "Ủ": "U",
                "Ů": "U",
                "Ű": "U",
                "Ǔ": "U",
                "Ȕ": "U",
                "Ȗ": "U",
                "Ư": "U",
                "Ừ": "U",
                "Ứ": "U",
                "Ữ": "U",
                "Ử": "U",
                "Ự": "U",
                "Ụ": "U",
                "Ṳ": "U",
                "Ų": "U",
                "Ṷ": "U",
                "Ṵ": "U",
                "Ʉ": "U",
                "Ⓥ": "V",
                "Ｖ": "V",
                "Ṽ": "V",
                "Ṿ": "V",
                "Ʋ": "V",
                "Ꝟ": "V",
                "Ʌ": "V",
                "Ꝡ": "VY",
                "Ⓦ": "W",
                "Ｗ": "W",
                "Ẁ": "W",
                "Ẃ": "W",
                "Ŵ": "W",
                "Ẇ": "W",
                "Ẅ": "W",
                "Ẉ": "W",
                "Ⱳ": "W",
                "Ⓧ": "X",
                "Ｘ": "X",
                "Ẋ": "X",
                "Ẍ": "X",
                "Ⓨ": "Y",
                "Ｙ": "Y",
                "Ỳ": "Y",
                "Ý": "Y",
                "Ŷ": "Y",
                "Ỹ": "Y",
                "Ȳ": "Y",
                "Ẏ": "Y",
                "Ÿ": "Y",
                "Ỷ": "Y",
                "Ỵ": "Y",
                "Ƴ": "Y",
                "Ɏ": "Y",
                "Ỿ": "Y",
                "Ⓩ": "Z",
                "Ｚ": "Z",
                "Ź": "Z",
                "Ẑ": "Z",
                "Ż": "Z",
                "Ž": "Z",
                "Ẓ": "Z",
                "Ẕ": "Z",
                "Ƶ": "Z",
                "Ȥ": "Z",
                "Ɀ": "Z",
                "Ⱬ": "Z",
                "Ꝣ": "Z",
                "ⓐ": "a",
                "ａ": "a",
                "ẚ": "a",
                "à": "a",
                "á": "a",
                "â": "a",
                "ầ": "a",
                "ấ": "a",
                "ẫ": "a",
                "ẩ": "a",
                "ã": "a",
                "ā": "a",
                "ă": "a",
                "ằ": "a",
                "ắ": "a",
                "ẵ": "a",
                "ẳ": "a",
                "ȧ": "a",
                "ǡ": "a",
                "ä": "a",
                "ǟ": "a",
                "ả": "a",
                "å": "a",
                "ǻ": "a",
                "ǎ": "a",
                "ȁ": "a",
                "ȃ": "a",
                "ạ": "a",
                "ậ": "a",
                "ặ": "a",
                "ḁ": "a",
                "ą": "a",
                "ⱥ": "a",
                "ɐ": "a",
                "ꜳ": "aa",
                "æ": "ae",
                "ǽ": "ae",
                "ǣ": "ae",
                "ꜵ": "ao",
                "ꜷ": "au",
                "ꜹ": "av",
                "ꜻ": "av",
                "ꜽ": "ay",
                "ⓑ": "b",
                "ｂ": "b",
                "ḃ": "b",
                "ḅ": "b",
                "ḇ": "b",
                "ƀ": "b",
                "ƃ": "b",
                "ɓ": "b",
                "ⓒ": "c",
                "ｃ": "c",
                "ć": "c",
                "ĉ": "c",
                "ċ": "c",
                "č": "c",
                "ç": "c",
                "ḉ": "c",
                "ƈ": "c",
                "ȼ": "c",
                "ꜿ": "c",
                "ↄ": "c",
                "ⓓ": "d",
                "ｄ": "d",
                "ḋ": "d",
                "ď": "d",
                "ḍ": "d",
                "ḑ": "d",
                "ḓ": "d",
                "ḏ": "d",
                "đ": "d",
                "ƌ": "d",
                "ɖ": "d",
                "ɗ": "d",
                "ꝺ": "d",
                "ǳ": "dz",
                "ǆ": "dz",
                "ⓔ": "e",
                "ｅ": "e",
                "è": "e",
                "é": "e",
                "ê": "e",
                "ề": "e",
                "ế": "e",
                "ễ": "e",
                "ể": "e",
                "ẽ": "e",
                "ē": "e",
                "ḕ": "e",
                "ḗ": "e",
                "ĕ": "e",
                "ė": "e",
                "ë": "e",
                "ẻ": "e",
                "ě": "e",
                "ȅ": "e",
                "ȇ": "e",
                "ẹ": "e",
                "ệ": "e",
                "ȩ": "e",
                "ḝ": "e",
                "ę": "e",
                "ḙ": "e",
                "ḛ": "e",
                "ɇ": "e",
                "ɛ": "e",
                "ǝ": "e",
                "ⓕ": "f",
                "ｆ": "f",
                "ḟ": "f",
                "ƒ": "f",
                "ꝼ": "f",
                "ⓖ": "g",
                "ｇ": "g",
                "ǵ": "g",
                "ĝ": "g",
                "ḡ": "g",
                "ğ": "g",
                "ġ": "g",
                "ǧ": "g",
                "ģ": "g",
                "ǥ": "g",
                "ɠ": "g",
                "ꞡ": "g",
                "ᵹ": "g",
                "ꝿ": "g",
                "ⓗ": "h",
                "ｈ": "h",
                "ĥ": "h",
                "ḣ": "h",
                "ḧ": "h",
                "ȟ": "h",
                "ḥ": "h",
                "ḩ": "h",
                "ḫ": "h",
                "ẖ": "h",
                "ħ": "h",
                "ⱨ": "h",
                "ⱶ": "h",
                "ɥ": "h",
                "ƕ": "hv",
                "ⓘ": "i",
                "ｉ": "i",
                "ì": "i",
                "í": "i",
                "î": "i",
                "ĩ": "i",
                "ī": "i",
                "ĭ": "i",
                "ï": "i",
                "ḯ": "i",
                "ỉ": "i",
                "ǐ": "i",
                "ȉ": "i",
                "ȋ": "i",
                "ị": "i",
                "į": "i",
                "ḭ": "i",
                "ɨ": "i",
                "ı": "i",
                "ⓙ": "j",
                "ｊ": "j",
                "ĵ": "j",
                "ǰ": "j",
                "ɉ": "j",
                "ⓚ": "k",
                "ｋ": "k",
                "ḱ": "k",
                "ǩ": "k",
                "ḳ": "k",
                "ķ": "k",
                "ḵ": "k",
                "ƙ": "k",
                "ⱪ": "k",
                "ꝁ": "k",
                "ꝃ": "k",
                "ꝅ": "k",
                "ꞣ": "k",
                "ⓛ": "l",
                "ｌ": "l",
                "ŀ": "l",
                "ĺ": "l",
                "ľ": "l",
                "ḷ": "l",
                "ḹ": "l",
                "ļ": "l",
                "ḽ": "l",
                "ḻ": "l",
                "ſ": "l",
                "ł": "l",
                "ƚ": "l",
                "ɫ": "l",
                "ⱡ": "l",
                "ꝉ": "l",
                "ꞁ": "l",
                "ꝇ": "l",
                "ǉ": "lj",
                "ⓜ": "m",
                "ｍ": "m",
                "ḿ": "m",
                "ṁ": "m",
                "ṃ": "m",
                "ɱ": "m",
                "ɯ": "m",
                "ⓝ": "n",
                "ｎ": "n",
                "ǹ": "n",
                "ń": "n",
                "ñ": "n",
                "ṅ": "n",
                "ň": "n",
                "ṇ": "n",
                "ņ": "n",
                "ṋ": "n",
                "ṉ": "n",
                "ƞ": "n",
                "ɲ": "n",
                "ŉ": "n",
                "ꞑ": "n",
                "ꞥ": "n",
                "ǌ": "nj",
                "ⓞ": "o",
                "ｏ": "o",
                "ò": "o",
                "ó": "o",
                "ô": "o",
                "ồ": "o",
                "ố": "o",
                "ỗ": "o",
                "ổ": "o",
                "õ": "o",
                "ṍ": "o",
                "ȭ": "o",
                "ṏ": "o",
                "ō": "o",
                "ṑ": "o",
                "ṓ": "o",
                "ŏ": "o",
                "ȯ": "o",
                "ȱ": "o",
                "ö": "o",
                "ȫ": "o",
                "ỏ": "o",
                "ő": "o",
                "ǒ": "o",
                "ȍ": "o",
                "ȏ": "o",
                "ơ": "o",
                "ờ": "o",
                "ớ": "o",
                "ỡ": "o",
                "ở": "o",
                "ợ": "o",
                "ọ": "o",
                "ộ": "o",
                "ǫ": "o",
                "ǭ": "o",
                "ø": "o",
                "ǿ": "o",
                "ɔ": "o",
                "ꝋ": "o",
                "ꝍ": "o",
                "ɵ": "o",
                "œ": "oe",
                "ƣ": "oi",
                "ȣ": "ou",
                "ꝏ": "oo",
                "ⓟ": "p",
                "ｐ": "p",
                "ṕ": "p",
                "ṗ": "p",
                "ƥ": "p",
                "ᵽ": "p",
                "ꝑ": "p",
                "ꝓ": "p",
                "ꝕ": "p",
                "ⓠ": "q",
                "ｑ": "q",
                "ɋ": "q",
                "ꝗ": "q",
                "ꝙ": "q",
                "ⓡ": "r",
                "ｒ": "r",
                "ŕ": "r",
                "ṙ": "r",
                "ř": "r",
                "ȑ": "r",
                "ȓ": "r",
                "ṛ": "r",
                "ṝ": "r",
                "ŗ": "r",
                "ṟ": "r",
                "ɍ": "r",
                "ɽ": "r",
                "ꝛ": "r",
                "ꞧ": "r",
                "ꞃ": "r",
                "ⓢ": "s",
                "ｓ": "s",
                "ß": "s",
                "ś": "s",
                "ṥ": "s",
                "ŝ": "s",
                "ṡ": "s",
                "š": "s",
                "ṧ": "s",
                "ṣ": "s",
                "ṩ": "s",
                "ș": "s",
                "ş": "s",
                "ȿ": "s",
                "ꞩ": "s",
                "ꞅ": "s",
                "ẛ": "s",
                "ⓣ": "t",
                "ｔ": "t",
                "ṫ": "t",
                "ẗ": "t",
                "ť": "t",
                "ṭ": "t",
                "ț": "t",
                "ţ": "t",
                "ṱ": "t",
                "ṯ": "t",
                "ŧ": "t",
                "ƭ": "t",
                "ʈ": "t",
                "ⱦ": "t",
                "ꞇ": "t",
                "ꜩ": "tz",
                "ⓤ": "u",
                "ｕ": "u",
                "ù": "u",
                "ú": "u",
                "û": "u",
                "ũ": "u",
                "ṹ": "u",
                "ū": "u",
                "ṻ": "u",
                "ŭ": "u",
                "ü": "u",
                "ǜ": "u",
                "ǘ": "u",
                "ǖ": "u",
                "ǚ": "u",
                "ủ": "u",
                "ů": "u",
                "ű": "u",
                "ǔ": "u",
                "ȕ": "u",
                "ȗ": "u",
                "ư": "u",
                "ừ": "u",
                "ứ": "u",
                "ữ": "u",
                "ử": "u",
                "ự": "u",
                "ụ": "u",
                "ṳ": "u",
                "ų": "u",
                "ṷ": "u",
                "ṵ": "u",
                "ʉ": "u",
                "ⓥ": "v",
                "ｖ": "v",
                "ṽ": "v",
                "ṿ": "v",
                "ʋ": "v",
                "ꝟ": "v",
                "ʌ": "v",
                "ꝡ": "vy",
                "ⓦ": "w",
                "ｗ": "w",
                "ẁ": "w",
                "ẃ": "w",
                "ŵ": "w",
                "ẇ": "w",
                "ẅ": "w",
                "ẘ": "w",
                "ẉ": "w",
                "ⱳ": "w",
                "ⓧ": "x",
                "ｘ": "x",
                "ẋ": "x",
                "ẍ": "x",
                "ⓨ": "y",
                "ｙ": "y",
                "ỳ": "y",
                "ý": "y",
                "ŷ": "y",
                "ỹ": "y",
                "ȳ": "y",
                "ẏ": "y",
                "ÿ": "y",
                "ỷ": "y",
                "ẙ": "y",
                "ỵ": "y",
                "ƴ": "y",
                "ɏ": "y",
                "ỿ": "y",
                "ⓩ": "z",
                "ｚ": "z",
                "ź": "z",
                "ẑ": "z",
                "ż": "z",
                "ž": "z",
                "ẓ": "z",
                "ẕ": "z",
                "ƶ": "z",
                "ȥ": "z",
                "ɀ": "z",
                "ⱬ": "z",
                "ꝣ": "z",
                "Ά": "Α",
                "Έ": "Ε",
                "Ή": "Η",
                "Ί": "Ι",
                "Ϊ": "Ι",
                "Ό": "Ο",
                "Ύ": "Υ",
                "Ϋ": "Υ",
                "Ώ": "Ω",
                "ά": "α",
                "έ": "ε",
                "ή": "η",
                "ί": "ι",
                "ϊ": "ι",
                "ΐ": "ι",
                "ό": "ο",
                "ύ": "υ",
                "ϋ": "υ",
                "ΰ": "υ",
                "ώ": "ω",
                "ς": "σ",
                "’": "'"
            };
            return diacritics;
        });
        S2.define("select2/data/base", [ "../utils" ], function(Utils) {
            function BaseAdapter($element, options) {
                BaseAdapter.__super__.constructor.call(this);
            }
            Utils.Extend(BaseAdapter, Utils.Observable);
            BaseAdapter.prototype.current = function(callback) {
                throw new Error("The `current` method must be defined in child classes.");
            };
            BaseAdapter.prototype.query = function(params, callback) {
                throw new Error("The `query` method must be defined in child classes.");
            };
            BaseAdapter.prototype.bind = function(container, $container) {};
            BaseAdapter.prototype.destroy = function() {};
            BaseAdapter.prototype.generateResultId = function(container, data) {
                var id = container.id + "-result-";
                id += Utils.generateChars(4);
                if (data.id != null) {
                    id += "-" + data.id.toString();
                } else {
                    id += "-" + Utils.generateChars(4);
                }
                return id;
            };
            return BaseAdapter;
        });
        S2.define("select2/data/select", [ "./base", "../utils", "jquery" ], function(BaseAdapter, Utils, $) {
            function SelectAdapter($element, options) {
                this.$element = $element;
                this.options = options;
                SelectAdapter.__super__.constructor.call(this);
            }
            Utils.Extend(SelectAdapter, BaseAdapter);
            SelectAdapter.prototype.current = function(callback) {
                var data = [];
                var self = this;
                this.$element.find(":selected").each(function() {
                    var $option = $(this);
                    var option = self.item($option);
                    data.push(option);
                });
                callback(data);
            };
            SelectAdapter.prototype.select = function(data) {
                var self = this;
                data.selected = true;
                if ($(data.element).is("option")) {
                    data.element.selected = true;
                    this.$element.trigger("change");
                    return;
                }
                if (this.$element.prop("multiple")) {
                    this.current(function(currentData) {
                        var val = [];
                        data = [ data ];
                        data.push.apply(data, currentData);
                        for (var d = 0; d < data.length; d++) {
                            var id = data[d].id;
                            if ($.inArray(id, val) === -1) {
                                val.push(id);
                            }
                        }
                        self.$element.val(val);
                        self.$element.trigger("change");
                    });
                } else {
                    var val = data.id;
                    this.$element.val(val);
                    this.$element.trigger("change");
                }
            };
            SelectAdapter.prototype.unselect = function(data) {
                var self = this;
                if (!this.$element.prop("multiple")) {
                    return;
                }
                data.selected = false;
                if ($(data.element).is("option")) {
                    data.element.selected = false;
                    this.$element.trigger("change");
                    return;
                }
                this.current(function(currentData) {
                    var val = [];
                    for (var d = 0; d < currentData.length; d++) {
                        var id = currentData[d].id;
                        if (id !== data.id && $.inArray(id, val) === -1) {
                            val.push(id);
                        }
                    }
                    self.$element.val(val);
                    self.$element.trigger("change");
                });
            };
            SelectAdapter.prototype.bind = function(container, $container) {
                var self = this;
                this.container = container;
                container.on("select", function(params) {
                    self.select(params.data);
                });
                container.on("unselect", function(params) {
                    self.unselect(params.data);
                });
            };
            SelectAdapter.prototype.destroy = function() {
                this.$element.find("*").each(function() {
                    Utils.RemoveData(this);
                });
            };
            SelectAdapter.prototype.query = function(params, callback) {
                var data = [];
                var self = this;
                var $options = this.$element.children();
                $options.each(function() {
                    var $option = $(this);
                    if (!$option.is("option") && !$option.is("optgroup")) {
                        return;
                    }
                    var option = self.item($option);
                    var matches = self.matches(params, option);
                    if (matches !== null) {
                        data.push(matches);
                    }
                });
                callback({
                    results: data
                });
            };
            SelectAdapter.prototype.addOptions = function($options) {
                Utils.appendMany(this.$element, $options);
            };
            SelectAdapter.prototype.option = function(data) {
                var option;
                if (data.children) {
                    option = document.createElement("optgroup");
                    option.label = data.text;
                } else {
                    option = document.createElement("option");
                    if (option.textContent !== undefined) {
                        option.textContent = data.text;
                    } else {
                        option.innerText = data.text;
                    }
                }
                if (data.id !== undefined) {
                    option.value = data.id;
                }
                if (data.disabled) {
                    option.disabled = true;
                }
                if (data.selected) {
                    option.selected = true;
                }
                if (data.title) {
                    option.title = data.title;
                }
                var $option = $(option);
                var normalizedData = this._normalizeItem(data);
                normalizedData.element = option;
                Utils.StoreData(option, "data", normalizedData);
                return $option;
            };
            SelectAdapter.prototype.item = function($option) {
                var data = {};
                data = Utils.GetData($option[0], "data");
                if (data != null) {
                    return data;
                }
                if ($option.is("option")) {
                    data = {
                        id: $option.val(),
                        text: $option.text(),
                        disabled: $option.prop("disabled"),
                        selected: $option.prop("selected"),
                        title: $option.prop("title")
                    };
                } else if ($option.is("optgroup")) {
                    data = {
                        text: $option.prop("label"),
                        children: [],
                        title: $option.prop("title")
                    };
                    var $children = $option.children("option");
                    var children = [];
                    for (var c = 0; c < $children.length; c++) {
                        var $child = $($children[c]);
                        var child = this.item($child);
                        children.push(child);
                    }
                    data.children = children;
                }
                data = this._normalizeItem(data);
                data.element = $option[0];
                Utils.StoreData($option[0], "data", data);
                return data;
            };
            SelectAdapter.prototype._normalizeItem = function(item) {
                if (item !== Object(item)) {
                    item = {
                        id: item,
                        text: item
                    };
                }
                item = $.extend({}, {
                    text: ""
                }, item);
                var defaults = {
                    selected: false,
                    disabled: false
                };
                if (item.id != null) {
                    item.id = item.id.toString();
                }
                if (item.text != null) {
                    item.text = item.text.toString();
                }
                if (item._resultId == null && item.id && this.container != null) {
                    item._resultId = this.generateResultId(this.container, item);
                }
                return $.extend({}, defaults, item);
            };
            SelectAdapter.prototype.matches = function(params, data) {
                var matcher = this.options.get("matcher");
                return matcher(params, data);
            };
            return SelectAdapter;
        });
        S2.define("select2/data/array", [ "./select", "../utils", "jquery" ], function(SelectAdapter, Utils, $) {
            function ArrayAdapter($element, options) {
                this._dataToConvert = options.get("data") || [];
                ArrayAdapter.__super__.constructor.call(this, $element, options);
            }
            Utils.Extend(ArrayAdapter, SelectAdapter);
            ArrayAdapter.prototype.bind = function(container, $container) {
                ArrayAdapter.__super__.bind.call(this, container, $container);
                this.addOptions(this.convertToOptions(this._dataToConvert));
            };
            ArrayAdapter.prototype.select = function(data) {
                var $option = this.$element.find("option").filter(function(i, elm) {
                    return elm.value == data.id.toString();
                });
                if ($option.length === 0) {
                    $option = this.option(data);
                    this.addOptions($option);
                }
                ArrayAdapter.__super__.select.call(this, data);
            };
            ArrayAdapter.prototype.convertToOptions = function(data) {
                var self = this;
                var $existing = this.$element.find("option");
                var existingIds = $existing.map(function() {
                    return self.item($(this)).id;
                }).get();
                var $options = [];
                function onlyItem(item) {
                    return function() {
                        return $(this).val() == item.id;
                    };
                }
                for (var d = 0; d < data.length; d++) {
                    var item = this._normalizeItem(data[d]);
                    if ($.inArray(item.id, existingIds) >= 0) {
                        var $existingOption = $existing.filter(onlyItem(item));
                        var existingData = this.item($existingOption);
                        var newData = $.extend(true, {}, item, existingData);
                        var $newOption = this.option(newData);
                        $existingOption.replaceWith($newOption);
                        continue;
                    }
                    var $option = this.option(item);
                    if (item.children) {
                        var $children = this.convertToOptions(item.children);
                        Utils.appendMany($option, $children);
                    }
                    $options.push($option);
                }
                return $options;
            };
            return ArrayAdapter;
        });
        S2.define("select2/data/ajax", [ "./array", "../utils", "jquery" ], function(ArrayAdapter, Utils, $) {
            function AjaxAdapter($element, options) {
                this.ajaxOptions = this._applyDefaults(options.get("ajax"));
                if (this.ajaxOptions.processResults != null) {
                    this.processResults = this.ajaxOptions.processResults;
                }
                AjaxAdapter.__super__.constructor.call(this, $element, options);
            }
            Utils.Extend(AjaxAdapter, ArrayAdapter);
            AjaxAdapter.prototype._applyDefaults = function(options) {
                var defaults = {
                    data: function(params) {
                        return $.extend({}, params, {
                            q: params.term
                        });
                    },
                    transport: function(params, success, failure) {
                        var $request = $.ajax(params);
                        $request.then(success);
                        $request.fail(failure);
                        return $request;
                    }
                };
                return $.extend({}, defaults, options, true);
            };
            AjaxAdapter.prototype.processResults = function(results) {
                return results;
            };
            AjaxAdapter.prototype.query = function(params, callback) {
                var matches = [];
                var self = this;
                if (this._request != null) {
                    if ($.isFunction(this._request.abort)) {
                        this._request.abort();
                    }
                    this._request = null;
                }
                var options = $.extend({
                    type: "GET"
                }, this.ajaxOptions);
                if (typeof options.url === "function") {
                    options.url = options.url.call(this.$element, params);
                }
                if (typeof options.data === "function") {
                    options.data = options.data.call(this.$element, params);
                }
                function request() {
                    var $request = options.transport(options, function(data) {
                        var results = self.processResults(data, params);
                        if (self.options.get("debug") && window.console && console.error) {
                            if (!results || !results.results || !$.isArray(results.results)) {
                                console.error("Select2: The AJAX results did not return an array in the " + "`results` key of the response.");
                            }
                        }
                        callback(results);
                    }, function() {
                        if ("status" in $request && ($request.status === 0 || $request.status === "0")) {
                            return;
                        }
                        self.trigger("results:message", {
                            message: "errorLoading"
                        });
                    });
                    self._request = $request;
                }
                if (this.ajaxOptions.delay && params.term != null) {
                    if (this._queryTimeout) {
                        window.clearTimeout(this._queryTimeout);
                    }
                    this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
                } else {
                    request();
                }
            };
            return AjaxAdapter;
        });
        S2.define("select2/data/tags", [ "jquery" ], function($) {
            function Tags(decorated, $element, options) {
                var tags = options.get("tags");
                var createTag = options.get("createTag");
                if (createTag !== undefined) {
                    this.createTag = createTag;
                }
                var insertTag = options.get("insertTag");
                if (insertTag !== undefined) {
                    this.insertTag = insertTag;
                }
                decorated.call(this, $element, options);
                if ($.isArray(tags)) {
                    for (var t = 0; t < tags.length; t++) {
                        var tag = tags[t];
                        var item = this._normalizeItem(tag);
                        var $option = this.option(item);
                        this.$element.append($option);
                    }
                }
            }
            Tags.prototype.query = function(decorated, params, callback) {
                var self = this;
                this._removeOldTags();
                if (params.term == null || params.page != null) {
                    decorated.call(this, params, callback);
                    return;
                }
                function wrapper(obj, child) {
                    var data = obj.results;
                    for (var i = 0; i < data.length; i++) {
                        var option = data[i];
                        var checkChildren = option.children != null && !wrapper({
                            results: option.children
                        }, true);
                        var optionText = (option.text || "").toUpperCase();
                        var paramsTerm = (params.term || "").toUpperCase();
                        var checkText = optionText === paramsTerm;
                        if (checkText || checkChildren) {
                            if (child) {
                                return false;
                            }
                            obj.data = data;
                            callback(obj);
                            return;
                        }
                    }
                    if (child) {
                        return true;
                    }
                    var tag = self.createTag(params);
                    if (tag != null) {
                        var $option = self.option(tag);
                        $option.attr("data-select2-tag", true);
                        self.addOptions([ $option ]);
                        self.insertTag(data, tag);
                    }
                    obj.results = data;
                    callback(obj);
                }
                decorated.call(this, params, wrapper);
            };
            Tags.prototype.createTag = function(decorated, params) {
                var term = $.trim(params.term);
                if (term === "") {
                    return null;
                }
                return {
                    id: term,
                    text: term
                };
            };
            Tags.prototype.insertTag = function(_, data, tag) {
                data.unshift(tag);
            };
            Tags.prototype._removeOldTags = function(_) {
                var $options = this.$element.find("option[data-select2-tag]");
                $options.each(function() {
                    if (this.selected) {
                        return;
                    }
                    $(this).remove();
                });
            };
            return Tags;
        });
        S2.define("select2/data/tokenizer", [ "jquery" ], function($) {
            function Tokenizer(decorated, $element, options) {
                var tokenizer = options.get("tokenizer");
                if (tokenizer !== undefined) {
                    this.tokenizer = tokenizer;
                }
                decorated.call(this, $element, options);
            }
            Tokenizer.prototype.bind = function(decorated, container, $container) {
                decorated.call(this, container, $container);
                this.$search = container.dropdown.$search || container.selection.$search || $container.find(".select2-search__field");
            };
            Tokenizer.prototype.query = function(decorated, params, callback) {
                var self = this;
                function createAndSelect(data) {
                    var item = self._normalizeItem(data);
                    var $existingOptions = self.$element.find("option").filter(function() {
                        return $(this).val() === item.id;
                    });
                    if (!$existingOptions.length) {
                        var $option = self.option(item);
                        $option.attr("data-select2-tag", true);
                        self._removeOldTags();
                        self.addOptions([ $option ]);
                    }
                    select(item);
                }
                function select(data) {
                    self.trigger("select", {
                        data: data
                    });
                }
                params.term = params.term || "";
                var tokenData = this.tokenizer(params, this.options, createAndSelect);
                if (tokenData.term !== params.term) {
                    if (this.$search.length) {
                        this.$search.val(tokenData.term);
                        this.$search.trigger("focus");
                    }
                    params.term = tokenData.term;
                }
                decorated.call(this, params, callback);
            };
            Tokenizer.prototype.tokenizer = function(_, params, options, callback) {
                var separators = options.get("tokenSeparators") || [];
                var term = params.term;
                var i = 0;
                var createTag = this.createTag || function(params) {
                    return {
                        id: params.term,
                        text: params.term
                    };
                };
                while (i < term.length) {
                    var termChar = term[i];
                    if ($.inArray(termChar, separators) === -1) {
                        i++;
                        continue;
                    }
                    var part = term.substr(0, i);
                    var partParams = $.extend({}, params, {
                        term: part
                    });
                    var data = createTag(partParams);
                    if (data == null) {
                        i++;
                        continue;
                    }
                    callback(data);
                    term = term.substr(i + 1) || "";
                    i = 0;
                }
                return {
                    term: term
                };
            };
            return Tokenizer;
        });
        S2.define("select2/data/minimumInputLength", [], function() {
            function MinimumInputLength(decorated, $e, options) {
                this.minimumInputLength = options.get("minimumInputLength");
                decorated.call(this, $e, options);
            }
            MinimumInputLength.prototype.query = function(decorated, params, callback) {
                params.term = params.term || "";
                if (params.term.length < this.minimumInputLength) {
                    this.trigger("results:message", {
                        message: "inputTooShort",
                        args: {
                            minimum: this.minimumInputLength,
                            input: params.term,
                            params: params
                        }
                    });
                    return;
                }
                decorated.call(this, params, callback);
            };
            return MinimumInputLength;
        });
        S2.define("select2/data/maximumInputLength", [], function() {
            function MaximumInputLength(decorated, $e, options) {
                this.maximumInputLength = options.get("maximumInputLength");
                decorated.call(this, $e, options);
            }
            MaximumInputLength.prototype.query = function(decorated, params, callback) {
                params.term = params.term || "";
                if (this.maximumInputLength > 0 && params.term.length > this.maximumInputLength) {
                    this.trigger("results:message", {
                        message: "inputTooLong",
                        args: {
                            maximum: this.maximumInputLength,
                            input: params.term,
                            params: params
                        }
                    });
                    return;
                }
                decorated.call(this, params, callback);
            };
            return MaximumInputLength;
        });
        S2.define("select2/data/maximumSelectionLength", [], function() {
            function MaximumSelectionLength(decorated, $e, options) {
                this.maximumSelectionLength = options.get("maximumSelectionLength");
                decorated.call(this, $e, options);
            }
            MaximumSelectionLength.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container);
                container.on("select", function() {
                    self._checkIfMaximumSelected();
                });
            };
            MaximumSelectionLength.prototype.query = function(decorated, params, callback) {
                var self = this;
                this._checkIfMaximumSelected(function() {
                    decorated.call(self, params, callback);
                });
            };
            MaximumSelectionLength.prototype._checkIfMaximumSelected = function(_, successCallback) {
                var self = this;
                this.current(function(currentData) {
                    var count = currentData != null ? currentData.length : 0;
                    if (self.maximumSelectionLength > 0 && count >= self.maximumSelectionLength) {
                        self.trigger("results:message", {
                            message: "maximumSelected",
                            args: {
                                maximum: self.maximumSelectionLength
                            }
                        });
                        return;
                    }
                    if (successCallback) {
                        successCallback();
                    }
                });
            };
            return MaximumSelectionLength;
        });
        S2.define("select2/dropdown", [ "jquery", "./utils" ], function($, Utils) {
            function Dropdown($element, options) {
                this.$element = $element;
                this.options = options;
                Dropdown.__super__.constructor.call(this);
            }
            Utils.Extend(Dropdown, Utils.Observable);
            Dropdown.prototype.render = function() {
                var $dropdown = $('<span class="select2-dropdown">' + '<span class="select2-results"></span>' + "</span>");
                $dropdown.attr("dir", this.options.get("dir"));
                this.$dropdown = $dropdown;
                return $dropdown;
            };
            Dropdown.prototype.bind = function() {};
            Dropdown.prototype.position = function($dropdown, $container) {};
            Dropdown.prototype.destroy = function() {
                this.$dropdown.remove();
            };
            return Dropdown;
        });
        S2.define("select2/dropdown/search", [ "jquery", "../utils" ], function($, Utils) {
            function Search() {}
            Search.prototype.render = function(decorated) {
                var $rendered = decorated.call(this);
                var $search = $('<span class="select2-search select2-search--dropdown">' + '<input class="select2-search__field" type="search" tabindex="-1"' + ' autocomplete="off" autocorrect="off" autocapitalize="none"' + ' spellcheck="false" role="searchbox" aria-autocomplete="list" />' + "</span>");
                this.$searchContainer = $search;
                this.$search = $search.find("input");
                $rendered.prepend($search);
                return $rendered;
            };
            Search.prototype.bind = function(decorated, container, $container) {
                var self = this;
                var resultsId = container.id + "-results";
                decorated.call(this, container, $container);
                this.$search.on("keydown", function(evt) {
                    self.trigger("keypress", evt);
                    self._keyUpPrevented = evt.isDefaultPrevented();
                });
                this.$search.on("input", function(evt) {
                    $(this).off("keyup");
                });
                this.$search.on("keyup input", function(evt) {
                    self.handleSearch(evt);
                });
                container.on("open", function() {
                    self.$search.attr("tabindex", 0);
                    self.$search.attr("aria-controls", resultsId);
                    self.$search.trigger("focus");
                    window.setTimeout(function() {
                        self.$search.trigger("focus");
                    }, 0);
                });
                container.on("close", function() {
                    self.$search.attr("tabindex", -1);
                    self.$search.removeAttr("aria-controls");
                    self.$search.removeAttr("aria-activedescendant");
                    self.$search.val("");
                    self.$search.trigger("blur");
                });
                container.on("focus", function() {
                    if (!container.isOpen()) {
                        self.$search.trigger("focus");
                    }
                });
                container.on("results:all", function(params) {
                    if (params.query.term == null || params.query.term === "") {
                        var showSearch = self.showSearch(params);
                        if (showSearch) {
                            self.$searchContainer.removeClass("select2-search--hide");
                        } else {
                            self.$searchContainer.addClass("select2-search--hide");
                        }
                    }
                });
                container.on("results:focus", function(params) {
                    if (params.data._resultId) {
                        self.$search.attr("aria-activedescendant", params.data._resultId);
                    } else {
                        self.$search.removeAttr("aria-activedescendant");
                    }
                });
            };
            Search.prototype.handleSearch = function(evt) {
                if (!this._keyUpPrevented) {
                    var input = this.$search.val();
                    this.trigger("query", {
                        term: input
                    });
                }
                this._keyUpPrevented = false;
            };
            Search.prototype.showSearch = function(_, params) {
                return true;
            };
            return Search;
        });
        S2.define("select2/dropdown/hidePlaceholder", [], function() {
            function HidePlaceholder(decorated, $element, options, dataAdapter) {
                this.placeholder = this.normalizePlaceholder(options.get("placeholder"));
                decorated.call(this, $element, options, dataAdapter);
            }
            HidePlaceholder.prototype.append = function(decorated, data) {
                data.results = this.removePlaceholder(data.results);
                decorated.call(this, data);
            };
            HidePlaceholder.prototype.normalizePlaceholder = function(_, placeholder) {
                if (typeof placeholder === "string") {
                    placeholder = {
                        id: "",
                        text: placeholder
                    };
                }
                return placeholder;
            };
            HidePlaceholder.prototype.removePlaceholder = function(_, data) {
                var modifiedData = data.slice(0);
                for (var d = data.length - 1; d >= 0; d--) {
                    var item = data[d];
                    if (this.placeholder.id === item.id) {
                        modifiedData.splice(d, 1);
                    }
                }
                return modifiedData;
            };
            return HidePlaceholder;
        });
        S2.define("select2/dropdown/infiniteScroll", [ "jquery" ], function($) {
            function InfiniteScroll(decorated, $element, options, dataAdapter) {
                this.lastParams = {};
                decorated.call(this, $element, options, dataAdapter);
                this.$loadingMore = this.createLoadingMore();
                this.loading = false;
            }
            InfiniteScroll.prototype.append = function(decorated, data) {
                this.$loadingMore.remove();
                this.loading = false;
                decorated.call(this, data);
                if (this.showLoadingMore(data)) {
                    this.$results.append(this.$loadingMore);
                    this.loadMoreIfNeeded();
                }
            };
            InfiniteScroll.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container);
                container.on("query", function(params) {
                    self.lastParams = params;
                    self.loading = true;
                });
                container.on("query:append", function(params) {
                    self.lastParams = params;
                    self.loading = true;
                });
                this.$results.on("scroll", this.loadMoreIfNeeded.bind(this));
            };
            InfiniteScroll.prototype.loadMoreIfNeeded = function() {
                var isLoadMoreVisible = $.contains(document.documentElement, this.$loadingMore[0]);
                if (this.loading || !isLoadMoreVisible) {
                    return;
                }
                var currentOffset = this.$results.offset().top + this.$results.outerHeight(false);
                var loadingMoreOffset = this.$loadingMore.offset().top + this.$loadingMore.outerHeight(false);
                if (currentOffset + 50 >= loadingMoreOffset) {
                    this.loadMore();
                }
            };
            InfiniteScroll.prototype.loadMore = function() {
                this.loading = true;
                var params = $.extend({}, {
                    page: 1
                }, this.lastParams);
                params.page++;
                this.trigger("query:append", params);
            };
            InfiniteScroll.prototype.showLoadingMore = function(_, data) {
                return data.pagination && data.pagination.more;
            };
            InfiniteScroll.prototype.createLoadingMore = function() {
                var $option = $("<li " + 'class="select2-results__option select2-results__option--load-more"' + 'role="option" aria-disabled="true"></li>');
                var message = this.options.get("translations").get("loadingMore");
                $option.html(message(this.lastParams));
                return $option;
            };
            return InfiniteScroll;
        });
        S2.define("select2/dropdown/attachBody", [ "jquery", "../utils" ], function($, Utils) {
            function AttachBody(decorated, $element, options) {
                this.$dropdownParent = $(options.get("dropdownParent") || document.body);
                decorated.call(this, $element, options);
            }
            AttachBody.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container);
                container.on("open", function() {
                    self._showDropdown();
                    self._attachPositioningHandler(container);
                    self._bindContainerResultHandlers(container);
                });
                container.on("close", function() {
                    self._hideDropdown();
                    self._detachPositioningHandler(container);
                });
                this.$dropdownContainer.on("mousedown", function(evt) {
                    evt.stopPropagation();
                });
            };
            AttachBody.prototype.destroy = function(decorated) {
                decorated.call(this);
                this.$dropdownContainer.remove();
            };
            AttachBody.prototype.position = function(decorated, $dropdown, $container) {
                $dropdown.attr("class", $container.attr("class"));
                $dropdown.removeClass("select2");
                $dropdown.addClass("select2-container--open");
                $dropdown.css({
                    position: "absolute",
                    top: -999999
                });
                this.$container = $container;
            };
            AttachBody.prototype.render = function(decorated) {
                var $container = $("<span></span>");
                var $dropdown = decorated.call(this);
                $container.append($dropdown);
                this.$dropdownContainer = $container;
                return $container;
            };
            AttachBody.prototype._hideDropdown = function(decorated) {
                this.$dropdownContainer.detach();
            };
            AttachBody.prototype._bindContainerResultHandlers = function(decorated, container) {
                if (this._containerResultsHandlersBound) {
                    return;
                }
                var self = this;
                container.on("results:all", function() {
                    self._positionDropdown();
                    self._resizeDropdown();
                });
                container.on("results:append", function() {
                    self._positionDropdown();
                    self._resizeDropdown();
                });
                container.on("results:message", function() {
                    self._positionDropdown();
                    self._resizeDropdown();
                });
                container.on("select", function() {
                    self._positionDropdown();
                    self._resizeDropdown();
                });
                container.on("unselect", function() {
                    self._positionDropdown();
                    self._resizeDropdown();
                });
                this._containerResultsHandlersBound = true;
            };
            AttachBody.prototype._attachPositioningHandler = function(decorated, container) {
                var self = this;
                var scrollEvent = "scroll.select2." + container.id;
                var resizeEvent = "resize.select2." + container.id;
                var orientationEvent = "orientationchange.select2." + container.id;
                var $watchers = this.$container.parents().filter(Utils.hasScroll);
                $watchers.each(function() {
                    Utils.StoreData(this, "select2-scroll-position", {
                        x: $(this).scrollLeft(),
                        y: $(this).scrollTop()
                    });
                });
                $watchers.on(scrollEvent, function(ev) {
                    var position = Utils.GetData(this, "select2-scroll-position");
                    $(this).scrollTop(position.y);
                });
                $(window).on(scrollEvent + " " + resizeEvent + " " + orientationEvent, function(e) {
                    self._positionDropdown();
                    self._resizeDropdown();
                });
            };
            AttachBody.prototype._detachPositioningHandler = function(decorated, container) {
                var scrollEvent = "scroll.select2." + container.id;
                var resizeEvent = "resize.select2." + container.id;
                var orientationEvent = "orientationchange.select2." + container.id;
                var $watchers = this.$container.parents().filter(Utils.hasScroll);
                $watchers.off(scrollEvent);
                $(window).off(scrollEvent + " " + resizeEvent + " " + orientationEvent);
            };
            AttachBody.prototype._positionDropdown = function() {
                var $window = $(window);
                var isCurrentlyAbove = this.$dropdown.hasClass("select2-dropdown--above");
                var isCurrentlyBelow = this.$dropdown.hasClass("select2-dropdown--below");
                var newDirection = null;
                var offset = this.$container.offset();
                offset.bottom = offset.top + this.$container.outerHeight(false);
                var container = {
                    height: this.$container.outerHeight(false)
                };
                container.top = offset.top;
                container.bottom = offset.top + container.height;
                var dropdown = {
                    height: this.$dropdown.outerHeight(false)
                };
                var viewport = {
                    top: $window.scrollTop(),
                    bottom: $window.scrollTop() + $window.height()
                };
                var enoughRoomAbove = viewport.top < offset.top - dropdown.height;
                var enoughRoomBelow = viewport.bottom > offset.bottom + dropdown.height;
                var css = {
                    left: offset.left,
                    top: container.bottom
                };
                var $offsetParent = this.$dropdownParent;
                if ($offsetParent.css("position") === "static") {
                    $offsetParent = $offsetParent.offsetParent();
                }
                var parentOffset = $offsetParent.offset();
                css.top -= parentOffset.top;
                css.left -= parentOffset.left;
                if (!isCurrentlyAbove && !isCurrentlyBelow) {
                    newDirection = "below";
                }
                if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
                    newDirection = "above";
                } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
                    newDirection = "below";
                }
                if (newDirection == "above" || isCurrentlyAbove && newDirection !== "below") {
                    css.top = container.top - parentOffset.top - dropdown.height;
                }
                if (newDirection != null) {
                    this.$dropdown.removeClass("select2-dropdown--below select2-dropdown--above").addClass("select2-dropdown--" + newDirection);
                    this.$container.removeClass("select2-container--below select2-container--above").addClass("select2-container--" + newDirection);
                }
                this.$dropdownContainer.css(css);
            };
            AttachBody.prototype._resizeDropdown = function() {
                var css = {
                    width: this.$container.outerWidth(false) + "px"
                };
                if (this.options.get("dropdownAutoWidth")) {
                    css.minWidth = css.width;
                    css.position = "relative";
                    css.width = "auto";
                }
                this.$dropdown.css(css);
            };
            AttachBody.prototype._showDropdown = function(decorated) {
                this.$dropdownContainer.appendTo(this.$dropdownParent);
                this._positionDropdown();
                this._resizeDropdown();
            };
            return AttachBody;
        });
        S2.define("select2/dropdown/minimumResultsForSearch", [], function() {
            function countResults(data) {
                var count = 0;
                for (var d = 0; d < data.length; d++) {
                    var item = data[d];
                    if (item.children) {
                        count += countResults(item.children);
                    } else {
                        count++;
                    }
                }
                return count;
            }
            function MinimumResultsForSearch(decorated, $element, options, dataAdapter) {
                this.minimumResultsForSearch = options.get("minimumResultsForSearch");
                if (this.minimumResultsForSearch < 0) {
                    this.minimumResultsForSearch = Infinity;
                }
                decorated.call(this, $element, options, dataAdapter);
            }
            MinimumResultsForSearch.prototype.showSearch = function(decorated, params) {
                if (countResults(params.data.results) < this.minimumResultsForSearch) {
                    return false;
                }
                return decorated.call(this, params);
            };
            return MinimumResultsForSearch;
        });
        S2.define("select2/dropdown/selectOnClose", [ "../utils" ], function(Utils) {
            function SelectOnClose() {}
            SelectOnClose.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container);
                container.on("close", function(params) {
                    self._handleSelectOnClose(params);
                });
            };
            SelectOnClose.prototype._handleSelectOnClose = function(_, params) {
                if (params && params.originalSelect2Event != null) {
                    var event = params.originalSelect2Event;
                    if (event._type === "select" || event._type === "unselect") {
                        return;
                    }
                }
                var $highlightedResults = this.getHighlightedResults();
                if ($highlightedResults.length < 1) {
                    return;
                }
                var data = Utils.GetData($highlightedResults[0], "data");
                if (data.element != null && data.element.selected || data.element == null && data.selected) {
                    return;
                }
                this.trigger("select", {
                    data: data
                });
            };
            return SelectOnClose;
        });
        S2.define("select2/dropdown/closeOnSelect", [], function() {
            function CloseOnSelect() {}
            CloseOnSelect.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container);
                container.on("select", function(evt) {
                    self._selectTriggered(evt);
                });
                container.on("unselect", function(evt) {
                    self._selectTriggered(evt);
                });
            };
            CloseOnSelect.prototype._selectTriggered = function(_, evt) {
                var originalEvent = evt.originalEvent;
                if (originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey)) {
                    return;
                }
                this.trigger("close", {
                    originalEvent: originalEvent,
                    originalSelect2Event: evt
                });
            };
            return CloseOnSelect;
        });
        S2.define("select2/i18n/en", [], function() {
            return {
                errorLoading: function() {
                    return "The results could not be loaded.";
                },
                inputTooLong: function(args) {
                    var overChars = args.input.length - args.maximum;
                    var message = "Please delete " + overChars + " character";
                    if (overChars != 1) {
                        message += "s";
                    }
                    return message;
                },
                inputTooShort: function(args) {
                    var remainingChars = args.minimum - args.input.length;
                    var message = "Please enter " + remainingChars + " or more characters";
                    return message;
                },
                loadingMore: function() {
                    return "Loading more results…";
                },
                maximumSelected: function(args) {
                    var message = "You can only select " + args.maximum + " item";
                    if (args.maximum != 1) {
                        message += "s";
                    }
                    return message;
                },
                noResults: function() {
                    return "No results found";
                },
                searching: function() {
                    return "Searching…";
                },
                removeAllItems: function() {
                    return "Remove all items";
                }
            };
        });
        S2.define("select2/defaults", [ "jquery", "require", "./results", "./selection/single", "./selection/multiple", "./selection/placeholder", "./selection/allowClear", "./selection/search", "./selection/eventRelay", "./utils", "./translation", "./diacritics", "./data/select", "./data/array", "./data/ajax", "./data/tags", "./data/tokenizer", "./data/minimumInputLength", "./data/maximumInputLength", "./data/maximumSelectionLength", "./dropdown", "./dropdown/search", "./dropdown/hidePlaceholder", "./dropdown/infiniteScroll", "./dropdown/attachBody", "./dropdown/minimumResultsForSearch", "./dropdown/selectOnClose", "./dropdown/closeOnSelect", "./i18n/en" ], function($, require, ResultsList, SingleSelection, MultipleSelection, Placeholder, AllowClear, SelectionSearch, EventRelay, Utils, Translation, DIACRITICS, SelectData, ArrayData, AjaxData, Tags, Tokenizer, MinimumInputLength, MaximumInputLength, MaximumSelectionLength, Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll, AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect, EnglishTranslation) {
            function Defaults() {
                this.reset();
            }
            Defaults.prototype.apply = function(options) {
                options = $.extend(true, {}, this.defaults, options);
                if (options.dataAdapter == null) {
                    if (options.ajax != null) {
                        options.dataAdapter = AjaxData;
                    } else if (options.data != null) {
                        options.dataAdapter = ArrayData;
                    } else {
                        options.dataAdapter = SelectData;
                    }
                    if (options.minimumInputLength > 0) {
                        options.dataAdapter = Utils.Decorate(options.dataAdapter, MinimumInputLength);
                    }
                    if (options.maximumInputLength > 0) {
                        options.dataAdapter = Utils.Decorate(options.dataAdapter, MaximumInputLength);
                    }
                    if (options.maximumSelectionLength > 0) {
                        options.dataAdapter = Utils.Decorate(options.dataAdapter, MaximumSelectionLength);
                    }
                    if (options.tags) {
                        options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
                    }
                    if (options.tokenSeparators != null || options.tokenizer != null) {
                        options.dataAdapter = Utils.Decorate(options.dataAdapter, Tokenizer);
                    }
                    if (options.query != null) {
                        var Query = require(options.amdBase + "compat/query");
                        options.dataAdapter = Utils.Decorate(options.dataAdapter, Query);
                    }
                    if (options.initSelection != null) {
                        var InitSelection = require(options.amdBase + "compat/initSelection");
                        options.dataAdapter = Utils.Decorate(options.dataAdapter, InitSelection);
                    }
                }
                if (options.resultsAdapter == null) {
                    options.resultsAdapter = ResultsList;
                    if (options.ajax != null) {
                        options.resultsAdapter = Utils.Decorate(options.resultsAdapter, InfiniteScroll);
                    }
                    if (options.placeholder != null) {
                        options.resultsAdapter = Utils.Decorate(options.resultsAdapter, HidePlaceholder);
                    }
                    if (options.selectOnClose) {
                        options.resultsAdapter = Utils.Decorate(options.resultsAdapter, SelectOnClose);
                    }
                }
                if (options.dropdownAdapter == null) {
                    if (options.multiple) {
                        options.dropdownAdapter = Dropdown;
                    } else {
                        var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);
                        options.dropdownAdapter = SearchableDropdown;
                    }
                    if (options.minimumResultsForSearch !== 0) {
                        options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, MinimumResultsForSearch);
                    }
                    if (options.closeOnSelect) {
                        options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, CloseOnSelect);
                    }
                    if (options.dropdownCssClass != null || options.dropdownCss != null || options.adaptDropdownCssClass != null) {
                        var DropdownCSS = require(options.amdBase + "compat/dropdownCss");
                        options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, DropdownCSS);
                    }
                    options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, AttachBody);
                }
                if (options.selectionAdapter == null) {
                    if (options.multiple) {
                        options.selectionAdapter = MultipleSelection;
                    } else {
                        options.selectionAdapter = SingleSelection;
                    }
                    if (options.placeholder != null) {
                        options.selectionAdapter = Utils.Decorate(options.selectionAdapter, Placeholder);
                    }
                    if (options.allowClear) {
                        options.selectionAdapter = Utils.Decorate(options.selectionAdapter, AllowClear);
                    }
                    if (options.multiple) {
                        options.selectionAdapter = Utils.Decorate(options.selectionAdapter, SelectionSearch);
                    }
                    if (options.containerCssClass != null || options.containerCss != null || options.adaptContainerCssClass != null) {
                        var ContainerCSS = require(options.amdBase + "compat/containerCss");
                        options.selectionAdapter = Utils.Decorate(options.selectionAdapter, ContainerCSS);
                    }
                    options.selectionAdapter = Utils.Decorate(options.selectionAdapter, EventRelay);
                }
                options.language = this._resolveLanguage(options.language);
                options.language.push("en");
                var uniqueLanguages = [];
                for (var l = 0; l < options.language.length; l++) {
                    var language = options.language[l];
                    if (uniqueLanguages.indexOf(language) === -1) {
                        uniqueLanguages.push(language);
                    }
                }
                options.language = uniqueLanguages;
                options.translations = this._processTranslations(options.language, options.debug);
                return options;
            };
            Defaults.prototype.reset = function() {
                function stripDiacritics(text) {
                    function match(a) {
                        return DIACRITICS[a] || a;
                    }
                    return text.replace(/[^\u0000-\u007E]/g, match);
                }
                function matcher(params, data) {
                    if ($.trim(params.term) === "") {
                        return data;
                    }
                    if (data.children && data.children.length > 0) {
                        var match = $.extend(true, {}, data);
                        for (var c = data.children.length - 1; c >= 0; c--) {
                            var child = data.children[c];
                            var matches = matcher(params, child);
                            if (matches == null) {
                                match.children.splice(c, 1);
                            }
                        }
                        if (match.children.length > 0) {
                            return match;
                        }
                        return matcher(params, match);
                    }
                    var original = stripDiacritics(data.text).toUpperCase();
                    var term = stripDiacritics(params.term).toUpperCase();
                    if (original.indexOf(term) > -1) {
                        return data;
                    }
                    return null;
                }
                this.defaults = {
                    amdBase: "./",
                    amdLanguageBase: "./i18n/",
                    closeOnSelect: true,
                    debug: false,
                    dropdownAutoWidth: false,
                    escapeMarkup: Utils.escapeMarkup,
                    language: {},
                    matcher: matcher,
                    minimumInputLength: 0,
                    maximumInputLength: 0,
                    maximumSelectionLength: 0,
                    minimumResultsForSearch: 0,
                    selectOnClose: false,
                    scrollAfterSelect: false,
                    sorter: function(data) {
                        return data;
                    },
                    templateResult: function(result) {
                        return result.text;
                    },
                    templateSelection: function(selection) {
                        return selection.text;
                    },
                    theme: "default",
                    width: "resolve"
                };
            };
            Defaults.prototype.applyFromElement = function(options, $element) {
                var optionLanguage = options.language;
                var defaultLanguage = this.defaults.language;
                var elementLanguage = $element.prop("lang");
                var parentLanguage = $element.closest("[lang]").prop("lang");
                var languages = Array.prototype.concat.call(this._resolveLanguage(elementLanguage), this._resolveLanguage(optionLanguage), this._resolveLanguage(defaultLanguage), this._resolveLanguage(parentLanguage));
                options.language = languages;
                return options;
            };
            Defaults.prototype._resolveLanguage = function(language) {
                if (!language) {
                    return [];
                }
                if ($.isEmptyObject(language)) {
                    return [];
                }
                if ($.isPlainObject(language)) {
                    return [ language ];
                }
                var languages;
                if (!$.isArray(language)) {
                    languages = [ language ];
                } else {
                    languages = language;
                }
                var resolvedLanguages = [];
                for (var l = 0; l < languages.length; l++) {
                    resolvedLanguages.push(languages[l]);
                    if (typeof languages[l] === "string" && languages[l].indexOf("-") > 0) {
                        var languageParts = languages[l].split("-");
                        var baseLanguage = languageParts[0];
                        resolvedLanguages.push(baseLanguage);
                    }
                }
                return resolvedLanguages;
            };
            Defaults.prototype._processTranslations = function(languages, debug) {
                var translations = new Translation();
                for (var l = 0; l < languages.length; l++) {
                    var languageData = new Translation();
                    var language = languages[l];
                    if (typeof language === "string") {
                        try {
                            languageData = Translation.loadPath(language);
                        } catch (e) {
                            try {
                                language = this.defaults.amdLanguageBase + language;
                                languageData = Translation.loadPath(language);
                            } catch (ex) {
                                if (debug && window.console && console.warn) {
                                    console.warn('Select2: The language file for "' + language + '" could ' + "not be automatically loaded. A fallback will be used instead.");
                                }
                            }
                        }
                    } else if ($.isPlainObject(language)) {
                        languageData = new Translation(language);
                    } else {
                        languageData = language;
                    }
                    translations.extend(languageData);
                }
                return translations;
            };
            Defaults.prototype.set = function(key, value) {
                var camelKey = $.camelCase(key);
                var data = {};
                data[camelKey] = value;
                var convertedData = Utils._convertData(data);
                $.extend(true, this.defaults, convertedData);
            };
            var defaults = new Defaults();
            return defaults;
        });
        S2.define("select2/options", [ "require", "jquery", "./defaults", "./utils" ], function(require, $, Defaults, Utils) {
            function Options(options, $element) {
                this.options = options;
                if ($element != null) {
                    this.fromElement($element);
                }
                if ($element != null) {
                    this.options = Defaults.applyFromElement(this.options, $element);
                }
                this.options = Defaults.apply(this.options);
                if ($element && $element.is("input")) {
                    var InputCompat = require(this.get("amdBase") + "compat/inputData");
                    this.options.dataAdapter = Utils.Decorate(this.options.dataAdapter, InputCompat);
                }
            }
            Options.prototype.fromElement = function($e) {
                var excludedData = [ "select2" ];
                if (this.options.multiple == null) {
                    this.options.multiple = $e.prop("multiple");
                }
                if (this.options.disabled == null) {
                    this.options.disabled = $e.prop("disabled");
                }
                if (this.options.dir == null) {
                    if ($e.prop("dir")) {
                        this.options.dir = $e.prop("dir");
                    } else if ($e.closest("[dir]").prop("dir")) {
                        this.options.dir = $e.closest("[dir]").prop("dir");
                    } else {
                        this.options.dir = "ltr";
                    }
                }
                $e.prop("disabled", this.options.disabled);
                $e.prop("multiple", this.options.multiple);
                if (Utils.GetData($e[0], "select2Tags")) {
                    if (this.options.debug && window.console && console.warn) {
                        console.warn("Select2: The `data-select2-tags` attribute has been changed to " + 'use the `data-data` and `data-tags="true"` attributes and will be ' + "removed in future versions of Select2.");
                    }
                    Utils.StoreData($e[0], "data", Utils.GetData($e[0], "select2Tags"));
                    Utils.StoreData($e[0], "tags", true);
                }
                if (Utils.GetData($e[0], "ajaxUrl")) {
                    if (this.options.debug && window.console && console.warn) {
                        console.warn("Select2: The `data-ajax-url` attribute has been changed to " + "`data-ajax--url` and support for the old attribute will be removed" + " in future versions of Select2.");
                    }
                    $e.attr("ajax--url", Utils.GetData($e[0], "ajaxUrl"));
                    Utils.StoreData($e[0], "ajax-Url", Utils.GetData($e[0], "ajaxUrl"));
                }
                var dataset = {};
                function upperCaseLetter(_, letter) {
                    return letter.toUpperCase();
                }
                for (var attr = 0; attr < $e[0].attributes.length; attr++) {
                    var attributeName = $e[0].attributes[attr].name;
                    var prefix = "data-";
                    if (attributeName.substr(0, prefix.length) == prefix) {
                        var dataName = attributeName.substring(prefix.length);
                        var dataValue = Utils.GetData($e[0], dataName);
                        var camelDataName = dataName.replace(/-([a-z])/g, upperCaseLetter);
                        dataset[camelDataName] = dataValue;
                    }
                }
                if ($.fn.jquery && $.fn.jquery.substr(0, 2) == "1." && $e[0].dataset) {
                    dataset = $.extend(true, {}, $e[0].dataset, dataset);
                }
                var data = $.extend(true, {}, Utils.GetData($e[0]), dataset);
                data = Utils._convertData(data);
                for (var key in data) {
                    if ($.inArray(key, excludedData) > -1) {
                        continue;
                    }
                    if ($.isPlainObject(this.options[key])) {
                        $.extend(this.options[key], data[key]);
                    } else {
                        this.options[key] = data[key];
                    }
                }
                return this;
            };
            Options.prototype.get = function(key) {
                return this.options[key];
            };
            Options.prototype.set = function(key, val) {
                this.options[key] = val;
            };
            return Options;
        });
        S2.define("select2/core", [ "jquery", "./options", "./utils", "./keys" ], function($, Options, Utils, KEYS) {
            var Select2 = function($element, options) {
                if (Utils.GetData($element[0], "select2") != null) {
                    Utils.GetData($element[0], "select2").destroy();
                }
                this.$element = $element;
                this.id = this._generateId($element);
                options = options || {};
                this.options = new Options(options, $element);
                Select2.__super__.constructor.call(this);
                var tabindex = $element.attr("tabindex") || 0;
                Utils.StoreData($element[0], "old-tabindex", tabindex);
                $element.attr("tabindex", "-1");
                var DataAdapter = this.options.get("dataAdapter");
                this.dataAdapter = new DataAdapter($element, this.options);
                var $container = this.render();
                this._placeContainer($container);
                var SelectionAdapter = this.options.get("selectionAdapter");
                this.selection = new SelectionAdapter($element, this.options);
                this.$selection = this.selection.render();
                this.selection.position(this.$selection, $container);
                var DropdownAdapter = this.options.get("dropdownAdapter");
                this.dropdown = new DropdownAdapter($element, this.options);
                this.$dropdown = this.dropdown.render();
                this.dropdown.position(this.$dropdown, $container);
                var ResultsAdapter = this.options.get("resultsAdapter");
                this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
                this.$results = this.results.render();
                this.results.position(this.$results, this.$dropdown);
                var self = this;
                this._bindAdapters();
                this._registerDomEvents();
                this._registerDataEvents();
                this._registerSelectionEvents();
                this._registerDropdownEvents();
                this._registerResultsEvents();
                this._registerEvents();
                this.dataAdapter.current(function(initialData) {
                    self.trigger("selection:update", {
                        data: initialData
                    });
                });
                $element.addClass("select2-hidden-accessible");
                $element.attr("aria-hidden", "true");
                this._syncAttributes();
                Utils.StoreData($element[0], "select2", this);
                $element.data("select2", this);
            };
            Utils.Extend(Select2, Utils.Observable);
            Select2.prototype._generateId = function($element) {
                var id = "";
                if ($element.attr("id") != null) {
                    id = $element.attr("id");
                } else if ($element.attr("name") != null) {
                    id = $element.attr("name") + "-" + Utils.generateChars(2);
                } else {
                    id = Utils.generateChars(4);
                }
                id = id.replace(/(:|\.|\[|\]|,)/g, "");
                id = "select2-" + id;
                return id;
            };
            Select2.prototype._placeContainer = function($container) {
                $container.insertAfter(this.$element);
                var width = this._resolveWidth(this.$element, this.options.get("width"));
                if (width != null) {
                    $container.css("width", width);
                }
            };
            Select2.prototype._resolveWidth = function($element, method) {
                var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;
                if (method == "resolve") {
                    var styleWidth = this._resolveWidth($element, "style");
                    if (styleWidth != null) {
                        return styleWidth;
                    }
                    return this._resolveWidth($element, "element");
                }
                if (method == "element") {
                    var elementWidth = $element.outerWidth(false);
                    if (elementWidth <= 0) {
                        return "auto";
                    }
                    return elementWidth + "px";
                }
                if (method == "style") {
                    var style = $element.attr("style");
                    if (typeof style !== "string") {
                        return null;
                    }
                    var attrs = style.split(";");
                    for (var i = 0, l = attrs.length; i < l; i = i + 1) {
                        var attr = attrs[i].replace(/\s/g, "");
                        var matches = attr.match(WIDTH);
                        if (matches !== null && matches.length >= 1) {
                            return matches[1];
                        }
                    }
                    return null;
                }
                if (method == "computedstyle") {
                    var computedStyle = window.getComputedStyle($element[0]);
                    return computedStyle.width;
                }
                return method;
            };
            Select2.prototype._bindAdapters = function() {
                this.dataAdapter.bind(this, this.$container);
                this.selection.bind(this, this.$container);
                this.dropdown.bind(this, this.$container);
                this.results.bind(this, this.$container);
            };
            Select2.prototype._registerDomEvents = function() {
                var self = this;
                this.$element.on("change.select2", function() {
                    self.dataAdapter.current(function(data) {
                        self.trigger("selection:update", {
                            data: data
                        });
                    });
                });
                this.$element.on("focus.select2", function(evt) {
                    self.trigger("focus", evt);
                });
                this._syncA = Utils.bind(this._syncAttributes, this);
                this._syncS = Utils.bind(this._syncSubtree, this);
                if (this.$element[0].attachEvent) {
                    this.$element[0].attachEvent("onpropertychange", this._syncA);
                }
                var observer = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
                if (observer != null) {
                    this._observer = new observer(function(mutations) {
                        $.each(mutations, self._syncA);
                        $.each(mutations, self._syncS);
                    });
                    this._observer.observe(this.$element[0], {
                        attributes: true,
                        childList: true,
                        subtree: false
                    });
                } else if (this.$element[0].addEventListener) {
                    this.$element[0].addEventListener("DOMAttrModified", self._syncA, false);
                    this.$element[0].addEventListener("DOMNodeInserted", self._syncS, false);
                    this.$element[0].addEventListener("DOMNodeRemoved", self._syncS, false);
                }
            };
            Select2.prototype._registerDataEvents = function() {
                var self = this;
                this.dataAdapter.on("*", function(name, params) {
                    self.trigger(name, params);
                });
            };
            Select2.prototype._registerSelectionEvents = function() {
                var self = this;
                var nonRelayEvents = [ "toggle", "focus" ];
                this.selection.on("toggle", function() {
                    self.toggleDropdown();
                });
                this.selection.on("focus", function(params) {
                    self.focus(params);
                });
                this.selection.on("*", function(name, params) {
                    if ($.inArray(name, nonRelayEvents) !== -1) {
                        return;
                    }
                    self.trigger(name, params);
                });
            };
            Select2.prototype._registerDropdownEvents = function() {
                var self = this;
                this.dropdown.on("*", function(name, params) {
                    self.trigger(name, params);
                });
            };
            Select2.prototype._registerResultsEvents = function() {
                var self = this;
                this.results.on("*", function(name, params) {
                    self.trigger(name, params);
                });
            };
            Select2.prototype._registerEvents = function() {
                var self = this;
                this.on("open", function() {
                    self.$container.addClass("select2-container--open");
                });
                this.on("close", function() {
                    self.$container.removeClass("select2-container--open");
                });
                this.on("enable", function() {
                    self.$container.removeClass("select2-container--disabled");
                });
                this.on("disable", function() {
                    self.$container.addClass("select2-container--disabled");
                });
                this.on("blur", function() {
                    self.$container.removeClass("select2-container--focus");
                });
                this.on("query", function(params) {
                    if (!self.isOpen()) {
                        self.trigger("open", {});
                    }
                    this.dataAdapter.query(params, function(data) {
                        self.trigger("results:all", {
                            data: data,
                            query: params
                        });
                    });
                });
                this.on("query:append", function(params) {
                    this.dataAdapter.query(params, function(data) {
                        self.trigger("results:append", {
                            data: data,
                            query: params
                        });
                    });
                });
                this.on("keypress", function(evt) {
                    var key = evt.which;
                    if (self.isOpen()) {
                        if (key === KEYS.ESC || key === KEYS.TAB || key === KEYS.UP && evt.altKey) {
                            self.close();
                            evt.preventDefault();
                        } else if (key === KEYS.ENTER) {
                            self.trigger("results:select", {});
                            evt.preventDefault();
                        } else if (key === KEYS.SPACE && evt.ctrlKey) {
                            self.trigger("results:toggle", {});
                            evt.preventDefault();
                        } else if (key === KEYS.UP) {
                            self.trigger("results:previous", {});
                            evt.preventDefault();
                        } else if (key === KEYS.DOWN) {
                            self.trigger("results:next", {});
                            evt.preventDefault();
                        }
                    } else {
                        if (key === KEYS.ENTER || key === KEYS.SPACE || key === KEYS.DOWN && evt.altKey) {
                            self.open();
                            evt.preventDefault();
                        }
                    }
                });
            };
            Select2.prototype._syncAttributes = function() {
                this.options.set("disabled", this.$element.prop("disabled"));
                if (this.options.get("disabled")) {
                    if (this.isOpen()) {
                        this.close();
                    }
                    this.trigger("disable", {});
                } else {
                    this.trigger("enable", {});
                }
            };
            Select2.prototype._syncSubtree = function(evt, mutations) {
                var changed = false;
                var self = this;
                if (evt && evt.target && (evt.target.nodeName !== "OPTION" && evt.target.nodeName !== "OPTGROUP")) {
                    return;
                }
                if (!mutations) {
                    changed = true;
                } else if (mutations.addedNodes && mutations.addedNodes.length > 0) {
                    for (var n = 0; n < mutations.addedNodes.length; n++) {
                        var node = mutations.addedNodes[n];
                        if (node.selected) {
                            changed = true;
                        }
                    }
                } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
                    changed = true;
                }
                if (changed) {
                    this.dataAdapter.current(function(currentData) {
                        self.trigger("selection:update", {
                            data: currentData
                        });
                    });
                }
            };
            Select2.prototype.trigger = function(name, args) {
                var actualTrigger = Select2.__super__.trigger;
                var preTriggerMap = {
                    open: "opening",
                    close: "closing",
                    select: "selecting",
                    unselect: "unselecting",
                    clear: "clearing"
                };
                if (args === undefined) {
                    args = {};
                }
                if (name in preTriggerMap) {
                    var preTriggerName = preTriggerMap[name];
                    var preTriggerArgs = {
                        prevented: false,
                        name: name,
                        args: args
                    };
                    actualTrigger.call(this, preTriggerName, preTriggerArgs);
                    if (preTriggerArgs.prevented) {
                        args.prevented = true;
                        return;
                    }
                }
                actualTrigger.call(this, name, args);
            };
            Select2.prototype.toggleDropdown = function() {
                if (this.options.get("disabled")) {
                    return;
                }
                if (this.isOpen()) {
                    this.close();
                } else {
                    this.open();
                }
            };
            Select2.prototype.open = function() {
                if (this.isOpen()) {
                    return;
                }
                this.trigger("query", {});
            };
            Select2.prototype.close = function() {
                if (!this.isOpen()) {
                    return;
                }
                this.trigger("close", {});
            };
            Select2.prototype.isOpen = function() {
                return this.$container.hasClass("select2-container--open");
            };
            Select2.prototype.hasFocus = function() {
                return this.$container.hasClass("select2-container--focus");
            };
            Select2.prototype.focus = function(data) {
                if (this.hasFocus()) {
                    return;
                }
                this.$container.addClass("select2-container--focus");
                this.trigger("focus", {});
            };
            Select2.prototype.enable = function(args) {
                if (this.options.get("debug") && window.console && console.warn) {
                    console.warn('Select2: The `select2("enable")` method has been deprecated and will' + ' be removed in later Select2 versions. Use $element.prop("disabled")' + " instead.");
                }
                if (args == null || args.length === 0) {
                    args = [ true ];
                }
                var disabled = !args[0];
                this.$element.prop("disabled", disabled);
            };
            Select2.prototype.data = function() {
                if (this.options.get("debug") && arguments.length > 0 && window.console && console.warn) {
                    console.warn('Select2: Data can no longer be set using `select2("data")`. You ' + "should consider setting the value instead using `$element.val()`.");
                }
                var data = [];
                this.dataAdapter.current(function(currentData) {
                    data = currentData;
                });
                return data;
            };
            Select2.prototype.val = function(args) {
                if (this.options.get("debug") && window.console && console.warn) {
                    console.warn('Select2: The `select2("val")` method has been deprecated and will be' + " removed in later Select2 versions. Use $element.val() instead.");
                }
                if (args == null || args.length === 0) {
                    return this.$element.val();
                }
                var newVal = args[0];
                if ($.isArray(newVal)) {
                    newVal = $.map(newVal, function(obj) {
                        return obj.toString();
                    });
                }
                this.$element.val(newVal).trigger("change");
            };
            Select2.prototype.destroy = function() {
                this.$container.remove();
                if (this.$element[0].detachEvent) {
                    this.$element[0].detachEvent("onpropertychange", this._syncA);
                }
                if (this._observer != null) {
                    this._observer.disconnect();
                    this._observer = null;
                } else if (this.$element[0].removeEventListener) {
                    this.$element[0].removeEventListener("DOMAttrModified", this._syncA, false);
                    this.$element[0].removeEventListener("DOMNodeInserted", this._syncS, false);
                    this.$element[0].removeEventListener("DOMNodeRemoved", this._syncS, false);
                }
                this._syncA = null;
                this._syncS = null;
                this.$element.off(".select2");
                this.$element.attr("tabindex", Utils.GetData(this.$element[0], "old-tabindex"));
                this.$element.removeClass("select2-hidden-accessible");
                this.$element.attr("aria-hidden", "false");
                Utils.RemoveData(this.$element[0]);
                this.$element.removeData("select2");
                this.dataAdapter.destroy();
                this.selection.destroy();
                this.dropdown.destroy();
                this.results.destroy();
                this.dataAdapter = null;
                this.selection = null;
                this.dropdown = null;
                this.results = null;
            };
            Select2.prototype.render = function() {
                var $container = $('<span class="select2 select2-container">' + '<span class="selection"></span>' + '<span class="dropdown-wrapper" aria-hidden="true"></span>' + "</span>");
                $container.attr("dir", this.options.get("dir"));
                this.$container = $container;
                this.$container.addClass("select2-container--" + this.options.get("theme"));
                Utils.StoreData($container[0], "element", this.$element);
                return $container;
            };
            return Select2;
        });
        S2.define("jquery-mousewheel", [ "jquery" ], function($) {
            return $;
        });
        S2.define("jquery.select2", [ "jquery", "jquery-mousewheel", "./select2/core", "./select2/defaults", "./select2/utils" ], function($, _, Select2, Defaults, Utils) {
            if ($.fn.select2 == null) {
                var thisMethods = [ "open", "close", "destroy" ];
                $.fn.select2 = function(options) {
                    options = options || {};
                    if (typeof options === "object") {
                        this.each(function() {
                            var instanceOptions = $.extend(true, {}, options);
                            var instance = new Select2($(this), instanceOptions);
                        });
                        return this;
                    } else if (typeof options === "string") {
                        var ret;
                        var args = Array.prototype.slice.call(arguments, 1);
                        this.each(function() {
                            var instance = Utils.GetData(this, "select2");
                            if (instance == null && window.console && console.error) {
                                console.error("The select2('" + options + "') method was called on an " + "element that is not using Select2.");
                            }
                            ret = instance[options].apply(instance, args);
                        });
                        if ($.inArray(options, thisMethods) > -1) {
                            return this;
                        }
                        return ret;
                    } else {
                        throw new Error("Invalid arguments for Select2: " + options);
                    }
                };
            }
            if ($.fn.select2.defaults == null) {
                $.fn.select2.defaults = Defaults;
            }
            return Select2;
        });
        return {
            define: S2.define,
            require: S2.require
        };
    }();
    var select2 = S2.require("jquery.select2");
    jQuery.fn.select2.amd = S2;
    return select2;
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    var pluses = /\+/g;
    function encode(s) {
        return config.raw ? s : encodeURIComponent(s);
    }
    function decode(s) {
        return config.raw ? s : decodeURIComponent(s);
    }
    function stringifyCookieValue(value) {
        return encode(config.json ? JSON.stringify(value) : String(value));
    }
    function parseCookieValue(s) {
        if (s.indexOf('"') === 0) {
            s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, "\\");
        }
        try {
            s = decodeURIComponent(s.replace(pluses, " "));
            return config.json ? JSON.parse(s) : s;
        } catch (e) {}
    }
    function read(s, converter) {
        var value = config.raw ? s : parseCookieValue(s);
        return $.isFunction(converter) ? converter(value) : value;
    }
    var config = $.cookie = function(key, value, options) {
        if (value !== undefined && !$.isFunction(value)) {
            options = $.extend({}, config.defaults, options);
            if (typeof options.expires === "number") {
                var days = options.expires, t = options.expires = new Date();
                t.setTime(+t + days * 864e5);
            }
            return document.cookie = [ encode(key), "=", stringifyCookieValue(value), options.expires ? "; expires=" + options.expires.toUTCString() : "", options.path ? "; path=" + options.path : "", options.domain ? "; domain=" + options.domain : "", options.secure ? "; secure" : "" ].join("");
        }
        var result = key ? undefined : {};
        var cookies = document.cookie ? document.cookie.split("; ") : [];
        for (var i = 0, l = cookies.length; i < l; i++) {
            var parts = cookies[i].split("=");
            var name = decode(parts.shift());
            var cookie = parts.join("=");
            if (key && key === name) {
                result = read(cookie, value);
                break;
            }
            if (!key && (cookie = read(cookie)) !== undefined) {
                result[name] = cookie;
            }
        }
        return result;
    };
    config.defaults = {};
    $.removeCookie = function(key, options) {
        if ($.cookie(key) === undefined) {
            return false;
        }
        $.cookie(key, "", $.extend({}, options, {
            expires: -1
        }));
        return !$.cookie(key);
    };
});

(function(wind, $, undef) {
    "use strict";
    function attrOrProp($el) {
        var args = Array.prototype.slice.call(arguments, 1);
        if ($el.prop) {
            return $el.prop.apply($el, args);
        }
        return $el.attr.apply($el, args);
    }
    function bindMany($el, options, events) {
        var name, namespaced;
        for (name in events) {
            if (events.hasOwnProperty(name)) {
                namespaced = name.replace(/ |$/g, options.eventNamespace);
                $el.bind(namespaced, events[name]);
            }
        }
    }
    function bindUi($el, $target, options) {
        bindMany($el, options, {
            focus: function() {
                $target.addClass(options.focusClass);
            },
            blur: function() {
                $target.removeClass(options.focusClass);
                $target.removeClass(options.activeClass);
            },
            mouseenter: function() {
                $target.addClass(options.hoverClass);
            },
            mouseleave: function() {
                $target.removeClass(options.hoverClass);
                $target.removeClass(options.activeClass);
            },
            "mousedown touchbegin": function() {
                if (!$el.is(":disabled")) {
                    $target.addClass(options.activeClass);
                }
            },
            "mouseup touchend": function() {
                $target.removeClass(options.activeClass);
            }
        });
    }
    function classClearStandard($el, options) {
        $el.removeClass(options.hoverClass + " " + options.focusClass + " " + options.activeClass);
    }
    function classUpdate($el, className, enabled) {
        if (enabled) {
            $el.addClass(className);
        } else {
            $el.removeClass(className);
        }
    }
    function classUpdateChecked($tag, $el, options) {
        var c = "checked", isChecked = $el.is(":" + c);
        if ($el.prop) {
            $el.prop(c, isChecked);
        } else {
            if (isChecked) {
                $el.attr(c, c);
            } else {
                $el.removeAttr(c);
            }
        }
        classUpdate($tag, options.checkedClass, isChecked);
    }
    function classUpdateDisabled($tag, $el, options) {
        classUpdate($tag, options.disabledClass, $el.is(":disabled"));
    }
    function divSpanWrap($el, $container, method) {
        switch (method) {
          case "after":
            $el.after($container);
            return $el.next();

          case "before":
            $el.before($container);
            return $el.prev();

          case "wrap":
            $el.wrap($container);
            return $el.parent();
        }
        return null;
    }
    function divSpan($el, options, divSpanConfig) {
        var $div, $span, id;
        if (!divSpanConfig) {
            divSpanConfig = {};
        }
        divSpanConfig = $.extend({
            bind: {},
            divClass: null,
            divWrap: "wrap",
            spanClass: null,
            spanHtml: null,
            spanWrap: "wrap"
        }, divSpanConfig);
        $div = $("<div />");
        $span = $("<span />");
        if (options.autoHide && $el.is(":hidden") && $el.css("display") === "none") {
            $div.hide();
        }
        if (divSpanConfig.divClass) {
            $div.addClass(divSpanConfig.divClass);
        }
        if (options.wrapperClass) {
            $div.addClass(options.wrapperClass);
        }
        if (divSpanConfig.spanClass) {
            $span.addClass(divSpanConfig.spanClass);
        }
        id = attrOrProp($el, "id");
        if (options.useID && id) {
            attrOrProp($div, "id", options.idPrefix + "-" + id);
        }
        if (divSpanConfig.spanHtml) {
            $span.html(divSpanConfig.spanHtml);
        }
        $div = divSpanWrap($el, $div, divSpanConfig.divWrap);
        $span = divSpanWrap($el, $span, divSpanConfig.spanWrap);
        classUpdateDisabled($div, $el, options);
        return {
            div: $div,
            span: $span
        };
    }
    function wrapWithWrapperClass($el, options) {
        var $span;
        if (!options.wrapperClass) {
            return null;
        }
        $span = $("<span />").addClass(options.wrapperClass);
        $span = divSpanWrap($el, $span, "wrap");
        return $span;
    }
    function highContrast() {
        var c, $div, el, rgb;
        rgb = "rgb(120,2,153)";
        $div = $('<div style="width:0;height:0;color:' + rgb + '">');
        $("body").append($div);
        el = $div.get(0);
        if (wind.getComputedStyle) {
            c = wind.getComputedStyle(el, "").color;
        } else {
            c = (el.currentStyle || el.style || {}).color;
        }
        $div.remove();
        return c.replace(/ /g, "") !== rgb;
    }
    function htmlify(text) {
        if (!text) {
            return "";
        }
        return $("<span />").text(text).html();
    }
    function isMsie() {
        return navigator.cpuClass && !navigator.product;
    }
    function isMsieSevenOrNewer() {
        if (wind.XMLHttpRequest !== undefined) {
            return true;
        }
        return false;
    }
    function isMultiselect($el) {
        var elSize;
        if ($el[0].multiple) {
            return true;
        }
        elSize = attrOrProp($el, "size");
        if (!elSize || elSize <= 1) {
            return false;
        }
        return true;
    }
    function returnFalse() {
        return false;
    }
    function noSelect($elem, options) {
        var none = "none";
        bindMany($elem, options, {
            "selectstart dragstart mousedown": returnFalse
        });
        $elem.css({
            MozUserSelect: none,
            msUserSelect: none,
            webkitUserSelect: none,
            userSelect: none
        });
    }
    function setFilename($el, $filenameTag, options) {
        var filename = $el.val();
        if (filename === "") {
            filename = options.fileDefaultHtml;
        } else {
            filename = filename.split(/[\/\\]+/);
            filename = filename[filename.length - 1];
        }
        $filenameTag.text(filename);
    }
    function swap($elements, newCss, callback) {
        var restore, item;
        restore = [];
        $elements.each(function() {
            var name;
            for (name in newCss) {
                if (Object.prototype.hasOwnProperty.call(newCss, name)) {
                    restore.push({
                        el: this,
                        name: name,
                        old: this.style[name]
                    });
                    this.style[name] = newCss[name];
                }
            }
        });
        callback();
        while (restore.length) {
            item = restore.pop();
            item.el.style[item.name] = item.old;
        }
    }
    function sizingInvisible($el, callback) {
        var targets;
        targets = $el.parents();
        targets.push($el[0]);
        targets = targets.not(":visible");
        swap(targets, {
            visibility: "hidden",
            display: "block",
            position: "absolute"
        }, callback);
    }
    function unwrapUnwrapUnbindFunction($el, options) {
        return function() {
            $el.unwrap().unwrap().unbind(options.eventNamespace);
        };
    }
    var allowStyling = true, highContrastTest = false, uniformHandlers = [ {
        match: function($el) {
            return $el.is("a, button, :submit, :reset, input[type='button']");
        },
        apply: function($el, options) {
            var $div, defaultSpanHtml, ds, getHtml, doingClickEvent;
            defaultSpanHtml = options.submitDefaultHtml;
            if ($el.is(":reset")) {
                defaultSpanHtml = options.resetDefaultHtml;
            }
            if ($el.is("a, button")) {
                getHtml = function() {
                    return $el.html() || defaultSpanHtml;
                };
            } else {
                getHtml = function() {
                    return htmlify(attrOrProp($el, "value")) || defaultSpanHtml;
                };
            }
            ds = divSpan($el, options, {
                divClass: options.buttonClass,
                spanHtml: getHtml()
            });
            $div = ds.div;
            bindUi($el, $div, options);
            doingClickEvent = false;
            bindMany($div, options, {
                "click touchend": function() {
                    var ev, res, target, href;
                    if (doingClickEvent) {
                        return;
                    }
                    if ($el.is(":disabled")) {
                        return;
                    }
                    doingClickEvent = true;
                    if ($el[0].dispatchEvent) {
                        ev = document.createEvent("MouseEvents");
                        ev.initEvent("click", true, true);
                        res = $el[0].dispatchEvent(ev);
                        if ($el.is("a") && res) {
                            target = attrOrProp($el, "target");
                            href = attrOrProp($el, "href");
                            if (!target || target === "_self") {
                                document.location.href = href;
                            } else {
                                wind.open(href, target);
                            }
                        }
                    } else {
                        $el.click();
                    }
                    doingClickEvent = false;
                }
            });
            noSelect($div, options);
            return {
                remove: function() {
                    $div.after($el);
                    $div.remove();
                    $el.unbind(options.eventNamespace);
                    return $el;
                },
                update: function() {
                    classClearStandard($div, options);
                    classUpdateDisabled($div, $el, options);
                    $el.detach();
                    ds.span.html(getHtml()).append($el);
                }
            };
        }
    }, {
        match: function($el) {
            return $el.is(":checkbox");
        },
        apply: function($el, options) {
            var ds, $div, $span;
            ds = divSpan($el, options, {
                divClass: options.checkboxClass
            });
            $div = ds.div;
            $span = ds.span;
            bindUi($el, $div, options);
            bindMany($el, options, {
                "click touchend": function() {
                    classUpdateChecked($span, $el, options);
                }
            });
            classUpdateChecked($span, $el, options);
            return {
                remove: unwrapUnwrapUnbindFunction($el, options),
                update: function() {
                    classClearStandard($div, options);
                    $span.removeClass(options.checkedClass);
                    classUpdateChecked($span, $el, options);
                    classUpdateDisabled($div, $el, options);
                }
            };
        }
    }, {
        match: function($el) {
            return $el.is(":file");
        },
        apply: function($el, options) {
            var ds, $div, $filename, $button;
            ds = divSpan($el, options, {
                divClass: options.fileClass,
                spanClass: options.fileButtonClass,
                spanHtml: options.fileButtonHtml,
                spanWrap: "after"
            });
            $div = ds.div;
            $button = ds.span;
            $filename = $("<span />").html(options.fileDefaultHtml);
            $filename.addClass(options.filenameClass);
            $filename = divSpanWrap($el, $filename, "after");
            if (!attrOrProp($el, "size")) {
                attrOrProp($el, "size", $div.width() / 10);
            }
            function filenameUpdate() {
                setFilename($el, $filename, options);
            }
            bindUi($el, $div, options);
            filenameUpdate();
            if (isMsie()) {
                bindMany($el, options, {
                    click: function() {
                        $el.trigger("change");
                        setTimeout(filenameUpdate, 0);
                    }
                });
            } else {
                bindMany($el, options, {
                    change: filenameUpdate
                });
            }
            noSelect($filename, options);
            noSelect($button, options);
            return {
                remove: function() {
                    $filename.remove();
                    $button.remove();
                    return $el.unwrap().unbind(options.eventNamespace);
                },
                update: function() {
                    classClearStandard($div, options);
                    setFilename($el, $filename, options);
                    classUpdateDisabled($div, $el, options);
                }
            };
        }
    }, {
        match: function($el) {
            if ($el.is("input")) {
                var t = (" " + attrOrProp($el, "type") + " ").toLowerCase(), allowed = " color date datetime datetime-local email month number password search tel text time url week ";
                return allowed.indexOf(t) >= 0;
            }
            return false;
        },
        apply: function($el, options) {
            var elType, $wrapper;
            elType = attrOrProp($el, "type");
            $el.addClass(options.inputClass);
            $wrapper = wrapWithWrapperClass($el, options);
            bindUi($el, $el, options);
            if (options.inputAddTypeAsClass) {
                $el.addClass(elType);
            }
            return {
                remove: function() {
                    $el.removeClass(options.inputClass);
                    if (options.inputAddTypeAsClass) {
                        $el.removeClass(elType);
                    }
                    if ($wrapper) {
                        $el.unwrap();
                    }
                },
                update: returnFalse
            };
        }
    }, {
        match: function($el) {
            return $el.is(":radio");
        },
        apply: function($el, options) {
            var ds, $div, $span;
            ds = divSpan($el, options, {
                divClass: options.radioClass
            });
            $div = ds.div;
            $span = ds.span;
            bindUi($el, $div, options);
            bindMany($el, options, {
                "click touchend": function() {
                    $.uniform.update($(':radio[name="' + attrOrProp($el, "name") + '"]'));
                }
            });
            classUpdateChecked($span, $el, options);
            return {
                remove: unwrapUnwrapUnbindFunction($el, options),
                update: function() {
                    classClearStandard($div, options);
                    classUpdateChecked($span, $el, options);
                    classUpdateDisabled($div, $el, options);
                }
            };
        }
    }, {
        match: function($el) {
            if ($el.is("select") && !isMultiselect($el)) {
                return true;
            }
            return false;
        },
        apply: function($el, options) {
            var ds, $div, $span, origElemWidth;
            if (options.selectAutoWidth) {
                sizingInvisible($el, function() {
                    origElemWidth = $el.width();
                });
            }
            ds = divSpan($el, options, {
                divClass: options.selectClass,
                spanHtml: ($el.find(":selected:first") || $el.find("option:first")).html(),
                spanWrap: "before"
            });
            $div = ds.div;
            $span = ds.span;
            if (options.selectAutoWidth) {
                sizingInvisible($el, function() {
                    swap($([ $span[0], $div[0] ]), {
                        display: "block"
                    }, function() {
                        var spanPad;
                        spanPad = $span.outerWidth() - $span.width();
                        $div.width(origElemWidth + spanPad);
                        $span.width(origElemWidth);
                    });
                });
            } else {
                $div.addClass("fixedWidth");
            }
            bindUi($el, $div, options);
            bindMany($el, options, {
                change: function() {
                    $span.html($el.find(":selected").html());
                    $div.removeClass(options.activeClass);
                },
                "click touchend": function() {
                    var selHtml = $el.find(":selected").html();
                    if ($span.html() !== selHtml) {
                        $el.trigger("change");
                    }
                },
                keyup: function() {
                    $span.html($el.find(":selected").html());
                }
            });
            noSelect($span, options);
            return {
                remove: function() {
                    $span.remove();
                    $el.unwrap().unbind(options.eventNamespace);
                    return $el;
                },
                update: function() {
                    if (options.selectAutoWidth) {
                        $.uniform.restore($el);
                        $el.uniform(options);
                    } else {
                        classClearStandard($div, options);
                        $el[0].selectedIndex = $el[0].selectedIndex;
                        $span.html($el.find(":selected").html());
                        classUpdateDisabled($div, $el, options);
                    }
                }
            };
        }
    }, {
        match: function($el) {
            if ($el.is("select") && isMultiselect($el)) {
                return true;
            }
            return false;
        },
        apply: function($el, options) {
            var $wrapper;
            $el.addClass(options.selectMultiClass);
            $wrapper = wrapWithWrapperClass($el, options);
            bindUi($el, $el, options);
            return {
                remove: function() {
                    $el.removeClass(options.selectMultiClass);
                    if ($wrapper) {
                        $el.unwrap();
                    }
                },
                update: returnFalse
            };
        }
    }, {
        match: function($el) {
            return $el.is("textarea");
        },
        apply: function($el, options) {
            var $wrapper;
            $el.addClass(options.textareaClass);
            $wrapper = wrapWithWrapperClass($el, options);
            bindUi($el, $el, options);
            return {
                remove: function() {
                    $el.removeClass(options.textareaClass);
                    if ($wrapper) {
                        $el.unwrap();
                    }
                },
                update: returnFalse
            };
        }
    } ];
    if (isMsie() && !isMsieSevenOrNewer()) {
        allowStyling = false;
    }
    $.uniform = {
        defaults: {
            activeClass: "active",
            autoHide: true,
            buttonClass: "button",
            checkboxClass: "checker",
            checkedClass: "checked",
            disabledClass: "disabled",
            eventNamespace: ".uniform",
            fileButtonClass: "action",
            fileButtonHtml: "Choose File",
            fileClass: "uploader",
            fileDefaultHtml: "No file selected",
            filenameClass: "filename",
            focusClass: "focus",
            hoverClass: "hover",
            idPrefix: "uniform",
            inputAddTypeAsClass: true,
            inputClass: "uniform-input",
            radioClass: "radio",
            resetDefaultHtml: "Reset",
            resetSelector: false,
            selectAutoWidth: true,
            selectClass: "selector",
            selectMultiClass: "uniform-multiselect",
            submitDefaultHtml: "Submit",
            textareaClass: "uniform",
            useID: true,
            wrapperClass: null
        },
        elements: []
    };
    $.fn.uniform = function(options) {
        var el = this;
        options = $.extend({}, $.uniform.defaults, options);
        if (!highContrastTest) {
            highContrastTest = true;
            if (highContrast()) {
                allowStyling = false;
            }
        }
        if (!allowStyling) {
            return this;
        }
        if (options.resetSelector) {
            $(options.resetSelector).mouseup(function() {
                wind.setTimeout(function() {
                    $.uniform.update(el);
                }, 10);
            });
        }
        return this.each(function() {
            var $el = $(this), i, handler, callbacks;
            if ($el.data("uniformed")) {
                $.uniform.update($el);
                return;
            }
            for (i = 0; i < uniformHandlers.length; i = i + 1) {
                handler = uniformHandlers[i];
                if (handler.match($el, options)) {
                    callbacks = handler.apply($el, options);
                    $el.data("uniformed", callbacks);
                    $.uniform.elements.push($el.get(0));
                    return;
                }
            }
        });
    };
    $.uniform.restore = $.fn.uniform.restore = function(elem) {
        if (elem === undef) {
            elem = $.uniform.elements;
        }
        $(elem).each(function() {
            var $el = $(this), index, elementData;
            elementData = $el.data("uniformed");
            if (!elementData) {
                return;
            }
            elementData.remove();
            index = $.inArray(this, $.uniform.elements);
            if (index >= 0) {
                $.uniform.elements.splice(index, 1);
            }
            $el.removeData("uniformed");
        });
    };
    $.uniform.update = $.fn.uniform.update = function(elem) {
        if (elem === undef) {
            elem = $.uniform.elements;
        }
        $(elem).each(function() {
            var $el = $(this), elementData;
            elementData = $el.data("uniformed");
            if (!elementData) {
                return;
            }
            elementData.update($el, elementData.options);
        });
    };
})(this, jQuery);

(function(define) {
    define([ "jquery" ], function($) {
        return function() {
            var $container;
            var listener;
            var toastId = 0;
            var toastType = {
                error: "error",
                info: "info",
                success: "success",
                warning: "warning"
            };
            var toastr = {
                clear: clear,
                remove: remove,
                error: error,
                getContainer: getContainer,
                info: info,
                options: {},
                subscribe: subscribe,
                success: success,
                version: "2.1.3",
                warning: warning
            };
            var previousToast;
            return toastr;
            function error(message, title, optionsOverride) {
                return notify({
                    type: toastType.error,
                    iconClass: getOptions().iconClasses.error,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }
            function getContainer(options, create) {
                if (!options) {
                    options = getOptions();
                }
                $container = $("#" + options.containerId);
                if ($container.length) {
                    return $container;
                }
                if (create) {
                    $container = createContainer(options);
                }
                return $container;
            }
            function info(message, title, optionsOverride) {
                return notify({
                    type: toastType.info,
                    iconClass: getOptions().iconClasses.info,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }
            function subscribe(callback) {
                listener = callback;
            }
            function success(message, title, optionsOverride) {
                return notify({
                    type: toastType.success,
                    iconClass: getOptions().iconClasses.success,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }
            function warning(message, title, optionsOverride) {
                return notify({
                    type: toastType.warning,
                    iconClass: getOptions().iconClasses.warning,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }
            function clear($toastElement, clearOptions) {
                var options = getOptions();
                if (!$container) {
                    getContainer(options);
                }
                if (!clearToast($toastElement, options, clearOptions)) {
                    clearContainer(options);
                }
            }
            function remove($toastElement) {
                var options = getOptions();
                if (!$container) {
                    getContainer(options);
                }
                if ($toastElement && $(":focus", $toastElement).length === 0) {
                    removeToast($toastElement);
                    return;
                }
                if ($container.children().length) {
                    $container.remove();
                }
            }
            function clearContainer(options) {
                var toastsToClear = $container.children();
                for (var i = toastsToClear.length - 1; i >= 0; i--) {
                    clearToast($(toastsToClear[i]), options);
                }
            }
            function clearToast($toastElement, options, clearOptions) {
                var force = clearOptions && clearOptions.force ? clearOptions.force : false;
                if ($toastElement && (force || $(":focus", $toastElement).length === 0)) {
                    $toastElement[options.hideMethod]({
                        duration: options.hideDuration,
                        easing: options.hideEasing,
                        complete: function() {
                            removeToast($toastElement);
                        }
                    });
                    return true;
                }
                return false;
            }
            function createContainer(options) {
                $container = $("<div/>").attr("id", options.containerId).addClass(options.positionClass);
                $container.appendTo($(options.target));
                return $container;
            }
            function getDefaults() {
                return {
                    tapToDismiss: true,
                    toastClass: "toast",
                    containerId: "toast-container",
                    debug: false,
                    showMethod: "fadeIn",
                    showDuration: 300,
                    showEasing: "swing",
                    onShown: undefined,
                    hideMethod: "fadeOut",
                    hideDuration: 1e3,
                    hideEasing: "swing",
                    onHidden: undefined,
                    closeMethod: false,
                    closeDuration: false,
                    closeEasing: false,
                    closeOnHover: true,
                    extendedTimeOut: 1e3,
                    iconClasses: {
                        error: "toast-error",
                        info: "toast-info",
                        success: "toast-success",
                        warning: "toast-warning"
                    },
                    iconClass: "toast-info",
                    positionClass: "toast-top-right",
                    timeOut: 5e3,
                    titleClass: "toast-title",
                    messageClass: "toast-message",
                    escapeHtml: false,
                    target: "body",
                    closeHtml: '<button type="button">&times;</button>',
                    closeClass: "toast-close-button",
                    newestOnTop: true,
                    preventDuplicates: false,
                    progressBar: false,
                    progressClass: "toast-progress",
                    rtl: false
                };
            }
            function publish(args) {
                if (!listener) {
                    return;
                }
                listener(args);
            }
            function notify(map) {
                var options = getOptions();
                var iconClass = map.iconClass || options.iconClass;
                if (typeof map.optionsOverride !== "undefined") {
                    options = $.extend(options, map.optionsOverride);
                    iconClass = map.optionsOverride.iconClass || iconClass;
                }
                if (shouldExit(options, map)) {
                    return;
                }
                toastId++;
                $container = getContainer(options, true);
                var intervalId = null;
                var $toastElement = $("<div/>");
                var $titleElement = $("<div/>");
                var $messageElement = $("<div/>");
                var $progressElement = $("<div/>");
                var $closeElement = $(options.closeHtml);
                var progressBar = {
                    intervalId: null,
                    hideEta: null,
                    maxHideTime: null
                };
                var response = {
                    toastId: toastId,
                    state: "visible",
                    startTime: new Date(),
                    options: options,
                    map: map
                };
                personalizeToast();
                displayToast();
                handleEvents();
                publish(response);
                if (options.debug && console) {
                    console.log(response);
                }
                return $toastElement;
                function escapeHtml(source) {
                    if (source == null) {
                        source = "";
                    }
                    return source.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                }
                function personalizeToast() {
                    setIcon();
                    setTitle();
                    setMessage();
                    setCloseButton();
                    setProgressBar();
                    setRTL();
                    setSequence();
                    setAria();
                }
                function setAria() {
                    var ariaValue = "";
                    switch (map.iconClass) {
                      case "toast-success":
                      case "toast-info":
                        ariaValue = "polite";
                        break;

                      default:
                        ariaValue = "assertive";
                    }
                    $toastElement.attr("aria-live", ariaValue);
                }
                function handleEvents() {
                    if (options.closeOnHover) {
                        $toastElement.hover(stickAround, delayedHideToast);
                    }
                    if (!options.onclick && options.tapToDismiss) {
                        $toastElement.click(hideToast);
                    }
                    if (options.closeButton && $closeElement) {
                        $closeElement.click(function(event) {
                            if (event.stopPropagation) {
                                event.stopPropagation();
                            } else if (event.cancelBubble !== undefined && event.cancelBubble !== true) {
                                event.cancelBubble = true;
                            }
                            if (options.onCloseClick) {
                                options.onCloseClick(event);
                            }
                            hideToast(true);
                        });
                    }
                    if (options.onclick) {
                        $toastElement.click(function(event) {
                            options.onclick(event);
                            hideToast();
                        });
                    }
                }
                function displayToast() {
                    $toastElement.hide();
                    $toastElement[options.showMethod]({
                        duration: options.showDuration,
                        easing: options.showEasing,
                        complete: options.onShown
                    });
                    if (options.timeOut > 0) {
                        intervalId = setTimeout(hideToast, options.timeOut);
                        progressBar.maxHideTime = parseFloat(options.timeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                        if (options.progressBar) {
                            progressBar.intervalId = setInterval(updateProgress, 10);
                        }
                    }
                }
                function setIcon() {
                    if (map.iconClass) {
                        $toastElement.addClass(options.toastClass).addClass(iconClass);
                    }
                }
                function setSequence() {
                    if (options.newestOnTop) {
                        $container.prepend($toastElement);
                    } else {
                        $container.append($toastElement);
                    }
                }
                function setTitle() {
                    if (map.title) {
                        var suffix = map.title;
                        if (options.escapeHtml) {
                            suffix = escapeHtml(map.title);
                        }
                        $titleElement.append(suffix).addClass(options.titleClass);
                        $toastElement.append($titleElement);
                    }
                }
                function setMessage() {
                    if (map.message) {
                        var suffix = map.message;
                        if (options.escapeHtml) {
                            suffix = escapeHtml(map.message);
                        }
                        $messageElement.append(suffix).addClass(options.messageClass);
                        $toastElement.append($messageElement);
                    }
                }
                function setCloseButton() {
                    if (options.closeButton) {
                        $closeElement.addClass(options.closeClass).attr("role", "button");
                        $toastElement.prepend($closeElement);
                    }
                }
                function setProgressBar() {
                    if (options.progressBar) {
                        $progressElement.addClass(options.progressClass);
                        $toastElement.prepend($progressElement);
                    }
                }
                function setRTL() {
                    if (options.rtl) {
                        $toastElement.addClass("rtl");
                    }
                }
                function shouldExit(options, map) {
                    if (options.preventDuplicates) {
                        if (map.message === previousToast) {
                            return true;
                        } else {
                            previousToast = map.message;
                        }
                    }
                    return false;
                }
                function hideToast(override) {
                    var method = override && options.closeMethod !== false ? options.closeMethod : options.hideMethod;
                    var duration = override && options.closeDuration !== false ? options.closeDuration : options.hideDuration;
                    var easing = override && options.closeEasing !== false ? options.closeEasing : options.hideEasing;
                    if ($(":focus", $toastElement).length && !override) {
                        return;
                    }
                    clearTimeout(progressBar.intervalId);
                    return $toastElement[method]({
                        duration: duration,
                        easing: easing,
                        complete: function() {
                            removeToast($toastElement);
                            clearTimeout(intervalId);
                            if (options.onHidden && response.state !== "hidden") {
                                options.onHidden();
                            }
                            response.state = "hidden";
                            response.endTime = new Date();
                            publish(response);
                        }
                    });
                }
                function delayedHideToast() {
                    if (options.timeOut > 0 || options.extendedTimeOut > 0) {
                        intervalId = setTimeout(hideToast, options.extendedTimeOut);
                        progressBar.maxHideTime = parseFloat(options.extendedTimeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                    }
                }
                function stickAround() {
                    clearTimeout(intervalId);
                    progressBar.hideEta = 0;
                    $toastElement.stop(true, true)[options.showMethod]({
                        duration: options.showDuration,
                        easing: options.showEasing
                    });
                }
                function updateProgress() {
                    var percentage = (progressBar.hideEta - new Date().getTime()) / progressBar.maxHideTime * 100;
                    $progressElement.width(percentage + "%");
                }
            }
            function getOptions() {
                return $.extend({}, getDefaults(), toastr.options);
            }
            function removeToast($toastElement) {
                if (!$container) {
                    $container = getContainer();
                }
                if ($toastElement.is(":visible")) {
                    return;
                }
                $toastElement.remove();
                $toastElement = null;
                if ($container.children().length === 0) {
                    $container.remove();
                    previousToast = undefined;
                }
            }
        }();
    });
})(typeof define === "function" && define.amd ? define : function(deps, factory) {
    if (typeof module !== "undefined" && module.exports) {
        module.exports = factory(require("jquery"));
    } else {
        window.toastr = factory(window.jQuery);
    }
});

(function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
})(this, function() {
    "use strict";
    var hookCallback;
    function utils_hooks__hooks() {
        return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
        hookCallback = callback;
    }
    function isArray(input) {
        return Object.prototype.toString.call(input) === "[object Array]";
    }
    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }
    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }
    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }
        if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
        }
        return a;
    }
    function create_utc__createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }
    function defaultParsingFlags() {
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false
        };
    }
    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }
    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated;
            if (m._strict) {
                m._isValid = m._isValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }
    function valid__createInvalid(flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }
        return m;
    }
    var momentProperties = utils_hooks__hooks.momentProperties = [];
    function copyConfig(to, from) {
        var i, prop, val;
        if (typeof from._isAMomentObject !== "undefined") {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== "undefined") {
            to._i = from._i;
        }
        if (typeof from._f !== "undefined") {
            to._f = from._f;
        }
        if (typeof from._l !== "undefined") {
            to._l = from._l;
        }
        if (typeof from._strict !== "undefined") {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== "undefined") {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== "undefined") {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== "undefined") {
            to._offset = from._offset;
        }
        if (typeof from._pf !== "undefined") {
            to._pf = getParsingFlags(from);
        }
        if (typeof from._locale !== "undefined") {
            to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== "undefined") {
                    to[prop] = val;
                }
            }
        }
        return to;
    }
    var updateInProgress = false;
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }
    function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function absFloor(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }
        return value;
    }
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    function Locale() {}
    var locales = {};
    var globalLocale;
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;
        while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join("-"));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }
    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && typeof module !== "undefined" && module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require("./locale/" + name);
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }
    function locale_locales__getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (typeof values === "undefined") {
                data = locale_locales__getLocale(key);
            } else {
                data = defineLocale(key, values);
            }
            if (data) {
                globalLocale = data;
            }
        }
        return globalLocale._abbr;
    }
    function defineLocale(name, values) {
        if (values !== null) {
            values.abbr = name;
            locales[name] = locales[name] || new Locale();
            locales[name].set(values);
            locale_locales__getSetGlobalLocale(name);
            return locales[name];
        } else {
            delete locales[name];
            return null;
        }
    }
    function locale_locales__getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }
        if (!key) {
            return globalLocale;
        }
        if (!isArray(key)) {
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [ key ];
        }
        return chooseLocale(key);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }
        return normalizedInput;
    }
    function makeGetSet(unit, keepTime) {
        return function(value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }
    function get_set__get(mom, unit) {
        return mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]();
    }
    function get_set__set(mom, unit, value) {
        return mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
    function getSet(units, value) {
        var unit;
        if (typeof units === "object") {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (typeof this[units] === "function") {
                return this[units](value);
            }
        }
        return this;
    }
    function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;
        return (sign ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {};
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === "string") {
            func = function() {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function() {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function() {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }
    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
        return function(mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
        return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }
        return format;
    }
    var match1 = /\d/;
    var match2 = /\d\d/;
    var match3 = /\d{3}/;
    var match4 = /\d{4}/;
    var match6 = /[+-]?\d{6}/;
    var match1to2 = /\d\d?/;
    var match1to3 = /\d{1,3}/;
    var match1to4 = /\d{1,4}/;
    var match1to6 = /[+-]?\d{1,6}/;
    var matchUnsigned = /\d+/;
    var matchSigned = /[+-]?\d+/;
    var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
    var regexes = {};
    function isFunction(sth) {
        return typeof sth === "function" && Object.prototype.toString.call(sth) === "[object Function]";
    }
    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function(isStrict) {
            return isStrict && strictRegex ? strictRegex : regex;
        };
    }
    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }
        return regexes[token](config._strict, config._locale);
    }
    function unescapeFormat(s) {
        return s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var tokens = {};
    function addParseToken(token, callback) {
        var i, func = callback;
        if (typeof token === "string") {
            token = [ token ];
        }
        if (typeof callback === "number") {
            func = function(input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }
    function addWeekParseToken(token, callback) {
        addParseToken(token, function(input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }
    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }
    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    addFormatToken("M", [ "MM", 2 ], "Mo", function() {
        return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format) {
        return this.localeData().monthsShort(this, format);
    });
    addFormatToken("MMMM", 0, 0, function(format) {
        return this.localeData().months(this, format);
    });
    addUnitAlias("month", "M");
    addRegexToken("M", match1to2);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", matchWord);
    addRegexToken("MMMM", matchWord);
    addParseToken([ "M", "MM" ], function(input, array) {
        array[MONTH] = toInt(input) - 1;
    });
    addParseToken([ "MMM", "MMMM" ], function(input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_");
    function localeMonths(m) {
        return this._months[m.month()];
    }
    var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
    function localeMonthsShort(m) {
        return this._monthsShort[m.month()];
    }
    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
            mom = create_utc__createUTC([ 2e3, i ]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
                this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
            }
            if (!strict && !this._monthsParse[i]) {
                regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format === "MMMM" && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === "MMM" && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }
    function setMonth(mom, value) {
        var dayOfMonth;
        if (typeof value === "string") {
            value = mom.localeData().monthsParse(value);
            if (typeof value !== "number") {
                return mom;
            }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
    }
    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, "Month");
        }
    }
    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }
    function checkOverflow(m) {
        var overflow;
        var a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            getParsingFlags(m).overflow = overflow;
        }
        return m;
    }
    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
        }
    }
    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
            if (firstTime) {
                warn(msg + "\n" + new Error().stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }
    utils_hooks__hooks.suppressDeprecationWarnings = false;
    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/ ], [ "YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d{2}/ ], [ "YYYY-DDD", /\d{4}-\d{3}/ ] ];
    var isoTimes = [ [ "HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss", /(T| )\d\d:\d\d:\d\d/ ], [ "HH:mm", /(T| )\d\d:\d\d/ ], [ "HH", /(T| )\d\d/ ] ];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
    function configFromISO(config) {
        var i, l, string = config._i, match = from_string__isoRegex.exec(string);
        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0];
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += (match[6] || " ") + isoTimes[i][0];
                    break;
                }
            }
            if (string.match(matchOffset)) {
                config._f += "Z";
            }
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }
        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }
    utils_hooks__hooks.createFromInputFallback = deprecate("moment construction falls back to js Date. This is " + "discouraged and will be removed in upcoming major " + "release. Please refer to " + "https://github.com/moment/moment/issues/1407 for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    });
    function createDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }
    function createUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }
    addFormatToken(0, [ "YY", 2 ], 0, function() {
        return this.year() % 100;
    });
    addFormatToken(0, [ "YYYY", 4 ], 0, "year");
    addFormatToken(0, [ "YYYYY", 5 ], 0, "year");
    addFormatToken(0, [ "YYYYYY", 6, true ], 0, "year");
    addUnitAlias("year", "y");
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken([ "YYYYY", "YYYYYY" ], YEAR);
    addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    utils_hooks__hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", false);
    function getIsLeapYear() {
        return isLeapYear(this.year());
    }
    addFormatToken("w", [ "ww", 2 ], "wo", "week");
    addFormatToken("W", [ "WW", 2 ], "Wo", "isoWeek");
    addUnitAlias("week", "w");
    addUnitAlias("isoWeek", "W");
    addRegexToken("w", match1to2);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken([ "w", "ww", "W", "WW" ], function(input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(), adjustedMoment;
        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }
        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }
        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, "d");
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }
    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
        dow: 0,
        doy: 6
    };
    function localeFirstDayOfWeek() {
        return this._week.dow;
    }
    function localeFirstDayOfYear() {
        return this._week.doy;
    }
    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("DDD", [ "DDDD", 3 ], "DDDo", "dayOfYear");
    addUnitAlias("dayOfYear", "DDD");
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken([ "DDD", "DDDD" ], function(input, array, config) {
        config._dayOfYear = toInt(input);
    });
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;
        if (d < firstDayOfWeek) {
            d += 7;
        }
        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;
        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;
        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }
    function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }
    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [ now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() ];
        }
        return [ now.getFullYear(), now.getMonth(), now.getDate() ];
    }
    function configFromArray(config) {
        var i, date, input = [], currentDate, yearToUse;
        if (config._d) {
            return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }
        for (;i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);
            if (w.d != null) {
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                weekday = w.e + dow;
            } else {
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
    utils_hooks__hooks.ISO_8601 = function() {};
    function configFromStringAndFormat(config) {
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }
        if (getParsingFlags(config).bigHour === true && config._a[HOUR] <= 12 && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        configFromArray(config);
        checkOverflow(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            return hour;
        }
    }
    function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (!valid__isValid(tempConfig)) {
                continue;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }
        extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
        if (config._d) {
            return;
        }
        var i = normalizeObjectUnits(config._i);
        config._a = [ i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond ];
        configFromArray(config);
    }
    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = undefined;
        }
        return res;
    }
    function prepareConfig(config) {
        var input = config._i, format = config._f;
        config._locale = config._locale || locale_locales__getLocale(config._l);
        if (input === null || format === undefined && input === "") {
            return valid__createInvalid({
                nullInput: true
            });
        }
        if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }
        return config;
    }
    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === "string") {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function(obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof input === "object") {
            configFromObject(config);
        } else if (typeof input === "number") {
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        if (typeof locale === "boolean") {
            strict = locale;
            locale = undefined;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        return createFromConfig(c);
    }
    function local__createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }
    var prototypeMin = deprecate("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548", function() {
        var other = local__createLocal.apply(null, arguments);
        return other < this ? this : other;
    });
    var prototypeMax = deprecate("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548", function() {
        var other = local__createLocal.apply(null, arguments);
        return other > this ? this : other;
    });
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }
    function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
    }
    function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = locale_locales__getLocale();
        this._bubble();
    }
    function isDuration(obj) {
        return obj instanceof Duration;
    }
    function offset(token, separator) {
        addFormatToken(token, 0, 0, function() {
            var offset = this.utcOffset();
            var sign = "+";
            if (offset < 0) {
                offset = -offset;
                sign = "-";
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchOffset);
    addRegexToken("ZZ", matchOffset);
    addParseToken([ "Z", "ZZ" ], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(string) {
        var matches = (string || "").match(matchOffset) || [];
        var chunk = matches[matches.length - 1] || [];
        var parts = (chunk + "").match(chunkOffset) || [ "-", 0, 0 ];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);
        return parts[0] === "+" ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - +res;
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }
    function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }
    utils_hooks__hooks.updateOffset = function() {};
    function getSetOffset(input, keepLocalTime) {
        var offset = this._offset || 0, localAdjust;
        if (input != null) {
            if (typeof input === "string") {
                input = offsetFromString(input);
            }
            if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, "m");
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, "m"), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }
    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== "string") {
                input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
        } else {
            return -this.utcOffset();
        }
    }
    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
                this.subtract(getDateOffset(this), "m");
            }
        }
        return this;
    }
    function setOffsetToParsedOffset() {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === "string") {
            this.utcOffset(offsetFromString(this._i));
        }
        return this;
    }
    function hasAlignedHourOffset(input) {
        input = input ? local__createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
        if (typeof this._isDSTShifted !== "undefined") {
            return this._isDSTShifted;
        }
        var c = {};
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }
        return this._isDSTShifted;
    }
    function isLocal() {
        return !this._isUTC;
    }
    function isUtcOffset() {
        return this._isUTC;
    }
    function isUtc() {
        return this._isUTC && this._offset === 0;
    }
    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
    function create__createDuration(input, key) {
        var duration = input, match = null, sign, ret, diffRes;
        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === "number") {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = create__isoRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                d: parseIso(match[4], sign),
                h: parseIso(match[5], sign),
                m: parseIso(match[6], sign),
                s: parseIso(match[7], sign),
                w: parseIso(match[8], sign)
            };
        } else if (duration == null) {
            duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
        }
        return ret;
    }
    create__createDuration.fn = Duration.prototype;
    function parseIso(inp, sign) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
    }
    function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }
        return res;
    }
    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period).");
                tmp = val;
                val = period;
                period = tmp;
            }
            val = typeof val === "string" ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }
    function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = duration._days, months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;
        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, "Date", get_set__get(mom, "Date") + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, "Month") + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }
    var add_subtract__add = createAdder(1, "add");
    var add_subtract__subtract = createAdder(-1, "subtract");
    function moment_calendar__calendar(time, formats) {
        var now = time || local__createLocal(), sod = cloneWithOffset(now, this).startOf("day"), diff = this.diff(sod, "days", true), format = diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));
    }
    function clone() {
        return new Moment(this);
    }
    function isAfter(input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== "undefined" ? units : "millisecond");
        if (units === "millisecond") {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this > +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return inputMs < +this.clone().startOf(units);
        }
    }
    function isBefore(input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== "undefined" ? units : "millisecond");
        if (units === "millisecond") {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this < +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return +this.clone().endOf(units) < inputMs;
        }
    }
    function isBetween(from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }
    function isSame(input, units) {
        var inputMs;
        units = normalizeUnits(units || "millisecond");
        if (units === "millisecond") {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this === +input;
        } else {
            inputMs = +local__createLocal(input);
            return +this.clone().startOf(units) <= inputMs && inputMs <= +this.clone().endOf(units);
        }
    }
    function diff(input, units, asFloat) {
        var that = cloneWithOffset(input, this), zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4, delta, output;
        units = normalizeUnits(units);
        if (units === "year" || units === "month" || units === "quarter") {
            output = monthDiff(this, that);
            if (units === "quarter") {
                output = output / 3;
            } else if (units === "year") {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === "second" ? delta / 1e3 : units === "minute" ? delta / 6e4 : units === "hour" ? delta / 36e5 : units === "day" ? (delta - zoneDelta) / 864e5 : units === "week" ? (delta - zoneDelta) / 6048e5 : delta;
        }
        return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust);
    }
    utils_hooks__hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function moment_format__toISOString() {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if ("function" === typeof Date.prototype.toISOString) {
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
            }
        } else {
            return formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
        }
    }
    function format(inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({
            to: this,
            from: time
        }).locale(this.locale()).humanize(!withoutSuffix);
    }
    function fromNow(withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({
            from: this,
            to: time
        }).locale(this.locale()).humanize(!withoutSuffix);
    }
    function toNow(withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }
    function locale(key) {
        var newLocaleData;
        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }
    var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    });
    function localeData() {
        return this._locale;
    }
    function startOf(units) {
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            this.month(0);

          case "quarter":
          case "month":
            this.date(1);

          case "week":
          case "isoWeek":
          case "day":
            this.hours(0);

          case "hour":
            this.minutes(0);

          case "minute":
            this.seconds(0);

          case "second":
            this.milliseconds(0);
        }
        if (units === "week") {
            this.weekday(0);
        }
        if (units === "isoWeek") {
            this.isoWeekday(1);
        }
        if (units === "quarter") {
            this.month(Math.floor(this.month() / 3) * 3);
        }
        return this;
    }
    function endOf(units) {
        units = normalizeUnits(units);
        if (units === undefined || units === "millisecond") {
            return this;
        }
        return this.startOf(units).add(1, units === "isoWeek" ? "week" : units).subtract(1, "ms");
    }
    function to_type__valueOf() {
        return +this._d - (this._offset || 0) * 6e4;
    }
    function unix() {
        return Math.floor(+this / 1e3);
    }
    function toDate() {
        return this._offset ? new Date(+this) : this._d;
    }
    function toArray() {
        var m = this;
        return [ m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond() ];
    }
    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }
    function moment_valid__isValid() {
        return valid__isValid(this);
    }
    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
        return getParsingFlags(this).overflow;
    }
    addFormatToken(0, [ "gg", 2 ], 0, function() {
        return this.weekYear() % 100;
    });
    addFormatToken(0, [ "GG", 2 ], 0, function() {
        return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [ token, token.length ], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addUnitAlias("weekYear", "gg");
    addUnitAlias("isoWeekYear", "GG");
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken([ "gggg", "ggggg", "GGGG", "GGGGG" ], function(input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken([ "gg", "GG" ], function(input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([ year, 11, 31 + dow - doy ]), dow, doy).week;
    }
    function getSetWeekYear(input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add(input - year, "y");
    }
    function getSetISOWeekYear(input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add(input - year, "y");
    }
    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }
    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    addFormatToken("Q", 0, 0, "quarter");
    addUnitAlias("quarter", "Q");
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", [ "DD", 2 ], "Do", "date");
    addUnitAlias("date", "D");
    addRegexToken("D", match1to2);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });
    addParseToken([ "D", "DD" ], DATE);
    addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format) {
        return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken("ddd", 0, 0, function(format) {
        return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken("dddd", 0, 0, function(format) {
        return this.localeData().weekdays(this, format);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addUnitAlias("day", "d");
    addUnitAlias("weekday", "e");
    addUnitAlias("isoWeekday", "E");
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", matchWord);
    addRegexToken("ddd", matchWord);
    addRegexToken("dddd", matchWord);
    addWeekParseToken([ "dd", "ddd", "dddd" ], function(input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });
    addWeekParseToken([ "d", "e", "E" ], function(input, week, config, token) {
        week[token] = toInt(input);
    });
    function parseWeekday(input, locale) {
        if (typeof input !== "string") {
            return input;
        }
        if (!isNaN(input)) {
            return parseInt(input, 10);
        }
        input = locale.weekdaysParse(input);
        if (typeof input === "number") {
            return input;
        }
        return null;
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
    function localeWeekdays(m) {
        return this._weekdays[m.day()];
    }
    var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
    function localeWeekdaysShort(m) {
        return this._weekdaysShort[m.day()];
    }
    var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
    function localeWeekdaysMin(m) {
        return this._weekdaysMin[m.day()];
    }
    function localeWeekdaysParse(weekdayName) {
        var i, mom, regex;
        this._weekdaysParse = this._weekdaysParse || [];
        for (i = 0; i < 7; i++) {
            if (!this._weekdaysParse[i]) {
                mom = local__createLocal([ 2e3, 1 ]).day(i);
                regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }
    function getSetDayOfWeek(input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
        } else {
            return day;
        }
    }
    function getSetLocaleDayOfWeek(input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }
    addFormatToken("H", [ "HH", 2 ], 0, "hour");
    addFormatToken("h", [ "hh", 2 ], 0, function() {
        return this.hours() % 12 || 12;
    });
    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }
    meridiem("a", true);
    meridiem("A", false);
    addUnitAlias("hour", "h");
    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2);
    addRegexToken("h", match1to2);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addParseToken([ "H", "HH" ], HOUR);
    addParseToken([ "a", "A" ], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken([ "h", "hh" ], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? "pm" : "PM";
        } else {
            return isLower ? "am" : "AM";
        }
    }
    var getSetHour = makeGetSet("Hours", true);
    addFormatToken("m", [ "mm", 2 ], 0, "minute");
    addUnitAlias("minute", "m");
    addRegexToken("m", match1to2);
    addRegexToken("mm", match1to2, match2);
    addParseToken([ "m", "mm" ], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", [ "ss", 2 ], 0, "second");
    addUnitAlias("second", "s");
    addRegexToken("s", match1to2);
    addRegexToken("ss", match1to2, match2);
    addParseToken([ "s", "ss" ], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, [ "SS", 2 ], 0, function() {
        return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, [ "SSS", 3 ], 0, "millisecond");
    addFormatToken(0, [ "SSSS", 4 ], 0, function() {
        return this.millisecond() * 10;
    });
    addFormatToken(0, [ "SSSSS", 5 ], 0, function() {
        return this.millisecond() * 100;
    });
    addFormatToken(0, [ "SSSSSS", 6 ], 0, function() {
        return this.millisecond() * 1e3;
    });
    addFormatToken(0, [ "SSSSSSS", 7 ], 0, function() {
        return this.millisecond() * 1e4;
    });
    addFormatToken(0, [ "SSSSSSSS", 8 ], 0, function() {
        return this.millisecond() * 1e5;
    });
    addFormatToken(0, [ "SSSSSSSSS", 9 ], 0, function() {
        return this.millisecond() * 1e6;
    });
    addUnitAlias("millisecond", "ms");
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token;
    for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
    }
    var getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var momentPrototype__proto = Moment.prototype;
    momentPrototype__proto.add = add_subtract__add;
    momentPrototype__proto.calendar = moment_calendar__calendar;
    momentPrototype__proto.clone = clone;
    momentPrototype__proto.diff = diff;
    momentPrototype__proto.endOf = endOf;
    momentPrototype__proto.format = format;
    momentPrototype__proto.from = from;
    momentPrototype__proto.fromNow = fromNow;
    momentPrototype__proto.to = to;
    momentPrototype__proto.toNow = toNow;
    momentPrototype__proto.get = getSet;
    momentPrototype__proto.invalidAt = invalidAt;
    momentPrototype__proto.isAfter = isAfter;
    momentPrototype__proto.isBefore = isBefore;
    momentPrototype__proto.isBetween = isBetween;
    momentPrototype__proto.isSame = isSame;
    momentPrototype__proto.isValid = moment_valid__isValid;
    momentPrototype__proto.lang = lang;
    momentPrototype__proto.locale = locale;
    momentPrototype__proto.localeData = localeData;
    momentPrototype__proto.max = prototypeMax;
    momentPrototype__proto.min = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set = getSet;
    momentPrototype__proto.startOf = startOf;
    momentPrototype__proto.subtract = add_subtract__subtract;
    momentPrototype__proto.toArray = toArray;
    momentPrototype__proto.toObject = toObject;
    momentPrototype__proto.toDate = toDate;
    momentPrototype__proto.toISOString = moment_format__toISOString;
    momentPrototype__proto.toJSON = moment_format__toISOString;
    momentPrototype__proto.toString = toString;
    momentPrototype__proto.unix = unix;
    momentPrototype__proto.valueOf = to_type__valueOf;
    momentPrototype__proto.year = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;
    momentPrototype__proto.weekYear = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
    momentPrototype__proto.month = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;
    momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
    momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
    momentPrototype__proto.weeksInYear = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
    momentPrototype__proto.date = getSetDayOfMonth;
    momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
    momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear = getSetDayOfYear;
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
    momentPrototype__proto.utcOffset = getSetOffset;
    momentPrototype__proto.utc = setOffsetToUTC;
    momentPrototype__proto.local = setOffsetToLocal;
    momentPrototype__proto.parseZone = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal = isLocal;
    momentPrototype__proto.isUtcOffset = isUtcOffset;
    momentPrototype__proto.isUtc = isUtc;
    momentPrototype__proto.isUTC = isUtc;
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;
    momentPrototype__proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
    momentPrototype__proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
    momentPrototype__proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
    momentPrototype__proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779", getSetZone);
    var momentPrototype = momentPrototype__proto;
    function moment__createUnix(input) {
        return local__createLocal(input * 1e3);
    }
    function moment__createInZone() {
        return local__createLocal.apply(null, arguments).parseZone();
    }
    var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
    };
    function locale_calendar__calendar(key, mom, now) {
        var output = this._calendar[key];
        return typeof output === "function" ? output.call(mom, now) : output;
    }
    var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
        var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format || !formatUpper) {
            return format;
        }
        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
            return val.slice(1);
        });
        return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
        return this._invalidDate;
    }
    var defaultOrdinal = "%d";
    var defaultOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
        return this._ordinal.replace("%d", number);
    }
    function preParsePostFormat(string) {
        return string;
    }
    var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
    };
    function relative__relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return typeof output === "function" ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? "future" : "past"];
        return typeof format === "function" ? format(output) : format.replace(/%s/i, output);
    }
    function locale_set__set(config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (typeof prop === "function") {
                this[i] = prop;
            } else {
                this["_" + i] = prop;
            }
        }
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source);
    }
    var prototype__proto = Locale.prototype;
    prototype__proto._calendar = defaultCalendar;
    prototype__proto.calendar = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat = longDateFormat;
    prototype__proto._invalidDate = defaultInvalidDate;
    prototype__proto.invalidDate = invalidDate;
    prototype__proto._ordinal = defaultOrdinal;
    prototype__proto.ordinal = ordinal;
    prototype__proto._ordinalParse = defaultOrdinalParse;
    prototype__proto.preparse = preParsePostFormat;
    prototype__proto.postformat = preParsePostFormat;
    prototype__proto._relativeTime = defaultRelativeTime;
    prototype__proto.relativeTime = relative__relativeTime;
    prototype__proto.pastFuture = pastFuture;
    prototype__proto.set = locale_set__set;
    prototype__proto.months = localeMonths;
    prototype__proto._months = defaultLocaleMonths;
    prototype__proto.monthsShort = localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse = localeMonthsParse;
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
    prototype__proto.weekdays = localeWeekdays;
    prototype__proto._weekdays = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin = localeWeekdaysMin;
    prototype__proto._weekdaysMin = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort = localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse = localeWeekdaysParse;
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;
    function lists__get(format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }
    function list(format, index, field, count, setter) {
        if (typeof format === "number") {
            index = format;
            format = undefined;
        }
        format = format || "";
        if (index != null) {
            return lists__get(format, index, field, setter);
        }
        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }
    function lists__listMonths(format, index) {
        return list(format, index, "months", 12, "month");
    }
    function lists__listMonthsShort(format, index) {
        return list(format, index, "monthsShort", 12, "month");
    }
    function lists__listWeekdays(format, index) {
        return list(format, index, "weekdays", 7, "day");
    }
    function lists__listWeekdaysShort(format, index) {
        return list(format, index, "weekdaysShort", 7, "day");
    }
    function lists__listWeekdaysMin(format, index) {
        return list(format, index, "weekdaysMin", 7, "day");
    }
    locale_locales__getSetGlobalLocale("en", {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        }
    });
    utils_hooks__hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", locale_locales__getLocale);
    var mathAbs = Math.abs;
    function duration_abs__abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
    }
    function duration_add_subtract__addSubtract(duration, input, value, direction) {
        var other = create__createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
    }
    function duration_add_subtract__add(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }
    function duration_add_subtract__subtract(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }
    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }
    function bubble() {
        var milliseconds = this._milliseconds;
        var days = this._days;
        var months = this._months;
        var data = this._data;
        var seconds, minutes, hours, years, monthsFromDays;
        if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }
        data.milliseconds = milliseconds % 1e3;
        seconds = absFloor(milliseconds / 1e3);
        data.seconds = seconds % 60;
        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;
        hours = absFloor(minutes / 60);
        data.hours = hours % 24;
        days += absFloor(hours / 24);
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));
        years = absFloor(months / 12);
        months %= 12;
        data.days = days;
        data.months = months;
        data.years = years;
        return this;
    }
    function daysToMonths(days) {
        return days * 4800 / 146097;
    }
    function monthsToDays(months) {
        return months * 146097 / 4800;
    }
    function as(units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "year") {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === "month" ? months : months / 12;
        } else {
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case "week":
                return days / 7 + milliseconds / 6048e5;

              case "day":
                return days + milliseconds / 864e5;

              case "hour":
                return days * 24 + milliseconds / 36e5;

              case "minute":
                return days * 1440 + milliseconds / 6e4;

              case "second":
                return days * 86400 + milliseconds / 1e3;

              case "millisecond":
                return Math.floor(days * 864e5) + milliseconds;

              default:
                throw new Error("Unknown unit " + units);
            }
        }
    }
    function duration_as__valueOf() {
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }
    function makeAs(alias) {
        return function() {
            return this.as(alias);
        };
    }
    var asMilliseconds = makeAs("ms");
    var asSeconds = makeAs("s");
    var asMinutes = makeAs("m");
    var asHours = makeAs("h");
    var asDays = makeAs("d");
    var asWeeks = makeAs("w");
    var asMonths = makeAs("M");
    var asYears = makeAs("y");
    function duration_get__get(units) {
        units = normalizeUnits(units);
        return this[units + "s"]();
    }
    function makeGetter(name) {
        return function() {
            return this._data[name];
        };
    }
    var milliseconds = makeGetter("milliseconds");
    var seconds = makeGetter("seconds");
    var minutes = makeGetter("minutes");
    var hours = makeGetter("hours");
    var days = makeGetter("days");
    var months = makeGetter("months");
    var years = makeGetter("years");
    function weeks() {
        return absFloor(this.days() / 7);
    }
    var round = Math.round;
    var thresholds = {
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds = round(duration.as("s"));
        var minutes = round(duration.as("m"));
        var hours = round(duration.as("h"));
        var days = round(duration.as("d"));
        var months = round(duration.as("M"));
        var years = round(duration.as("y"));
        var a = seconds < thresholds.s && [ "s", seconds ] || minutes === 1 && [ "m" ] || minutes < thresholds.m && [ "mm", minutes ] || hours === 1 && [ "h" ] || hours < thresholds.h && [ "hh", hours ] || days === 1 && [ "d" ] || days < thresholds.d && [ "dd", days ] || months === 1 && [ "M" ] || months < thresholds.M && [ "MM", months ] || years === 1 && [ "y" ] || [ "yy", years ];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }
    function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }
    function humanize(withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);
        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }
        return locale.postformat(output);
    }
    var iso_string__abs = Math.abs;
    function iso_string__toISOString() {
        var seconds = iso_string__abs(this._milliseconds) / 1e3;
        var days = iso_string__abs(this._days);
        var months = iso_string__abs(this._months);
        var minutes, hours, years;
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;
        years = absFloor(months / 12);
        months %= 12;
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();
        if (!total) {
            return "P0D";
        }
        return (total < 0 ? "-" : "") + "P" + (Y ? Y + "Y" : "") + (M ? M + "M" : "") + (D ? D + "D" : "") + (h || m || s ? "T" : "") + (h ? h + "H" : "") + (m ? m + "M" : "") + (s ? s + "S" : "");
    }
    var duration_prototype__proto = Duration.prototype;
    duration_prototype__proto.abs = duration_abs__abs;
    duration_prototype__proto.add = duration_add_subtract__add;
    duration_prototype__proto.subtract = duration_add_subtract__subtract;
    duration_prototype__proto.as = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds = asSeconds;
    duration_prototype__proto.asMinutes = asMinutes;
    duration_prototype__proto.asHours = asHours;
    duration_prototype__proto.asDays = asDays;
    duration_prototype__proto.asWeeks = asWeeks;
    duration_prototype__proto.asMonths = asMonths;
    duration_prototype__proto.asYears = asYears;
    duration_prototype__proto.valueOf = duration_as__valueOf;
    duration_prototype__proto._bubble = bubble;
    duration_prototype__proto.get = duration_get__get;
    duration_prototype__proto.milliseconds = milliseconds;
    duration_prototype__proto.seconds = seconds;
    duration_prototype__proto.minutes = minutes;
    duration_prototype__proto.hours = hours;
    duration_prototype__proto.days = days;
    duration_prototype__proto.weeks = weeks;
    duration_prototype__proto.months = months;
    duration_prototype__proto.years = years;
    duration_prototype__proto.humanize = humanize;
    duration_prototype__proto.toISOString = iso_string__toISOString;
    duration_prototype__proto.toString = iso_string__toISOString;
    duration_prototype__proto.toJSON = iso_string__toISOString;
    duration_prototype__proto.locale = locale;
    duration_prototype__proto.localeData = localeData;
    duration_prototype__proto.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", iso_string__toISOString);
    duration_prototype__proto.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1e3);
    });
    addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
    });
    utils_hooks__hooks.version = "2.10.6";
    setHookCallback(local__createLocal);
    utils_hooks__hooks.fn = momentPrototype;
    utils_hooks__hooks.min = min;
    utils_hooks__hooks.max = max;
    utils_hooks__hooks.utc = create_utc__createUTC;
    utils_hooks__hooks.unix = moment__createUnix;
    utils_hooks__hooks.months = lists__listMonths;
    utils_hooks__hooks.isDate = isDate;
    utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid = valid__createInvalid;
    utils_hooks__hooks.duration = create__createDuration;
    utils_hooks__hooks.isMoment = isMoment;
    utils_hooks__hooks.weekdays = lists__listWeekdays;
    utils_hooks__hooks.parseZone = moment__createInZone;
    utils_hooks__hooks.localeData = locale_locales__getLocale;
    utils_hooks__hooks.isDuration = isDuration;
    utils_hooks__hooks.monthsShort = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale = defineLocale;
    utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    var _moment = utils_hooks__hooks;
    return _moment;
});

(function(window, document, undefined) {
    "use strict";
    function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
            var code = arguments[0], prefix = "[" + (module ? module + ":" : "") + code + "] ", template = arguments[1], templateArgs = arguments, message, i;
            message = prefix + template.replace(/\{\d+\}/g, function(match) {
                var index = +match.slice(1, -1), arg;
                if (index + 2 < templateArgs.length) {
                    return toDebugString(templateArgs[index + 2]);
                }
                return match;
            });
            message = message + "\nhttp://errors.angularjs.org/1.3.20/" + (module ? module + "/" : "") + code;
            for (i = 2; i < arguments.length; i++) {
                message = message + (i == 2 ? "?" : "&") + "p" + (i - 2) + "=" + encodeURIComponent(toDebugString(arguments[i]));
            }
            return new ErrorConstructor(message);
        };
    }
    var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
    var VALIDITY_STATE_PROPERTY = "validity";
    var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    };
    var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
            return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
    };
    var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
            return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
    };
    if ("i" !== "I".toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
    }
    var msie, jqLite, jQuery, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), angularModule, uid = 0;
    msie = document.documentMode;
    function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) {
            return false;
        }
        var length = "length" in Object(obj) && obj.length;
        if (obj.nodeType === NODE_TYPE_ELEMENT && length) {
            return true;
        }
        return isString(obj) || isArray(obj) || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    function forEach(obj, iterator, context) {
        var key, length;
        if (obj) {
            if (isFunction(obj)) {
                for (key in obj) {
                    if (key != "prototype" && key != "length" && key != "name" && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            } else if (isArray(obj) || isArrayLike(obj)) {
                var isPrimitive = typeof obj !== "object";
                for (key = 0, length = obj.length; key < length; key++) {
                    if (isPrimitive || key in obj) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            } else if (obj.forEach && obj.forEach !== forEach) {
                obj.forEach(iterator, context, obj);
            } else {
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            }
        }
        return obj;
    }
    function sortedKeys(obj) {
        return Object.keys(obj).sort();
    }
    function forEachSorted(obj, iterator, context) {
        var keys = sortedKeys(obj);
        for (var i = 0; i < keys.length; i++) {
            iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        return ++uid;
    }
    function setHashKey(obj, h) {
        if (h) {
            obj.$$hashKey = h;
        } else {
            delete obj.$$hashKey;
        }
    }
    function extend(dst) {
        var h = dst.$$hashKey;
        for (var i = 1, ii = arguments.length; i < ii; i++) {
            var obj = arguments[i];
            if (obj) {
                var keys = Object.keys(obj);
                for (var j = 0, jj = keys.length; j < jj; j++) {
                    var key = keys[j];
                    dst[key] = obj[key];
                }
            }
        }
        setHashKey(dst, h);
        return dst;
    }
    function int(str) {
        return parseInt(str, 10);
    }
    function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
    }
    function noop() {}
    noop.$inject = [];
    function identity($) {
        return $;
    }
    identity.$inject = [];
    function valueFn(value) {
        return function() {
            return value;
        };
    }
    function isUndefined(value) {
        return typeof value === "undefined";
    }
    function isDefined(value) {
        return typeof value !== "undefined";
    }
    function isObject(value) {
        return value !== null && typeof value === "object";
    }
    function isString(value) {
        return typeof value === "string";
    }
    function isNumber(value) {
        return typeof value === "number";
    }
    function isDate(value) {
        return toString.call(value) === "[object Date]";
    }
    var isArray = Array.isArray;
    function isFunction(value) {
        return typeof value === "function";
    }
    function isRegExp(value) {
        return toString.call(value) === "[object RegExp]";
    }
    function isWindow(obj) {
        return obj && obj.window === obj;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
        return toString.call(obj) === "[object File]";
    }
    function isFormData(obj) {
        return toString.call(obj) === "[object FormData]";
    }
    function isBlob(obj) {
        return toString.call(obj) === "[object Blob]";
    }
    function isBoolean(value) {
        return typeof value === "boolean";
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
    }
    var trim = function(value) {
        return isString(value) ? value.trim() : value;
    };
    var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    };
    function isElement(node) {
        return !!(node && (node.nodeName || node.prop && node.attr && node.find));
    }
    function makeMap(str) {
        var obj = {}, items = str.split(","), i;
        for (i = 0; i < items.length; i++) obj[items[i]] = true;
        return obj;
    }
    function nodeName_(element) {
        return lowercase(element.nodeName || element[0] && element[0].nodeName);
    }
    function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
    }
    function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) array.splice(index, 1);
        return value;
    }
    function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) {
            throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
        }
        if (!destination) {
            destination = source;
            if (source) {
                if (isArray(source)) {
                    destination = copy(source, [], stackSource, stackDest);
                } else if (isDate(source)) {
                    destination = new Date(source.getTime());
                } else if (isRegExp(source)) {
                    destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                    destination.lastIndex = source.lastIndex;
                } else if (isObject(source)) {
                    var emptyObject = Object.create(Object.getPrototypeOf(source));
                    destination = copy(source, emptyObject, stackSource, stackDest);
                }
            }
        } else {
            if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            stackSource = stackSource || [];
            stackDest = stackDest || [];
            if (isObject(source)) {
                var index = stackSource.indexOf(source);
                if (index !== -1) return stackDest[index];
                stackSource.push(source);
                stackDest.push(destination);
            }
            var result;
            if (isArray(source)) {
                destination.length = 0;
                for (var i = 0; i < source.length; i++) {
                    result = copy(source[i], null, stackSource, stackDest);
                    if (isObject(source[i])) {
                        stackSource.push(source[i]);
                        stackDest.push(result);
                    }
                    destination.push(result);
                }
            } else {
                var h = destination.$$hashKey;
                if (isArray(destination)) {
                    destination.length = 0;
                } else {
                    forEach(destination, function(value, key) {
                        delete destination[key];
                    });
                }
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        result = copy(source[key], null, stackSource, stackDest);
                        if (isObject(source[key])) {
                            stackSource.push(source[key]);
                            stackDest.push(result);
                        }
                        destination[key] = result;
                    }
                }
                setHashKey(destination, h);
            }
        }
        return destination;
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; i < ii; i++) {
                dst[i] = src[i];
            }
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) {
                if (!(key.charAt(0) === "$" && key.charAt(1) === "$")) {
                    dst[key] = src[key];
                }
            }
        }
        return dst || src;
    }
    function equals(o1, o2) {
        if (o1 === o2) return true;
        if (o1 === null || o2 === null) return false;
        if (o1 !== o1 && o2 !== o2) return true;
        var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
        if (t1 == t2) {
            if (t1 == "object") {
                if (isArray(o1)) {
                    if (!isArray(o2)) return false;
                    if ((length = o1.length) == o2.length) {
                        for (key = 0; key < length; key++) {
                            if (!equals(o1[key], o2[key])) return false;
                        }
                        return true;
                    }
                } else if (isDate(o1)) {
                    if (!isDate(o2)) return false;
                    return equals(o1.getTime(), o2.getTime());
                } else if (isRegExp(o1)) {
                    return isRegExp(o2) ? o1.toString() == o2.toString() : false;
                } else {
                    if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return false;
                    keySet = {};
                    for (key in o1) {
                        if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
                        if (!equals(o1[key], o2[key])) return false;
                        keySet[key] = true;
                    }
                    for (key in o2) {
                        if (!keySet.hasOwnProperty(key) && key.charAt(0) !== "$" && o2[key] !== undefined && !isFunction(o2[key])) return false;
                    }
                    return true;
                }
            }
        }
        return false;
    }
    var csp = function() {
        if (isDefined(csp.isActive_)) return csp.isActive_;
        var active = !!(document.querySelector("[ng-csp]") || document.querySelector("[data-ng-csp]"));
        if (!active) {
            try {
                new Function("");
            } catch (e) {
                active = true;
            }
        }
        return csp.isActive_ = active;
    };
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
            return curryArgs.length ? function() {
                return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
            } : function() {
                return arguments.length ? fn.apply(self, arguments) : fn.call(self);
            };
        } else {
            return fn;
        }
    }
    function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === "string" && key.charAt(0) === "$" && key.charAt(1) === "$") {
            val = undefined;
        } else if (isWindow(value)) {
            val = "$WINDOW";
        } else if (value && document === value) {
            val = "$DOCUMENT";
        } else if (isScope(value)) {
            val = "$SCOPE";
        }
        return val;
    }
    function toJson(obj, pretty) {
        if (typeof obj === "undefined") return undefined;
        if (!isNumber(pretty)) {
            pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.empty();
        } catch (e) {}
        var elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var obj = {}, key_value, key;
        forEach((keyValue || "").split("&"), function(keyValue) {
            if (keyValue) {
                key_value = keyValue.replace(/\+/g, "%20").split("=");
                key = tryDecodeURIComponent(key_value[0]);
                if (isDefined(key)) {
                    var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
                    if (!hasOwnProperty.call(obj, key)) {
                        obj[key] = val;
                    } else if (isArray(obj[key])) {
                        obj[key].push(val);
                    } else {
                        obj[key] = [ obj[key], val ];
                    }
                }
            }
        });
        return obj;
    }
    function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
            if (isArray(value)) {
                forEach(value, function(arrayValue) {
                    parts.push(encodeUriQuery(key, true) + (arrayValue === true ? "" : "=" + encodeUriQuery(arrayValue, true)));
                });
            } else {
                parts.push(encodeUriQuery(key, true) + (value === true ? "" : "=" + encodeUriQuery(value, true)));
            }
        });
        return parts.length ? parts.join("&") : "";
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    var ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ];
    function getNgAttribute(element, ngAttr) {
        var attr, i, ii = ngAttrPrefixes.length;
        element = jqLite(element);
        for (i = 0; i < ii; ++i) {
            attr = ngAttrPrefixes[i] + ngAttr;
            if (isString(attr = element.attr(attr))) {
                return attr;
            }
        }
        return null;
    }
    function angularInit(element, bootstrap) {
        var appElement, module, config = {};
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
                appElement = element;
                module = element.getAttribute(name);
            }
        });
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            var candidate;
            if (!appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]"))) {
                appElement = candidate;
                module = candidate.getAttribute(name);
            }
        });
        if (appElement) {
            config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
            bootstrap(appElement, module ? [ module ] : [], config);
        }
    }
    function bootstrap(element, modules, config) {
        if (!isObject(config)) config = {};
        var defaultConfig = {
            strictDi: false
        };
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
            element = jqLite(element);
            if (element.injector()) {
                var tag = element[0] === document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            modules = modules || [];
            modules.unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]);
            if (config.debugInfoEnabled) {
                modules.push([ "$compileProvider", function($compileProvider) {
                    $compileProvider.debugInfoEnabled(true);
                } ]);
            }
            modules.unshift("ng");
            var injector = createInjector(modules, config.strictDi);
            injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function bootstrapApply(scope, element, compile, injector) {
                scope.$apply(function() {
                    element.data("$injector", injector);
                    compile(element)(scope);
                });
            } ]);
            return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
            config.debugInfoEnabled = true;
            window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "");
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
            return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, "");
        angular.resumeBootstrap = function(extraModules) {
            forEach(extraModules, function(module) {
                modules.push(module);
            });
            return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
            angular.resumeDeferredBootstrap();
        }
    }
    function reloadWithDebugInfo() {
        window.name = "NG_ENABLE_DEBUG_INFO!" + window.name;
        window.location.reload();
    }
    function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
            throw ngMinErr("test", "no injector found for element argument to getTestability");
        }
        return injector.get("$$testability");
    }
    var SNAKE_CASE_REGEXP = /[A-Z]/g;
    function snake_case(name, separator) {
        separator = separator || "_";
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    var bindJQueryFired = false;
    var skipDestroyOnNextJQueryCleanData;
    function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
            return;
        }
        jQuery = window.jQuery;
        if (jQuery && jQuery.fn.on) {
            jqLite = jQuery;
            extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                isolateScope: JQLitePrototype.isolateScope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            });
            originalCleanData = jQuery.cleanData;
            jQuery.cleanData = function(elems) {
                var events;
                if (!skipDestroyOnNextJQueryCleanData) {
                    for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                        events = jQuery._data(elem, "events");
                        if (events && events.$destroy) {
                            jQuery(elem).triggerHandler("$destroy");
                        }
                    }
                } else {
                    skipDestroyOnNextJQueryCleanData = false;
                }
                originalCleanData(elems);
            };
        } else {
            jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
    }
    function assertArg(arg, name, reason) {
        if (!arg) {
            throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        }
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
            arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, "not a function, got " + (arg && typeof arg === "object" ? arg.constructor.name || "Object" : typeof arg));
        return arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if (name === "hasOwnProperty") {
            throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
        }
    }
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        var keys = path.split(".");
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
            key = keys[i];
            if (obj) {
                obj = (lastInstance = obj)[key];
            }
        }
        if (!bindFnToScope && isFunction(obj)) {
            return bind(lastInstance, obj);
        }
        return obj;
    }
    function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes = [ node ];
        do {
            node = node.nextSibling;
            if (!node) break;
            blockNodes.push(node);
        } while (node !== endNode);
        return jqLite(blockNodes);
    }
    function createMap() {
        return Object.create(null);
    }
    var NODE_TYPE_ELEMENT = 1;
    var NODE_TYPE_ATTRIBUTE = 2;
    var NODE_TYPE_TEXT = 3;
    var NODE_TYPE_COMMENT = 8;
    var NODE_TYPE_DOCUMENT = 9;
    var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
    function setupModuleLoader(window) {
        var $injectorMinErr = minErr("$injector");
        var ngMinErr = minErr("ng");
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, "angular", Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, "module", function() {
            var modules = {};
            return function module(name, requires, configFn) {
                var assertNotHasOwnProperty = function(name, context) {
                    if (name === "hasOwnProperty") {
                        throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                    }
                };
                assertNotHasOwnProperty(name, "module");
                if (requires && modules.hasOwnProperty(name)) {
                    modules[name] = null;
                }
                return ensure(modules, name, function() {
                    if (!requires) {
                        throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
                    }
                    var invokeQueue = [];
                    var configBlocks = [];
                    var runBlocks = [];
                    var config = invokeLater("$injector", "invoke", "push", configBlocks);
                    var moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _configBlocks: configBlocks,
                        _runBlocks: runBlocks,
                        requires: requires,
                        name: name,
                        provider: invokeLater("$provide", "provider"),
                        factory: invokeLater("$provide", "factory"),
                        service: invokeLater("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        animation: invokeLater("$animateProvider", "register"),
                        filter: invokeLater("$filterProvider", "register"),
                        controller: invokeLater("$controllerProvider", "register"),
                        directive: invokeLater("$compileProvider", "directive"),
                        config: config,
                        run: function(block) {
                            runBlocks.push(block);
                            return this;
                        }
                    };
                    if (configFn) {
                        config(configFn);
                    }
                    return moduleInstance;
                    function invokeLater(provider, method, insertMethod, queue) {
                        if (!queue) queue = invokeQueue;
                        return function() {
                            queue[insertMethod || "push"]([ provider, method, arguments ]);
                            return moduleInstance;
                        };
                    }
                });
            };
        });
    }
    function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
            val = toJsonReplacer(key, val);
            if (isObject(val)) {
                if (seen.indexOf(val) >= 0) return "<<already seen>>";
                seen.push(val);
            }
            return val;
        });
    }
    function toDebugString(obj) {
        if (typeof obj === "function") {
            return obj.toString().replace(/ \{[\s\S]*$/, "");
        } else if (typeof obj === "undefined") {
            return "undefined";
        } else if (typeof obj !== "string") {
            return serializeObject(obj);
        }
        return obj;
    }
    var version = {
        full: "1.3.20",
        major: 1,
        minor: 3,
        dot: 20,
        codeName: "shallow-translucence"
    };
    function publishExternalAPI(angular) {
        extend(angular, {
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            lowercase: lowercase,
            uppercase: uppercase,
            callbacks: {
                counter: 0
            },
            getTestability: getTestability,
            $$minErr: minErr,
            $$csp: csp,
            reloadWithDebugInfo: reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        try {
            angularModule("ngLocale");
        } catch (e) {
            angularModule("ngLocale", []).provider("$locale", $LocaleProvider);
        }
        angularModule("ng", [ "ngLocale" ], [ "$provide", function ngModule($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            });
            $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                style: styleDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
            $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpBackend: $HttpBackendProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$asyncCallback: $$AsyncCallbackProvider,
                $$jqLite: $$jqLiteProvider
            });
        } ]);
    }
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = function(element, type, fn) {
        element.addEventListener(type, fn, false);
    }, removeEventListenerFn = function(element, type, fn) {
        element.removeEventListener(type, fn, false);
    };
    JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    };
    function jqNextId() {
        return ++jqId;
    }
    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
    var MOZ_HACK_REGEXP = /^moz([A-Z])/;
    var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    };
    var jqLiteMinErr = minErr("jqLite");
    function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, "Moz$1");
    }
    var SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var HTML_REGEXP = /<|&#?\w+;/;
    var TAG_NAME_REGEXP = /<([\w:]+)/;
    var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
    var wrapMap = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, fragment = context.createDocumentFragment(), nodes = [], i;
        if (jqLiteIsTextNode(html)) {
            nodes.push(context.createTextNode(html));
        } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
            i = wrap[0];
            while (i--) {
                tmp = tmp.lastChild;
            }
            nodes = concat(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
            fragment.appendChild(node);
        });
        return fragment;
    }
    function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
            return [ context.createElement(parsed[1]) ];
        }
        if (parsed = jqLiteBuildFragment(html, context)) {
            return parsed.childNodes;
        }
        return [];
    }
    function JQLite(element) {
        if (element instanceof JQLite) {
            return element;
        }
        var argIsString;
        if (isString(element)) {
            element = trim(element);
            argIsString = true;
        }
        if (!(this instanceof JQLite)) {
            if (argIsString && element.charAt(0) != "<") {
                throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            }
            return new JQLite(element);
        }
        if (argIsString) {
            jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
            jqLiteAddNodes(this, element);
        }
    }
    function jqLiteClone(element) {
        return element.cloneNode(true);
    }
    function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants) jqLiteRemoveData(element);
        if (element.querySelectorAll) {
            var descendants = element.querySelectorAll("*");
            for (var i = 0, l = descendants.length; i < l; i++) {
                jqLiteRemoveData(descendants[i]);
            }
        }
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle) return;
        if (!type) {
            for (type in events) {
                if (type !== "$destroy") {
                    removeEventListenerFn(element, type, handle);
                }
                delete events[type];
            }
        } else {
            forEach(type.split(" "), function(type) {
                if (isDefined(fn)) {
                    var listenerFns = events[type];
                    arrayRemove(listenerFns || [], fn);
                    if (listenerFns && listenerFns.length > 0) {
                        return;
                    }
                }
                removeEventListenerFn(element, type, handle);
                delete events[type];
            });
        }
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
            if (name) {
                delete expandoStore.data[name];
                return;
            }
            if (expandoStore.handle) {
                if (expandoStore.events.$destroy) {
                    expandoStore.handle({}, "$destroy");
                }
                jqLiteOff(element);
            }
            delete jqCache[expandoId];
            element.ng339 = undefined;
        }
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
            element.ng339 = expandoId = jqNextId();
            expandoStore = jqCache[expandoId] = {
                events: {},
                data: {},
                handle: undefined
            };
        }
        return expandoStore;
    }
    function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
            var isSimpleSetter = isDefined(value);
            var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
            var massGetter = !key;
            var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
            var data = expandoStore && expandoStore.data;
            if (isSimpleSetter) {
                data[key] = value;
            } else {
                if (massGetter) {
                    return data;
                } else {
                    if (isSimpleGetter) {
                        return data && data[key];
                    } else {
                        extend(data, key);
                    }
                }
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        if (!element.getAttribute) return false;
        return (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1;
    }
    function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            forEach(cssClasses.split(" "), function(cssClass) {
                element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
            });
        }
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass);
                if (existingClasses.indexOf(" " + cssClass + " ") === -1) {
                    existingClasses += cssClass + " ";
                }
            });
            element.setAttribute("class", trim(existingClasses));
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) {
            if (elements.nodeType) {
                root[root.length++] = elements;
            } else {
                var length = elements.length;
                if (typeof length === "number" && elements.window !== elements) {
                    if (length) {
                        for (var i = 0; i < length; i++) {
                            root[root.length++] = elements[i];
                        }
                    }
                } else {
                    root[root.length++] = elements;
                }
            }
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
            element = element.documentElement;
        }
        var names = isArray(name) ? name : [ name ];
        while (element) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                if ((value = jqLite.data(element, names[i])) !== undefined) return value;
            }
            element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
        }
    }
    function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
            element.removeChild(element.firstChild);
        }
    }
    function jqLiteRemove(element, keepData) {
        if (!keepData) jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent) parent.removeChild(element);
    }
    function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === "complete") {
            win.setTimeout(action);
        } else {
            jqLite(win).on("load", action);
        }
    }
    var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
            var fired = false;
            function trigger() {
                if (fired) return;
                fired = true;
                fn();
            }
            if (document.readyState === "complete") {
                setTimeout(trigger);
            } else {
                this.on("DOMContentLoaded", trigger);
                JQLite(window).on("load", trigger);
            }
        },
        toString: function() {
            var value = [];
            forEach(this, function(e) {
                value.push("" + e);
            });
            return "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    };
    var BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
    });
    var ALIASED_ATTR = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern"
    };
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
    }
    function getAliasedAttrName(element, name) {
        var nodeName = element.nodeName;
        return (nodeName === "INPUT" || nodeName === "TEXTAREA") && ALIASED_ATTR[name];
    }
    forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData
    }, function(fn, name) {
        JQLite[name] = fn;
    });
    forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            name = camelCase(name);
            if (isDefined(value)) {
                element.style[name] = value;
            } else {
                return element.style[name];
            }
        },
        attr: function(element, name, value) {
            var nodeType = element.nodeType;
            if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
                return;
            }
            var lowercasedName = lowercase(name);
            if (BOOLEAN_ATTR[lowercasedName]) {
                if (isDefined(value)) {
                    if (!!value) {
                        element[name] = true;
                        element.setAttribute(name, lowercasedName);
                    } else {
                        element[name] = false;
                        element.removeAttribute(lowercasedName);
                    }
                } else {
                    return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                }
            } else if (isDefined(value)) {
                element.setAttribute(name, value);
            } else if (element.getAttribute) {
                var ret = element.getAttribute(name, 2);
                return ret === null ? undefined : ret;
            }
        },
        prop: function(element, name, value) {
            if (isDefined(value)) {
                element[name] = value;
            } else {
                return element[name];
            }
        },
        text: function() {
            getText.$dv = "";
            return getText;
            function getText(element, value) {
                if (isUndefined(value)) {
                    var nodeType = element.nodeType;
                    return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                }
                element.textContent = value;
            }
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if (element.multiple && nodeName_(element) === "select") {
                    var result = [];
                    forEach(element.options, function(option) {
                        if (option.selected) {
                            result.push(option.value || option.text);
                        }
                    });
                    return result.length === 0 ? null : result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            if (isUndefined(value)) {
                return element.innerHTML;
            }
            jqLiteDealoc(element, true);
            element.innerHTML = value;
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key;
            var nodeCount = this.length;
            if (fn !== jqLiteEmpty && (fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2) === undefined) {
                if (isObject(arg1)) {
                    for (i = 0; i < nodeCount; i++) {
                        if (fn === jqLiteData) {
                            fn(this[i], arg1);
                        } else {
                            for (key in arg1) {
                                fn(this[i], key, arg1[key]);
                            }
                        }
                    }
                    return this;
                } else {
                    var value = fn.$dv;
                    var jj = value === undefined ? Math.min(nodeCount, 1) : nodeCount;
                    for (var j = 0; j < jj; j++) {
                        var nodeValue = fn(this[j], arg1, arg2);
                        value = value ? value + nodeValue : nodeValue;
                    }
                    return value;
                }
            } else {
                for (i = 0; i < nodeCount; i++) {
                    fn(this[i], arg1, arg2);
                }
                return this;
            }
        };
    });
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            event.isDefaultPrevented = function() {
                return event.defaultPrevented;
            };
            var eventFns = events[type || event.type];
            var eventFnsLength = eventFns ? eventFns.length : 0;
            if (!eventFnsLength) return;
            if (isUndefined(event.immediatePropagationStopped)) {
                var originalStopImmediatePropagation = event.stopImmediatePropagation;
                event.stopImmediatePropagation = function() {
                    event.immediatePropagationStopped = true;
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    if (originalStopImmediatePropagation) {
                        originalStopImmediatePropagation.call(event);
                    }
                };
            }
            event.isImmediatePropagationStopped = function() {
                return event.immediatePropagationStopped === true;
            };
            if (eventFnsLength > 1) {
                eventFns = shallowCopy(eventFns);
            }
            for (var i = 0; i < eventFnsLength; i++) {
                if (!event.isImmediatePropagationStopped()) {
                    eventFns[i].call(element, event);
                }
            }
        };
        eventHandler.elem = element;
        return eventHandler;
    }
    forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (!jqLiteAcceptsData(element)) {
                return;
            }
            var expandoStore = jqLiteExpandoStore(element, true);
            var events = expandoStore.events;
            var handle = expandoStore.handle;
            if (!handle) {
                handle = expandoStore.handle = createEventHandler(element, events);
            }
            var types = type.indexOf(" ") >= 0 ? type.split(" ") : [ type ];
            var i = types.length;
            while (i--) {
                type = types[i];
                var eventFns = events[type];
                if (!eventFns) {
                    events[type] = [];
                    if (type === "mouseenter" || type === "mouseleave") {
                        jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
                            var target = this, related = event.relatedTarget;
                            if (!related || related !== target && !target.contains(related)) {
                                handle(event, type);
                            }
                        });
                    } else {
                        if (type !== "$destroy") {
                            addEventListenerFn(element, type, handle);
                        }
                    }
                    eventFns = events[type];
                }
                eventFns.push(fn);
            }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element);
            element.on(type, function onFn() {
                element.off(type, fn);
                element.off(type, onFn);
            });
            element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element);
            forEach(new JQLite(replaceNode), function(node) {
                if (index) {
                    parent.insertBefore(node, index.nextSibling);
                } else {
                    parent.replaceChild(node, element);
                }
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            forEach(element.childNodes, function(element) {
                if (element.nodeType === NODE_TYPE_ELEMENT) children.push(element);
            });
            return children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            var nodeType = element.nodeType;
            if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) return;
            node = new JQLite(node);
            for (var i = 0, ii = node.length; i < ii; i++) {
                var child = node[i];
                element.appendChild(child);
            }
        },
        prepend: function(element, node) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index);
                });
            }
        },
        wrap: function(element, wrapNode) {
            wrapNode = jqLite(wrapNode).eq(0).clone()[0];
            var parent = element.parentNode;
            if (parent) {
                parent.replaceChild(wrapNode, element);
            }
            wrapNode.appendChild(element);
        },
        remove: jqLiteRemove,
        detach: function(element) {
            jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            newElement = new JQLite(newElement);
            for (var i = 0, ii = newElement.length; i < ii; i++) {
                var node = newElement[i];
                parent.insertBefore(node, index.nextSibling);
                index = node;
            }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            if (selector) {
                forEach(selector.split(" "), function(className) {
                    var classCondition = condition;
                    if (isUndefined(classCondition)) {
                        classCondition = !jqLiteHasClass(element, className);
                    }
                    (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
                });
            }
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
            return element.nextElementSibling;
        },
        find: function(element, selector) {
            if (element.getElementsByTagName) {
                return element.getElementsByTagName(selector);
            } else {
                return [];
            }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs;
            var eventName = event.type || event;
            var expandoStore = jqLiteExpandoStore(element);
            var events = expandoStore && expandoStore.events;
            var eventFns = events && events[eventName];
            if (eventFns) {
                dummyEvent = {
                    preventDefault: function() {
                        this.defaultPrevented = true;
                    },
                    isDefaultPrevented: function() {
                        return this.defaultPrevented === true;
                    },
                    stopImmediatePropagation: function() {
                        this.immediatePropagationStopped = true;
                    },
                    isImmediatePropagationStopped: function() {
                        return this.immediatePropagationStopped === true;
                    },
                    stopPropagation: noop,
                    type: eventName,
                    target: element
                };
                if (event.type) {
                    dummyEvent = extend(dummyEvent, event);
                }
                eventFnsCopy = shallowCopy(eventFns);
                handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ];
                forEach(eventFnsCopy, function(fn) {
                    if (!dummyEvent.isImmediatePropagationStopped()) {
                        fn.apply(element, handlerArgs);
                    }
                });
            }
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            var value;
            for (var i = 0, ii = this.length; i < ii; i++) {
                if (isUndefined(value)) {
                    value = fn(this[i], arg1, arg2, arg3);
                    if (isDefined(value)) {
                        value = jqLite(value);
                    }
                } else {
                    jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                }
            }
            return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
    });
    function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
            return extend(JQLite, {
                hasClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteHasClass(node, classes);
                },
                addClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteAddClass(node, classes);
                },
                removeClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteRemoveClass(node, classes);
                }
            });
        };
    }
    function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
            if (typeof key === "function") {
                key = obj.$$hashKey();
            }
            return key;
        }
        var objType = typeof obj;
        if (objType == "function" || objType == "object" && obj !== null) {
            key = obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)();
        } else {
            key = objType + ":" + obj;
        }
        return key;
    }
    function HashMap(array, isolatedUid) {
        if (isolatedUid) {
            var uid = 0;
            this.nextUid = function() {
                return ++uid;
            };
        }
        forEach(array, this.put, this);
    }
    HashMap.prototype = {
        put: function(key, value) {
            this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
            return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
            var value = this[key = hashKey(key, this.nextUid)];
            delete this[key];
            return value;
        }
    };
    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
    var $injectorMinErr = minErr("$injector");
    function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ""), args = fnText.match(FN_ARGS);
        if (args) {
            return "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")";
        }
        return "fn";
    }
    function annotate(fn, strictDi, name) {
        var $inject, fnText, argDecl, last;
        if (typeof fn === "function") {
            if (!($inject = fn.$inject)) {
                $inject = [];
                if (fn.length) {
                    if (strictDi) {
                        if (!isString(name) || !name) {
                            name = fn.name || anonFn(fn);
                        }
                        throw $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                    }
                    fnText = fn.toString().replace(STRIP_COMMENTS, "");
                    argDecl = fnText.match(FN_ARGS);
                    forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                        arg.replace(FN_ARG, function(all, underscore, name) {
                            $inject.push(name);
                        });
                    });
                }
                fn.$inject = $inject;
            }
        } else if (isArray(fn)) {
            last = fn.length - 1;
            assertArgFn(fn[last], "fn");
            $inject = fn.slice(0, last);
        } else {
            assertArgFn(fn, "fn", true);
        }
        return $inject;
    }
    function createInjector(modulesToLoad, strictDi) {
        strictDi = strictDi === true;
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], true), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
            if (angular.isString(caller)) {
                path.push(caller);
            }
            throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function(serviceName, caller) {
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
        });
        forEach(loadModules(modulesToLoad), function(fn) {
            instanceInjector.invoke(fn || noop);
        });
        return instanceInjector;
        function supportObject(delegate) {
            return function(key, value) {
                if (isObject(key)) {
                    forEach(key, reverseParams(delegate));
                } else {
                    return delegate(key, value);
                }
            };
        }
        function provider(name, provider_) {
            assertNotHasOwnProperty(name, "service");
            if (isFunction(provider_) || isArray(provider_)) {
                provider_ = providerInjector.instantiate(provider_);
            }
            if (!provider_.$get) {
                throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            }
            return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
            return function enforcedReturnValue() {
                var result = instanceInjector.invoke(factory, this);
                if (isUndefined(result)) {
                    throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                }
                return result;
            };
        }
        function factory(name, factoryFn, enforce) {
            return provider(name, {
                $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
            });
        }
        function service(name, constructor) {
            return factory(name, [ "$injector", function($injector) {
                return $injector.instantiate(constructor);
            } ]);
        }
        function value(name, val) {
            return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant");
            providerCache[name] = value;
            instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                });
            };
        }
        function loadModules(modulesToLoad) {
            var runBlocks = [], moduleFn;
            forEach(modulesToLoad, function(module) {
                if (loadedModules.get(module)) return;
                loadedModules.put(module, true);
                function runInvokeQueue(queue) {
                    var i, ii;
                    for (i = 0, ii = queue.length; i < ii; i++) {
                        var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                        provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                    }
                }
                try {
                    if (isString(module)) {
                        moduleFn = angularModule(module);
                        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                        runInvokeQueue(moduleFn._invokeQueue);
                        runInvokeQueue(moduleFn._configBlocks);
                    } else if (isFunction(module)) {
                        runBlocks.push(providerInjector.invoke(module));
                    } else if (isArray(module)) {
                        runBlocks.push(providerInjector.invoke(module));
                    } else {
                        assertArgFn(module, "module");
                    }
                } catch (e) {
                    if (isArray(module)) {
                        module = module[module.length - 1];
                    }
                    if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                        e = e.message + "\n" + e.stack;
                    }
                    throw $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                }
            });
            return runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName, caller) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) {
                        throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    }
                    return cache[serviceName];
                } else {
                    try {
                        path.unshift(serviceName);
                        cache[serviceName] = INSTANTIATING;
                        return cache[serviceName] = factory(serviceName, caller);
                    } catch (err) {
                        if (cache[serviceName] === INSTANTIATING) {
                            delete cache[serviceName];
                        }
                        throw err;
                    } finally {
                        path.shift();
                    }
                }
            }
            function invoke(fn, self, locals, serviceName) {
                if (typeof locals === "string") {
                    serviceName = locals;
                    locals = null;
                }
                var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName), length, i, key;
                for (i = 0, length = $inject.length; i < length; i++) {
                    key = $inject[i];
                    if (typeof key !== "string") {
                        throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    }
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                }
                if (isArray(fn)) {
                    fn = fn[length];
                }
                return fn.apply(self, args);
            }
            function instantiate(Type, locals, serviceName) {
                var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
                var returnedValue = invoke(Type, instance, locals, serviceName);
                return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: createInjector.$$annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
    }
    createInjector.$$annotate = annotate;
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = false;
        };
        this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            var document = $window.document;
            function getFirstAnchor(list) {
                var result = null;
                Array.prototype.some.call(list, function(element) {
                    if (nodeName_(element) === "a") {
                        result = element;
                        return true;
                    }
                });
                return result;
            }
            function getYOffset() {
                var offset = scroll.yOffset;
                if (isFunction(offset)) {
                    offset = offset();
                } else if (isElement(offset)) {
                    var elem = offset[0];
                    var style = $window.getComputedStyle(elem);
                    if (style.position !== "fixed") {
                        offset = 0;
                    } else {
                        offset = elem.getBoundingClientRect().bottom;
                    }
                } else if (!isNumber(offset)) {
                    offset = 0;
                }
                return offset;
            }
            function scrollTo(elem) {
                if (elem) {
                    elem.scrollIntoView();
                    var offset = getYOffset();
                    if (offset) {
                        var elemTop = elem.getBoundingClientRect().top;
                        $window.scrollBy(0, elemTop - offset);
                    }
                } else {
                    $window.scrollTo(0, 0);
                }
            }
            function scroll() {
                var hash = $location.hash(), elm;
                if (!hash) scrollTo(null); else if (elm = document.getElementById(hash)) scrollTo(elm); else if (elm = getFirstAnchor(document.getElementsByName(hash))) scrollTo(elm); else if (hash === "top") scrollTo(null);
            }
            if (autoScrollingEnabled) {
                $rootScope.$watch(function autoScrollWatch() {
                    return $location.hash();
                }, function autoScrollWatchAction(newVal, oldVal) {
                    if (newVal === oldVal && newVal === "") return;
                    jqLiteDocumentLoaded(function() {
                        $rootScope.$evalAsync(scroll);
                    });
                });
            }
            return scroll;
        } ];
    }
    var $animateMinErr = minErr("$animate");
    var $AnimateProvider = [ "$provide", function($provide) {
        this.$$selectors = {};
        this.register = function(name, factory) {
            var key = name + "-animation";
            if (name && name.charAt(0) != ".") throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            this.$$selectors[name.substr(1)] = key;
            $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
            if (arguments.length === 1) {
                this.$$classNameFilter = expression instanceof RegExp ? expression : null;
            }
            return this.$$classNameFilter;
        };
        this.$get = [ "$$q", "$$asyncCallback", "$rootScope", function($$q, $$asyncCallback, $rootScope) {
            var currentDefer;
            function runAnimationPostDigest(fn) {
                var cancelFn, defer = $$q.defer();
                defer.promise.$$cancelFn = function ngAnimateMaybeCancel() {
                    cancelFn && cancelFn();
                };
                $rootScope.$$postDigest(function ngAnimatePostDigest() {
                    cancelFn = fn(function ngAnimateNotifyComplete() {
                        defer.resolve();
                    });
                });
                return defer.promise;
            }
            function resolveElementClasses(element, classes) {
                var toAdd = [], toRemove = [];
                var hasClasses = createMap();
                forEach((element.attr("class") || "").split(/\s+/), function(className) {
                    hasClasses[className] = true;
                });
                forEach(classes, function(status, className) {
                    var hasClass = hasClasses[className];
                    if (status === false && hasClass) {
                        toRemove.push(className);
                    } else if (status === true && !hasClass) {
                        toAdd.push(className);
                    }
                });
                return toAdd.length + toRemove.length > 0 && [ toAdd.length ? toAdd : null, toRemove.length ? toRemove : null ];
            }
            function cachedClassManipulation(cache, classes, op) {
                for (var i = 0, ii = classes.length; i < ii; ++i) {
                    var className = classes[i];
                    cache[className] = op;
                }
            }
            function asyncPromise() {
                if (!currentDefer) {
                    currentDefer = $$q.defer();
                    $$asyncCallback(function() {
                        currentDefer.resolve();
                        currentDefer = null;
                    });
                }
                return currentDefer.promise;
            }
            function applyStyles(element, options) {
                if (angular.isObject(options)) {
                    var styles = extend(options.from || {}, options.to || {});
                    element.css(styles);
                }
            }
            return {
                animate: function(element, from, to) {
                    applyStyles(element, {
                        from: from,
                        to: to
                    });
                    return asyncPromise();
                },
                enter: function(element, parent, after, options) {
                    applyStyles(element, options);
                    after ? after.after(element) : parent.prepend(element);
                    return asyncPromise();
                },
                leave: function(element, options) {
                    applyStyles(element, options);
                    element.remove();
                    return asyncPromise();
                },
                move: function(element, parent, after, options) {
                    return this.enter(element, parent, after, options);
                },
                addClass: function(element, className, options) {
                    return this.setClass(element, className, [], options);
                },
                $$addClassImmediately: function(element, className, options) {
                    element = jqLite(element);
                    className = !isString(className) ? isArray(className) ? className.join(" ") : "" : className;
                    forEach(element, function(element) {
                        jqLiteAddClass(element, className);
                    });
                    applyStyles(element, options);
                    return asyncPromise();
                },
                removeClass: function(element, className, options) {
                    return this.setClass(element, [], className, options);
                },
                $$removeClassImmediately: function(element, className, options) {
                    element = jqLite(element);
                    className = !isString(className) ? isArray(className) ? className.join(" ") : "" : className;
                    forEach(element, function(element) {
                        jqLiteRemoveClass(element, className);
                    });
                    applyStyles(element, options);
                    return asyncPromise();
                },
                setClass: function(element, add, remove, options) {
                    var self = this;
                    var STORAGE_KEY = "$$animateClasses";
                    var createdCache = false;
                    element = jqLite(element);
                    var cache = element.data(STORAGE_KEY);
                    if (!cache) {
                        cache = {
                            classes: {},
                            options: options
                        };
                        createdCache = true;
                    } else if (options && cache.options) {
                        cache.options = angular.extend(cache.options || {}, options);
                    }
                    var classes = cache.classes;
                    add = isArray(add) ? add : add.split(" ");
                    remove = isArray(remove) ? remove : remove.split(" ");
                    cachedClassManipulation(classes, add, true);
                    cachedClassManipulation(classes, remove, false);
                    if (createdCache) {
                        cache.promise = runAnimationPostDigest(function(done) {
                            var cache = element.data(STORAGE_KEY);
                            element.removeData(STORAGE_KEY);
                            if (cache) {
                                var classes = resolveElementClasses(element, cache.classes);
                                if (classes) {
                                    self.$$setClassImmediately(element, classes[0], classes[1], cache.options);
                                }
                            }
                            done();
                        });
                        element.data(STORAGE_KEY, cache);
                    }
                    return cache.promise;
                },
                $$setClassImmediately: function(element, add, remove, options) {
                    add && this.$$addClassImmediately(element, add);
                    remove && this.$$removeClassImmediately(element, remove);
                    applyStyles(element, options);
                    return asyncPromise();
                },
                enabled: noop,
                cancel: noop
            };
        } ];
    } ];
    function $$AsyncCallbackProvider() {
        this.$get = [ "$$rAF", "$timeout", function($$rAF, $timeout) {
            return $$rAF.supported ? function(fn) {
                return $$rAF(fn);
            } : function(fn) {
                return $timeout(fn, 0, false);
            };
        } ];
    }
    function Browser(window, document, $log, $sniffer) {
        var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
            outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                outstandingRequestCount--;
                if (outstandingRequestCount === 0) {
                    while (outstandingRequestCallbacks.length) {
                        try {
                            outstandingRequestCallbacks.pop()();
                        } catch (e) {
                            $log.error(e);
                        }
                    }
                }
            }
        }
        function getHash(url) {
            var index = url.indexOf("#");
            return index === -1 ? "" : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
            forEach(pollFns, function(pollFn) {
                pollFn();
            });
            if (outstandingRequestCount === 0) {
                callback();
            } else {
                outstandingRequestCallbacks.push(callback);
            }
        };
        var pollFns = [], pollTimeout;
        self.addPollFn = function(fn) {
            if (isUndefined(pollTimeout)) startPoller(100, setTimeout);
            pollFns.push(fn);
            return fn;
        };
        function startPoller(interval, setTimeout) {
            (function check() {
                forEach(pollFns, function(pollFn) {
                    pollFn();
                });
                pollTimeout = setTimeout(check, interval);
            })();
        }
        var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), reloadLocation = null;
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
            if (isUndefined(state)) {
                state = null;
            }
            if (location !== window.location) location = window.location;
            if (history !== window.history) history = window.history;
            if (url) {
                var sameState = lastHistoryState === state;
                if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
                    return self;
                }
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                lastBrowserUrl = url;
                lastHistoryState = state;
                if ($sniffer.history && (!sameBase || !sameState)) {
                    history[replace ? "replaceState" : "pushState"](state, "", url);
                    cacheState();
                    lastHistoryState = cachedState;
                } else {
                    if (!sameBase || reloadLocation) {
                        reloadLocation = url;
                    }
                    if (replace) {
                        location.replace(url);
                    } else if (!sameBase) {
                        location.href = url;
                    } else {
                        location.hash = getHash(url);
                    }
                }
                return self;
            } else {
                return reloadLocation || location.href.replace(/%27/g, "'");
            }
        };
        self.state = function() {
            return cachedState;
        };
        var urlChangeListeners = [], urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
            cacheState();
            fireUrlChange();
        }
        function getCurrentState() {
            try {
                return history.state;
            } catch (e) {}
        }
        var lastCachedState = null;
        function cacheState() {
            cachedState = getCurrentState();
            cachedState = isUndefined(cachedState) ? null : cachedState;
            if (equals(cachedState, lastCachedState)) {
                cachedState = lastCachedState;
            }
            lastCachedState = cachedState;
        }
        function fireUrlChange() {
            if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
                return;
            }
            lastBrowserUrl = self.url();
            lastHistoryState = cachedState;
            forEach(urlChangeListeners, function(listener) {
                listener(self.url(), cachedState);
            });
        }
        self.onUrlChange = function(callback) {
            if (!urlChangeInit) {
                if ($sniffer.history) jqLite(window).on("popstate", cacheStateAndFireUrlChange);
                jqLite(window).on("hashchange", cacheStateAndFireUrlChange);
                urlChangeInit = true;
            }
            urlChangeListeners.push(callback);
            return callback;
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : "";
        };
        var lastCookies = {};
        var lastCookieString = "";
        var cookiePath = self.baseHref();
        function safeDecodeURIComponent(str) {
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return str;
            }
        }
        self.cookies = function(name, value) {
            var cookieLength, cookieArray, cookie, i, index;
            if (name) {
                if (value === undefined) {
                    rawDocument.cookie = encodeURIComponent(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT";
                } else {
                    if (isString(value)) {
                        cookieLength = (rawDocument.cookie = encodeURIComponent(name) + "=" + encodeURIComponent(value) + ";path=" + cookiePath).length + 1;
                        if (cookieLength > 4096) {
                            $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!");
                        }
                    }
                }
            } else {
                if (rawDocument.cookie !== lastCookieString) {
                    lastCookieString = rawDocument.cookie;
                    cookieArray = lastCookieString.split("; ");
                    lastCookies = {};
                    for (i = 0; i < cookieArray.length; i++) {
                        cookie = cookieArray[i];
                        index = cookie.indexOf("=");
                        if (index > 0) {
                            name = safeDecodeURIComponent(cookie.substring(0, index));
                            if (lastCookies[name] === undefined) {
                                lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                            }
                        }
                    }
                }
                return lastCookies;
            }
        };
        self.defer = function(fn, delay) {
            var timeoutId;
            outstandingRequestCount++;
            timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId];
                completeOutstandingRequest(fn);
            }, delay || 0);
            pendingDeferIds[timeoutId] = true;
            return timeoutId;
        };
        self.defer.cancel = function(deferId) {
            if (pendingDeferIds[deferId]) {
                delete pendingDeferIds[deferId];
                clearTimeout(deferId);
                completeOutstandingRequest(noop);
                return true;
            }
            return false;
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            var caches = {};
            function cacheFactory(cacheId, options) {
                if (cacheId in caches) {
                    throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                }
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key] || (lruHash[key] = {
                                key: key
                            });
                            refresh(lruEntry);
                        }
                        if (isUndefined(value)) return;
                        if (!(key in data)) size++;
                        data[key] = value;
                        if (size > capacity) {
                            this.remove(staleEnd.key);
                        }
                        return value;
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            if (lruEntry == freshEnd) freshEnd = lruEntry.p;
                            if (lruEntry == staleEnd) staleEnd = lruEntry.n;
                            link(lruEntry.n, lruEntry.p);
                            delete lruHash[key];
                        }
                        delete data[key];
                        size--;
                    },
                    removeAll: function() {
                        data = {};
                        size = 0;
                        lruHash = {};
                        freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        data = null;
                        stats = null;
                        lruHash = null;
                        delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
                function refresh(entry) {
                    if (entry != freshEnd) {
                        if (!staleEnd) {
                            staleEnd = entry;
                        } else if (staleEnd == entry) {
                            staleEnd = entry.n;
                        }
                        link(entry.n, entry.p);
                        link(entry, freshEnd);
                        freshEnd = entry;
                        freshEnd.n = null;
                    }
                }
                function link(nextEntry, prevEntry) {
                    if (nextEntry != prevEntry) {
                        if (nextEntry) nextEntry.p = prevEntry;
                        if (prevEntry) prevEntry.n = nextEntry;
                    }
                }
            }
            cacheFactory.info = function() {
                var info = {};
                forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                });
                return info;
            };
            cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            };
            return cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    var $compileMinErr = minErr("$compile");
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ];
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        function parseIsolateBindings(scope, directiveName) {
            var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
            var bindings = {};
            forEach(scope, function(definition, scopeName) {
                var match = definition.match(LOCAL_REGEXP);
                if (!match) {
                    throw $compileMinErr("iscp", "Invalid isolate scope definition for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition);
                }
                bindings[scopeName] = {
                    mode: match[1][0],
                    collection: match[2] === "*",
                    optional: match[3] === "?",
                    attrName: match[4] || scopeName
                };
            });
            return bindings;
        }
        this.directive = function registerDirective(name, directiveFactory) {
            assertNotHasOwnProperty(name, "directive");
            if (isString(name)) {
                assertArg(directiveFactory, "directiveFactory");
                if (!hasDirectives.hasOwnProperty(name)) {
                    hasDirectives[name] = [];
                    $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                        var directives = [];
                        forEach(hasDirectives[name], function(directiveFactory, index) {
                            try {
                                var directive = $injector.invoke(directiveFactory);
                                if (isFunction(directive)) {
                                    directive = {
                                        compile: valueFn(directive)
                                    };
                                } else if (!directive.compile && directive.link) {
                                    directive.compile = valueFn(directive.link);
                                }
                                directive.priority = directive.priority || 0;
                                directive.index = index;
                                directive.name = directive.name || name;
                                directive.require = directive.require || directive.controller && directive.name;
                                directive.restrict = directive.restrict || "EA";
                                if (isObject(directive.scope)) {
                                    directive.$$isolateBindings = parseIsolateBindings(directive.scope, directive.name);
                                }
                                directives.push(directive);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        });
                        return directives;
                    } ]);
                }
                hasDirectives[name].push(directiveFactory);
            } else {
                forEach(name, reverseParams(registerDirective));
            }
            return this;
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
                return this;
            } else {
                return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
            }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
                return this;
            } else {
                return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
            }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
            if (isDefined(enabled)) {
                debugInfoEnabled = enabled;
                return this;
            }
            return debugInfoEnabled;
        };
        this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
            var Attributes = function(element, attributesToCopy) {
                if (attributesToCopy) {
                    var keys = Object.keys(attributesToCopy);
                    var i, l, key;
                    for (i = 0, l = keys.length; i < l; i++) {
                        key = keys[i];
                        this[key] = attributesToCopy[key];
                    }
                } else {
                    this.$attr = {};
                }
                this.$$element = element;
            };
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.addClass(this.$$element, classVal);
                    }
                },
                $removeClass: function(classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.removeClass(this.$$element, classVal);
                    }
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses);
                    if (toAdd && toAdd.length) {
                        $animate.addClass(this.$$element, toAdd);
                    }
                    var toRemove = tokenDifference(oldClasses, newClasses);
                    if (toRemove && toRemove.length) {
                        $animate.removeClass(this.$$element, toRemove);
                    }
                },
                $set: function(key, value, writeAttr, attrName) {
                    var node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(node, key), observer = key, nodeName;
                    if (booleanKey) {
                        this.$$element.prop(key, value);
                        attrName = booleanKey;
                    } else if (aliasedKey) {
                        this[aliasedKey] = value;
                        observer = aliasedKey;
                    }
                    this[key] = value;
                    if (attrName) {
                        this.$attr[key] = attrName;
                    } else {
                        attrName = this.$attr[key];
                        if (!attrName) {
                            this.$attr[key] = attrName = snake_case(key, "-");
                        }
                    }
                    nodeName = nodeName_(this.$$element);
                    if (nodeName === "a" && key === "href" || nodeName === "img" && key === "src") {
                        this[key] = value = $$sanitizeUri(value, key === "src");
                    } else if (nodeName === "img" && key === "srcset") {
                        var result = "";
                        var trimmedSrcset = trim(value);
                        var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                        var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                        var rawUris = trimmedSrcset.split(pattern);
                        var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                        for (var i = 0; i < nbrUrisWith2parts; i++) {
                            var innerIdx = i * 2;
                            result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                            result += " " + trim(rawUris[innerIdx + 1]);
                        }
                        var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                        result += $$sanitizeUri(trim(lastTuple[0]), true);
                        if (lastTuple.length === 2) {
                            result += " " + trim(lastTuple[1]);
                        }
                        this[key] = value = result;
                    }
                    if (writeAttr !== false) {
                        if (value === null || value === undefined) {
                            this.$$element.removeAttr(attrName);
                        } else {
                            this.$$element.attr(attrName, value);
                        }
                    }
                    var $$observers = this.$$observers;
                    $$observers && forEach($$observers[observer], function(fn) {
                        try {
                            fn(value);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                    listeners.push(fn);
                    $rootScope.$evalAsync(function() {
                        if (!listeners.$$inter && attrs.hasOwnProperty(key)) {
                            fn(attrs[key]);
                        }
                    });
                    return function() {
                        arrayRemove(listeners, fn);
                    };
                }
            };
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol == "{{" || endSymbol == "}}" ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
            compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
                var bindings = $element.data("$binding") || [];
                if (isArray(binding)) {
                    bindings = bindings.concat(binding);
                } else {
                    bindings.push(binding);
                }
                $element.data("$binding", bindings);
            } : noop;
            compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
                safeAddClass($element, "ng-binding");
            } : noop;
            compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope);
            } : noop;
            compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
                safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
            } : noop;
            return compile;
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                if (!($compileNodes instanceof jqLite)) {
                    $compileNodes = jqLite($compileNodes);
                }
                forEach($compileNodes, function(node, index) {
                    if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/)) {
                        $compileNodes[index] = jqLite(node).wrap("<span></span>").parent()[0];
                    }
                });
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function publicLinkFn(scope, cloneConnectFn, options) {
                    assertArg(scope, "scope");
                    options = options || {};
                    var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                    if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                        parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                    }
                    if (!namespace) {
                        namespace = detectNamespaceForChildElements(futureParentElement);
                    }
                    var $linkNode;
                    if (namespace !== "html") {
                        $linkNode = jqLite(wrapTemplate(namespace, jqLite("<div>").append($compileNodes).html()));
                    } else if (cloneConnectFn) {
                        $linkNode = JQLitePrototype.clone.call($compileNodes);
                    } else {
                        $linkNode = $compileNodes;
                    }
                    if (transcludeControllers) {
                        for (var controllerName in transcludeControllers) {
                            $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                        }
                    }
                    compile.$$addScopeInfo($linkNode, scope);
                    if (cloneConnectFn) cloneConnectFn($linkNode, scope);
                    if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                    return $linkNode;
                };
            }
            function detectNamespaceForChildElements(parentElement) {
                var node = parentElement && parentElement[0];
                if (!node) {
                    return "html";
                } else {
                    return nodeName_(node) !== "foreignobject" && node.toString().match(/SVG/) ? "svg" : "html";
                }
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                var linkFns = [], attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
                for (var i = 0; i < nodeList.length; i++) {
                    attrs = new Attributes();
                    directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
                    nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
                    if (nodeLinkFn && nodeLinkFn.scope) {
                        compile.$$addScopeClass(attrs.$$element);
                    }
                    childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
                    if (nodeLinkFn || childLinkFn) {
                        linkFns.push(i, nodeLinkFn, childLinkFn);
                        linkFnFound = true;
                        nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                    }
                    previousCompileContext = null;
                }
                return linkFnFound ? compositeLinkFn : null;
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
                    var stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        stableNodeList = new Array(nodeListLength);
                        for (i = 0; i < linkFns.length; i += 3) {
                            idx = linkFns[i];
                            stableNodeList[idx] = nodeList[idx];
                        }
                    } else {
                        stableNodeList = nodeList;
                    }
                    for (i = 0, ii = linkFns.length; i < ii; ) {
                        node = stableNodeList[linkFns[i++]];
                        nodeLinkFn = linkFns[i++];
                        childLinkFn = linkFns[i++];
                        if (nodeLinkFn) {
                            if (nodeLinkFn.scope) {
                                childScope = scope.$new();
                                compile.$$addScopeInfo(jqLite(node), childScope);
                            } else {
                                childScope = scope;
                            }
                            if (nodeLinkFn.transcludeOnThisElement) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn, nodeLinkFn.elementTranscludeOnThisElement);
                            } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                                childBoundTranscludeFn = parentBoundTranscludeFn;
                            } else if (!parentBoundTranscludeFn && transcludeFn) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                            } else {
                                childBoundTranscludeFn = null;
                            }
                            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                        } else if (childLinkFn) {
                            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                        }
                    }
                }
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn, elementTransclusion) {
                var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    if (!transcludedScope) {
                        transcludedScope = scope.$new(false, containingScope);
                        transcludedScope.$$transcluded = true;
                    }
                    return transcludeFn(transcludedScope, cloneFn, {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    });
                };
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var nodeType = node.nodeType, attrsMap = attrs.$attr, match, className;
                switch (nodeType) {
                  case NODE_TYPE_ELEMENT:
                    addDirective(directives, directiveNormalize(nodeName_(node)), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                        var attrStartName = false;
                        var attrEndName = false;
                        attr = nAttrs[j];
                        name = attr.name;
                        value = trim(attr.value);
                        ngAttrName = directiveNormalize(name);
                        if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                            name = name.replace(PREFIX_REGEXP, "").substr(8).replace(/_(.)/g, function(match, letter) {
                                return letter.toUpperCase();
                            });
                        }
                        var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
                        if (directiveIsMultiElement(directiveNName)) {
                            if (ngAttrName === directiveNName + "Start") {
                                attrStartName = name;
                                attrEndName = name.substr(0, name.length - 5) + "end";
                                name = name.substr(0, name.length - 6);
                            }
                        }
                        nName = directiveNormalize(name.toLowerCase());
                        attrsMap[nName] = name;
                        if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                            attrs[nName] = value;
                            if (getBooleanAttrName(node, nName)) {
                                attrs[nName] = true;
                            }
                        }
                        addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                        addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                    }
                    className = node.className;
                    if (isObject(className)) {
                        className = className.animVal;
                    }
                    if (isString(className) && className !== "") {
                        while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                            nName = directiveNormalize(match[2]);
                            if (addDirective(directives, nName, "C", maxPriority, ignoreDirective)) {
                                attrs[nName] = trim(match[3]);
                            }
                            className = className.substr(match.index + match[0].length);
                        }
                    }
                    break;

                  case NODE_TYPE_TEXT:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;

                  case NODE_TYPE_COMMENT:
                    try {
                        match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                        if (match) {
                            nName = directiveNormalize(match[1]);
                            if (addDirective(directives, nName, "M", maxPriority, ignoreDirective)) {
                                attrs[nName] = trim(match[2]);
                            }
                        }
                    } catch (e) {}
                    break;
                }
                directives.sort(byPriority);
                return directives;
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [];
                var depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    do {
                        if (!node) {
                            throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                        }
                        if (node.nodeType == NODE_TYPE_ELEMENT) {
                            if (node.hasAttribute(attrStart)) depth++;
                            if (node.hasAttribute(attrEnd)) depth--;
                        }
                        nodes.push(node);
                        node = node.nextSibling;
                    } while (depth > 0);
                } else {
                    nodes.push(node);
                }
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function(scope, element, attrs, controllers, transcludeFn) {
                    element = groupScan(element[0], attrStart, attrEnd);
                    return linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                previousCompileContext = previousCompileContext || {};
                var terminalPriority = -Number.MAX_VALUE, newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, controllers, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, directiveValue;
                for (var i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start;
                    var attrEnd = directive.$$end;
                    if (attrStart) {
                        $compileNode = groupScan(compileNode, attrStart, attrEnd);
                    }
                    $template = undefined;
                    if (terminalPriority > directive.priority) {
                        break;
                    }
                    if (directiveValue = directive.scope) {
                        if (!directive.templateUrl) {
                            if (isObject(directiveValue)) {
                                assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                                newIsolateScopeDirective = directive;
                            } else {
                                assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode);
                            }
                        }
                        newScopeDirective = newScopeDirective || directive;
                    }
                    directiveName = directive.name;
                    if (!directive.templateUrl && directive.controller) {
                        directiveValue = directive.controller;
                        controllerDirectives = controllerDirectives || {};
                        assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                        controllerDirectives[directiveName] = directive;
                    }
                    if (directiveValue = directive.transclude) {
                        hasTranscludeDirective = true;
                        if (!directive.$$tlb) {
                            assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode);
                            nonTlbTranscludeDirective = directive;
                        }
                        if (directiveValue == "element") {
                            hasElementTranscludeDirective = true;
                            terminalPriority = directive.priority;
                            $template = $compileNode;
                            $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " "));
                            compileNode = $compileNode[0];
                            replaceWith(jqCollection, sliceArgs($template), compileNode);
                            childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                nonTlbTranscludeDirective: nonTlbTranscludeDirective
                            });
                        } else {
                            $template = jqLite(jqLiteClone(compileNode)).contents();
                            $compileNode.empty();
                            childTranscludeFn = compile($template, transcludeFn);
                        }
                    }
                    if (directive.template) {
                        hasTemplate = true;
                        assertNoDuplicate("template", templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
                        directiveValue = denormalizeTemplate(directiveValue);
                        if (directive.replace) {
                            replaceDirective = directive;
                            if (jqLiteIsTextNode(directiveValue)) {
                                $template = [];
                            } else {
                                $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                            }
                            compileNode = $template[0];
                            if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                            }
                            replaceWith(jqCollection, $compileNode, compileNode);
                            var newTemplateAttrs = {
                                $attr: {}
                            };
                            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                            if (newIsolateScopeDirective) {
                                markDirectivesAsIsolate(templateDirectives);
                            }
                            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                            ii = directives.length;
                        } else {
                            $compileNode.html(directiveValue);
                        }
                    }
                    if (directive.templateUrl) {
                        hasTemplate = true;
                        assertNoDuplicate("template", templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        if (directive.replace) {
                            replaceDirective = directive;
                        }
                        nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                            controllerDirectives: controllerDirectives,
                            newIsolateScopeDirective: newIsolateScopeDirective,
                            templateDirective: templateDirective,
                            nonTlbTranscludeDirective: nonTlbTranscludeDirective
                        });
                        ii = directives.length;
                    } else if (directive.compile) {
                        try {
                            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                            if (isFunction(linkFn)) {
                                addLinkFns(null, linkFn, attrStart, attrEnd);
                            } else if (linkFn) {
                                addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                            }
                        } catch (e) {
                            $exceptionHandler(e, startingTag($compileNode));
                        }
                    }
                    if (directive.terminal) {
                        nodeLinkFn.terminal = true;
                        terminalPriority = Math.max(terminalPriority, directive.priority);
                    }
                }
                nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
                nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
                nodeLinkFn.elementTranscludeOnThisElement = hasElementTranscludeDirective;
                nodeLinkFn.templateOnThisElement = hasTemplate;
                nodeLinkFn.transclude = childTranscludeFn;
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                return nodeLinkFn;
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    if (pre) {
                        if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                        pre.require = directive.require;
                        pre.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            pre = cloneAndAnnotateFn(pre, {
                                isolateScope: true
                            });
                        }
                        preLinkFns.push(pre);
                    }
                    if (post) {
                        if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                        post.require = directive.require;
                        post.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            post = cloneAndAnnotateFn(post, {
                                isolateScope: true
                            });
                        }
                        postLinkFns.push(post);
                    }
                }
                function getControllers(directiveName, require, $element, elementControllers) {
                    var value, retrievalMethod = "data", optional = false;
                    var $searchElement = $element;
                    var match;
                    if (isString(require)) {
                        match = require.match(REQUIRE_PREFIX_REGEXP);
                        require = require.substring(match[0].length);
                        if (match[3]) {
                            if (match[1]) match[3] = null; else match[1] = match[3];
                        }
                        if (match[1] === "^") {
                            retrievalMethod = "inheritedData";
                        } else if (match[1] === "^^") {
                            retrievalMethod = "inheritedData";
                            $searchElement = $element.parent();
                        }
                        if (match[2] === "?") {
                            optional = true;
                        }
                        value = null;
                        if (elementControllers && retrievalMethod === "data") {
                            if (value = elementControllers[require]) {
                                value = value.instance;
                            }
                        }
                        value = value || $searchElement[retrievalMethod]("$" + require + "Controller");
                        if (!value && !optional) {
                            throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName);
                        }
                        return value || null;
                    } else if (isArray(require)) {
                        value = [];
                        forEach(require, function(require) {
                            value.push(getControllers(directiveName, require, $element, elementControllers));
                        });
                    }
                    return value;
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    var i, ii, linkFn, controller, isolateScope, elementControllers, transcludeFn, $element, attrs;
                    if (compileNode === linkNode) {
                        attrs = templateAttrs;
                        $element = templateAttrs.$$element;
                    } else {
                        $element = jqLite(linkNode);
                        attrs = new Attributes($element, templateAttrs);
                    }
                    if (newIsolateScopeDirective) {
                        isolateScope = scope.$new(true);
                    }
                    if (boundTranscludeFn) {
                        transcludeFn = controllersBoundTransclude;
                        transcludeFn.$$boundTransclude = boundTranscludeFn;
                    }
                    if (controllerDirectives) {
                        controllers = {};
                        elementControllers = {};
                        forEach(controllerDirectives, function(directive) {
                            var locals = {
                                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                $element: $element,
                                $attrs: attrs,
                                $transclude: transcludeFn
                            }, controllerInstance;
                            controller = directive.controller;
                            if (controller == "@") {
                                controller = attrs[directive.name];
                            }
                            controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                            elementControllers[directive.name] = controllerInstance;
                            if (!hasElementTranscludeDirective) {
                                $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                            }
                            controllers[directive.name] = controllerInstance;
                        });
                    }
                    if (newIsolateScopeDirective) {
                        compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                        compile.$$addScopeClass($element, true);
                        var isolateScopeController = controllers && controllers[newIsolateScopeDirective.name];
                        var isolateBindingContext = isolateScope;
                        if (isolateScopeController && isolateScopeController.identifier && newIsolateScopeDirective.bindToController === true) {
                            isolateBindingContext = isolateScopeController.instance;
                        }
                        forEach(isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, function(definition, scopeName) {
                            var attrName = definition.attrName, optional = definition.optional, mode = definition.mode, lastValue, parentGet, parentSet, compare;
                            switch (mode) {
                              case "@":
                                attrs.$observe(attrName, function(value) {
                                    isolateBindingContext[scopeName] = value;
                                });
                                attrs.$$observers[attrName].$$scope = scope;
                                if (attrs[attrName]) {
                                    isolateBindingContext[scopeName] = $interpolate(attrs[attrName])(scope);
                                }
                                break;

                              case "=":
                                if (optional && !attrs[attrName]) {
                                    return;
                                }
                                parentGet = $parse(attrs[attrName]);
                                if (parentGet.literal) {
                                    compare = equals;
                                } else {
                                    compare = function(a, b) {
                                        return a === b || a !== a && b !== b;
                                    };
                                }
                                parentSet = parentGet.assign || function() {
                                    lastValue = isolateBindingContext[scopeName] = parentGet(scope);
                                    throw $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], newIsolateScopeDirective.name);
                                };
                                lastValue = isolateBindingContext[scopeName] = parentGet(scope);
                                var parentValueWatch = function parentValueWatch(parentValue) {
                                    if (!compare(parentValue, isolateBindingContext[scopeName])) {
                                        if (!compare(parentValue, lastValue)) {
                                            isolateBindingContext[scopeName] = parentValue;
                                        } else {
                                            parentSet(scope, parentValue = isolateBindingContext[scopeName]);
                                        }
                                    }
                                    return lastValue = parentValue;
                                };
                                parentValueWatch.$stateful = true;
                                var unwatch;
                                if (definition.collection) {
                                    unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                                } else {
                                    unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                                }
                                isolateScope.$on("$destroy", unwatch);
                                break;

                              case "&":
                                parentGet = $parse(attrs[attrName]);
                                isolateBindingContext[scopeName] = function(locals) {
                                    return parentGet(scope, locals);
                                };
                                break;
                            }
                        });
                    }
                    if (controllers) {
                        forEach(controllers, function(controller) {
                            controller();
                        });
                        controllers = null;
                    }
                    for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                        linkFn = preLinkFns[i];
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    }
                    var scopeToChild = scope;
                    if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                        scopeToChild = isolateScope;
                    }
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
                    for (i = postLinkFns.length - 1; i >= 0; i--) {
                        linkFn = postLinkFns[i];
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    }
                    function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                        var transcludeControllers;
                        if (!isScope(scope)) {
                            futureParentElement = cloneAttachFn;
                            cloneAttachFn = scope;
                            scope = undefined;
                        }
                        if (hasElementTranscludeDirective) {
                            transcludeControllers = elementControllers;
                        }
                        if (!futureParentElement) {
                            futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                        }
                        return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                    }
                }
            }
            function markDirectivesAsIsolate(directives) {
                for (var j = 0, jj = directives.length; j < jj; j++) {
                    directives[j] = inherit(directives[j], {
                        $$isolateScope: true
                    });
                }
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective) return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        try {
                            directive = directives[i];
                            if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                                if (startAttrName) {
                                    directive = inherit(directive, {
                                        $$start: startAttrName,
                                        $$end: endAttrName
                                    });
                                }
                                tDirectives.push(directive);
                                match = directive;
                            }
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                }
                return match;
            }
            function directiveIsMultiElement(name) {
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        directive = directives[i];
                        if (directive.multiElement) {
                            return true;
                        }
                    }
                }
                return false;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
                forEach(dst, function(value, key) {
                    if (key.charAt(0) != "$") {
                        if (src[key] && src[key] !== value) {
                            value += (key === "style" ? ";" : " ") + src[key];
                        }
                        dst.$set(key, value, true, srcAttr[key]);
                    }
                });
                forEach(src, function(value, key) {
                    if (key == "class") {
                        safeAddClass($element, value);
                        dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value;
                    } else if (key == "style") {
                        $element.attr("style", $element.attr("style") + ";" + value);
                        dst["style"] = (dst["style"] ? dst["style"] + ";" : "") + value;
                    } else if (key.charAt(0) != "$" && !dst.hasOwnProperty(key)) {
                        dst[key] = value;
                        dstAttr[key] = srcAttr[key];
                    }
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                $compileNode.empty();
                $templateRequest(templateUrl).then(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    content = denormalizeTemplate(content);
                    if (origAsyncDirective.replace) {
                        if (jqLiteIsTextNode(content)) {
                            $template = [];
                        } else {
                            $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                        }
                        compileNode = $template[0];
                        if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                            throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        }
                        tempTemplateAttrs = {
                            $attr: {}
                        };
                        replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        if (isObject(origAsyncDirective.scope)) {
                            markDirectivesAsIsolate(templateDirectives);
                        }
                        directives = templateDirectives.concat(directives);
                        mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else {
                        compileNode = beforeTemplateCompileNode;
                        $compileNode.html(content);
                    }
                    directives.unshift(derivedSyncDirective);
                    afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                    forEach($rootElement, function(node, i) {
                        if (node == compileNode) {
                            $rootElement[i] = $compileNode[0];
                        }
                    });
                    afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
                    while (linkQueue.length) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (scope.$$destroyed) continue;
                        if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                            var oldClasses = beforeTemplateLinkNode.className;
                            if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                                linkNode = jqLiteClone(compileNode);
                            }
                            replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                            safeAddClass(jqLite(linkNode), oldClasses);
                        }
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        } else {
                            childBoundTranscludeFn = boundTranscludeFn;
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                    }
                    linkQueue = null;
                });
                return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    if (scope.$$destroyed) return;
                    if (linkQueue) {
                        linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
                    } else {
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
                    }
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                if (diff !== 0) return diff;
                if (a.name !== b.name) return a.name < b.name ? -1 : 1;
                return a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                if (previousDirective) {
                    throw $compileMinErr("multidir", "Multiple directives [{0}, {1}] asking for {2} on: {3}", previousDirective.name, directive.name, what, startingTag(element));
                }
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, true);
                if (interpolateFn) {
                    directives.push({
                        priority: 0,
                        compile: function textInterpolateCompileFn(templateNode) {
                            var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                            if (hasCompileParent) compile.$$addBindingClass(templateNodeParent);
                            return function textInterpolateLinkFn(scope, node) {
                                var parent = node.parent();
                                if (!hasCompileParent) compile.$$addBindingClass(parent);
                                compile.$$addBindingInfo(parent, interpolateFn.expressions);
                                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                    node[0].nodeValue = value;
                                });
                            };
                        }
                    });
                }
            }
            function wrapTemplate(type, template) {
                type = lowercase(type || "html");
                switch (type) {
                  case "svg":
                  case "math":
                    var wrapper = document.createElement("div");
                    wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">";
                    return wrapper.childNodes[0].childNodes;

                  default:
                    return template;
                }
            }
            function getTrustedContext(node, attrNormalizedName) {
                if (attrNormalizedName == "srcdoc") {
                    return $sce.HTML;
                }
                var tag = nodeName_(node);
                if (attrNormalizedName == "xlinkHref" || tag == "form" && attrNormalizedName == "action" || tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc")) {
                    return $sce.RESOURCE_URL;
                }
            }
            function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
                var trustedContext = getTrustedContext(node, name);
                allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
                var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
                if (!interpolateFn) return;
                if (name === "multiple" && nodeName_(node) === "select") {
                    throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                }
                directives.push({
                    priority: 100,
                    compile: function() {
                        return {
                            pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                                var $$observers = attr.$$observers || (attr.$$observers = {});
                                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                                    throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                                }
                                var newValue = attr[name];
                                if (newValue !== value) {
                                    interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                                    value = newValue;
                                }
                                if (!interpolateFn) return;
                                attr[name] = interpolateFn(scope);
                                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                                (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                                    if (name === "class" && newValue != oldValue) {
                                        attr.$updateClass(newValue, oldValue);
                                    } else {
                                        attr.$set(name, newValue);
                                    }
                                });
                            }
                        };
                    }
                });
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii;
                if ($rootElement) {
                    for (i = 0, ii = $rootElement.length; i < ii; i++) {
                        if ($rootElement[i] == firstElementToRemove) {
                            $rootElement[i++] = newNode;
                            for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, 
                            j2++) {
                                if (j2 < jj) {
                                    $rootElement[j] = $rootElement[j2];
                                } else {
                                    delete $rootElement[j];
                                }
                            }
                            $rootElement.length -= removeCount - 1;
                            if ($rootElement.context === firstElementToRemove) {
                                $rootElement.context = newNode;
                            }
                            break;
                        }
                    }
                }
                if (parent) {
                    parent.replaceChild(newNode, firstElementToRemove);
                }
                var fragment = document.createDocumentFragment();
                fragment.appendChild(firstElementToRemove);
                jqLite(newNode).data(jqLite(firstElementToRemove).data());
                if (!jQuery) {
                    delete jqLite.cache[firstElementToRemove[jqLite.expando]];
                } else {
                    skipDestroyOnNextJQueryCleanData = true;
                    jQuery.cleanData([ firstElementToRemove ]);
                }
                for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
                    var element = elementsToRemove[k];
                    jqLite(element).remove();
                    fragment.appendChild(element);
                    delete elementsToRemove[k];
                }
                elementsToRemove[0] = newNode;
                elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    linkFn(scope, $element, attrs, controllers, transcludeFn);
                } catch (e) {
                    $exceptionHandler(e, startingTag($element));
                }
            }
        } ];
    }
    var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ""));
    }
    function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
    function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            var token = tokens1[i];
            for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j]) continue outer;
            }
            values += (values.length > 0 ? " " : "") + token;
        }
        return values;
    }
    function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
            return jqNodes;
        }
        while (i--) {
            var node = jqNodes[i];
            if (node.nodeType === NODE_TYPE_COMMENT) {
                splice.call(jqNodes, i, 1);
            }
        }
        return jqNodes;
    }
    var $controllerMinErr = minErr("$controller");
    function $ControllerProvider() {
        var controllers = {}, globals = false, CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
        this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller");
            if (isObject(name)) {
                extend(controllers, name);
            } else {
                controllers[name] = constructor;
            }
        };
        this.allowGlobals = function() {
            globals = true;
        };
        this.$get = [ "$injector", "$window", function($injector, $window) {
            return function(expression, locals, later, ident) {
                var instance, match, constructor, identifier;
                later = later === true;
                if (ident && isString(ident)) {
                    identifier = ident;
                }
                if (isString(expression)) {
                    match = expression.match(CNTRL_REG);
                    if (!match) {
                        throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
                    }
                    constructor = match[1], identifier = identifier || match[3];
                    expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
                    assertArgFn(expression, constructor, true);
                }
                if (later) {
                    var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                    instance = Object.create(controllerPrototype || null);
                    if (identifier) {
                        addIdentifier(locals, identifier, instance, constructor || expression.name);
                    }
                    return extend(function() {
                        $injector.invoke(expression, instance, locals, constructor);
                        return instance;
                    }, {
                        instance: instance,
                        identifier: identifier
                    });
                }
                instance = $injector.instantiate(expression, locals, constructor);
                if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                }
                return instance;
            };
            function addIdentifier(locals, identifier, instance, name) {
                if (!(locals && isObject(locals.$scope))) {
                    throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                }
                locals.$scope[identifier] = instance;
            }
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function(exception, cause) {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    var APPLICATION_JSON = "application/json";
    var CONTENT_TYPE_APPLICATION_JSON = {
        "Content-Type": APPLICATION_JSON + ";charset=utf-8"
    };
    var JSON_START = /^\[|^\{(?!\{)/;
    var JSON_ENDS = {
        "[": /]$/,
        "{": /}$/
    };
    var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
    function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
            var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
            if (tempData) {
                var contentType = headers("Content-Type");
                if (contentType && contentType.indexOf(APPLICATION_JSON) === 0 || isJsonLike(tempData)) {
                    data = fromJson(tempData);
                }
            }
        }
        return data;
    }
    function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
    }
    function parseHeaders(headers) {
        var parsed = createMap(), key, val, i;
        if (!headers) return parsed;
        forEach(headers.split("\n"), function(line) {
            i = line.indexOf(":");
            key = lowercase(trim(line.substr(0, i)));
            val = trim(line.substr(i + 1));
            if (key) {
                parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
        });
        return parsed;
    }
    function headersGetter(headers) {
        var headersObj = isObject(headers) ? headers : undefined;
        return function(name) {
            if (!headersObj) headersObj = parseHeaders(headers);
            if (name) {
                var value = headersObj[lowercase(name)];
                if (value === void 0) {
                    value = null;
                }
                return value;
            }
            return headersObj;
        };
    }
    function transformData(data, headers, status, fns) {
        if (isFunction(fns)) return fns(data, headers, status);
        forEach(fns, function(fn) {
            data = fn(data, headers, status);
        });
        return data;
    }
    function isSuccess(status) {
        return 200 <= status && status < 300;
    }
    function $HttpProvider() {
        var defaults = this.defaults = {
            transformResponse: [ defaultHttpResponseTransform ],
            transformRequest: [ function(d) {
                return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN"
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
            if (isDefined(value)) {
                useApplyAsync = !!value;
                return this;
            }
            return useApplyAsync;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = [ "$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector", function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
            var defaultCache = $cacheFactory("$http");
            var reversedInterceptors = [];
            forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            });
            function $http(requestConfig) {
                if (!angular.isObject(requestConfig)) {
                    throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                }
                var config = extend({
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse
                }, requestConfig);
                config.headers = mergeHeaders(requestConfig);
                config.method = uppercase(config.method);
                var serverRequest = function(config) {
                    var headers = config.headers;
                    var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                    if (isUndefined(reqData)) {
                        forEach(headers, function(value, header) {
                            if (lowercase(header) === "content-type") {
                                delete headers[header];
                            }
                        });
                    }
                    if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                        config.withCredentials = defaults.withCredentials;
                    }
                    return sendReq(config, reqData).then(transformResponse, transformResponse);
                };
                var chain = [ serverRequest, undefined ];
                var promise = $q.when(config);
                forEach(reversedInterceptors, function(interceptor) {
                    if (interceptor.request || interceptor.requestError) {
                        chain.unshift(interceptor.request, interceptor.requestError);
                    }
                    if (interceptor.response || interceptor.responseError) {
                        chain.push(interceptor.response, interceptor.responseError);
                    }
                });
                while (chain.length) {
                    var thenFn = chain.shift();
                    var rejectFn = chain.shift();
                    promise = promise.then(thenFn, rejectFn);
                }
                promise.success = function(fn) {
                    assertArgFn(fn, "fn");
                    promise.then(function(response) {
                        fn(response.data, response.status, response.headers, config);
                    });
                    return promise;
                };
                promise.error = function(fn) {
                    assertArgFn(fn, "fn");
                    promise.then(null, function(response) {
                        fn(response.data, response.status, response.headers, config);
                    });
                    return promise;
                };
                return promise;
                function transformResponse(response) {
                    var resp = extend({}, response);
                    if (!response.data) {
                        resp.data = response.data;
                    } else {
                        resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
                    }
                    return isSuccess(response.status) ? resp : $q.reject(resp);
                }
                function executeHeaderFns(headers) {
                    var headerContent, processedHeaders = {};
                    forEach(headers, function(headerFn, header) {
                        if (isFunction(headerFn)) {
                            headerContent = headerFn();
                            if (headerContent != null) {
                                processedHeaders[header] = headerContent;
                            }
                        } else {
                            processedHeaders[header] = headerFn;
                        }
                    });
                    return processedHeaders;
                }
                function mergeHeaders(config) {
                    var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName;
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) {
                            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                                continue defaultHeadersIteration;
                            }
                        }
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    return executeHeaderFns(reqHeaders);
                }
            }
            $http.pendingRequests = [];
            createShortMethods("get", "delete", "head", "jsonp");
            createShortMethodsWithData("post", "put", "patch");
            $http.defaults = defaults;
            return $http;
            function createShortMethods(names) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }
            function createShortMethodsWithData(name) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }
            function sendReq(config, reqData) {
                var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, reqHeaders = config.headers, url = buildUrl(config.url, config.params);
                $http.pendingRequests.push(config);
                promise.then(removePendingReq, removePendingReq);
                if ((config.cache || defaults.cache) && config.cache !== false && (config.method === "GET" || config.method === "JSONP")) {
                    cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
                }
                if (cache) {
                    cachedResp = cache.get(url);
                    if (isDefined(cachedResp)) {
                        if (isPromiseLike(cachedResp)) {
                            cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                        } else {
                            if (isArray(cachedResp)) {
                                resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                            } else {
                                resolvePromise(cachedResp, 200, {}, "OK");
                            }
                        }
                    } else {
                        cache.put(url, promise);
                    }
                }
                if (isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                    if (xsrfValue) {
                        reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
                    }
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
                }
                return promise;
                function done(status, response, headersString, statusText) {
                    if (cache) {
                        if (isSuccess(status)) {
                            cache.put(url, [ status, response, parseHeaders(headersString), statusText ]);
                        } else {
                            cache.remove(url);
                        }
                    }
                    function resolveHttpPromise() {
                        resolvePromise(response, status, headersString, statusText);
                    }
                    if (useApplyAsync) {
                        $rootScope.$applyAsync(resolveHttpPromise);
                    } else {
                        resolveHttpPromise();
                        if (!$rootScope.$$phase) $rootScope.$apply();
                    }
                }
                function resolvePromise(response, status, headers, statusText) {
                    status = status >= -1 ? status : 0;
                    (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    });
                }
                function resolvePromiseWithResult(result) {
                    resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
                }
                function removePendingReq() {
                    var idx = $http.pendingRequests.indexOf(config);
                    if (idx !== -1) $http.pendingRequests.splice(idx, 1);
                }
            }
            function buildUrl(url, params) {
                if (!params) return url;
                var parts = [];
                forEachSorted(params, function(value, key) {
                    if (value === null || isUndefined(value)) return;
                    if (!isArray(value)) value = [ value ];
                    forEach(value, function(v) {
                        if (isObject(v)) {
                            if (isDate(v)) {
                                v = v.toISOString();
                            } else {
                                v = toJson(v);
                            }
                        }
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v));
                    });
                });
                if (parts.length > 0) {
                    url += (url.indexOf("?") == -1 ? "?" : "&") + parts.join("&");
                }
                return url;
            }
        } ];
    }
    function createXhr() {
        return new window.XMLHttpRequest();
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$window", "$document", function($browser, $window, $document) {
            return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
        } ];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
            $browser.$$incOutstandingRequestCount();
            url = url || $browser.url();
            if (lowercase(method) == "jsonp") {
                var callbackId = "_" + (callbacks.counter++).toString(36);
                callbacks[callbackId] = function(data) {
                    callbacks[callbackId].data = data;
                    callbacks[callbackId].called = true;
                };
                var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), callbackId, function(status, text) {
                    completeRequest(callback, status, callbacks[callbackId].data, "", text);
                    callbacks[callbackId] = noop;
                });
            } else {
                var xhr = createXhr();
                xhr.open(method, url, true);
                forEach(headers, function(value, key) {
                    if (isDefined(value)) {
                        xhr.setRequestHeader(key, value);
                    }
                });
                xhr.onload = function requestLoaded() {
                    var statusText = xhr.statusText || "";
                    var response = "response" in xhr ? xhr.response : xhr.responseText;
                    var status = xhr.status === 1223 ? 204 : xhr.status;
                    if (status === 0) {
                        status = response ? 200 : urlResolve(url).protocol == "file" ? 404 : 0;
                    }
                    completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
                };
                var requestError = function() {
                    completeRequest(callback, -1, null, null, "");
                };
                xhr.onerror = requestError;
                xhr.onabort = requestError;
                if (withCredentials) {
                    xhr.withCredentials = true;
                }
                if (responseType) {
                    try {
                        xhr.responseType = responseType;
                    } catch (e) {
                        if (responseType !== "json") {
                            throw e;
                        }
                    }
                }
                xhr.send(post || null);
            }
            if (timeout > 0) {
                var timeoutId = $browserDefer(timeoutRequest, timeout);
            } else if (isPromiseLike(timeout)) {
                timeout.then(timeoutRequest);
            }
            function timeoutRequest() {
                jsonpDone && jsonpDone();
                xhr && xhr.abort();
            }
            function completeRequest(callback, status, response, headersString, statusText) {
                if (timeoutId !== undefined) {
                    $browserDefer.cancel(timeoutId);
                }
                jsonpDone = xhr = null;
                callback(status, response, headersString, statusText);
                $browser.$$completeOutstandingRequest(noop);
            }
        };
        function jsonpReq(url, callbackId, done) {
            var script = rawDocument.createElement("script"), callback = null;
            script.type = "text/javascript";
            script.src = url;
            script.async = true;
            callback = function(event) {
                removeEventListenerFn(script, "load", callback);
                removeEventListenerFn(script, "error", callback);
                rawDocument.body.removeChild(script);
                script = null;
                var status = -1;
                var text = "unknown";
                if (event) {
                    if (event.type === "load" && !callbacks[callbackId].called) {
                        event = {
                            type: "error"
                        };
                    }
                    text = event.type;
                    status = event.type === "error" ? 404 : 200;
                }
                if (done) {
                    done(status, text);
                }
            };
            addEventListenerFn(script, "load", callback);
            addEventListenerFn(script, "error", callback);
            rawDocument.body.appendChild(script);
            return callback;
        }
    }
    var $interpolateMinErr = minErr("$interpolate");
    function $InterpolateProvider() {
        var startSymbol = "{{";
        var endSymbol = "}}";
        this.startSymbol = function(value) {
            if (value) {
                startSymbol = value;
                return this;
            } else {
                return startSymbol;
            }
        };
        this.endSymbol = function(value) {
            if (value) {
                endSymbol = value;
                return this;
            } else {
                return endSymbol;
            }
        };
        this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
            function escape(ch) {
                return "\\\\\\" + ch;
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                allOrNothing = !!allOrNothing;
                var startIndex, endIndex, index = 0, expressions = [], parseFns = [], textLength = text.length, exp, concat = [], expressionPositions = [];
                while (index < textLength) {
                    if ((startIndex = text.indexOf(startSymbol, index)) != -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) {
                        if (index !== startIndex) {
                            concat.push(unescapeText(text.substring(index, startIndex)));
                        }
                        exp = text.substring(startIndex + startSymbolLength, endIndex);
                        expressions.push(exp);
                        parseFns.push($parse(exp, parseStringifyInterceptor));
                        index = endIndex + endSymbolLength;
                        expressionPositions.push(concat.length);
                        concat.push("");
                    } else {
                        if (index !== textLength) {
                            concat.push(unescapeText(text.substring(index)));
                        }
                        break;
                    }
                }
                if (trustedContext && concat.length > 1) {
                    throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
                }
                if (!mustHaveExpression || expressions.length) {
                    var compute = function(values) {
                        for (var i = 0, ii = expressions.length; i < ii; i++) {
                            if (allOrNothing && isUndefined(values[i])) return;
                            concat[expressionPositions[i]] = values[i];
                        }
                        return concat.join("");
                    };
                    var getValue = function(value) {
                        return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                    };
                    var stringify = function(value) {
                        if (value == null) {
                            return "";
                        }
                        switch (typeof value) {
                          case "string":
                            break;

                          case "number":
                            value = "" + value;
                            break;

                          default:
                            value = toJson(value);
                        }
                        return value;
                    };
                    return extend(function interpolationFn(context) {
                        var i = 0;
                        var ii = expressions.length;
                        var values = new Array(ii);
                        try {
                            for (;i < ii; i++) {
                                values[i] = parseFns[i](context);
                            }
                            return compute(values);
                        } catch (err) {
                            var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                            $exceptionHandler(newErr);
                        }
                    }, {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: function(scope, listener, objectEquality) {
                            var lastValue;
                            return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                                var currValue = compute(values);
                                if (isFunction(listener)) {
                                    listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                                }
                                lastValue = currValue;
                            }, objectEquality);
                        }
                    });
                }
                function unescapeText(text) {
                    return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
                }
                function parseStringifyInterceptor(value) {
                    try {
                        value = getValue(value);
                        return allOrNothing && !isDefined(value) ? value : stringify(value);
                    } catch (err) {
                        var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                        $exceptionHandler(newErr);
                    }
                }
            }
            $interpolate.startSymbol = function() {
                return startSymbol;
            };
            $interpolate.endSymbol = function() {
                return endSymbol;
            };
            return $interpolate;
        } ];
    }
    function $IntervalProvider() {
        this.$get = [ "$rootScope", "$window", "$q", "$$q", function($rootScope, $window, $q, $$q) {
            var intervals = {};
            function interval(fn, delay, count, invokeApply) {
                var setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                count = isDefined(count) ? count : 0;
                promise.then(null, null, fn);
                promise.$$intervalId = setInterval(function tick() {
                    deferred.notify(iteration++);
                    if (count > 0 && iteration >= count) {
                        deferred.resolve(iteration);
                        clearInterval(promise.$$intervalId);
                        delete intervals[promise.$$intervalId];
                    }
                    if (!skipApply) $rootScope.$apply();
                }, delay);
                intervals[promise.$$intervalId] = deferred;
                return promise;
            }
            interval.cancel = function(promise) {
                if (promise && promise.$$intervalId in intervals) {
                    intervals[promise.$$intervalId].reject("canceled");
                    $window.clearInterval(promise.$$intervalId);
                    delete intervals[promise.$$intervalId];
                    return true;
                }
                return false;
            };
            return interval;
        } ];
    }
    function $LocaleProvider() {
        this.$get = function() {
            return {
                id: "en-us",
                NUMBER_FORMATS: {
                    DECIMAL_SEP: ".",
                    GROUP_SEP: ",",
                    PATTERNS: [ {
                        minInt: 1,
                        minFrac: 0,
                        maxFrac: 3,
                        posPre: "",
                        posSuf: "",
                        negPre: "-",
                        negSuf: "",
                        gSize: 3,
                        lgSize: 3
                    }, {
                        minInt: 1,
                        minFrac: 2,
                        maxFrac: 2,
                        posPre: "¤",
                        posSuf: "",
                        negPre: "(¤",
                        negSuf: ")",
                        gSize: 3,
                        lgSize: 3
                    } ],
                    CURRENCY_SYM: "$"
                },
                DATETIME_FORMATS: {
                    MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
                    SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
                    DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
                    SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
                    AMPMS: [ "AM", "PM" ],
                    medium: "MMM d, y h:mm:ss a",
                    short: "M/d/yy h:mm a",
                    fullDate: "EEEE, MMMM d, y",
                    longDate: "MMMM d, y",
                    mediumDate: "MMM d, y",
                    shortDate: "M/d/yy",
                    mediumTime: "h:mm:ss a",
                    shortTime: "h:mm a",
                    ERANAMES: [ "Before Christ", "Anno Domini" ],
                    ERAS: [ "BC", "AD" ]
                },
                pluralCat: function(num) {
                    if (num === 1) {
                        return "one";
                    }
                    return "other";
                }
            };
        };
    }
    var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    };
    var $locationMinErr = minErr("$location");
    function encodePath(path) {
        var segments = path.split("/"), i = segments.length;
        while (i--) {
            segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join("/");
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = relativeUrl.charAt(0) !== "/";
        if (prefixed) {
            relativeUrl = "/" + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === "/" ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != "/") {
            locationObj.$$path = "/" + locationObj.$$path;
        }
    }
    function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
            return whole.substr(begin.length);
        }
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return index == -1 ? url : url.substr(0, index);
    }
    function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, "$1");
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
    }
    function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || "";
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
            var pathUrl = beginsWith(appBaseNoFile, url);
            if (!isString(pathUrl)) {
                throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            }
            parseAppUrl(pathUrl, this);
            if (!this.$$path) {
                this.$$path = "/";
            }
            this.$$compose();
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && relHref[0] === "#") {
                this.hash(relHref.slice(1));
                return true;
            }
            var appUrl, prevAppUrl;
            var rewrittenUrl;
            if ((appUrl = beginsWith(appBase, url)) !== undefined) {
                prevAppUrl = appUrl;
                if ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) {
                    rewrittenUrl = appBaseNoFile + (beginsWith("/", appUrl) || appUrl);
                } else {
                    rewrittenUrl = appBase + prevAppUrl;
                }
            } else if ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) {
                rewrittenUrl = appBaseNoFile + appUrl;
            } else if (appBaseNoFile == url + "/") {
                rewrittenUrl = appBaseNoFile;
            }
            if (rewrittenUrl) {
                this.$$parse(rewrittenUrl);
            }
            return !!rewrittenUrl;
        };
    }
    function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
            var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
            var withoutHashUrl;
            if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === "#") {
                withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
                if (isUndefined(withoutHashUrl)) {
                    withoutHashUrl = withoutBaseUrl;
                }
            } else {
                if (this.$$html5) {
                    withoutHashUrl = withoutBaseUrl;
                } else {
                    withoutHashUrl = "";
                    if (isUndefined(withoutBaseUrl)) {
                        appBase = url;
                        this.replace();
                    }
                }
            }
            parseAppUrl(withoutHashUrl, this);
            this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
            this.$$compose();
            function removeWindowsDriveName(path, url, base) {
                var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                var firstPathSegmentMatch;
                if (url.indexOf(base) === 0) {
                    url = url.replace(base, "");
                }
                if (windowsFilePathExp.exec(url)) {
                    return path;
                }
                firstPathSegmentMatch = windowsFilePathExp.exec(path);
                return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
            }
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
        };
        this.$$parseLinkUrl = function(url, relHref) {
            if (stripHash(appBase) == stripHash(url)) {
                this.$$parse(url);
                return true;
            }
            return false;
        };
    }
    function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && relHref[0] === "#") {
                this.hash(relHref.slice(1));
                return true;
            }
            var rewrittenUrl;
            var appUrl;
            if (appBase == stripHash(url)) {
                rewrittenUrl = url;
            } else if (appUrl = beginsWith(appBaseNoFile, url)) {
                rewrittenUrl = appBase + hashPrefix + appUrl;
            } else if (appBaseNoFile === url + "/") {
                rewrittenUrl = appBaseNoFile;
            }
            if (rewrittenUrl) {
                this.$$parse(rewrittenUrl);
            }
            return !!rewrittenUrl;
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
    }
    var locationPrototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter("$$absUrl"),
        url: function(url) {
            if (isUndefined(url)) return this.$$url;
            var match = PATH_MATCH.exec(url);
            if (match[1] || url === "") this.path(decodeURIComponent(match[1]));
            if (match[2] || match[1] || url === "") this.search(match[3] || "");
            this.hash(match[5] || "");
            return this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            path = path !== null ? path.toString() : "";
            return path.charAt(0) == "/" ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search) || isNumber(search)) {
                    search = search.toString();
                    this.$$search = parseKeyValue(search);
                } else if (isObject(search)) {
                    search = copy(search, {});
                    forEach(search, function(value, key) {
                        if (value == null) delete search[key];
                    });
                    this.$$search = search;
                } else {
                    throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                }
                break;

              default:
                if (isUndefined(paramValue) || paramValue === null) {
                    delete this.$$search[search];
                } else {
                    this.$$search[search] = paramValue;
                }
            }
            this.$$compose();
            return this;
        },
        hash: locationGetterSetter("$$hash", function(hash) {
            return hash !== null ? hash.toString() : "";
        }),
        replace: function() {
            this.$$replace = true;
            return this;
        }
    };
    forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
            if (!arguments.length) return this.$$state;
            if (Location !== LocationHtml5Url || !this.$$html5) {
                throw $locationMinErr("nostate", "History API state support is available only " + "in HTML5 mode and only in browsers supporting HTML5 History API");
            }
            this.$$state = isUndefined(state) ? null : state;
            return this;
        };
    });
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            if (isUndefined(value)) return this[property];
            this[property] = preprocess(value);
            this.$$compose();
            return this;
        };
    }
    function $LocationProvider() {
        var hashPrefix = "", html5Mode = {
            enabled: false,
            requireBase: true,
            rewriteLinks: true
        };
        this.hashPrefix = function(prefix) {
            if (isDefined(prefix)) {
                hashPrefix = prefix;
                return this;
            } else {
                return hashPrefix;
            }
        };
        this.html5Mode = function(mode) {
            if (isBoolean(mode)) {
                html5Mode.enabled = mode;
                return this;
            } else if (isObject(mode)) {
                if (isBoolean(mode.enabled)) {
                    html5Mode.enabled = mode.enabled;
                }
                if (isBoolean(mode.requireBase)) {
                    html5Mode.requireBase = mode.requireBase;
                }
                if (isBoolean(mode.rewriteLinks)) {
                    html5Mode.rewriteLinks = mode.rewriteLinks;
                }
                return this;
            } else {
                return html5Mode;
            }
        };
        this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
            var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase;
            if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase) {
                    throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                }
                appBase = serverBase(initialUrl) + (baseHref || "/");
                LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
            } else {
                appBase = stripHash(initialUrl);
                LocationMode = LocationHashbangUrl;
            }
            var appBaseNoFile = stripFile(appBase);
            $location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix);
            $location.$$parseLinkUrl(initialUrl, initialUrl);
            $location.$$state = $browser.state();
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url();
                var oldState = $location.$$state;
                try {
                    $browser.url(url, replace, state);
                    $location.$$state = $browser.state();
                } catch (e) {
                    $location.url(oldUrl);
                    $location.$$state = oldState;
                    throw e;
                }
            }
            $rootElement.on("click", function(event) {
                if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2) return;
                var elm = jqLite(event.target);
                while (nodeName_(elm[0]) !== "a") {
                    if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                }
                var absHref = elm.prop("href");
                var relHref = elm.attr("href") || elm.attr("xlink:href");
                if (isObject(absHref) && absHref.toString() === "[object SVGAnimatedString]") {
                    absHref = urlResolve(absHref.animVal).href;
                }
                if (IGNORE_URI_REGEXP.test(absHref)) return;
                if (absHref && !elm.attr("target") && !event.isDefaultPrevented()) {
                    if ($location.$$parseLinkUrl(absHref, relHref)) {
                        event.preventDefault();
                        if ($location.absUrl() != $browser.url()) {
                            $rootScope.$apply();
                            $window.angular["ff-684208-preventDefault"] = true;
                        }
                    }
                }
            });
            if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
                $browser.url($location.absUrl(), true);
            }
            var initializing = true;
            $browser.onUrlChange(function(newUrl, newState) {
                if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
                    $window.location.href = newUrl;
                    return;
                }
                $rootScope.$evalAsync(function() {
                    var oldUrl = $location.absUrl();
                    var oldState = $location.$$state;
                    var defaultPrevented;
                    $location.$$parse(newUrl);
                    $location.$$state = newState;
                    defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented;
                    if ($location.absUrl() !== newUrl) return;
                    if (defaultPrevented) {
                        $location.$$parse(oldUrl);
                        $location.$$state = oldState;
                        setBrowserUrlWithFallback(oldUrl, false, oldState);
                    } else {
                        initializing = false;
                        afterLocationChange(oldUrl, oldState);
                    }
                });
                if (!$rootScope.$$phase) $rootScope.$digest();
            });
            $rootScope.$watch(function $locationWatch() {
                var oldUrl = trimEmptyHash($browser.url());
                var newUrl = trimEmptyHash($location.absUrl());
                var oldState = $browser.state();
                var currentReplace = $location.$$replace;
                var urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                if (initializing || urlOrStateChanged) {
                    initializing = false;
                    $rootScope.$evalAsync(function() {
                        var newUrl = $location.absUrl();
                        var defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                        if ($location.absUrl() !== newUrl) return;
                        if (defaultPrevented) {
                            $location.$$parse(oldUrl);
                            $location.$$state = oldState;
                        } else {
                            if (urlOrStateChanged) {
                                setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                            }
                            afterLocationChange(oldUrl, oldState);
                        }
                    });
                }
                $location.$$replace = false;
            });
            return $location;
            function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
            }
        } ];
    }
    function $LogProvider() {
        var debug = true, self = this;
        this.debugEnabled = function(flag) {
            if (isDefined(flag)) {
                debug = flag;
                return this;
            } else {
                return debug;
            }
        };
        this.$get = [ "$window", function($window) {
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        if (debug) {
                            fn.apply(self, arguments);
                        }
                    };
                }()
            };
            function formatError(arg) {
                if (arg instanceof Error) {
                    if (arg.stack) {
                        arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? "Error: " + arg.message + "\n" + arg.stack : arg.stack;
                    } else if (arg.sourceURL) {
                        arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line;
                    }
                }
                return arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = false;
                try {
                    hasApply = !!logFn.apply;
                } catch (e) {}
                if (hasApply) {
                    return function() {
                        var args = [];
                        forEach(arguments, function(arg) {
                            args.push(formatError(arg));
                        });
                        return logFn.apply(console, args);
                    };
                }
                return function(arg1, arg2) {
                    logFn(arg1, arg2 == null ? "" : arg2);
                };
            }
        } ];
    }
    var $parseMinErr = minErr("$parse");
    function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
            throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! " + "Expression: {0}", fullExpression);
        }
        return name;
    }
    function getStringValue(name, fullExpression) {
        name = name + "";
        if (!isString(name)) {
            throw $parseMinErr("iseccst", "Cannot convert object to primitive value! " + "Expression: {0}", fullExpression);
        }
        return name;
    }
    function ensureSafeObject(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) {
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj.window === obj) {
                throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) {
                throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj === Object) {
                throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression);
            }
        }
        return obj;
    }
    var CALL = Function.prototype.call;
    var APPLY = Function.prototype.apply;
    var BIND = Function.prototype.bind;
    function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) {
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj === CALL || obj === APPLY || obj === BIND) {
                throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression);
            }
        }
    }
    var CONSTANTS = createMap();
    forEach({
        null: function() {
            return null;
        },
        true: function() {
            return true;
        },
        false: function() {
            return false;
        },
        undefined: function() {}
    }, function(constantGetter, name) {
        constantGetter.constant = constantGetter.literal = constantGetter.sharedGetter = true;
        CONSTANTS[name] = constantGetter;
    });
    CONSTANTS["this"] = function(self) {
        return self;
    };
    CONSTANTS["this"].sharedGetter = true;
    var OPERATORS = extend(createMap(), {
        "+": function(self, locals, a, b) {
            a = a(self, locals);
            b = b(self, locals);
            if (isDefined(a)) {
                if (isDefined(b)) {
                    return a + b;
                }
                return a;
            }
            return isDefined(b) ? b : undefined;
        },
        "-": function(self, locals, a, b) {
            a = a(self, locals);
            b = b(self, locals);
            return (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);
        },
        "*": function(self, locals, a, b) {
            return a(self, locals) * b(self, locals);
        },
        "/": function(self, locals, a, b) {
            return a(self, locals) / b(self, locals);
        },
        "%": function(self, locals, a, b) {
            return a(self, locals) % b(self, locals);
        },
        "===": function(self, locals, a, b) {
            return a(self, locals) === b(self, locals);
        },
        "!==": function(self, locals, a, b) {
            return a(self, locals) !== b(self, locals);
        },
        "==": function(self, locals, a, b) {
            return a(self, locals) == b(self, locals);
        },
        "!=": function(self, locals, a, b) {
            return a(self, locals) != b(self, locals);
        },
        "<": function(self, locals, a, b) {
            return a(self, locals) < b(self, locals);
        },
        ">": function(self, locals, a, b) {
            return a(self, locals) > b(self, locals);
        },
        "<=": function(self, locals, a, b) {
            return a(self, locals) <= b(self, locals);
        },
        ">=": function(self, locals, a, b) {
            return a(self, locals) >= b(self, locals);
        },
        "&&": function(self, locals, a, b) {
            return a(self, locals) && b(self, locals);
        },
        "||": function(self, locals, a, b) {
            return a(self, locals) || b(self, locals);
        },
        "!": function(self, locals, a) {
            return !a(self, locals);
        },
        "=": true,
        "|": true
    });
    var ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "\t",
        v: "\v",
        "'": "'",
        '"': '"'
    };
    var Lexer = function(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            this.text = text;
            this.index = 0;
            this.tokens = [];
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                if (ch === '"' || ch === "'") {
                    this.readString(ch);
                } else if (this.isNumber(ch) || ch === "." && this.isNumber(this.peek())) {
                    this.readNumber();
                } else if (this.isIdent(ch)) {
                    this.readIdent();
                } else if (this.is(ch, "(){}[].,;:?")) {
                    this.tokens.push({
                        index: this.index,
                        text: ch
                    });
                    this.index++;
                } else if (this.isWhitespace(ch)) {
                    this.index++;
                } else {
                    var ch2 = ch + this.peek();
                    var ch3 = ch2 + this.peek(2);
                    var op1 = OPERATORS[ch];
                    var op2 = OPERATORS[ch2];
                    var op3 = OPERATORS[ch3];
                    if (op1 || op2 || op3) {
                        var token = op3 ? ch3 : op2 ? ch2 : ch;
                        this.tokens.push({
                            index: this.index,
                            text: token,
                            operator: true
                        });
                        this.index += token.length;
                    } else {
                        this.throwError("Unexpected next character ", this.index, this.index + 1);
                    }
                }
            }
            return this.tokens;
        },
        is: function(ch, chars) {
            return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
            return "0" <= ch && ch <= "9" && typeof ch === "string";
        },
        isWhitespace: function(ch) {
            return ch === " " || ch === "\r" || ch === "\t" || ch === "\n" || ch === "\v" || ch === " ";
        },
        isIdent: function(ch) {
            return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || ch === "$";
        },
        isExpOperator: function(ch) {
            return ch === "-" || ch === "+" || this.isNumber(ch);
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            var number = "";
            var start = this.index;
            while (this.index < this.text.length) {
                var ch = lowercase(this.text.charAt(this.index));
                if (ch == "." || this.isNumber(ch)) {
                    number += ch;
                } else {
                    var peekCh = this.peek();
                    if (ch == "e" && this.isExpOperator(peekCh)) {
                        number += ch;
                    } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == "e") {
                        number += ch;
                    } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == "e") {
                        this.throwError("Invalid exponent");
                    } else {
                        break;
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: number,
                constant: true,
                value: Number(number)
            });
        },
        readIdent: function() {
            var start = this.index;
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                if (!(this.isIdent(ch) || this.isNumber(ch))) {
                    break;
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: this.text.slice(start, this.index),
                identifier: true
            });
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            var string = "";
            var rawString = quote;
            var escape = false;
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                rawString += ch;
                if (escape) {
                    if (ch === "u") {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        if (!hex.match(/[\da-f]{4}/i)) this.throwError("Invalid unicode escape [\\u" + hex + "]");
                        this.index += 4;
                        string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        string = string + (rep || ch);
                    }
                    escape = false;
                } else if (ch === "\\") {
                    escape = true;
                } else if (ch === quote) {
                    this.index++;
                    this.tokens.push({
                        index: start,
                        text: rawString,
                        constant: true,
                        value: string
                    });
                    return;
                } else {
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    function isConstant(exp) {
        return exp.constant;
    }
    var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
    };
    Parser.ZERO = extend(function() {
        return 0;
    }, {
        sharedGetter: true,
        constant: true
    });
    Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            this.text = text;
            this.tokens = this.lexer.lex(text);
            var value = this.statements();
            if (this.tokens.length !== 0) {
                this.throwError("is an unexpected token", this.tokens[0]);
            }
            value.literal = !!value.literal;
            value.constant = !!value.constant;
            return value;
        },
        primary: function() {
            var primary;
            if (this.expect("(")) {
                primary = this.filterChain();
                this.consume(")");
            } else if (this.expect("[")) {
                primary = this.arrayDeclaration();
            } else if (this.expect("{")) {
                primary = this.object();
            } else if (this.peek().identifier && this.peek().text in CONSTANTS) {
                primary = CONSTANTS[this.consume().text];
            } else if (this.peek().identifier) {
                primary = this.identifier();
            } else if (this.peek().constant) {
                primary = this.constant();
            } else {
                this.throwError("not a primary expression", this.peek());
            }
            var next, context;
            while (next = this.expect("(", "[", ".")) {
                if (next.text === "(") {
                    primary = this.functionCall(primary, context);
                    context = null;
                } else if (next.text === "[") {
                    context = primary;
                    primary = this.objectIndex(primary);
                } else if (next.text === ".") {
                    context = primary;
                    primary = this.fieldAccess(primary);
                } else {
                    this.throwError("IMPOSSIBLE");
                }
            }
            return primary;
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        peekToken: function() {
            if (this.tokens.length === 0) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
            if (this.tokens.length > i) {
                var token = this.tokens[i];
                var t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
                    return token;
                }
            }
            return false;
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            if (token) {
                this.tokens.shift();
                return token;
            }
            return false;
        },
        consume: function(e1) {
            if (this.tokens.length === 0) {
                throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            }
            var token = this.expect(e1);
            if (!token) {
                this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
            }
            return token;
        },
        unaryFn: function(op, right) {
            var fn = OPERATORS[op];
            return extend(function $parseUnaryFn(self, locals) {
                return fn(self, locals, right);
            }, {
                constant: right.constant,
                inputs: [ right ]
            });
        },
        binaryFn: function(left, op, right, isBranching) {
            var fn = OPERATORS[op];
            return extend(function $parseBinaryFn(self, locals) {
                return fn(self, locals, left, right);
            }, {
                constant: left.constant && right.constant,
                inputs: !isBranching && [ left, right ]
            });
        },
        identifier: function() {
            var id = this.consume().text;
            while (this.peek(".") && this.peekAhead(1).identifier && !this.peekAhead(2, "(")) {
                id += this.consume().text + this.consume().text;
            }
            return getterFn(id, this.options, this.text);
        },
        constant: function() {
            var value = this.consume().value;
            return extend(function $parseConstant() {
                return value;
            }, {
                constant: true,
                literal: true
            });
        },
        statements: function() {
            var statements = [];
            while (true) {
                if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]")) statements.push(this.filterChain());
                if (!this.expect(";")) {
                    return statements.length === 1 ? statements[0] : function $parseStatements(self, locals) {
                        var value;
                        for (var i = 0, ii = statements.length; i < ii; i++) {
                            value = statements[i](self, locals);
                        }
                        return value;
                    };
                }
            }
        },
        filterChain: function() {
            var left = this.expression();
            var token;
            while (token = this.expect("|")) {
                left = this.filter(left);
            }
            return left;
        },
        filter: function(inputFn) {
            var fn = this.$filter(this.consume().text);
            var argsFn;
            var args;
            if (this.peek(":")) {
                argsFn = [];
                args = [];
                while (this.expect(":")) {
                    argsFn.push(this.expression());
                }
            }
            var inputs = [ inputFn ].concat(argsFn || []);
            return extend(function $parseFilter(self, locals) {
                var input = inputFn(self, locals);
                if (args) {
                    args[0] = input;
                    var i = argsFn.length;
                    while (i--) {
                        args[i + 1] = argsFn[i](self, locals);
                    }
                    return fn.apply(undefined, args);
                }
                return fn(input);
            }, {
                constant: !fn.$stateful && inputs.every(isConstant),
                inputs: !fn.$stateful && inputs
            });
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var left = this.ternary();
            var right;
            var token;
            if (token = this.expect("=")) {
                if (!left.assign) {
                    this.throwError("implies assignment but [" + this.text.substring(0, token.index) + "] can not be assigned to", token);
                }
                right = this.ternary();
                return extend(function $parseAssignment(scope, locals) {
                    return left.assign(scope, right(scope, locals), locals);
                }, {
                    inputs: [ left, right ]
                });
            }
            return left;
        },
        ternary: function() {
            var left = this.logicalOR();
            var middle;
            var token;
            if (token = this.expect("?")) {
                middle = this.assignment();
                if (this.consume(":")) {
                    var right = this.assignment();
                    return extend(function $parseTernary(self, locals) {
                        return left(self, locals) ? middle(self, locals) : right(self, locals);
                    }, {
                        constant: left.constant && middle.constant && right.constant
                    });
                }
            }
            return left;
        },
        logicalOR: function() {
            var left = this.logicalAND();
            var token;
            while (token = this.expect("||")) {
                left = this.binaryFn(left, token.text, this.logicalAND(), true);
            }
            return left;
        },
        logicalAND: function() {
            var left = this.equality();
            var token;
            while (token = this.expect("&&")) {
                left = this.binaryFn(left, token.text, this.equality(), true);
            }
            return left;
        },
        equality: function() {
            var left = this.relational();
            var token;
            while (token = this.expect("==", "!=", "===", "!==")) {
                left = this.binaryFn(left, token.text, this.relational());
            }
            return left;
        },
        relational: function() {
            var left = this.additive();
            var token;
            while (token = this.expect("<", ">", "<=", ">=")) {
                left = this.binaryFn(left, token.text, this.additive());
            }
            return left;
        },
        additive: function() {
            var left = this.multiplicative();
            var token;
            while (token = this.expect("+", "-")) {
                left = this.binaryFn(left, token.text, this.multiplicative());
            }
            return left;
        },
        multiplicative: function() {
            var left = this.unary();
            var token;
            while (token = this.expect("*", "/", "%")) {
                left = this.binaryFn(left, token.text, this.unary());
            }
            return left;
        },
        unary: function() {
            var token;
            if (this.expect("+")) {
                return this.primary();
            } else if (token = this.expect("-")) {
                return this.binaryFn(Parser.ZERO, token.text, this.unary());
            } else if (token = this.expect("!")) {
                return this.unaryFn(token.text, this.unary());
            } else {
                return this.primary();
            }
        },
        fieldAccess: function(object) {
            var getter = this.identifier();
            return extend(function $parseFieldAccess(scope, locals, self) {
                var o = self || object(scope, locals);
                return o == null ? undefined : getter(o);
            }, {
                assign: function(scope, value, locals) {
                    var o = object(scope, locals);
                    if (!o) object.assign(scope, o = {}, locals);
                    return getter.assign(o, value);
                }
            });
        },
        objectIndex: function(obj) {
            var expression = this.text;
            var indexFn = this.expression();
            this.consume("]");
            return extend(function $parseObjectIndex(self, locals) {
                var o = obj(self, locals), i = getStringValue(indexFn(self, locals), expression), v;
                ensureSafeMemberName(i, expression);
                if (!o) return undefined;
                v = ensureSafeObject(o[i], expression);
                return v;
            }, {
                assign: function(self, value, locals) {
                    var key = ensureSafeMemberName(getStringValue(indexFn(self, locals), expression), expression);
                    var o = ensureSafeObject(obj(self, locals), expression);
                    if (!o) obj.assign(self, o = {}, locals);
                    return o[key] = value;
                }
            });
        },
        functionCall: function(fnGetter, contextGetter) {
            var argsFn = [];
            if (this.peekToken().text !== ")") {
                do {
                    argsFn.push(this.expression());
                } while (this.expect(","));
            }
            this.consume(")");
            var expressionText = this.text;
            var args = argsFn.length ? [] : null;
            return function $parseFunctionCall(scope, locals) {
                var context = contextGetter ? contextGetter(scope, locals) : isDefined(contextGetter) ? undefined : scope;
                var fn = fnGetter(scope, locals, context) || noop;
                if (args) {
                    var i = argsFn.length;
                    while (i--) {
                        args[i] = ensureSafeObject(argsFn[i](scope, locals), expressionText);
                    }
                }
                ensureSafeObject(context, expressionText);
                ensureSafeFunction(fn, expressionText);
                var v = fn.apply ? fn.apply(context, args) : fn(args[0], args[1], args[2], args[3], args[4]);
                if (args) {
                    args.length = 0;
                }
                return ensureSafeObject(v, expressionText);
            };
        },
        arrayDeclaration: function() {
            var elementFns = [];
            if (this.peekToken().text !== "]") {
                do {
                    if (this.peek("]")) {
                        break;
                    }
                    elementFns.push(this.expression());
                } while (this.expect(","));
            }
            this.consume("]");
            return extend(function $parseArrayLiteral(self, locals) {
                var array = [];
                for (var i = 0, ii = elementFns.length; i < ii; i++) {
                    array.push(elementFns[i](self, locals));
                }
                return array;
            }, {
                literal: true,
                constant: elementFns.every(isConstant),
                inputs: elementFns
            });
        },
        object: function() {
            var keys = [], valueFns = [];
            if (this.peekToken().text !== "}") {
                do {
                    if (this.peek("}")) {
                        break;
                    }
                    var token = this.consume();
                    if (token.constant) {
                        keys.push(token.value);
                    } else if (token.identifier) {
                        keys.push(token.text);
                    } else {
                        this.throwError("invalid key", token);
                    }
                    this.consume(":");
                    valueFns.push(this.expression());
                } while (this.expect(","));
            }
            this.consume("}");
            return extend(function $parseObjectLiteral(self, locals) {
                var object = {};
                for (var i = 0, ii = valueFns.length; i < ii; i++) {
                    object[keys[i]] = valueFns[i](self, locals);
                }
                return object;
            }, {
                literal: true,
                constant: valueFns.every(isConstant),
                inputs: valueFns
            });
        }
    };
    function setter(obj, locals, path, setValue, fullExp) {
        ensureSafeObject(obj, fullExp);
        ensureSafeObject(locals, fullExp);
        var element = path.split("."), key;
        for (var i = 0; element.length > 1; i++) {
            key = ensureSafeMemberName(element.shift(), fullExp);
            var propertyObj = i === 0 && locals && locals[key] || obj[key];
            if (!propertyObj) {
                propertyObj = {};
                obj[key] = propertyObj;
            }
            obj = ensureSafeObject(propertyObj, fullExp);
        }
        key = ensureSafeMemberName(element.shift(), fullExp);
        ensureSafeObject(obj[key], fullExp);
        obj[key] = setValue;
        return setValue;
    }
    var getterFnCacheDefault = createMap();
    var getterFnCacheExpensive = createMap();
    function isPossiblyDangerousMemberName(name) {
        return name == "constructor";
    }
    function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, expensiveChecks) {
        ensureSafeMemberName(key0, fullExp);
        ensureSafeMemberName(key1, fullExp);
        ensureSafeMemberName(key2, fullExp);
        ensureSafeMemberName(key3, fullExp);
        ensureSafeMemberName(key4, fullExp);
        var eso = function(o) {
            return ensureSafeObject(o, fullExp);
        };
        var eso0 = expensiveChecks || isPossiblyDangerousMemberName(key0) ? eso : identity;
        var eso1 = expensiveChecks || isPossiblyDangerousMemberName(key1) ? eso : identity;
        var eso2 = expensiveChecks || isPossiblyDangerousMemberName(key2) ? eso : identity;
        var eso3 = expensiveChecks || isPossiblyDangerousMemberName(key3) ? eso : identity;
        var eso4 = expensiveChecks || isPossiblyDangerousMemberName(key4) ? eso : identity;
        return function cspSafeGetter(scope, locals) {
            var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
            if (pathVal == null) return pathVal;
            pathVal = eso0(pathVal[key0]);
            if (!key1) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = eso1(pathVal[key1]);
            if (!key2) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = eso2(pathVal[key2]);
            if (!key3) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = eso3(pathVal[key3]);
            if (!key4) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = eso4(pathVal[key4]);
            return pathVal;
        };
    }
    function getterFnWithEnsureSafeObject(fn, fullExpression) {
        return function(s, l) {
            return fn(s, l, ensureSafeObject, fullExpression);
        };
    }
    function getterFn(path, options, fullExp) {
        var expensiveChecks = options.expensiveChecks;
        var getterFnCache = expensiveChecks ? getterFnCacheExpensive : getterFnCacheDefault;
        var fn = getterFnCache[path];
        if (fn) return fn;
        var pathKeys = path.split("."), pathKeysLength = pathKeys.length;
        if (options.csp) {
            if (pathKeysLength < 6) {
                fn = cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, expensiveChecks);
            } else {
                fn = function cspSafeGetter(scope, locals) {
                    var i = 0, val;
                    do {
                        val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp, expensiveChecks)(scope, locals);
                        locals = undefined;
                        scope = val;
                    } while (i < pathKeysLength);
                    return val;
                };
            }
        } else {
            var code = "";
            if (expensiveChecks) {
                code += "s = eso(s, fe);\nl = eso(l, fe);\n";
            }
            var needsEnsureSafeObject = expensiveChecks;
            forEach(pathKeys, function(key, index) {
                ensureSafeMemberName(key, fullExp);
                var lookupJs = (index ? "s" : '((l&&l.hasOwnProperty("' + key + '"))?l:s)') + "." + key;
                if (expensiveChecks || isPossiblyDangerousMemberName(key)) {
                    lookupJs = "eso(" + lookupJs + ", fe)";
                    needsEnsureSafeObject = true;
                }
                code += "if(s == null) return undefined;\n" + "s=" + lookupJs + ";\n";
            });
            code += "return s;";
            var evaledFnGetter = new Function("s", "l", "eso", "fe", code);
            evaledFnGetter.toString = valueFn(code);
            if (needsEnsureSafeObject) {
                evaledFnGetter = getterFnWithEnsureSafeObject(evaledFnGetter, fullExp);
            }
            fn = evaledFnGetter;
        }
        fn.sharedGetter = true;
        fn.assign = function(self, value, locals) {
            return setter(self, locals, path, value, path);
        };
        getterFnCache[path] = fn;
        return fn;
    }
    var objectValueOf = Object.prototype.valueOf;
    function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
    }
    function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        this.$get = [ "$filter", "$sniffer", function($filter, $sniffer) {
            var $parseOptions = {
                csp: $sniffer.csp,
                expensiveChecks: false
            }, $parseOptionsExpensive = {
                csp: $sniffer.csp,
                expensiveChecks: true
            };
            function wrapSharedExpression(exp) {
                var wrapped = exp;
                if (exp.sharedGetter) {
                    wrapped = function $parseWrapper(self, locals) {
                        return exp(self, locals);
                    };
                    wrapped.literal = exp.literal;
                    wrapped.constant = exp.constant;
                    wrapped.assign = exp.assign;
                }
                return wrapped;
            }
            return function $parse(exp, interceptorFn, expensiveChecks) {
                var parsedExpression, oneTime, cacheKey;
                switch (typeof exp) {
                  case "string":
                    cacheKey = exp = exp.trim();
                    var cache = expensiveChecks ? cacheExpensive : cacheDefault;
                    parsedExpression = cache[cacheKey];
                    if (!parsedExpression) {
                        if (exp.charAt(0) === ":" && exp.charAt(1) === ":") {
                            oneTime = true;
                            exp = exp.substring(2);
                        }
                        var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                        var lexer = new Lexer(parseOptions);
                        var parser = new Parser(lexer, $filter, parseOptions);
                        parsedExpression = parser.parse(exp);
                        if (parsedExpression.constant) {
                            parsedExpression.$$watchDelegate = constantWatchDelegate;
                        } else if (oneTime) {
                            parsedExpression = wrapSharedExpression(parsedExpression);
                            parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                        } else if (parsedExpression.inputs) {
                            parsedExpression.$$watchDelegate = inputsWatchDelegate;
                        }
                        cache[cacheKey] = parsedExpression;
                    }
                    return addInterceptor(parsedExpression, interceptorFn);

                  case "function":
                    return addInterceptor(exp, interceptorFn);

                  default:
                    return addInterceptor(noop, interceptorFn);
                }
            };
            function collectExpressionInputs(inputs, list) {
                for (var i = 0, ii = inputs.length; i < ii; i++) {
                    var input = inputs[i];
                    if (!input.constant) {
                        if (input.inputs) {
                            collectExpressionInputs(input.inputs, list);
                        } else if (list.indexOf(input) === -1) {
                            list.push(input);
                        }
                    }
                }
                return list;
            }
            function expressionInputDirtyCheck(newValue, oldValueOfValue) {
                if (newValue == null || oldValueOfValue == null) {
                    return newValue === oldValueOfValue;
                }
                if (typeof newValue === "object") {
                    newValue = getValueOf(newValue);
                    if (typeof newValue === "object") {
                        return false;
                    }
                }
                return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var inputExpressions = parsedExpression.$$inputs || (parsedExpression.$$inputs = collectExpressionInputs(parsedExpression.inputs, []));
                var lastResult;
                if (inputExpressions.length === 1) {
                    var oldInputValue = expressionInputDirtyCheck;
                    inputExpressions = inputExpressions[0];
                    return scope.$watch(function expressionInputWatch(scope) {
                        var newInputValue = inputExpressions(scope);
                        if (!expressionInputDirtyCheck(newInputValue, oldInputValue)) {
                            lastResult = parsedExpression(scope);
                            oldInputValue = newInputValue && getValueOf(newInputValue);
                        }
                        return lastResult;
                    }, listener, objectEquality);
                }
                var oldInputValueOfValues = [];
                for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                    oldInputValueOfValues[i] = expressionInputDirtyCheck;
                }
                return scope.$watch(function expressionInputsWatch(scope) {
                    var changed = false;
                    for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                        var newInputValue = inputExpressions[i](scope);
                        if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                            oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                        }
                    }
                    if (changed) {
                        lastResult = parsedExpression(scope);
                    }
                    return lastResult;
                }, listener, objectEquality);
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch, lastValue;
                return unwatch = scope.$watch(function oneTimeWatch(scope) {
                    return parsedExpression(scope);
                }, function oneTimeListener(value, old, scope) {
                    lastValue = value;
                    if (isFunction(listener)) {
                        listener.apply(this, arguments);
                    }
                    if (isDefined(value)) {
                        scope.$$postDigest(function() {
                            if (isDefined(lastValue)) {
                                unwatch();
                            }
                        });
                    }
                }, objectEquality);
            }
            function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch, lastValue;
                return unwatch = scope.$watch(function oneTimeWatch(scope) {
                    return parsedExpression(scope);
                }, function oneTimeListener(value, old, scope) {
                    lastValue = value;
                    if (isFunction(listener)) {
                        listener.call(this, value, old, scope);
                    }
                    if (isAllDefined(value)) {
                        scope.$$postDigest(function() {
                            if (isAllDefined(lastValue)) unwatch();
                        });
                    }
                }, objectEquality);
                function isAllDefined(value) {
                    var allDefined = true;
                    forEach(value, function(val) {
                        if (!isDefined(val)) allDefined = false;
                    });
                    return allDefined;
                }
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch;
                return unwatch = scope.$watch(function constantWatch(scope) {
                    return parsedExpression(scope);
                }, function constantListener(value, old, scope) {
                    if (isFunction(listener)) {
                        listener.apply(this, arguments);
                    }
                    unwatch();
                }, objectEquality);
            }
            function addInterceptor(parsedExpression, interceptorFn) {
                if (!interceptorFn) return parsedExpression;
                var watchDelegate = parsedExpression.$$watchDelegate;
                var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
                var fn = regularWatch ? function regularInterceptedExpression(scope, locals) {
                    var value = parsedExpression(scope, locals);
                    return interceptorFn(value, scope, locals);
                } : function oneTimeInterceptedExpression(scope, locals) {
                    var value = parsedExpression(scope, locals);
                    var result = interceptorFn(value, scope, locals);
                    return isDefined(value) ? result : value;
                };
                if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
                    fn.$$watchDelegate = parsedExpression.$$watchDelegate;
                } else if (!interceptorFn.$stateful) {
                    fn.$$watchDelegate = inputsWatchDelegate;
                    fn.inputs = [ parsedExpression ];
                }
                return fn;
            }
        } ];
    }
    function $QProvider() {
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler);
        } ];
    }
    function $$QProvider() {
        this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
            return qFactory(function(callback) {
                $browser.defer(callback);
            }, $exceptionHandler);
        } ];
    }
    function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr("$q", TypeError);
        function callOnce(self, resolveFn, rejectFn) {
            var called = false;
            function wrap(fn) {
                return function(value) {
                    if (called) return;
                    called = true;
                    fn.call(self, value);
                };
            }
            return [ wrap(resolveFn), wrap(rejectFn) ];
        }
        var defer = function() {
            return new Deferred();
        };
        function Promise() {
            this.$$state = {
                status: 0
            };
        }
        Promise.prototype = {
            then: function(onFulfilled, onRejected, progressBack) {
                var result = new Deferred();
                this.$$state.pending = this.$$state.pending || [];
                this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]);
                if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);
                return result.promise;
            },
            catch: function(callback) {
                return this.then(null, callback);
            },
            finally: function(callback, progressBack) {
                return this.then(function(value) {
                    return handleCallback(value, true, callback);
                }, function(error) {
                    return handleCallback(error, false, callback);
                }, progressBack);
            }
        };
        function simpleBind(context, fn) {
            return function(value) {
                fn.call(context, value);
            };
        }
        function processQueue(state) {
            var fn, promise, pending;
            pending = state.pending;
            state.processScheduled = false;
            state.pending = undefined;
            for (var i = 0, ii = pending.length; i < ii; ++i) {
                promise = pending[i][0];
                fn = pending[i][state.status];
                try {
                    if (isFunction(fn)) {
                        promise.resolve(fn(state.value));
                    } else if (state.status === 1) {
                        promise.resolve(state.value);
                    } else {
                        promise.reject(state.value);
                    }
                } catch (e) {
                    promise.reject(e);
                    exceptionHandler(e);
                }
            }
        }
        function scheduleProcessQueue(state) {
            if (state.processScheduled || !state.pending) return;
            state.processScheduled = true;
            nextTick(function() {
                processQueue(state);
            });
        }
        function Deferred() {
            this.promise = new Promise();
            this.resolve = simpleBind(this, this.resolve);
            this.reject = simpleBind(this, this.reject);
            this.notify = simpleBind(this, this.notify);
        }
        Deferred.prototype = {
            resolve: function(val) {
                if (this.promise.$$state.status) return;
                if (val === this.promise) {
                    this.$$reject($qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val));
                } else {
                    this.$$resolve(val);
                }
            },
            $$resolve: function(val) {
                var then, fns;
                fns = callOnce(this, this.$$resolve, this.$$reject);
                try {
                    if (isObject(val) || isFunction(val)) then = val && val.then;
                    if (isFunction(then)) {
                        this.promise.$$state.status = -1;
                        then.call(val, fns[0], fns[1], this.notify);
                    } else {
                        this.promise.$$state.value = val;
                        this.promise.$$state.status = 1;
                        scheduleProcessQueue(this.promise.$$state);
                    }
                } catch (e) {
                    fns[1](e);
                    exceptionHandler(e);
                }
            },
            reject: function(reason) {
                if (this.promise.$$state.status) return;
                this.$$reject(reason);
            },
            $$reject: function(reason) {
                this.promise.$$state.value = reason;
                this.promise.$$state.status = 2;
                scheduleProcessQueue(this.promise.$$state);
            },
            notify: function(progress) {
                var callbacks = this.promise.$$state.pending;
                if (this.promise.$$state.status <= 0 && callbacks && callbacks.length) {
                    nextTick(function() {
                        var callback, result;
                        for (var i = 0, ii = callbacks.length; i < ii; i++) {
                            result = callbacks[i][0];
                            callback = callbacks[i][3];
                            try {
                                result.notify(isFunction(callback) ? callback(progress) : progress);
                            } catch (e) {
                                exceptionHandler(e);
                            }
                        }
                    });
                }
            }
        };
        var reject = function(reason) {
            var result = new Deferred();
            result.reject(reason);
            return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
            var result = new Deferred();
            if (resolved) {
                result.resolve(value);
            } else {
                result.reject(value);
            }
            return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
            var callbackOutput = null;
            try {
                if (isFunction(callback)) callbackOutput = callback();
            } catch (e) {
                return makePromise(e, false);
            }
            if (isPromiseLike(callbackOutput)) {
                return callbackOutput.then(function() {
                    return makePromise(value, isResolved);
                }, function(error) {
                    return makePromise(error, false);
                });
            } else {
                return makePromise(value, isResolved);
            }
        };
        var when = function(value, callback, errback, progressBack) {
            var result = new Deferred();
            result.resolve(value);
            return result.promise.then(callback, errback, progressBack);
        };
        function all(promises) {
            var deferred = new Deferred(), counter = 0, results = isArray(promises) ? [] : {};
            forEach(promises, function(promise, key) {
                counter++;
                when(promise).then(function(value) {
                    if (results.hasOwnProperty(key)) return;
                    results[key] = value;
                    if (!--counter) deferred.resolve(results);
                }, function(reason) {
                    if (results.hasOwnProperty(key)) return;
                    deferred.reject(reason);
                });
            });
            if (counter === 0) {
                deferred.resolve(results);
            }
            return deferred.promise;
        }
        var $Q = function Q(resolver) {
            if (!isFunction(resolver)) {
                throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            }
            if (!(this instanceof Q)) {
                return new Q(resolver);
            }
            var deferred = new Deferred();
            function resolveFn(value) {
                deferred.resolve(value);
            }
            function rejectFn(reason) {
                deferred.reject(reason);
            }
            resolver(resolveFn, rejectFn);
            return deferred.promise;
        };
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.all = all;
        return $Q;
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
            var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
            var rafSupported = !!requestAnimationFrame;
            var rafFn = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, false);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            queueFn.supported = rafSupported;
            var cancelLastRAF;
            var taskCount = 0;
            var taskQueue = [];
            return queueFn;
            function flush() {
                for (var i = 0; i < taskQueue.length; i++) {
                    var task = taskQueue[i];
                    if (task) {
                        taskQueue[i] = null;
                        task();
                    }
                }
                taskCount = taskQueue.length = 0;
            }
            function queueFn(asyncFn) {
                var index = taskQueue.length;
                taskCount++;
                taskQueue.push(asyncFn);
                if (index === 0) {
                    cancelLastRAF = rafFn(flush);
                }
                return function cancelQueueFn() {
                    if (index >= 0) {
                        taskQueue[index] = null;
                        index = null;
                        if (--taskCount === 0 && cancelLastRAF) {
                            cancelLastRAF();
                            cancelLastRAF = null;
                            taskQueue.length = 0;
                        }
                    }
                };
            }
        } ];
    }
    function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr("$rootScope");
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
            if (arguments.length) {
                TTL = value;
            }
            return TTL;
        };
        function createChildScopeClass(parent) {
            function ChildScope() {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$id = nextUid();
                this.$$ChildScope = null;
            }
            ChildScope.prototype = parent;
            return ChildScope;
        }
        this.$get = [ "$injector", "$exceptionHandler", "$parse", "$browser", function($injector, $exceptionHandler, $parse, $browser) {
            function destroyChildScope($event) {
                $event.currentScope.$$destroyed = true;
            }
            function Scope() {
                this.$id = nextUid();
                this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                this.$root = this;
                this.$$destroyed = false;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$isolateBindings = null;
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate, parent) {
                    var child;
                    parent = parent || this;
                    if (isolate) {
                        child = new Scope();
                        child.$root = this.$root;
                    } else {
                        if (!this.$$ChildScope) {
                            this.$$ChildScope = createChildScopeClass(this);
                        }
                        child = new this.$$ChildScope();
                    }
                    child.$parent = parent;
                    child.$$prevSibling = parent.$$childTail;
                    if (parent.$$childHead) {
                        parent.$$childTail.$$nextSibling = child;
                        parent.$$childTail = child;
                    } else {
                        parent.$$childHead = parent.$$childTail = child;
                    }
                    if (isolate || parent != this) child.$on("$destroy", destroyChildScope);
                    return child;
                },
                $watch: function(watchExp, listener, objectEquality) {
                    var get = $parse(watchExp);
                    if (get.$$watchDelegate) {
                        return get.$$watchDelegate(this, listener, objectEquality, get);
                    }
                    var scope = this, array = scope.$$watchers, watcher = {
                        fn: listener,
                        last: initWatchVal,
                        get: get,
                        exp: watchExp,
                        eq: !!objectEquality
                    };
                    lastDirtyWatch = null;
                    if (!isFunction(listener)) {
                        watcher.fn = noop;
                    }
                    if (!array) {
                        array = scope.$$watchers = [];
                    }
                    array.unshift(watcher);
                    return function deregisterWatch() {
                        arrayRemove(array, watcher);
                        lastDirtyWatch = null;
                    };
                },
                $watchGroup: function(watchExpressions, listener) {
                    var oldValues = new Array(watchExpressions.length);
                    var newValues = new Array(watchExpressions.length);
                    var deregisterFns = [];
                    var self = this;
                    var changeReactionScheduled = false;
                    var firstRun = true;
                    if (!watchExpressions.length) {
                        var shouldCall = true;
                        self.$evalAsync(function() {
                            if (shouldCall) listener(newValues, newValues, self);
                        });
                        return function deregisterWatchGroup() {
                            shouldCall = false;
                        };
                    }
                    if (watchExpressions.length === 1) {
                        return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                            newValues[0] = value;
                            oldValues[0] = oldValue;
                            listener(newValues, value === oldValue ? newValues : oldValues, scope);
                        });
                    }
                    forEach(watchExpressions, function(expr, i) {
                        var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                            newValues[i] = value;
                            oldValues[i] = oldValue;
                            if (!changeReactionScheduled) {
                                changeReactionScheduled = true;
                                self.$evalAsync(watchGroupAction);
                            }
                        });
                        deregisterFns.push(unwatchFn);
                    });
                    function watchGroupAction() {
                        changeReactionScheduled = false;
                        if (firstRun) {
                            firstRun = false;
                            listener(newValues, newValues, self);
                        } else {
                            listener(newValues, oldValues, self);
                        }
                    }
                    return function deregisterWatchGroup() {
                        while (deregisterFns.length) {
                            deregisterFns.shift()();
                        }
                    };
                },
                $watchCollection: function(obj, listener) {
                    $watchCollectionInterceptor.$stateful = true;
                    var self = this;
                    var newValue;
                    var oldValue;
                    var veryOldValue;
                    var trackVeryOldValue = listener.length > 1;
                    var changeDetected = 0;
                    var changeDetector = $parse(obj, $watchCollectionInterceptor);
                    var internalArray = [];
                    var internalObject = {};
                    var initRun = true;
                    var oldLength = 0;
                    function $watchCollectionInterceptor(_value) {
                        newValue = _value;
                        var newLength, key, bothNaN, newItem, oldItem;
                        if (isUndefined(newValue)) return;
                        if (!isObject(newValue)) {
                            if (oldValue !== newValue) {
                                oldValue = newValue;
                                changeDetected++;
                            }
                        } else if (isArrayLike(newValue)) {
                            if (oldValue !== internalArray) {
                                oldValue = internalArray;
                                oldLength = oldValue.length = 0;
                                changeDetected++;
                            }
                            newLength = newValue.length;
                            if (oldLength !== newLength) {
                                changeDetected++;
                                oldValue.length = oldLength = newLength;
                            }
                            for (var i = 0; i < newLength; i++) {
                                oldItem = oldValue[i];
                                newItem = newValue[i];
                                bothNaN = oldItem !== oldItem && newItem !== newItem;
                                if (!bothNaN && oldItem !== newItem) {
                                    changeDetected++;
                                    oldValue[i] = newItem;
                                }
                            }
                        } else {
                            if (oldValue !== internalObject) {
                                oldValue = internalObject = {};
                                oldLength = 0;
                                changeDetected++;
                            }
                            newLength = 0;
                            for (key in newValue) {
                                if (newValue.hasOwnProperty(key)) {
                                    newLength++;
                                    newItem = newValue[key];
                                    oldItem = oldValue[key];
                                    if (key in oldValue) {
                                        bothNaN = oldItem !== oldItem && newItem !== newItem;
                                        if (!bothNaN && oldItem !== newItem) {
                                            changeDetected++;
                                            oldValue[key] = newItem;
                                        }
                                    } else {
                                        oldLength++;
                                        oldValue[key] = newItem;
                                        changeDetected++;
                                    }
                                }
                            }
                            if (oldLength > newLength) {
                                changeDetected++;
                                for (key in oldValue) {
                                    if (!newValue.hasOwnProperty(key)) {
                                        oldLength--;
                                        delete oldValue[key];
                                    }
                                }
                            }
                        }
                        return changeDetected;
                    }
                    function $watchCollectionAction() {
                        if (initRun) {
                            initRun = false;
                            listener(newValue, newValue, self);
                        } else {
                            listener(newValue, veryOldValue, self);
                        }
                        if (trackVeryOldValue) {
                            if (!isObject(newValue)) {
                                veryOldValue = newValue;
                            } else if (isArrayLike(newValue)) {
                                veryOldValue = new Array(newValue.length);
                                for (var i = 0; i < newValue.length; i++) {
                                    veryOldValue[i] = newValue[i];
                                }
                            } else {
                                veryOldValue = {};
                                for (var key in newValue) {
                                    if (hasOwnProperty.call(newValue, key)) {
                                        veryOldValue[key] = newValue[key];
                                    }
                                }
                            }
                        }
                    }
                    return this.$watch(changeDetector, $watchCollectionAction);
                },
                $digest: function() {
                    var watch, value, last, watchers, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, logMsg, asyncTask;
                    beginPhase("$digest");
                    $browser.$$checkUrlChange();
                    if (this === $rootScope && applyAsyncId !== null) {
                        $browser.defer.cancel(applyAsyncId);
                        flushApplyAsync();
                    }
                    lastDirtyWatch = null;
                    do {
                        dirty = false;
                        current = target;
                        while (asyncQueue.length) {
                            try {
                                asyncTask = asyncQueue.shift();
                                asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        traverseScopesLoop: do {
                            if (watchers = current.$$watchers) {
                                length = watchers.length;
                                while (length--) {
                                    try {
                                        watch = watchers[length];
                                        if (watch) {
                                            if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : typeof value === "number" && typeof last === "number" && isNaN(value) && isNaN(last))) {
                                                dirty = true;
                                                lastDirtyWatch = watch;
                                                watch.last = watch.eq ? copy(value, null) : value;
                                                watch.fn(value, last === initWatchVal ? value : last, current);
                                                if (ttl < 5) {
                                                    logIdx = 4 - ttl;
                                                    if (!watchLog[logIdx]) watchLog[logIdx] = [];
                                                    watchLog[logIdx].push({
                                                        msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                                        newVal: value,
                                                        oldVal: last
                                                    });
                                                }
                                            } else if (watch === lastDirtyWatch) {
                                                dirty = false;
                                                break traverseScopesLoop;
                                            }
                                        }
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                            }
                            if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                                while (current !== target && !(next = current.$$nextSibling)) {
                                    current = current.$parent;
                                }
                            }
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) {
                            clearPhase();
                            throw $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\n" + "Watchers fired in the last 5 iterations: {1}", TTL, watchLog);
                        }
                    } while (dirty || asyncQueue.length);
                    clearPhase();
                    while (postDigestQueue.length) {
                        try {
                            postDigestQueue.shift()();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                },
                $destroy: function() {
                    if (this.$$destroyed) return;
                    var parent = this.$parent;
                    this.$broadcast("$destroy");
                    this.$$destroyed = true;
                    if (this === $rootScope) return;
                    for (var eventName in this.$$listenerCount) {
                        decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                    }
                    if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
                    if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
                    if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                    if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                    this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
                    this.$on = this.$watch = this.$watchGroup = function() {
                        return noop;
                    };
                    this.$$listeners = {};
                    this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null;
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr, locals) {
                    if (!$rootScope.$$phase && !asyncQueue.length) {
                        $browser.defer(function() {
                            if (asyncQueue.length) {
                                $rootScope.$digest();
                            }
                        });
                    }
                    asyncQueue.push({
                        scope: this,
                        expression: expr,
                        locals: locals
                    });
                },
                $$postDigest: function(fn) {
                    postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        beginPhase("$apply");
                        return this.$eval(expr);
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        clearPhase();
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            $exceptionHandler(e);
                            throw e;
                        }
                    }
                },
                $applyAsync: function(expr) {
                    var scope = this;
                    expr && applyAsyncQueue.push($applyAsyncExpression);
                    scheduleApplyAsync();
                    function $applyAsyncExpression() {
                        scope.$eval(expr);
                    }
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    if (!namedListeners) {
                        this.$$listeners[name] = namedListeners = [];
                    }
                    namedListeners.push(listener);
                    var current = this;
                    do {
                        if (!current.$$listenerCount[name]) {
                            current.$$listenerCount[name] = 0;
                        }
                        current.$$listenerCount[name]++;
                    } while (current = current.$parent);
                    var self = this;
                    return function() {
                        var indexOfListener = namedListeners.indexOf(listener);
                        if (indexOfListener !== -1) {
                            namedListeners[indexOfListener] = null;
                            decrementListenerCount(self, 1, name);
                        }
                    };
                },
                $emit: function(name, args) {
                    var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = true;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    }, listenerArgs = concat([ event ], arguments, 1), i, length;
                    do {
                        namedListeners = scope.$$listeners[name] || empty;
                        event.currentScope = scope;
                        for (i = 0, length = namedListeners.length; i < length; i++) {
                            if (!namedListeners[i]) {
                                namedListeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                namedListeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (stopPropagation) {
                            event.currentScope = null;
                            return event;
                        }
                        scope = scope.$parent;
                    } while (scope);
                    event.currentScope = null;
                    return event;
                },
                $broadcast: function(name, args) {
                    var target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    };
                    if (!target.$$listenerCount[name]) return event;
                    var listenerArgs = concat([ event ], arguments, 1), listeners, i, length;
                    while (current = next) {
                        event.currentScope = current;
                        listeners = current.$$listeners[name] || [];
                        for (i = 0, length = listeners.length; i < length; i++) {
                            if (!listeners[i]) {
                                listeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                listeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
                            while (current !== target && !(next = current.$$nextSibling)) {
                                current = current.$parent;
                            }
                        }
                    }
                    event.currentScope = null;
                    return event;
                }
            };
            var $rootScope = new Scope();
            var asyncQueue = $rootScope.$$asyncQueue = [];
            var postDigestQueue = $rootScope.$$postDigestQueue = [];
            var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
            return $rootScope;
            function beginPhase(phase) {
                if ($rootScope.$$phase) {
                    throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                }
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function decrementListenerCount(current, count, name) {
                do {
                    current.$$listenerCount[name] -= count;
                    if (current.$$listenerCount[name] === 0) {
                        delete current.$$listenerCount[name];
                    }
                } while (current = current.$parent);
            }
            function initWatchVal() {}
            function flushApplyAsync() {
                while (applyAsyncQueue.length) {
                    try {
                        applyAsyncQueue.shift()();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }
                applyAsyncId = null;
            }
            function scheduleApplyAsync() {
                if (applyAsyncId === null) {
                    applyAsyncId = $browser.defer(function() {
                        $rootScope.$apply(flushApplyAsync);
                    });
                }
            }
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                aHrefSanitizationWhitelist = regexp;
                return this;
            }
            return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                imgSrcSanitizationWhitelist = regexp;
                return this;
            }
            return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
            return function sanitizeUri(uri, isImage) {
                var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                var normalizedVal;
                normalizedVal = urlResolve(uri).href;
                if (normalizedVal !== "" && !normalizedVal.match(regex)) {
                    return "unsafe:" + normalizedVal;
                }
                return uri;
            };
        };
    }
    var $sceMinErr = minErr("$sce");
    var SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    };
    function adjustMatcher(matcher) {
        if (matcher === "self") {
            return matcher;
        } else if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) {
                throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            }
            matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*");
            return new RegExp("^" + matcher + "$");
        } else if (isRegExp(matcher)) {
            return new RegExp("^" + matcher.source + "$");
        } else {
            throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
        }
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
            forEach(matchers, function(matcher) {
                adjustedMatchers.push(adjustMatcher(matcher));
            });
        }
        return adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            if (arguments.length) {
                resourceUrlWhitelist = adjustMatchers(value);
            }
            return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
            if (arguments.length) {
                resourceUrlBlacklist = adjustMatchers(value);
            }
            return resourceUrlBlacklist;
        };
        this.$get = [ "$injector", function($injector) {
            var htmlSanitizer = function htmlSanitizer(html) {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            if ($injector.has("$sanitize")) {
                htmlSanitizer = $injector.get("$sanitize");
            }
            function matchUrl(matcher, parsedUrl) {
                if (matcher === "self") {
                    return urlIsSameOrigin(parsedUrl);
                } else {
                    return !!matcher.exec(parsedUrl.href);
                }
            }
            function isResourceUrlAllowedByPolicy(url) {
                var parsedUrl = urlResolve(url.toString());
                var i, n, allowed = false;
                for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
                    if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                        allowed = true;
                        break;
                    }
                }
                if (allowed) {
                    for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                        if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                            allowed = false;
                            break;
                        }
                    }
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function TrustedValueHolderType(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                };
                if (Base) {
                    holderType.prototype = new Base();
                }
                holderType.prototype.valueOf = function sceValueOf() {
                    return this.$$unwrapTrustedValue();
                };
                holderType.prototype.toString = function sceToString() {
                    return this.$$unwrapTrustedValue().toString();
                };
                return holderType;
            }
            var trustedValueHolderBase = generateHolderType(), byType = {};
            byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) {
                    throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                }
                if (trustedValue === null || trustedValue === undefined || trustedValue === "") {
                    return trustedValue;
                }
                if (typeof trustedValue !== "string") {
                    throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                }
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                if (maybeTrusted instanceof trustedValueHolderBase) {
                    return maybeTrusted.$$unwrapTrustedValue();
                } else {
                    return maybeTrusted;
                }
            }
            function getTrusted(type, maybeTrusted) {
                if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === "") {
                    return maybeTrusted;
                }
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) {
                    return maybeTrusted.$$unwrapTrustedValue();
                }
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                        return maybeTrusted;
                    } else {
                        throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                    }
                } else if (type === SCE_CONTEXTS.HTML) {
                    return htmlSanitizer(maybeTrusted);
                }
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            return {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        } ];
    }
    function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
            if (arguments.length) {
                enabled = !!value;
            }
            return enabled;
        };
        this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
            if (enabled && msie < 8) {
                throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks " + "mode.  You can fix this by adding the text <!doctype html> to the top of your HTML " + "document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            }
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            };
            sce.trustAs = $sceDelegate.trustAs;
            sce.getTrusted = $sceDelegate.getTrusted;
            sce.valueOf = $sceDelegate.valueOf;
            if (!enabled) {
                sce.trustAs = sce.getTrusted = function(type, value) {
                    return value;
                };
                sce.valueOf = identity;
            }
            sce.parseAs = function sceParseAs(type, expr) {
                var parsed = $parse(expr);
                if (parsed.literal && parsed.constant) {
                    return parsed;
                } else {
                    return $parse(expr, function(value) {
                        return sce.getTrusted(type, value);
                    });
                }
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[camelCase("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                };
                sce[camelCase("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                };
                sce[camelCase("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            });
            return sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function($window, $document) {
            var eventSupport = {}, android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, vendorPrefix, vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = false, animations = false, match;
            if (bodyStyle) {
                for (var prop in bodyStyle) {
                    if (match = vendorRegex.exec(prop)) {
                        vendorPrefix = match[0];
                        vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                        break;
                    }
                }
                if (!vendorPrefix) {
                    vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit";
                }
                transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle);
                animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle);
                if (android && (!transitions || !animations)) {
                    transitions = isString(document.body.style.webkitTransition);
                    animations = isString(document.body.style.webkitAnimation);
                }
            }
            return {
                history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
                hasEvent: function(event) {
                    if (event === "input" && msie <= 11) return false;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                vendorPrefix: vendorPrefix,
                transitions: transitions,
                animations: animations,
                android: android
            };
        } ];
    }
    var $compileMinErr = minErr("$compile");
    function $TemplateRequestProvider() {
        this.$get = [ "$templateCache", "$http", "$q", "$sce", function($templateCache, $http, $q, $sce) {
            function handleRequestFn(tpl, ignoreRequestError) {
                handleRequestFn.totalPendingRequests++;
                if (!isString(tpl) || !$templateCache.get(tpl)) {
                    tpl = $sce.getTrustedResourceUrl(tpl);
                }
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                if (isArray(transformResponse)) {
                    transformResponse = transformResponse.filter(function(transformer) {
                        return transformer !== defaultHttpResponseTransform;
                    });
                } else if (transformResponse === defaultHttpResponseTransform) {
                    transformResponse = null;
                }
                var httpOptions = {
                    cache: $templateCache,
                    transformResponse: transformResponse
                };
                return $http.get(tpl, httpOptions)["finally"](function() {
                    handleRequestFn.totalPendingRequests--;
                }).then(function(response) {
                    return response.data;
                }, handleError);
                function handleError(resp) {
                    if (!ignoreRequestError) {
                        throw $compileMinErr("tpload", "Failed to load template: {0}", tpl);
                    }
                    return $q.reject(resp);
                }
            }
            handleRequestFn.totalPendingRequests = 0;
            return handleRequestFn;
        } ];
    }
    function $$TestabilityProvider() {
        this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
            var testability = {};
            testability.findBindings = function(element, expression, opt_exactMatch) {
                var bindings = element.getElementsByClassName("ng-binding");
                var matches = [];
                forEach(bindings, function(binding) {
                    var dataBinding = angular.element(binding).data("$binding");
                    if (dataBinding) {
                        forEach(dataBinding, function(bindingName) {
                            if (opt_exactMatch) {
                                var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                                if (matcher.test(bindingName)) {
                                    matches.push(binding);
                                }
                            } else {
                                if (bindingName.indexOf(expression) != -1) {
                                    matches.push(binding);
                                }
                            }
                        });
                    }
                });
                return matches;
            };
            testability.findModels = function(element, expression, opt_exactMatch) {
                var prefixes = [ "ng-", "data-ng-", "ng\\:" ];
                for (var p = 0; p < prefixes.length; ++p) {
                    var attributeEquals = opt_exactMatch ? "=" : "*=";
                    var selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]';
                    var elements = element.querySelectorAll(selector);
                    if (elements.length) {
                        return elements;
                    }
                }
            };
            testability.getLocation = function() {
                return $location.url();
            };
            testability.setLocation = function(url) {
                if (url !== $location.url()) {
                    $location.url(url);
                    $rootScope.$digest();
                }
            };
            testability.whenStable = function(callback) {
                $browser.notifyWhenNoOutstandingRequests(callback);
            };
            return testability;
        } ];
    }
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
            var deferreds = {};
            function timeout(fn, delay, invokeApply) {
                var skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise, timeoutId;
                timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn());
                    } catch (e) {
                        deferred.reject(e);
                        $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    if (!skipApply) $rootScope.$apply();
                }, delay);
                promise.$$timeoutId = timeoutId;
                deferreds[timeoutId] = deferred;
                return promise;
            }
            timeout.cancel = function(promise) {
                if (promise && promise.$$timeoutId in deferreds) {
                    deferreds[promise.$$timeoutId].reject("canceled");
                    delete deferreds[promise.$$timeoutId];
                    return $browser.defer.cancel(promise.$$timeoutId);
                }
                return false;
            };
            return timeout;
        } ];
    }
    var urlParsingNode = document.createElement("a");
    var originUrl = urlResolve(window.location.href);
    function urlResolve(url) {
        var href = url;
        if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    $FilterProvider.$inject = [ "$provide" ];
    function $FilterProvider($provide) {
        var suffix = "Filter";
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                });
                return filters;
            } else {
                return $provide.factory(name + suffix, factory);
            }
        }
        this.register = register;
        this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ];
        register("currency", currencyFilter);
        register("date", dateFilter);
        register("filter", filterFilter);
        register("json", jsonFilter);
        register("limitTo", limitToFilter);
        register("lowercase", lowercaseFilter);
        register("number", numberFilter);
        register("orderBy", orderByFilter);
        register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator) {
            if (!isArray(array)) return array;
            var expressionType = expression !== null ? typeof expression : "null";
            var predicateFn;
            var matchAgainstAnyProp;
            switch (expressionType) {
              case "function":
                predicateFn = expression;
                break;

              case "boolean":
              case "null":
              case "number":
              case "string":
                matchAgainstAnyProp = true;

              case "object":
                predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
                break;

              default:
                return array;
            }
            return array.filter(predicateFn);
        };
    }
    function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && "$" in expression;
        var predicateFn;
        if (comparator === true) {
            comparator = equals;
        } else if (!isFunction(comparator)) {
            comparator = function(actual, expected) {
                if (isUndefined(actual)) {
                    return false;
                }
                if (actual === null || expected === null) {
                    return actual === expected;
                }
                if (isObject(actual) || isObject(expected)) {
                    return false;
                }
                actual = lowercase("" + actual);
                expected = lowercase("" + expected);
                return actual.indexOf(expected) !== -1;
            };
        }
        predicateFn = function(item) {
            if (shouldMatchPrimitives && !isObject(item)) {
                return deepCompare(item, expression.$, comparator, false);
            }
            return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
    }
    function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = actual !== null ? typeof actual : "null";
        var expectedType = expected !== null ? typeof expected : "null";
        if (expectedType === "string" && expected.charAt(0) === "!") {
            return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
            return actual.some(function(item) {
                return deepCompare(item, expected, comparator, matchAgainstAnyProp);
            });
        }
        switch (actualType) {
          case "object":
            var key;
            if (matchAgainstAnyProp) {
                for (key in actual) {
                    if (key.charAt(0) !== "$" && deepCompare(actual[key], expected, comparator, true)) {
                        return true;
                    }
                }
                return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === "object") {
                for (key in expected) {
                    var expectedVal = expected[key];
                    if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                        continue;
                    }
                    var matchAnyProperty = key === "$";
                    var actualVal = matchAnyProperty ? actual : actual[key];
                    if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                        return false;
                    }
                }
                return true;
            } else {
                return comparator(actual, expected);
            }
            break;

          case "function":
            return false;

          default:
            return comparator(actual, expected);
        }
    }
    currencyFilter.$inject = [ "$locale" ];
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
            if (isUndefined(currencySymbol)) {
                currencySymbol = formats.CURRENCY_SYM;
            }
            if (isUndefined(fractionSize)) {
                fractionSize = formats.PATTERNS[1].maxFrac;
            }
            return amount == null ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
    }
    numberFilter.$inject = [ "$locale" ];
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return number == null ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    var DECIMAL_SEP = ".";
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!isFinite(number) || isObject(number)) return "";
        var isNegative = number < 0;
        number = Math.abs(number);
        var numStr = number + "", formatedText = "", parts = [];
        var hasExponent = false;
        if (numStr.indexOf("e") !== -1) {
            var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
            if (match && match[2] == "-" && match[3] > fractionSize + 1) {
                number = 0;
            } else {
                formatedText = numStr;
                hasExponent = true;
            }
        }
        if (!hasExponent) {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
            if (isUndefined(fractionSize)) {
                fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
            }
            number = +(Math.round(+(number.toString() + "e" + fractionSize)).toString() + "e" + -fractionSize);
            var fraction = ("" + number).split(DECIMAL_SEP);
            var whole = fraction[0];
            fraction = fraction[1] || "";
            var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
            if (whole.length >= lgroup + group) {
                pos = whole.length - lgroup;
                for (i = 0; i < pos; i++) {
                    if ((pos - i) % group === 0 && i !== 0) {
                        formatedText += groupSep;
                    }
                    formatedText += whole.charAt(i);
                }
            }
            for (i = pos; i < whole.length; i++) {
                if ((whole.length - i) % lgroup === 0 && i !== 0) {
                    formatedText += groupSep;
                }
                formatedText += whole.charAt(i);
            }
            while (fraction.length < fractionSize) {
                fraction += "0";
            }
            if (fractionSize && fractionSize !== "0") formatedText += decimalSep + fraction.substr(0, fractionSize);
        } else {
            if (fractionSize > 0 && number < 1) {
                formatedText = number.toFixed(fractionSize);
                number = parseFloat(formatedText);
            }
        }
        if (number === 0) {
            isNegative = false;
        }
        parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf);
        return parts.join("");
    }
    function padNumber(num, digits, trim) {
        var neg = "";
        if (num < 0) {
            neg = "-";
            num = -num;
        }
        num = "" + num;
        while (num.length < digits) num = "0" + num;
        if (trim) num = num.substr(num.length - digits);
        return neg + num;
    }
    function dateGetter(name, size, offset, trim) {
        offset = offset || 0;
        return function(date) {
            var value = date["get" + name]();
            if (offset > 0 || value > -offset) value += offset;
            if (value === 0 && offset == -12) value = 12;
            return padNumber(value, size, trim);
        };
    }
    function dateStrGetter(name, shortForm) {
        return function(date, formats) {
            var value = date["get" + name]();
            var get = uppercase(shortForm ? "SHORT" + name : name);
            return formats[get][value];
        };
    }
    function timeZoneGetter(date) {
        var zone = -1 * date.getTimezoneOffset();
        var paddedZone = zone >= 0 ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
    }
    function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
        return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
    }
    function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
    }
    function weekGetter(size) {
        return function(date) {
            var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date);
            var diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6048e5);
            return padNumber(result, size);
        };
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
    }
    function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
    }
    var DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4),
        yy: dateGetter("FullYear", 2, 0, true),
        y: dateGetter("FullYear", 1),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", true),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
    };
    var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/, NUMBER_STRING = /^\-?\d+$/;
    dateFilter.$inject = [ "$locale" ];
    function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                if (match[9]) {
                    tzHour = int(match[9] + match[10]);
                    tzMin = int(match[9] + match[11]);
                }
                dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
                var h = int(match[4] || 0) - tzHour;
                var m = int(match[5] || 0) - tzMin;
                var s = int(match[6] || 0);
                var ms = Math.round(parseFloat("0." + (match[7] || 0)) * 1e3);
                timeSetter.call(date, h, m, s, ms);
                return date;
            }
            return string;
        }
        return function(date, format, timezone) {
            var text = "", parts = [], fn, match;
            format = format || "mediumDate";
            format = $locale.DATETIME_FORMATS[format] || format;
            if (isString(date)) {
                date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date);
            }
            if (isNumber(date)) {
                date = new Date(date);
            }
            if (!isDate(date)) {
                return date;
            }
            while (format) {
                match = DATE_FORMATS_SPLIT.exec(format);
                if (match) {
                    parts = concat(parts, match, 1);
                    format = parts.pop();
                } else {
                    parts.push(format);
                    format = null;
                }
            }
            if (timezone && timezone === "UTC") {
                date = new Date(date.getTime());
                date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
            }
            forEach(parts, function(value) {
                fn = DATE_FORMATS[value];
                text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            });
            return text;
        };
    }
    function jsonFilter() {
        return function(object, spacing) {
            if (isUndefined(spacing)) {
                spacing = 2;
            }
            return toJson(object, spacing);
        };
    }
    var lowercaseFilter = valueFn(lowercase);
    var uppercaseFilter = valueFn(uppercase);
    function limitToFilter() {
        return function(input, limit) {
            if (isNumber(input)) input = input.toString();
            if (!isArray(input) && !isString(input)) return input;
            if (Math.abs(Number(limit)) === Infinity) {
                limit = Number(limit);
            } else {
                limit = int(limit);
            }
            if (limit) {
                return limit > 0 ? input.slice(0, limit) : input.slice(limit);
            } else {
                return isString(input) ? "" : [];
            }
        };
    }
    orderByFilter.$inject = [ "$parse" ];
    function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
            if (!isArrayLike(array)) return array;
            sortPredicate = isArray(sortPredicate) ? sortPredicate : [ sortPredicate ];
            if (sortPredicate.length === 0) {
                sortPredicate = [ "+" ];
            }
            sortPredicate = sortPredicate.map(function(predicate) {
                var descending = false, get = predicate || identity;
                if (isString(predicate)) {
                    if (predicate.charAt(0) == "+" || predicate.charAt(0) == "-") {
                        descending = predicate.charAt(0) == "-";
                        predicate = predicate.substring(1);
                    }
                    if (predicate === "") {
                        return reverseComparator(compare, descending);
                    }
                    get = $parse(predicate);
                    if (get.constant) {
                        var key = get();
                        return reverseComparator(function(a, b) {
                            return compare(a[key], b[key]);
                        }, descending);
                    }
                }
                return reverseComparator(function(a, b) {
                    return compare(get(a), get(b));
                }, descending);
            });
            return slice.call(array).sort(reverseComparator(comparator, reverseOrder));
            function comparator(o1, o2) {
                for (var i = 0; i < sortPredicate.length; i++) {
                    var comp = sortPredicate[i](o1, o2);
                    if (comp !== 0) return comp;
                }
                return 0;
            }
            function reverseComparator(comp, descending) {
                return descending ? function(a, b) {
                    return comp(b, a);
                } : comp;
            }
            function isPrimitive(value) {
                switch (typeof value) {
                  case "number":
                  case "boolean":
                  case "string":
                    return true;

                  default:
                    return false;
                }
            }
            function objectToString(value) {
                if (value === null) return "null";
                if (typeof value.valueOf === "function") {
                    value = value.valueOf();
                    if (isPrimitive(value)) return value;
                }
                if (typeof value.toString === "function") {
                    value = value.toString();
                    if (isPrimitive(value)) return value;
                }
                return "";
            }
            function compare(v1, v2) {
                var t1 = typeof v1;
                var t2 = typeof v2;
                if (t1 === t2 && t1 === "object") {
                    v1 = objectToString(v1);
                    v2 = objectToString(v2);
                }
                if (t1 === t2) {
                    if (t1 === "string") {
                        v1 = v1.toLowerCase();
                        v2 = v2.toLowerCase();
                    }
                    if (v1 === v2) return 0;
                    return v1 < v2 ? -1 : 1;
                } else {
                    return t1 < t2 ? -1 : 1;
                }
            }
        };
    }
    function ngDirective(directive) {
        if (isFunction(directive)) {
            directive = {
                link: directive
            };
        }
        directive.restrict = directive.restrict || "AC";
        return valueFn(directive);
    }
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            if (!attr.href && !attr.xlinkHref && !attr.name) {
                return function(scope, element) {
                    if (element[0].nodeName.toLowerCase() !== "a") return;
                    var href = toString.call(element.prop("href")) === "[object SVGAnimatedString]" ? "xlink:href" : "href";
                    element.on("click", function(event) {
                        if (!element.attr(href)) {
                            event.preventDefault();
                        }
                    });
                };
            }
        }
    });
    var ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple") return;
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                restrict: "A",
                priority: 100,
                link: function(scope, element, attr) {
                    scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
                        attr.$set(attrName, !!value);
                    });
                }
            };
        };
    });
    forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
            return {
                priority: 100,
                link: function(scope, element, attr) {
                    if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                        var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                        if (match) {
                            attr.$set("ngPattern", new RegExp(match[1], match[2]));
                            return;
                        }
                    }
                    scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                        attr.$set(ngAttr, value);
                    });
                }
            };
        };
    });
    forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    if (attrName === "href" && toString.call(element.prop("href")) === "[object SVGAnimatedString]") {
                        name = "xlinkHref";
                        attr.$attr[name] = "xlink:href";
                        propName = null;
                    }
                    attr.$observe(normalized, function(value) {
                        if (!value) {
                            if (attrName === "href") {
                                attr.$set(name, null);
                            }
                            return;
                        }
                        attr.$set(name, value);
                        if (msie && propName) element.prop(propName, attr[name]);
                    });
                }
            };
        };
    });
    var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
    }, SUBMITTED_CLASS = "ng-submitted";
    function nullFormRenameControl(control, name) {
        control.$name = name;
    }
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ];
    function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this, controls = [];
        var parentForm = form.$$parentForm = element.parent().controller("form") || nullFormCtrl;
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || "")($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        parentForm.$addControl(form);
        form.$rollbackViewValue = function() {
            forEach(controls, function(control) {
                control.$rollbackViewValue();
            });
        };
        form.$commitViewValue = function() {
            forEach(controls, function(control) {
                control.$commitViewValue();
            });
        };
        form.$addControl = function(control) {
            assertNotHasOwnProperty(control.$name, "input");
            controls.push(control);
            if (control.$name) {
                form[control.$name] = control;
            }
        };
        form.$$renameControl = function(control, newName) {
            var oldName = control.$name;
            if (form[oldName] === control) {
                delete form[oldName];
            }
            form[newName] = control;
            control.$name = newName;
        };
        form.$removeControl = function(control) {
            if (control.$name && form[control.$name] === control) {
                delete form[control.$name];
            }
            forEach(form.$pending, function(value, name) {
                form.$setValidity(name, null, control);
            });
            forEach(form.$error, function(value, name) {
                form.$setValidity(name, null, control);
            });
            forEach(form.$$success, function(value, name) {
                form.$setValidity(name, null, control);
            });
            arrayRemove(controls, control);
        };
        addSetValidityMethod({
            ctrl: this,
            $element: element,
            set: function(object, property, controller) {
                var list = object[property];
                if (!list) {
                    object[property] = [ controller ];
                } else {
                    var index = list.indexOf(controller);
                    if (index === -1) {
                        list.push(controller);
                    }
                }
            },
            unset: function(object, property, controller) {
                var list = object[property];
                if (!list) {
                    return;
                }
                arrayRemove(list, controller);
                if (list.length === 0) {
                    delete object[property];
                }
            },
            parentForm: parentForm,
            $animate: $animate
        });
        form.$setDirty = function() {
            $animate.removeClass(element, PRISTINE_CLASS);
            $animate.addClass(element, DIRTY_CLASS);
            form.$dirty = true;
            form.$pristine = false;
            parentForm.$setDirty();
        };
        form.$setPristine = function() {
            $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS);
            form.$dirty = false;
            form.$pristine = true;
            form.$submitted = false;
            forEach(controls, function(control) {
                control.$setPristine();
            });
        };
        form.$setUntouched = function() {
            forEach(controls, function(control) {
                control.$setUntouched();
            });
        };
        form.$setSubmitted = function() {
            $animate.addClass(element, SUBMITTED_CLASS);
            form.$submitted = true;
            parentForm.$setSubmitted();
        };
    }
    var formDirectiveFactory = function(isNgForm) {
        return [ "$timeout", function($timeout) {
            var formDirective = {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                controller: FormController,
                compile: function ngFormCompile(formElement, attr) {
                    formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                    var nameAttr = attr.name ? "name" : isNgForm && attr.ngForm ? "ngForm" : false;
                    return {
                        pre: function ngFormPreLink(scope, formElement, attr, controller) {
                            if (!("action" in attr)) {
                                var handleFormSubmission = function(event) {
                                    scope.$apply(function() {
                                        controller.$commitViewValue();
                                        controller.$setSubmitted();
                                    });
                                    event.preventDefault();
                                };
                                addEventListenerFn(formElement[0], "submit", handleFormSubmission);
                                formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        removeEventListenerFn(formElement[0], "submit", handleFormSubmission);
                                    }, 0, false);
                                });
                            }
                            var parentFormCtrl = controller.$$parentForm;
                            if (nameAttr) {
                                setter(scope, null, controller.$name, controller, controller.$name);
                                attr.$observe(nameAttr, function(newValue) {
                                    if (controller.$name === newValue) return;
                                    setter(scope, null, controller.$name, undefined, controller.$name);
                                    parentFormCtrl.$$renameControl(controller, newValue);
                                    setter(scope, null, controller.$name, controller, controller.$name);
                                });
                            }
                            formElement.on("$destroy", function() {
                                parentFormCtrl.$removeControl(controller);
                                if (nameAttr) {
                                    setter(scope, null, attr[nameAttr], undefined, controller.$name);
                                }
                                extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
            return formDirective;
        } ];
    };
    var formDirective = formDirectiveFactory();
    var ngFormDirective = formDirectiveFactory(true);
    var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
    var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
    var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
    var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;
    var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
    var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
    var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
    var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var inputType = {
        text: textInputType,
        date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
        month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    };
    function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? value : value.toString();
        });
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
            var composing = false;
            element.on("compositionstart", function(data) {
                composing = true;
            });
            element.on("compositionend", function() {
                composing = false;
                listener();
            });
        }
        var listener = function(ev) {
            if (timeout) {
                $browser.defer.cancel(timeout);
                timeout = null;
            }
            if (composing) return;
            var value = element.val(), event = ev && ev.type;
            if (type !== "password" && (!attr.ngTrim || attr.ngTrim !== "false")) {
                value = trim(value);
            }
            if (ctrl.$viewValue !== value || value === "" && ctrl.$$hasNativeValidators) {
                ctrl.$setViewValue(value, event);
            }
        };
        if ($sniffer.hasEvent("input")) {
            element.on("input", listener);
        } else {
            var timeout;
            var deferListener = function(ev, input, origValue) {
                if (!timeout) {
                    timeout = $browser.defer(function() {
                        timeout = null;
                        if (!input || input.value !== origValue) {
                            listener(ev);
                        }
                    });
                }
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40) return;
                deferListener(event, this, this.value);
            });
            if ($sniffer.hasEvent("paste")) {
                element.on("paste cut", deferListener);
            }
        }
        element.on("change", listener);
        ctrl.$render = function() {
            element.val(ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue);
        };
    }
    function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
            return isoWeek;
        }
        if (isString(isoWeek)) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
                var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = (week - 1) * 7;
                if (existingDate) {
                    hours = existingDate.getHours();
                    minutes = existingDate.getMinutes();
                    seconds = existingDate.getSeconds();
                    milliseconds = existingDate.getMilliseconds();
                }
                return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
            }
        }
        return NaN;
    }
    function createDateParser(regexp, mapping) {
        return function(iso, date) {
            var parts, map;
            if (isDate(iso)) {
                return iso;
            }
            if (isString(iso)) {
                if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
                    iso = iso.substring(1, iso.length - 1);
                }
                if (ISO_DATE_REGEXP.test(iso)) {
                    return new Date(iso);
                }
                regexp.lastIndex = 0;
                parts = regexp.exec(iso);
                if (parts) {
                    parts.shift();
                    if (date) {
                        map = {
                            yyyy: date.getFullYear(),
                            MM: date.getMonth() + 1,
                            dd: date.getDate(),
                            HH: date.getHours(),
                            mm: date.getMinutes(),
                            ss: date.getSeconds(),
                            sss: date.getMilliseconds() / 1e3
                        };
                    } else {
                        map = {
                            yyyy: 1970,
                            MM: 1,
                            dd: 1,
                            HH: 0,
                            mm: 0,
                            ss: 0,
                            sss: 0
                        };
                    }
                    forEach(parts, function(part, index) {
                        if (index < mapping.length) {
                            map[mapping[index]] = +part;
                        }
                    });
                    return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1e3 || 0);
                }
            }
            return NaN;
        };
    }
    function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
            badInputChecker(scope, element, attr, ctrl);
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
            var previousDate;
            ctrl.$$parserName = type;
            ctrl.$parsers.push(function(value) {
                if (ctrl.$isEmpty(value)) return null;
                if (regexp.test(value)) {
                    var parsedDate = parseDate(value, previousDate);
                    if (timezone === "UTC") {
                        parsedDate.setMinutes(parsedDate.getMinutes() - parsedDate.getTimezoneOffset());
                    }
                    return parsedDate;
                }
                return undefined;
            });
            ctrl.$formatters.push(function(value) {
                if (value && !isDate(value)) {
                    throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                }
                if (isValidDate(value)) {
                    previousDate = value;
                    if (previousDate && timezone === "UTC") {
                        var timezoneOffset = 6e4 * previousDate.getTimezoneOffset();
                        previousDate = new Date(previousDate.getTime() + timezoneOffset);
                    }
                    return $filter("date")(value, format, timezone);
                } else {
                    previousDate = null;
                    return "";
                }
            });
            if (isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function(value) {
                    return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                };
                attr.$observe("min", function(val) {
                    minVal = parseObservedDateValue(val);
                    ctrl.$validate();
                });
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function(value) {
                    return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                };
                attr.$observe("max", function(val) {
                    maxVal = parseObservedDateValue(val);
                    ctrl.$validate();
                });
            }
            function isValidDate(value) {
                return value && !(value.getTime && value.getTime() !== value.getTime());
            }
            function parseObservedDateValue(val) {
                return isDefined(val) ? isDate(val) ? val : parseDate(val) : undefined;
            }
        };
    }
    function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
            ctrl.$parsers.push(function(value) {
                var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
                return validity.badInput && !validity.typeMismatch ? undefined : value;
            });
        }
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = "number";
        ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value)) return null;
            if (NUMBER_REGEXP.test(value)) return parseFloat(value);
            return undefined;
        });
        ctrl.$formatters.push(function(value) {
            if (!ctrl.$isEmpty(value)) {
                if (!isNumber(value)) {
                    throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                }
                value = value.toString();
            }
            return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
            };
            attr.$observe("min", function(val) {
                if (isDefined(val) && !isNumber(val)) {
                    val = parseFloat(val, 10);
                }
                minVal = isNumber(val) && !isNaN(val) ? val : undefined;
                ctrl.$validate();
            });
        }
        if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
            };
            attr.$observe("max", function(val) {
                if (isDefined(val) && !isNumber(val)) {
                    val = parseFloat(val, 10);
                }
                maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
                ctrl.$validate();
            });
        }
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = "url";
        ctrl.$validators.url = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = "email";
        ctrl.$validators.email = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
    }
    function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
            element.attr("name", nextUid());
        }
        var listener = function(ev) {
            if (element[0].checked) {
                ctrl.$setViewValue(attr.value, ev && ev.type);
            }
        };
        element.on("click", listener);
        ctrl.$render = function() {
            var value = attr.value;
            element[0].checked = value == ctrl.$viewValue;
        };
        attr.$observe("value", ctrl.$render);
    }
    function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
            parseFn = $parse(expression);
            if (!parseFn.constant) {
                throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw " + "`{1}`.", name, expression);
            }
            return parseFn(context);
        }
        return fallback;
    }
    function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, false);
        var listener = function(ev) {
            ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on("click", listener);
        ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
            return value === false;
        };
        ctrl.$formatters.push(function(value) {
            return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }
    var inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(scope, element, attr, ctrls) {
                    if (ctrls[0]) {
                        (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                    }
                }
            }
        };
    } ];
    var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
    var ngValueDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            compile: function(tpl, tplAttr) {
                if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                    return function ngValueConstantLink(scope, elm, attr) {
                        attr.$set("value", scope.$eval(attr.ngValue));
                    };
                } else {
                    return function ngValueLink(scope, elm, attr) {
                        scope.$watch(attr.ngValue, function valueWatchAction(value) {
                            attr.$set("value", value);
                        });
                    };
                }
            }
        };
    };
    var ngBindDirective = [ "$compile", function($compile) {
        return {
            restrict: "AC",
            compile: function ngBindCompile(templateElement) {
                $compile.$$addBindingClass(templateElement);
                return function ngBindLink(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBind);
                    element = element[0];
                    scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                        element.textContent = value === undefined ? "" : value;
                    });
                };
            }
        };
    } ];
    var ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
        return {
            compile: function ngBindTemplateCompile(templateElement) {
                $compile.$$addBindingClass(templateElement);
                return function ngBindTemplateLink(scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    $compile.$$addBindingInfo(element, interpolateFn.expressions);
                    element = element[0];
                    attr.$observe("ngBindTemplate", function(value) {
                        element.textContent = value === undefined ? "" : value;
                    });
                };
            }
        };
    } ];
    var ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
        return {
            restrict: "A",
            compile: function ngBindHtmlCompile(tElement, tAttrs) {
                var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
                var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
                    return (value || "").toString();
                });
                $compile.$$addBindingClass(tElement);
                return function ngBindHtmlLink(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBindHtml);
                    scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                        element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || "");
                    });
                };
            }
        };
    } ];
    var ngChangeDirective = valueFn({
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    });
    function classDirective(name, selector) {
        name = "ngClass" + name;
        return [ "$animate", function($animate) {
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    var oldVal;
                    scope.$watch(attr[name], ngClassWatchAction, true);
                    attr.$observe("class", function(value) {
                        ngClassWatchAction(scope.$eval(attr[name]));
                    });
                    if (name !== "ngClass") {
                        scope.$watch("$index", function($index, old$index) {
                            var mod = $index & 1;
                            if (mod !== (old$index & 1)) {
                                var classes = arrayClasses(scope.$eval(attr[name]));
                                mod === selector ? addClasses(classes) : removeClasses(classes);
                            }
                        });
                    }
                    function addClasses(classes) {
                        var newClasses = digestClassCounts(classes, 1);
                        attr.$addClass(newClasses);
                    }
                    function removeClasses(classes) {
                        var newClasses = digestClassCounts(classes, -1);
                        attr.$removeClass(newClasses);
                    }
                    function digestClassCounts(classes, count) {
                        var classCounts = element.data("$classCounts") || {};
                        var classesToUpdate = [];
                        forEach(classes, function(className) {
                            if (count > 0 || classCounts[className]) {
                                classCounts[className] = (classCounts[className] || 0) + count;
                                if (classCounts[className] === +(count > 0)) {
                                    classesToUpdate.push(className);
                                }
                            }
                        });
                        element.data("$classCounts", classCounts);
                        return classesToUpdate.join(" ");
                    }
                    function updateClasses(oldClasses, newClasses) {
                        var toAdd = arrayDifference(newClasses, oldClasses);
                        var toRemove = arrayDifference(oldClasses, newClasses);
                        toAdd = digestClassCounts(toAdd, 1);
                        toRemove = digestClassCounts(toRemove, -1);
                        if (toAdd && toAdd.length) {
                            $animate.addClass(element, toAdd);
                        }
                        if (toRemove && toRemove.length) {
                            $animate.removeClass(element, toRemove);
                        }
                    }
                    function ngClassWatchAction(newVal) {
                        if (selector === true || scope.$index % 2 === selector) {
                            var newClasses = arrayClasses(newVal || []);
                            if (!oldVal) {
                                addClasses(newClasses);
                            } else if (!equals(newVal, oldVal)) {
                                var oldClasses = arrayClasses(oldVal);
                                updateClasses(oldClasses, newClasses);
                            }
                        }
                        oldVal = shallowCopy(newVal);
                    }
                }
            };
            function arrayDifference(tokens1, tokens2) {
                var values = [];
                outer: for (var i = 0; i < tokens1.length; i++) {
                    var token = tokens1[i];
                    for (var j = 0; j < tokens2.length; j++) {
                        if (token == tokens2[j]) continue outer;
                    }
                    values.push(token);
                }
                return values;
            }
            function arrayClasses(classVal) {
                if (isArray(classVal)) {
                    return classVal;
                } else if (isString(classVal)) {
                    return classVal.split(" ");
                } else if (isObject(classVal)) {
                    var classes = [];
                    forEach(classVal, function(v, k) {
                        if (v) {
                            classes = classes.concat(k.split(" "));
                        }
                    });
                    return classes;
                }
                return classVal;
            }
        } ];
    }
    var ngClassDirective = classDirective("", true);
    var ngClassOddDirective = classDirective("Odd", 0);
    var ngClassEvenDirective = classDirective("Even", 1);
    var ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", undefined);
            element.removeClass("ng-cloak");
        }
    });
    var ngControllerDirective = [ function() {
        return {
            restrict: "A",
            scope: true,
            controller: "@",
            priority: 500
        };
    } ];
    var ngEventDirectives = {};
    var forceAsyncEvents = {
        blur: true,
        focus: true
    };
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = [ "$parse", "$rootScope", function($parse, $rootScope) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName], null, true);
                    return function ngEventHandler(scope, element) {
                        element.on(eventName, function(event) {
                            var callback = function() {
                                fn(scope, {
                                    $event: event
                                });
                            };
                            if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                                scope.$evalAsync(callback);
                            } else {
                                scope.$apply(callback);
                            }
                        });
                    };
                }
            };
        } ];
    });
    var ngIfDirective = [ "$animate", function($animate) {
        return {
            multiElement: true,
            transclude: "element",
            priority: 600,
            terminal: true,
            restrict: "A",
            $$tlb: true,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                    if (value) {
                        if (!childScope) {
                            $transclude(function(clone, newScope) {
                                childScope = newScope;
                                clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " ");
                                block = {
                                    clone: clone
                                };
                                $animate.enter(clone, $element.parent(), $element);
                            });
                        }
                    } else {
                        if (previousElements) {
                            previousElements.remove();
                            previousElements = null;
                        }
                        if (childScope) {
                            childScope.$destroy();
                            childScope = null;
                        }
                        if (block) {
                            previousElements = getBlockNodes(block.clone);
                            $animate.leave(previousElements).then(function() {
                                previousElements = null;
                            });
                            block = null;
                        }
                    }
                });
            }
        };
    } ];
    var ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", function($templateRequest, $anchorScroll, $animate) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: true,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var changeCounter = 0, currentScope, previousElement, currentElement;
                    var cleanupLastIncludeContent = function() {
                        if (previousElement) {
                            previousElement.remove();
                            previousElement = null;
                        }
                        if (currentScope) {
                            currentScope.$destroy();
                            currentScope = null;
                        }
                        if (currentElement) {
                            $animate.leave(currentElement).then(function() {
                                previousElement = null;
                            });
                            previousElement = currentElement;
                            currentElement = null;
                        }
                    };
                    scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                        var afterAnimation = function() {
                            if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                $anchorScroll();
                            }
                        };
                        var thisChangeId = ++changeCounter;
                        if (src) {
                            $templateRequest(src, true).then(function(response) {
                                if (thisChangeId !== changeCounter) return;
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent();
                                    $animate.enter(clone, null, $element).then(afterAnimation);
                                });
                                currentScope = newScope;
                                currentElement = clone;
                                currentScope.$emit("$includeContentLoaded", src);
                                scope.$eval(onloadExp);
                            }, function() {
                                if (thisChangeId === changeCounter) {
                                    cleanupLastIncludeContent();
                                    scope.$emit("$includeContentError", src);
                                }
                            });
                            scope.$emit("$includeContentRequested", src);
                        } else {
                            cleanupLastIncludeContent();
                            ctrl.template = null;
                        }
                    });
                };
            }
        };
    } ];
    var ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                if (/SVG/.test($element[0].toString())) {
                    $element.empty();
                    $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                        $element.append(clone);
                    }, {
                        futureParentElement: $element
                    });
                    return;
                }
                $element.html(ctrl.template);
                $compile($element.contents())(scope);
            }
        };
    } ];
    var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    });
    var ngListDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var ngList = element.attr(attr.$attr.ngList) || ", ";
                var trimValues = attr.ngTrim !== "false";
                var separator = trimValues ? trim(ngList) : ngList;
                var parse = function(viewValue) {
                    if (isUndefined(viewValue)) return;
                    var list = [];
                    if (viewValue) {
                        forEach(viewValue.split(separator), function(value) {
                            if (value) list.push(trimValues ? trim(value) : value);
                        });
                    }
                    return list;
                };
                ctrl.$parsers.push(parse);
                ctrl.$formatters.push(function(value) {
                    if (isArray(value)) {
                        return value.join(ngList);
                    }
                    return undefined;
                });
                ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    };
    var VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", UNTOUCHED_CLASS = "ng-untouched", TOUCHED_CLASS = "ng-touched", PENDING_CLASS = "ng-pending";
    var ngModelMinErr = minErr("ngModel");
    var NgModelController = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || "", false)($scope);
        var parsedNgModel = $parse($attr.ngModel), parsedNgModelAssign = parsedNgModel.assign, ngModelGet = parsedNgModel, ngModelSet = parsedNgModelAssign, pendingDebounce = null, parserValid, ctrl = this;
        this.$$setOptions = function(options) {
            ctrl.$options = options;
            if (options && options.getterSetter) {
                var invokeModelGetter = $parse($attr.ngModel + "()"), invokeModelSetter = $parse($attr.ngModel + "($$$p)");
                ngModelGet = function($scope) {
                    var modelValue = parsedNgModel($scope);
                    if (isFunction(modelValue)) {
                        modelValue = invokeModelGetter($scope);
                    }
                    return modelValue;
                };
                ngModelSet = function($scope, newValue) {
                    if (isFunction(parsedNgModel($scope))) {
                        invokeModelSetter($scope, {
                            $$$p: ctrl.$modelValue
                        });
                    } else {
                        parsedNgModelAssign($scope, ctrl.$modelValue);
                    }
                };
            } else if (!parsedNgModel.assign) {
                throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
            }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
            return isUndefined(value) || value === "" || value === null || value !== value;
        };
        var parentForm = $element.inheritedData("$formController") || nullFormCtrl, currentValidationRunId = 0;
        addSetValidityMethod({
            ctrl: this,
            $element: $element,
            set: function(object, property) {
                object[property] = true;
            },
            unset: function(object, property) {
                delete object[property];
            },
            parentForm: parentForm,
            $animate: $animate
        });
        this.$setPristine = function() {
            ctrl.$dirty = false;
            ctrl.$pristine = true;
            $animate.removeClass($element, DIRTY_CLASS);
            $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
            ctrl.$dirty = true;
            ctrl.$pristine = false;
            $animate.removeClass($element, PRISTINE_CLASS);
            $animate.addClass($element, DIRTY_CLASS);
            parentForm.$setDirty();
        };
        this.$setUntouched = function() {
            ctrl.$touched = false;
            ctrl.$untouched = true;
            $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
            ctrl.$touched = true;
            ctrl.$untouched = false;
            $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
            $timeout.cancel(pendingDebounce);
            ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
            ctrl.$render();
        };
        this.$validate = function() {
            if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
                return;
            }
            var viewValue = ctrl.$$lastCommittedViewValue;
            var modelValue = ctrl.$$rawModelValue;
            var prevValid = ctrl.$valid;
            var prevModelValue = ctrl.$modelValue;
            var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
            ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
                if (!allowInvalid && prevValid !== allValid) {
                    ctrl.$modelValue = allValid ? modelValue : undefined;
                    if (ctrl.$modelValue !== prevModelValue) {
                        ctrl.$$writeModelToScope();
                    }
                }
            });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
            currentValidationRunId++;
            var localValidationRunId = currentValidationRunId;
            if (!processParseErrors()) {
                validationDone(false);
                return;
            }
            if (!processSyncValidators()) {
                validationDone(false);
                return;
            }
            processAsyncValidators();
            function processParseErrors() {
                var errorKey = ctrl.$$parserName || "parse";
                if (parserValid === undefined) {
                    setValidity(errorKey, null);
                } else {
                    if (!parserValid) {
                        forEach(ctrl.$validators, function(v, name) {
                            setValidity(name, null);
                        });
                        forEach(ctrl.$asyncValidators, function(v, name) {
                            setValidity(name, null);
                        });
                    }
                    setValidity(errorKey, parserValid);
                    return parserValid;
                }
                return true;
            }
            function processSyncValidators() {
                var syncValidatorsValid = true;
                forEach(ctrl.$validators, function(validator, name) {
                    var result = validator(modelValue, viewValue);
                    syncValidatorsValid = syncValidatorsValid && result;
                    setValidity(name, result);
                });
                if (!syncValidatorsValid) {
                    forEach(ctrl.$asyncValidators, function(v, name) {
                        setValidity(name, null);
                    });
                    return false;
                }
                return true;
            }
            function processAsyncValidators() {
                var validatorPromises = [];
                var allValid = true;
                forEach(ctrl.$asyncValidators, function(validator, name) {
                    var promise = validator(modelValue, viewValue);
                    if (!isPromiseLike(promise)) {
                        throw ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                    }
                    setValidity(name, undefined);
                    validatorPromises.push(promise.then(function() {
                        setValidity(name, true);
                    }, function(error) {
                        allValid = false;
                        setValidity(name, false);
                    }));
                });
                if (!validatorPromises.length) {
                    validationDone(true);
                } else {
                    $q.all(validatorPromises).then(function() {
                        validationDone(allValid);
                    }, noop);
                }
            }
            function setValidity(name, isValid) {
                if (localValidationRunId === currentValidationRunId) {
                    ctrl.$setValidity(name, isValid);
                }
            }
            function validationDone(allValid) {
                if (localValidationRunId === currentValidationRunId) {
                    doneCallback(allValid);
                }
            }
        };
        this.$commitViewValue = function() {
            var viewValue = ctrl.$viewValue;
            $timeout.cancel(pendingDebounce);
            if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== "" || !ctrl.$$hasNativeValidators)) {
                return;
            }
            ctrl.$$lastCommittedViewValue = viewValue;
            if (ctrl.$pristine) {
                this.$setDirty();
            }
            this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
            var viewValue = ctrl.$$lastCommittedViewValue;
            var modelValue = viewValue;
            parserValid = isUndefined(modelValue) ? undefined : true;
            if (parserValid) {
                for (var i = 0; i < ctrl.$parsers.length; i++) {
                    modelValue = ctrl.$parsers[i](modelValue);
                    if (isUndefined(modelValue)) {
                        parserValid = false;
                        break;
                    }
                }
            }
            if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
                ctrl.$modelValue = ngModelGet($scope);
            }
            var prevModelValue = ctrl.$modelValue;
            var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
            ctrl.$$rawModelValue = modelValue;
            if (allowInvalid) {
                ctrl.$modelValue = modelValue;
                writeToModelIfNeeded();
            }
            ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
                if (!allowInvalid) {
                    ctrl.$modelValue = allValid ? modelValue : undefined;
                    writeToModelIfNeeded();
                }
            });
            function writeToModelIfNeeded() {
                if (ctrl.$modelValue !== prevModelValue) {
                    ctrl.$$writeModelToScope();
                }
            }
        };
        this.$$writeModelToScope = function() {
            ngModelSet($scope, ctrl.$modelValue);
            forEach(ctrl.$viewChangeListeners, function(listener) {
                try {
                    listener();
                } catch (e) {
                    $exceptionHandler(e);
                }
            });
        };
        this.$setViewValue = function(value, trigger) {
            ctrl.$viewValue = value;
            if (!ctrl.$options || ctrl.$options.updateOnDefault) {
                ctrl.$$debounceViewValueCommit(trigger);
            }
        };
        this.$$debounceViewValueCommit = function(trigger) {
            var debounceDelay = 0, options = ctrl.$options, debounce;
            if (options && isDefined(options.debounce)) {
                debounce = options.debounce;
                if (isNumber(debounce)) {
                    debounceDelay = debounce;
                } else if (isNumber(debounce[trigger])) {
                    debounceDelay = debounce[trigger];
                } else if (isNumber(debounce["default"])) {
                    debounceDelay = debounce["default"];
                }
            }
            $timeout.cancel(pendingDebounce);
            if (debounceDelay) {
                pendingDebounce = $timeout(function() {
                    ctrl.$commitViewValue();
                }, debounceDelay);
            } else if ($rootScope.$$phase) {
                ctrl.$commitViewValue();
            } else {
                $scope.$apply(function() {
                    ctrl.$commitViewValue();
                });
            }
        };
        $scope.$watch(function ngModelWatch() {
            var modelValue = ngModelGet($scope);
            if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
                ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
                parserValid = undefined;
                var formatters = ctrl.$formatters, idx = formatters.length;
                var viewValue = modelValue;
                while (idx--) {
                    viewValue = formatters[idx](viewValue);
                }
                if (ctrl.$viewValue !== viewValue) {
                    ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
                    ctrl.$render();
                    ctrl.$$runValidators(modelValue, viewValue, noop);
                }
            }
            return modelValue;
        });
    } ];
    var ngModelDirective = [ "$rootScope", function($rootScope) {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: NgModelController,
            priority: 1,
            compile: function ngModelCompile(element) {
                element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
                return {
                    pre: function ngModelPreLink(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
                        modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                        formCtrl.$addControl(modelCtrl);
                        attr.$observe("name", function(newValue) {
                            if (modelCtrl.$name !== newValue) {
                                formCtrl.$$renameControl(modelCtrl, newValue);
                            }
                        });
                        scope.$on("$destroy", function() {
                            formCtrl.$removeControl(modelCtrl);
                        });
                    },
                    post: function ngModelPostLink(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0];
                        if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                            element.on(modelCtrl.$options.updateOn, function(ev) {
                                modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                            });
                        }
                        element.on("blur", function(ev) {
                            if (modelCtrl.$touched) return;
                            if ($rootScope.$$phase) {
                                scope.$evalAsync(modelCtrl.$setTouched);
                            } else {
                                scope.$apply(modelCtrl.$setTouched);
                            }
                        });
                    }
                };
            }
        };
    } ];
    var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
    var ngModelOptionsDirective = function() {
        return {
            restrict: "A",
            controller: [ "$scope", "$attrs", function($scope, $attrs) {
                var that = this;
                this.$options = $scope.$eval($attrs.ngModelOptions);
                if (this.$options.updateOn !== undefined) {
                    this.$options.updateOnDefault = false;
                    this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                        that.$options.updateOnDefault = true;
                        return " ";
                    }));
                } else {
                    this.$options.updateOnDefault = true;
                }
            } ]
        };
    };
    function addSetValidityMethod(context) {
        var ctrl = context.ctrl, $element = context.$element, classCache = {}, set = context.set, unset = context.unset, parentForm = context.parentForm, $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
            if (state === undefined) {
                createAndSet("$pending", validationErrorKey, controller);
            } else {
                unsetAndCleanup("$pending", validationErrorKey, controller);
            }
            if (!isBoolean(state)) {
                unset(ctrl.$error, validationErrorKey, controller);
                unset(ctrl.$$success, validationErrorKey, controller);
            } else {
                if (state) {
                    unset(ctrl.$error, validationErrorKey, controller);
                    set(ctrl.$$success, validationErrorKey, controller);
                } else {
                    set(ctrl.$error, validationErrorKey, controller);
                    unset(ctrl.$$success, validationErrorKey, controller);
                }
            }
            if (ctrl.$pending) {
                cachedToggleClass(PENDING_CLASS, true);
                ctrl.$valid = ctrl.$invalid = undefined;
                toggleValidationCss("", null);
            } else {
                cachedToggleClass(PENDING_CLASS, false);
                ctrl.$valid = isObjectEmpty(ctrl.$error);
                ctrl.$invalid = !ctrl.$valid;
                toggleValidationCss("", ctrl.$valid);
            }
            var combinedState;
            if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
                combinedState = undefined;
            } else if (ctrl.$error[validationErrorKey]) {
                combinedState = false;
            } else if (ctrl.$$success[validationErrorKey]) {
                combinedState = true;
            } else {
                combinedState = null;
            }
            toggleValidationCss(validationErrorKey, combinedState);
            parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
            if (!ctrl[name]) {
                ctrl[name] = {};
            }
            set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
            if (ctrl[name]) {
                unset(ctrl[name], value, controller);
            }
            if (isObjectEmpty(ctrl[name])) {
                ctrl[name] = undefined;
            }
        }
        function cachedToggleClass(className, switchValue) {
            if (switchValue && !classCache[className]) {
                $animate.addClass($element, className);
                classCache[className] = true;
            } else if (!switchValue && classCache[className]) {
                $animate.removeClass($element, className);
                classCache[className] = false;
            }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "";
            cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
            cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
    }
    function isObjectEmpty(obj) {
        if (obj) {
            for (var prop in obj) {
                return false;
            }
        }
        return true;
    }
    var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1e3
    });
    var ngPluralizeDirective = [ "$locale", "$interpolate", function($locale, $interpolate) {
        var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
        return {
            restrict: "EA",
            link: function(scope, element, attr) {
                var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop, lastCount;
                forEach(attr, function(expression, attributeName) {
                    var tmpMatch = IS_WHEN.exec(attributeName);
                    if (tmpMatch) {
                        var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                        whens[whenKey] = element.attr(attr.$attr[attributeName]);
                    }
                });
                forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                });
                scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
                    var count = parseFloat(newVal);
                    var countIsNaN = isNaN(count);
                    if (!countIsNaN && !(count in whens)) {
                        count = $locale.pluralCat(count - offset);
                    }
                    if (count !== lastCount && !(countIsNaN && isNaN(lastCount))) {
                        watchRemover();
                        watchRemover = scope.$watch(whensExpFns[count], updateElementText);
                        lastCount = count;
                    }
                });
                function updateElementText(newText) {
                    element.text(newText || "");
                }
            }
        };
    } ];
    var ngRepeatDirective = [ "$parse", "$animate", function($parse, $animate) {
        var NG_REMOVED = "$$NG_REMOVED";
        var ngRepeatMinErr = minErr("ngRepeat");
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value;
            if (keyIdentifier) scope[keyIdentifier] = key;
            scope.$index = index;
            scope.$first = index === 0;
            scope.$last = index === arrayLength - 1;
            scope.$middle = !(scope.$first || scope.$last);
            scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
            return block.clone[0];
        };
        var getBlockEnd = function(block) {
            return block.clone[block.clone.length - 1];
        };
        return {
            restrict: "A",
            multiElement: true,
            transclude: "element",
            priority: 1e3,
            terminal: true,
            $$tlb: true,
            compile: function ngRepeatCompile($element, $attr) {
                var expression = $attr.ngRepeat;
                var ngRepeatEndComment = document.createComment(" end ngRepeat: " + expression + " ");
                var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!match) {
                    throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                }
                var lhs = match[1];
                var rhs = match[2];
                var aliasAs = match[3];
                var trackByExp = match[4];
                match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
                if (!match) {
                    throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                }
                var valueIdentifier = match[3] || match[1];
                var keyIdentifier = match[2];
                if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
                    throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                }
                var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
                var hashFnLocals = {
                    $id: hashKey
                };
                if (trackByExp) {
                    trackByExpGetter = $parse(trackByExp);
                } else {
                    trackByIdArrayFn = function(key, value) {
                        return hashKey(value);
                    };
                    trackByIdObjFn = function(key) {
                        return key;
                    };
                }
                return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
                    if (trackByExpGetter) {
                        trackByIdExpFn = function(key, value, index) {
                            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
                            hashFnLocals[valueIdentifier] = value;
                            hashFnLocals.$index = index;
                            return trackByExpGetter($scope, hashFnLocals);
                        };
                    }
                    var lastBlockMap = createMap();
                    $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                        var index, length, previousNode = $element[0], nextNode, nextBlockMap = createMap(), collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove;
                        if (aliasAs) {
                            $scope[aliasAs] = collection;
                        }
                        if (isArrayLike(collection)) {
                            collectionKeys = collection;
                            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                        } else {
                            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                            collectionKeys = [];
                            for (var itemKey in collection) {
                                if (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) != "$") {
                                    collectionKeys.push(itemKey);
                                }
                            }
                            collectionKeys.sort();
                        }
                        collectionLength = collectionKeys.length;
                        nextBlockOrder = new Array(collectionLength);
                        for (index = 0; index < collectionLength; index++) {
                            key = collection === collectionKeys ? index : collectionKeys[index];
                            value = collection[key];
                            trackById = trackByIdFn(key, value, index);
                            if (lastBlockMap[trackById]) {
                                block = lastBlockMap[trackById];
                                delete lastBlockMap[trackById];
                                nextBlockMap[trackById] = block;
                                nextBlockOrder[index] = block;
                            } else if (nextBlockMap[trackById]) {
                                forEach(nextBlockOrder, function(block) {
                                    if (block && block.scope) lastBlockMap[block.id] = block;
                                });
                                throw ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                            } else {
                                nextBlockOrder[index] = {
                                    id: trackById,
                                    scope: undefined,
                                    clone: undefined
                                };
                                nextBlockMap[trackById] = true;
                            }
                        }
                        for (var blockKey in lastBlockMap) {
                            block = lastBlockMap[blockKey];
                            elementsToRemove = getBlockNodes(block.clone);
                            $animate.leave(elementsToRemove);
                            if (elementsToRemove[0].parentNode) {
                                for (index = 0, length = elementsToRemove.length; index < length; index++) {
                                    elementsToRemove[index][NG_REMOVED] = true;
                                }
                            }
                            block.scope.$destroy();
                        }
                        for (index = 0; index < collectionLength; index++) {
                            key = collection === collectionKeys ? index : collectionKeys[index];
                            value = collection[key];
                            block = nextBlockOrder[index];
                            if (block.scope) {
                                nextNode = previousNode;
                                do {
                                    nextNode = nextNode.nextSibling;
                                } while (nextNode && nextNode[NG_REMOVED]);
                                if (getBlockStart(block) != nextNode) {
                                    $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
                                }
                                previousNode = getBlockEnd(block);
                                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                            } else {
                                $transclude(function ngRepeatTransclude(clone, scope) {
                                    block.scope = scope;
                                    var endNode = ngRepeatEndComment.cloneNode(false);
                                    clone[clone.length++] = endNode;
                                    $animate.enter(clone, null, jqLite(previousNode));
                                    previousNode = endNode;
                                    block.clone = clone;
                                    nextBlockMap[block.id] = block;
                                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                });
                            }
                        }
                        lastBlockMap = nextBlockMap;
                    });
                };
            }
        };
    } ];
    var NG_HIDE_CLASS = "ng-hide";
    var NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate";
    var ngShowDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: true,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
                    $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ];
    var ngHideDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: true,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
                    $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ];
    var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
            if (oldStyles && newStyles !== oldStyles) {
                forEach(oldStyles, function(val, style) {
                    element.css(style, "");
                });
            }
            if (newStyles) element.css(newStyles);
        }, true);
    });
    var ngSwitchDirective = [ "$animate", function($animate) {
        return {
            restrict: "EA",
            require: "ngSwitch",
            controller: [ "$scope", function ngSwitchController() {
                this.cases = {};
            } ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [];
                var spliceFactory = function(array, index) {
                    return function() {
                        array.splice(index, 1);
                    };
                };
                scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                    var i, ii;
                    for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                        $animate.cancel(previousLeaveAnimations[i]);
                    }
                    previousLeaveAnimations.length = 0;
                    for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                        var selected = getBlockNodes(selectedElements[i].clone);
                        selectedScopes[i].$destroy();
                        var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                        promise.then(spliceFactory(previousLeaveAnimations, i));
                    }
                    selectedElements.length = 0;
                    selectedScopes.length = 0;
                    if (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) {
                        forEach(selectedTranscludes, function(selectedTransclude) {
                            selectedTransclude.transclude(function(caseElement, selectedScope) {
                                selectedScopes.push(selectedScope);
                                var anchor = selectedTransclude.element;
                                caseElement[caseElement.length++] = document.createComment(" end ngSwitchWhen: ");
                                var block = {
                                    clone: caseElement
                                };
                                selectedElements.push(block);
                                $animate.enter(caseElement, anchor.parent(), anchor);
                            });
                        });
                    }
                });
            }
        };
    } ];
    var ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
            ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [];
            ctrl.cases["!" + attrs.ngSwitchWhen].push({
                transclude: $transclude,
                element: element
            });
        }
    });
    var ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [];
            ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    });
    var ngTranscludeDirective = ngDirective({
        restrict: "EAC",
        link: function($scope, $element, $attrs, controller, $transclude) {
            if (!$transclude) {
                throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! " + "No parent directive that requires a transclusion found. " + "Element: {0}", startingTag($element));
            }
            $transclude(function(clone) {
                $element.empty();
                $element.append(clone);
            });
        }
    });
    var scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: true,
            compile: function(element, attr) {
                if (attr.type == "text/ng-template") {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    } ];
    var ngOptionsMinErr = minErr("ngOptions");
    var ngOptionsDirective = valueFn({
        restrict: "A",
        terminal: true
    });
    var selectDirective = [ "$compile", "$parse", function($compile, $parse) {
        var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, nullModelCtrl = {
            $setViewValue: noop
        };
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: [ "$element", "$scope", "$attrs", function($element, $scope, $attrs) {
                var self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl, nullOption, unknownOption;
                self.databound = $attrs.ngModel;
                self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
                    ngModelCtrl = ngModelCtrl_;
                    nullOption = nullOption_;
                    unknownOption = unknownOption_;
                };
                self.addOption = function(value, element) {
                    assertNotHasOwnProperty(value, '"option value"');
                    optionsMap[value] = true;
                    if (ngModelCtrl.$viewValue == value) {
                        $element.val(value);
                        if (unknownOption.parent()) unknownOption.remove();
                    }
                    if (element && element[0].hasAttribute("selected")) {
                        element[0].selected = true;
                    }
                };
                self.removeOption = function(value) {
                    if (this.hasOption(value)) {
                        delete optionsMap[value];
                        if (ngModelCtrl.$viewValue === value) {
                            this.renderUnknownOption(value);
                        }
                    }
                };
                self.renderUnknownOption = function(val) {
                    var unknownVal = "? " + hashKey(val) + " ?";
                    unknownOption.val(unknownVal);
                    $element.prepend(unknownOption);
                    $element.val(unknownVal);
                    unknownOption.prop("selected", true);
                };
                self.hasOption = function(value) {
                    return optionsMap.hasOwnProperty(value);
                };
                $scope.$on("$destroy", function() {
                    self.renderUnknownOption = noop;
                });
            } ],
            link: function(scope, element, attr, ctrls) {
                if (!ctrls[1]) return;
                var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = false, emptyOption, renderScheduled = false, optionTemplate = jqLite(document.createElement("option")), optGroupTemplate = jqLite(document.createElement("optgroup")), unknownOption = optionTemplate.clone();
                for (var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
                    if (children[i].value === "") {
                        emptyOption = nullOption = children.eq(i);
                        break;
                    }
                }
                selectCtrl.init(ngModelCtrl, nullOption, unknownOption);
                if (multiple) {
                    ngModelCtrl.$isEmpty = function(value) {
                        return !value || value.length === 0;
                    };
                }
                if (optionsExp) setupAsOptions(scope, element, ngModelCtrl); else if (multiple) setupAsMultiple(scope, element, ngModelCtrl); else setupAsSingle(scope, element, ngModelCtrl, selectCtrl);
                function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
                    ngModelCtrl.$render = function() {
                        var viewValue = ngModelCtrl.$viewValue;
                        if (selectCtrl.hasOption(viewValue)) {
                            if (unknownOption.parent()) unknownOption.remove();
                            selectElement.val(viewValue);
                            if (viewValue === "") emptyOption.prop("selected", true);
                        } else {
                            if (viewValue == null && emptyOption) {
                                selectElement.val("");
                            } else {
                                selectCtrl.renderUnknownOption(viewValue);
                            }
                        }
                    };
                    selectElement.on("change", function() {
                        scope.$apply(function() {
                            if (unknownOption.parent()) unknownOption.remove();
                            ngModelCtrl.$setViewValue(selectElement.val());
                        });
                    });
                }
                function setupAsMultiple(scope, selectElement, ctrl) {
                    var lastView;
                    ctrl.$render = function() {
                        var items = new HashMap(ctrl.$viewValue);
                        forEach(selectElement.find("option"), function(option) {
                            option.selected = isDefined(items.get(option.value));
                        });
                    };
                    scope.$watch(function selectMultipleWatch() {
                        if (!equals(lastView, ctrl.$viewValue)) {
                            lastView = shallowCopy(ctrl.$viewValue);
                            ctrl.$render();
                        }
                    });
                    selectElement.on("change", function() {
                        scope.$apply(function() {
                            var array = [];
                            forEach(selectElement.find("option"), function(option) {
                                if (option.selected) {
                                    array.push(option.value);
                                }
                            });
                            ctrl.$setViewValue(array);
                        });
                    });
                }
                function setupAsOptions(scope, selectElement, ctrl) {
                    var match;
                    if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
                        throw ngOptionsMinErr("iexp", "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                    }
                    var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], selectAs = / as /.test(match[0]) && match[1], selectAsFn = selectAs ? $parse(selectAs) : null, keyName = match[5], groupByFn = $parse(match[3] || ""), valueFn = $parse(match[2] ? match[1] : valueName), valuesFn = $parse(match[7]), track = match[8], trackFn = track ? $parse(match[8]) : null, trackKeysCache = {}, optionGroupsCache = [ [ {
                        element: selectElement,
                        label: ""
                    } ] ], locals = {};
                    if (nullOption) {
                        $compile(nullOption)(scope);
                        nullOption.removeClass("ng-scope");
                        nullOption.remove();
                    }
                    selectElement.empty();
                    selectElement.on("change", selectionChanged);
                    ctrl.$render = render;
                    scope.$watchCollection(valuesFn, scheduleRendering);
                    scope.$watchCollection(getLabels, scheduleRendering);
                    if (multiple) {
                        scope.$watchCollection(function() {
                            return ctrl.$modelValue;
                        }, scheduleRendering);
                    }
                    function callExpression(exprFn, key, value) {
                        locals[valueName] = value;
                        if (keyName) locals[keyName] = key;
                        return exprFn(scope, locals);
                    }
                    function selectionChanged() {
                        scope.$apply(function() {
                            var collection = valuesFn(scope) || [];
                            var viewValue;
                            if (multiple) {
                                viewValue = [];
                                forEach(selectElement.val(), function(selectedKey) {
                                    selectedKey = trackFn ? trackKeysCache[selectedKey] : selectedKey;
                                    viewValue.push(getViewValue(selectedKey, collection[selectedKey]));
                                });
                            } else {
                                var selectedKey = trackFn ? trackKeysCache[selectElement.val()] : selectElement.val();
                                viewValue = getViewValue(selectedKey, collection[selectedKey]);
                            }
                            ctrl.$setViewValue(viewValue);
                            render();
                        });
                    }
                    function getViewValue(key, value) {
                        if (key === "?") {
                            return undefined;
                        } else if (key === "") {
                            return null;
                        } else {
                            var viewValueFn = selectAsFn ? selectAsFn : valueFn;
                            return callExpression(viewValueFn, key, value);
                        }
                    }
                    function getLabels() {
                        var values = valuesFn(scope);
                        var toDisplay;
                        if (values && isArray(values)) {
                            toDisplay = new Array(values.length);
                            for (var i = 0, ii = values.length; i < ii; i++) {
                                toDisplay[i] = callExpression(displayFn, i, values[i]);
                            }
                            return toDisplay;
                        } else if (values) {
                            toDisplay = {};
                            for (var prop in values) {
                                if (values.hasOwnProperty(prop)) {
                                    toDisplay[prop] = callExpression(displayFn, prop, values[prop]);
                                }
                            }
                        }
                        return toDisplay;
                    }
                    function createIsSelectedFn(viewValue) {
                        var selectedSet;
                        if (multiple) {
                            if (trackFn && isArray(viewValue)) {
                                selectedSet = new HashMap([]);
                                for (var trackIndex = 0; trackIndex < viewValue.length; trackIndex++) {
                                    selectedSet.put(callExpression(trackFn, null, viewValue[trackIndex]), true);
                                }
                            } else {
                                selectedSet = new HashMap(viewValue);
                            }
                        } else if (trackFn) {
                            viewValue = callExpression(trackFn, null, viewValue);
                        }
                        return function isSelected(key, value) {
                            var compareValueFn;
                            if (trackFn) {
                                compareValueFn = trackFn;
                            } else if (selectAsFn) {
                                compareValueFn = selectAsFn;
                            } else {
                                compareValueFn = valueFn;
                            }
                            if (multiple) {
                                return isDefined(selectedSet.remove(callExpression(compareValueFn, key, value)));
                            } else {
                                return viewValue === callExpression(compareValueFn, key, value);
                            }
                        };
                    }
                    function scheduleRendering() {
                        if (!renderScheduled) {
                            scope.$$postDigest(render);
                            renderScheduled = true;
                        }
                    }
                    function updateLabelMap(labelMap, label, added) {
                        labelMap[label] = labelMap[label] || 0;
                        labelMap[label] += added ? 1 : -1;
                    }
                    function render() {
                        renderScheduled = false;
                        var optionGroups = {
                            "": []
                        }, optionGroupNames = [ "" ], optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, viewValue = ctrl.$viewValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, key, value, groupLength, length, groupIndex, index, labelMap = {}, selected, isSelected = createIsSelectedFn(viewValue), anySelected = false, lastElement, element, label, optionId;
                        trackKeysCache = {};
                        for (index = 0; length = keys.length, index < length; index++) {
                            key = index;
                            if (keyName) {
                                key = keys[index];
                                if (key.charAt(0) === "$") continue;
                            }
                            value = values[key];
                            optionGroupName = callExpression(groupByFn, key, value) || "";
                            if (!(optionGroup = optionGroups[optionGroupName])) {
                                optionGroup = optionGroups[optionGroupName] = [];
                                optionGroupNames.push(optionGroupName);
                            }
                            selected = isSelected(key, value);
                            anySelected = anySelected || selected;
                            label = callExpression(displayFn, key, value);
                            label = isDefined(label) ? label : "";
                            optionId = trackFn ? trackFn(scope, locals) : keyName ? keys[index] : index;
                            if (trackFn) {
                                trackKeysCache[optionId] = key;
                            }
                            optionGroup.push({
                                id: optionId,
                                label: label,
                                selected: selected
                            });
                        }
                        if (!multiple) {
                            if (nullOption || viewValue === null) {
                                optionGroups[""].unshift({
                                    id: "",
                                    label: "",
                                    selected: !anySelected
                                });
                            } else if (!anySelected) {
                                optionGroups[""].unshift({
                                    id: "?",
                                    label: "",
                                    selected: true
                                });
                            }
                        }
                        for (groupIndex = 0, groupLength = optionGroupNames.length; groupIndex < groupLength; groupIndex++) {
                            optionGroupName = optionGroupNames[groupIndex];
                            optionGroup = optionGroups[optionGroupName];
                            if (optionGroupsCache.length <= groupIndex) {
                                existingParent = {
                                    element: optGroupTemplate.clone().attr("label", optionGroupName),
                                    label: optionGroup.label
                                };
                                existingOptions = [ existingParent ];
                                optionGroupsCache.push(existingOptions);
                                selectElement.append(existingParent.element);
                            } else {
                                existingOptions = optionGroupsCache[groupIndex];
                                existingParent = existingOptions[0];
                                if (existingParent.label != optionGroupName) {
                                    existingParent.element.attr("label", existingParent.label = optionGroupName);
                                }
                            }
                            lastElement = null;
                            for (index = 0, length = optionGroup.length; index < length; index++) {
                                option = optionGroup[index];
                                if (existingOption = existingOptions[index + 1]) {
                                    lastElement = existingOption.element;
                                    if (existingOption.label !== option.label) {
                                        updateLabelMap(labelMap, existingOption.label, false);
                                        updateLabelMap(labelMap, option.label, true);
                                        lastElement.text(existingOption.label = option.label);
                                        lastElement.prop("label", existingOption.label);
                                    }
                                    if (existingOption.id !== option.id) {
                                        lastElement.val(existingOption.id = option.id);
                                    }
                                    if (lastElement[0].selected !== option.selected) {
                                        lastElement.prop("selected", existingOption.selected = option.selected);
                                        if (msie) {
                                            lastElement.prop("selected", existingOption.selected);
                                        }
                                    }
                                } else {
                                    if (option.id === "" && nullOption) {
                                        element = nullOption;
                                    } else {
                                        (element = optionTemplate.clone()).val(option.id).prop("selected", option.selected).attr("selected", option.selected).prop("label", option.label).text(option.label);
                                    }
                                    existingOptions.push(existingOption = {
                                        element: element,
                                        label: option.label,
                                        id: option.id,
                                        selected: option.selected
                                    });
                                    updateLabelMap(labelMap, option.label, true);
                                    if (lastElement) {
                                        lastElement.after(element);
                                    } else {
                                        existingParent.element.append(element);
                                    }
                                    lastElement = element;
                                }
                            }
                            index++;
                            while (existingOptions.length > index) {
                                option = existingOptions.pop();
                                updateLabelMap(labelMap, option.label, false);
                                option.element.remove();
                            }
                        }
                        while (optionGroupsCache.length > groupIndex) {
                            optionGroup = optionGroupsCache.pop();
                            for (index = 1; index < optionGroup.length; ++index) {
                                updateLabelMap(labelMap, optionGroup[index].label, false);
                            }
                            optionGroup[0].element.remove();
                        }
                        forEach(labelMap, function(count, label) {
                            if (count > 0) {
                                selectCtrl.addOption(label);
                            } else if (count < 0) {
                                selectCtrl.removeOption(label);
                            }
                        });
                    }
                }
            }
        };
    } ];
    var optionDirective = [ "$interpolate", function($interpolate) {
        var nullSelectCtrl = {
            addOption: noop,
            removeOption: noop
        };
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                if (isUndefined(attr.value)) {
                    var interpolateFn = $interpolate(element.text(), true);
                    if (!interpolateFn) {
                        attr.$set("value", element.text());
                    }
                }
                return function(scope, element, attr) {
                    var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                    if (!selectCtrl || !selectCtrl.databound) {
                        selectCtrl = nullSelectCtrl;
                    }
                    if (interpolateFn) {
                        scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                            attr.$set("value", newVal);
                            if (oldVal !== newVal) {
                                selectCtrl.removeOption(oldVal);
                            }
                            selectCtrl.addOption(newVal, element);
                        });
                    } else {
                        selectCtrl.addOption(attr.value, element);
                    }
                    element.on("$destroy", function() {
                        selectCtrl.removeOption(attr.value);
                    });
                };
            }
        };
    } ];
    var styleDirective = valueFn({
        restrict: "E",
        terminal: false
    });
    var requiredDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                attr.required = true;
                ctrl.$validators.required = function(modelValue, viewValue) {
                    return !attr.required || !ctrl.$isEmpty(viewValue);
                };
                attr.$observe("required", function() {
                    ctrl.$validate();
                });
            }
        };
    };
    var patternDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var regexp, patternExp = attr.ngPattern || attr.pattern;
                attr.$observe("pattern", function(regex) {
                    if (isString(regex) && regex.length > 0) {
                        regex = new RegExp("^" + regex + "$");
                    }
                    if (regex && !regex.test) {
                        throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                    }
                    regexp = regex || undefined;
                    ctrl.$validate();
                });
                ctrl.$validators.pattern = function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
                };
            }
        };
    };
    var maxlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var maxlength = -1;
                attr.$observe("maxlength", function(value) {
                    var intVal = int(value);
                    maxlength = isNaN(intVal) ? -1 : intVal;
                    ctrl.$validate();
                });
                ctrl.$validators.maxlength = function(modelValue, viewValue) {
                    return maxlength < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
                };
            }
        };
    };
    var minlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var minlength = 0;
                attr.$observe("minlength", function(value) {
                    minlength = int(value) || 0;
                    ctrl.$validate();
                });
                ctrl.$validators.minlength = function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
                };
            }
        };
    };
    if (window.angular.bootstrap) {
        console.log("WARNING: Tried to load angular more than once.");
        return;
    }
    bindJQuery();
    publishExternalAPI(angular);
    jqLite(document).ready(function() {
        angularInit(document, bootstrap);
    });
})(window, document);

!window.angular.$$csp() && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}</style>');

(function(window, angular, undefined) {
    "use strict";
    angular.module("ngCookies", [ "ng" ]).factory("$cookies", [ "$rootScope", "$browser", function($rootScope, $browser) {
        var cookies = {}, lastCookies = {}, lastBrowserCookies, runEval = false, copy = angular.copy, isUndefined = angular.isUndefined;
        $browser.addPollFn(function() {
            var currentCookies = $browser.cookies();
            if (lastBrowserCookies != currentCookies) {
                lastBrowserCookies = currentCookies;
                copy(currentCookies, lastCookies);
                copy(currentCookies, cookies);
                if (runEval) $rootScope.$apply();
            }
        })();
        runEval = true;
        $rootScope.$watch(push);
        return cookies;
        function push() {
            var name, value, browserCookies, updated;
            for (name in lastCookies) {
                if (isUndefined(cookies[name])) {
                    $browser.cookies(name, undefined);
                    delete lastCookies[name];
                }
            }
            for (name in cookies) {
                value = cookies[name];
                if (!angular.isString(value)) {
                    value = "" + value;
                    cookies[name] = value;
                }
                if (value !== lastCookies[name]) {
                    $browser.cookies(name, value);
                    lastCookies[name] = value;
                    updated = true;
                }
            }
            if (updated) {
                browserCookies = $browser.cookies();
                for (name in cookies) {
                    if (cookies[name] !== browserCookies[name]) {
                        if (isUndefined(browserCookies[name])) {
                            delete cookies[name];
                            delete lastCookies[name];
                        } else {
                            cookies[name] = lastCookies[name] = browserCookies[name];
                        }
                    }
                }
            }
        }
    } ]).factory("$cookieStore", [ "$cookies", function($cookies) {
        return {
            get: function(key) {
                var value = $cookies[key];
                return value ? angular.fromJson(value) : value;
            },
            put: function(key, value) {
                $cookies[key] = angular.toJson(value);
            },
            remove: function(key) {
                delete $cookies[key];
            }
        };
    } ]);
})(window, window.angular);

(function(window, angular, undefined) {
    "use strict";
    var $sanitizeMinErr = angular.$$minErr("$sanitize");
    function $SanitizeProvider() {
        this.$get = [ "$$sanitizeUri", function($$sanitizeUri) {
            return function(html) {
                var buf = [];
                htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
                    return !/^unsafe/.test($$sanitizeUri(uri, isImage));
                }));
                return buf.join("");
            };
        } ];
    }
    function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, angular.noop);
        writer.chars(chars);
        return buf.join("");
    }
    var START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/, END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/, ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g, BEGIN_TAG_REGEXP = /^</, BEGING_END_TAGE_REGEXP = /^<\//, COMMENT_REGEXP = /<!--(.*?)-->/g, DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i, CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g, SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
    var voidElements = makeMap("area,br,col,hr,img,wbr");
    var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), optionalEndTagInlineElements = makeMap("rp,rt"), optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
    var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
    var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
    var svgElements = makeMap("animate,animateColor,animateMotion,animateTransform,circle,defs," + "desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient," + "line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set," + "stop,svg,switch,text,title,tspan,use");
    var specialElements = makeMap("script,style");
    var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements, svgElements);
    var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");
    var htmlAttrs = makeMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear," + "color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace," + "ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules," + "scope,scrolling,shape,size,span,start,summary,target,title,type," + "valign,value,vspace,width");
    var svgAttrs = makeMap("accent-height,accumulate,additive,alphabetic,arabic-form,ascent," + "attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color," + "color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family," + "font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name," + "gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints," + "keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits," + "markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position," + "overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY," + "repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh," + "stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke," + "stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit," + "stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2," + "underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version," + "viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role," + "xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2," + "zoomAndPan");
    var validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs);
    function makeMap(str) {
        var obj = {}, items = str.split(","), i;
        for (i = 0; i < items.length; i++) obj[items[i]] = true;
        return obj;
    }
    function htmlParser(html, handler) {
        if (typeof html !== "string") {
            if (html === null || typeof html === "undefined") {
                html = "";
            } else {
                html = "" + html;
            }
        }
        var index, chars, match, stack = [], last = html, text;
        stack.last = function() {
            return stack[stack.length - 1];
        };
        while (html) {
            text = "";
            chars = true;
            if (!stack.last() || !specialElements[stack.last()]) {
                if (html.indexOf("\x3c!--") === 0) {
                    index = html.indexOf("--", 4);
                    if (index >= 0 && html.lastIndexOf("--\x3e", index) === index) {
                        if (handler.comment) handler.comment(html.substring(4, index));
                        html = html.substring(index + 3);
                        chars = false;
                    }
                } else if (DOCTYPE_REGEXP.test(html)) {
                    match = html.match(DOCTYPE_REGEXP);
                    if (match) {
                        html = html.replace(match[0], "");
                        chars = false;
                    }
                } else if (BEGING_END_TAGE_REGEXP.test(html)) {
                    match = html.match(END_TAG_REGEXP);
                    if (match) {
                        html = html.substring(match[0].length);
                        match[0].replace(END_TAG_REGEXP, parseEndTag);
                        chars = false;
                    }
                } else if (BEGIN_TAG_REGEXP.test(html)) {
                    match = html.match(START_TAG_REGEXP);
                    if (match) {
                        if (match[4]) {
                            html = html.substring(match[0].length);
                            match[0].replace(START_TAG_REGEXP, parseStartTag);
                        }
                        chars = false;
                    } else {
                        text += "<";
                        html = html.substring(1);
                    }
                }
                if (chars) {
                    index = html.indexOf("<");
                    text += index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? "" : html.substring(index);
                    if (handler.chars) handler.chars(decodeEntities(text));
                }
            } else {
                html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", "i"), function(all, text) {
                    text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
                    if (handler.chars) handler.chars(decodeEntities(text));
                    return "";
                });
                parseEndTag("", stack.last());
            }
            if (html == last) {
                throw $sanitizeMinErr("badparse", "The sanitizer was unable to parse the following block " + "of html: {0}", html);
            }
            last = html;
        }
        parseEndTag();
        function parseStartTag(tag, tagName, rest, unary) {
            tagName = angular.lowercase(tagName);
            if (blockElements[tagName]) {
                while (stack.last() && inlineElements[stack.last()]) {
                    parseEndTag("", stack.last());
                }
            }
            if (optionalEndTagElements[tagName] && stack.last() == tagName) {
                parseEndTag("", tagName);
            }
            unary = voidElements[tagName] || !!unary;
            if (!unary) stack.push(tagName);
            var attrs = {};
            rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
                var value = doubleQuotedValue || singleQuotedValue || unquotedValue || "";
                attrs[name] = decodeEntities(value);
            });
            if (handler.start) handler.start(tagName, attrs, unary);
        }
        function parseEndTag(tag, tagName) {
            var pos = 0, i;
            tagName = angular.lowercase(tagName);
            if (tagName) for (pos = stack.length - 1; pos >= 0; pos--) if (stack[pos] == tagName) break;
            if (pos >= 0) {
                for (i = stack.length - 1; i >= pos; i--) if (handler.end) handler.end(stack[i]);
                stack.length = pos;
            }
        }
    }
    var hiddenPre = document.createElement("pre");
    function decodeEntities(value) {
        if (!value) {
            return "";
        }
        hiddenPre.innerHTML = value.replace(/</g, "&lt;");
        return hiddenPre.textContent;
    }
    function encodeEntities(value) {
        return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(value) {
            var hi = value.charCodeAt(0);
            var low = value.charCodeAt(1);
            return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
            return "&#" + value.charCodeAt(0) + ";";
        }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    function htmlSanitizeWriter(buf, uriValidator) {
        var ignore = false;
        var out = angular.bind(buf, buf.push);
        return {
            start: function(tag, attrs, unary) {
                tag = angular.lowercase(tag);
                if (!ignore && specialElements[tag]) {
                    ignore = tag;
                }
                if (!ignore && validElements[tag] === true) {
                    out("<");
                    out(tag);
                    angular.forEach(attrs, function(value, key) {
                        var lkey = angular.lowercase(key);
                        var isImage = tag === "img" && lkey === "src" || lkey === "background";
                        if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                            out(" ");
                            out(key);
                            out('="');
                            out(encodeEntities(value));
                            out('"');
                        }
                    });
                    out(unary ? "/>" : ">");
                }
            },
            end: function(tag) {
                tag = angular.lowercase(tag);
                if (!ignore && validElements[tag] === true) {
                    out("</");
                    out(tag);
                    out(">");
                }
                if (tag == ignore) {
                    ignore = false;
                }
            },
            chars: function(chars) {
                if (!ignore) {
                    out(encodeEntities(chars));
                }
            }
        };
    }
    angular.module("ngSanitize", []).provider("$sanitize", $SanitizeProvider);
    angular.module("ngSanitize").filter("linky", [ "$sanitize", function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"”’]/i, MAILTO_REGEXP = /^mailto:/i;
        return function(text, target) {
            if (!text) return text;
            var match;
            var raw = text;
            var html = [];
            var url;
            var i;
            while (match = raw.match(LINKY_URL_REGEXP)) {
                url = match[0];
                if (!match[2] && !match[4]) {
                    url = (match[3] ? "http://" : "mailto:") + url;
                }
                i = match.index;
                addText(raw.substr(0, i));
                addLink(url, match[0].replace(MAILTO_REGEXP, ""));
                raw = raw.substring(i + match[0].length);
            }
            addText(raw);
            return $sanitize(html.join(""));
            function addText(text) {
                if (!text) {
                    return;
                }
                html.push(sanitizeText(text));
            }
            function addLink(url, text) {
                html.push("<a ");
                if (angular.isDefined(target)) {
                    html.push('target="', target, '" ');
                }
                html.push('href="', url.replace(/"/g, "&quot;"), '">');
                addText(text);
                html.push("</a>");
            }
        };
    } ]);
})(window, window.angular);

(function(window, angular, undefined) {
    "use strict";
    angular.module("ngAnimate", [ "ng" ]).directive("ngAnimateChildren", function() {
        var NG_ANIMATE_CHILDREN = "$$ngAnimateChildren";
        return function(scope, element, attrs) {
            var val = attrs.ngAnimateChildren;
            if (angular.isString(val) && val.length === 0) {
                element.data(NG_ANIMATE_CHILDREN, true);
            } else {
                scope.$watch(val, function(value) {
                    element.data(NG_ANIMATE_CHILDREN, !!value);
                });
            }
        };
    }).factory("$$animateReflow", [ "$$rAF", "$document", function($$rAF, $document) {
        var bod = $document[0].body;
        return function(fn) {
            return $$rAF(function() {
                fn(bod.offsetWidth);
            });
        };
    } ]).config([ "$provide", "$animateProvider", function($provide, $animateProvider) {
        var noop = angular.noop;
        var forEach = angular.forEach;
        var selectors = $animateProvider.$$selectors;
        var isArray = angular.isArray;
        var isString = angular.isString;
        var isObject = angular.isObject;
        var ELEMENT_NODE = 1;
        var NG_ANIMATE_STATE = "$$ngAnimateState";
        var NG_ANIMATE_CHILDREN = "$$ngAnimateChildren";
        var NG_ANIMATE_CLASS_NAME = "ng-animate";
        var rootAnimateState = {
            running: true
        };
        function extractElementNode(element) {
            for (var i = 0; i < element.length; i++) {
                var elm = element[i];
                if (elm.nodeType == ELEMENT_NODE) {
                    return elm;
                }
            }
        }
        function prepareElement(element) {
            return element && angular.element(element);
        }
        function stripCommentsFromElement(element) {
            return angular.element(extractElementNode(element));
        }
        function isMatchingElement(elm1, elm2) {
            return extractElementNode(elm1) == extractElementNode(elm2);
        }
        var $$jqLite;
        $provide.decorator("$animate", [ "$delegate", "$$q", "$injector", "$sniffer", "$rootElement", "$$asyncCallback", "$rootScope", "$document", "$templateRequest", "$$jqLite", function($delegate, $$q, $injector, $sniffer, $rootElement, $$asyncCallback, $rootScope, $document, $templateRequest, $$$jqLite) {
            $$jqLite = $$$jqLite;
            $rootElement.data(NG_ANIMATE_STATE, rootAnimateState);
            var deregisterWatch = $rootScope.$watch(function() {
                return $templateRequest.totalPendingRequests;
            }, function(val, oldVal) {
                if (val !== 0) return;
                deregisterWatch();
                $rootScope.$$postDigest(function() {
                    $rootScope.$$postDigest(function() {
                        rootAnimateState.running = false;
                    });
                });
            });
            var globalAnimationCounter = 0;
            var classNameFilter = $animateProvider.classNameFilter();
            var isAnimatableClassName = !classNameFilter ? function() {
                return true;
            } : function(className) {
                return classNameFilter.test(className);
            };
            function classBasedAnimationsBlocked(element, setter) {
                var data = element.data(NG_ANIMATE_STATE) || {};
                if (setter) {
                    data.running = true;
                    data.structural = true;
                    element.data(NG_ANIMATE_STATE, data);
                }
                return data.disabled || data.running && data.structural;
            }
            function runAnimationPostDigest(fn) {
                var cancelFn, defer = $$q.defer();
                defer.promise.$$cancelFn = function() {
                    cancelFn && cancelFn();
                };
                $rootScope.$$postDigest(function() {
                    cancelFn = fn(function() {
                        defer.resolve();
                    });
                });
                return defer.promise;
            }
            function parseAnimateOptions(options) {
                if (isObject(options)) {
                    if (options.tempClasses && isString(options.tempClasses)) {
                        options.tempClasses = options.tempClasses.split(/\s+/);
                    }
                    return options;
                }
            }
            function resolveElementClasses(element, cache, runningAnimations) {
                runningAnimations = runningAnimations || {};
                var lookup = {};
                forEach(runningAnimations, function(data, selector) {
                    forEach(selector.split(" "), function(s) {
                        lookup[s] = data;
                    });
                });
                var hasClasses = Object.create(null);
                forEach((element.attr("class") || "").split(/\s+/), function(className) {
                    hasClasses[className] = true;
                });
                var toAdd = [], toRemove = [];
                forEach(cache && cache.classes || [], function(status, className) {
                    var hasClass = hasClasses[className];
                    var matchingAnimation = lookup[className] || {};
                    if (status === false) {
                        if (hasClass || matchingAnimation.event == "addClass") {
                            toRemove.push(className);
                        }
                    } else if (status === true) {
                        if (!hasClass || matchingAnimation.event == "removeClass") {
                            toAdd.push(className);
                        }
                    }
                });
                return toAdd.length + toRemove.length > 0 && [ toAdd.join(" "), toRemove.join(" ") ];
            }
            function lookup(name) {
                if (name) {
                    var matches = [], flagMap = {}, classes = name.substr(1).split(".");
                    if ($sniffer.transitions || $sniffer.animations) {
                        matches.push($injector.get(selectors[""]));
                    }
                    for (var i = 0; i < classes.length; i++) {
                        var klass = classes[i], selectorFactoryName = selectors[klass];
                        if (selectorFactoryName && !flagMap[klass]) {
                            matches.push($injector.get(selectorFactoryName));
                            flagMap[klass] = true;
                        }
                    }
                    return matches;
                }
            }
            function animationRunner(element, animationEvent, className, options) {
                var node = element[0];
                if (!node) {
                    return;
                }
                if (options) {
                    options.to = options.to || {};
                    options.from = options.from || {};
                }
                var classNameAdd;
                var classNameRemove;
                if (isArray(className)) {
                    classNameAdd = className[0];
                    classNameRemove = className[1];
                    if (!classNameAdd) {
                        className = classNameRemove;
                        animationEvent = "removeClass";
                    } else if (!classNameRemove) {
                        className = classNameAdd;
                        animationEvent = "addClass";
                    } else {
                        className = classNameAdd + " " + classNameRemove;
                    }
                }
                var isSetClassOperation = animationEvent == "setClass";
                var isClassBased = isSetClassOperation || animationEvent == "addClass" || animationEvent == "removeClass" || animationEvent == "animate";
                var currentClassName = element.attr("class");
                var classes = currentClassName + " " + className;
                if (!isAnimatableClassName(classes)) {
                    return;
                }
                var beforeComplete = noop, beforeCancel = [], before = [], afterComplete = noop, afterCancel = [], after = [];
                var animationLookup = (" " + classes).replace(/\s+/g, ".");
                forEach(lookup(animationLookup), function(animationFactory) {
                    var created = registerAnimation(animationFactory, animationEvent);
                    if (!created && isSetClassOperation) {
                        registerAnimation(animationFactory, "addClass");
                        registerAnimation(animationFactory, "removeClass");
                    }
                });
                function registerAnimation(animationFactory, event) {
                    var afterFn = animationFactory[event];
                    var beforeFn = animationFactory["before" + event.charAt(0).toUpperCase() + event.substr(1)];
                    if (afterFn || beforeFn) {
                        if (event == "leave") {
                            beforeFn = afterFn;
                            afterFn = null;
                        }
                        after.push({
                            event: event,
                            fn: afterFn
                        });
                        before.push({
                            event: event,
                            fn: beforeFn
                        });
                        return true;
                    }
                }
                function run(fns, cancellations, allCompleteFn) {
                    var animations = [];
                    forEach(fns, function(animation) {
                        animation.fn && animations.push(animation);
                    });
                    var count = 0;
                    function afterAnimationComplete(index) {
                        if (cancellations) {
                            (cancellations[index] || noop)();
                            if (++count < animations.length) return;
                            cancellations = null;
                        }
                        allCompleteFn();
                    }
                    forEach(animations, function(animation, index) {
                        var progress = function() {
                            afterAnimationComplete(index);
                        };
                        switch (animation.event) {
                          case "setClass":
                            cancellations.push(animation.fn(element, classNameAdd, classNameRemove, progress, options));
                            break;

                          case "animate":
                            cancellations.push(animation.fn(element, className, options.from, options.to, progress));
                            break;

                          case "addClass":
                            cancellations.push(animation.fn(element, classNameAdd || className, progress, options));
                            break;

                          case "removeClass":
                            cancellations.push(animation.fn(element, classNameRemove || className, progress, options));
                            break;

                          default:
                            cancellations.push(animation.fn(element, progress, options));
                            break;
                        }
                    });
                    if (cancellations && cancellations.length === 0) {
                        allCompleteFn();
                    }
                }
                return {
                    node: node,
                    event: animationEvent,
                    className: className,
                    isClassBased: isClassBased,
                    isSetClassOperation: isSetClassOperation,
                    applyStyles: function() {
                        if (options) {
                            element.css(angular.extend(options.from || {}, options.to || {}));
                        }
                    },
                    before: function(allCompleteFn) {
                        beforeComplete = allCompleteFn;
                        run(before, beforeCancel, function() {
                            beforeComplete = noop;
                            allCompleteFn();
                        });
                    },
                    after: function(allCompleteFn) {
                        afterComplete = allCompleteFn;
                        run(after, afterCancel, function() {
                            afterComplete = noop;
                            allCompleteFn();
                        });
                    },
                    cancel: function() {
                        if (beforeCancel) {
                            forEach(beforeCancel, function(cancelFn) {
                                (cancelFn || noop)(true);
                            });
                            beforeComplete(true);
                        }
                        if (afterCancel) {
                            forEach(afterCancel, function(cancelFn) {
                                (cancelFn || noop)(true);
                            });
                            afterComplete(true);
                        }
                    }
                };
            }
            return {
                animate: function(element, from, to, className, options) {
                    className = className || "ng-inline-animate";
                    options = parseAnimateOptions(options) || {};
                    options.from = to ? from : null;
                    options.to = to ? to : from;
                    return runAnimationPostDigest(function(done) {
                        return performAnimation("animate", className, stripCommentsFromElement(element), null, null, noop, options, done);
                    });
                },
                enter: function(element, parentElement, afterElement, options) {
                    options = parseAnimateOptions(options);
                    element = angular.element(element);
                    parentElement = prepareElement(parentElement);
                    afterElement = prepareElement(afterElement);
                    classBasedAnimationsBlocked(element, true);
                    $delegate.enter(element, parentElement, afterElement);
                    return runAnimationPostDigest(function(done) {
                        return performAnimation("enter", "ng-enter", stripCommentsFromElement(element), parentElement, afterElement, noop, options, done);
                    });
                },
                leave: function(element, options) {
                    options = parseAnimateOptions(options);
                    element = angular.element(element);
                    cancelChildAnimations(element);
                    classBasedAnimationsBlocked(element, true);
                    return runAnimationPostDigest(function(done) {
                        return performAnimation("leave", "ng-leave", stripCommentsFromElement(element), null, null, function() {
                            $delegate.leave(element);
                        }, options, done);
                    });
                },
                move: function(element, parentElement, afterElement, options) {
                    options = parseAnimateOptions(options);
                    element = angular.element(element);
                    parentElement = prepareElement(parentElement);
                    afterElement = prepareElement(afterElement);
                    cancelChildAnimations(element);
                    classBasedAnimationsBlocked(element, true);
                    $delegate.move(element, parentElement, afterElement);
                    return runAnimationPostDigest(function(done) {
                        return performAnimation("move", "ng-move", stripCommentsFromElement(element), parentElement, afterElement, noop, options, done);
                    });
                },
                addClass: function(element, className, options) {
                    return this.setClass(element, className, [], options);
                },
                removeClass: function(element, className, options) {
                    return this.setClass(element, [], className, options);
                },
                setClass: function(element, add, remove, options) {
                    options = parseAnimateOptions(options);
                    var STORAGE_KEY = "$$animateClasses";
                    element = angular.element(element);
                    element = stripCommentsFromElement(element);
                    if (classBasedAnimationsBlocked(element)) {
                        return $delegate.$$setClassImmediately(element, add, remove, options);
                    }
                    var classes, cache = element.data(STORAGE_KEY);
                    var hasCache = !!cache;
                    if (!cache) {
                        cache = {};
                        cache.classes = {};
                    }
                    classes = cache.classes;
                    add = isArray(add) ? add : add.split(" ");
                    forEach(add, function(c) {
                        if (c && c.length) {
                            classes[c] = true;
                        }
                    });
                    remove = isArray(remove) ? remove : remove.split(" ");
                    forEach(remove, function(c) {
                        if (c && c.length) {
                            classes[c] = false;
                        }
                    });
                    if (hasCache) {
                        if (options && cache.options) {
                            cache.options = angular.extend(cache.options || {}, options);
                        }
                        return cache.promise;
                    } else {
                        element.data(STORAGE_KEY, cache = {
                            classes: classes,
                            options: options
                        });
                    }
                    return cache.promise = runAnimationPostDigest(function(done) {
                        var cache, parentNode, parentElement, elementNode = extractElementNode(element);
                        if (elementNode) {
                            cache = element.data(STORAGE_KEY);
                            element.removeData(STORAGE_KEY);
                            parentElement = element.parent();
                            parentNode = elementNode.parentNode;
                        }
                        if (!parentNode || parentNode["$$NG_REMOVED"] || elementNode["$$NG_REMOVED"]) {
                            done();
                            return;
                        }
                        var state = element.data(NG_ANIMATE_STATE) || {};
                        var classes = resolveElementClasses(element, cache, state.active);
                        return !classes ? done() : performAnimation("setClass", classes, element, parentElement, null, function() {
                            if (classes[0]) $delegate.$$addClassImmediately(element, classes[0]);
                            if (classes[1]) $delegate.$$removeClassImmediately(element, classes[1]);
                        }, cache.options, done);
                    });
                },
                cancel: function(promise) {
                    promise.$$cancelFn();
                },
                enabled: function(value, element) {
                    switch (arguments.length) {
                      case 2:
                        if (value) {
                            cleanup(element);
                        } else {
                            var data = element.data(NG_ANIMATE_STATE) || {};
                            data.disabled = true;
                            element.data(NG_ANIMATE_STATE, data);
                        }
                        break;

                      case 1:
                        rootAnimateState.disabled = !value;
                        break;

                      default:
                        value = !rootAnimateState.disabled;
                        break;
                    }
                    return !!value;
                }
            };
            function performAnimation(animationEvent, className, element, parentElement, afterElement, domOperation, options, doneCallback) {
                var noopCancel = noop;
                var runner = animationRunner(element, animationEvent, className, options);
                if (!runner) {
                    fireDOMOperation();
                    fireBeforeCallbackAsync();
                    fireAfterCallbackAsync();
                    closeAnimation();
                    return noopCancel;
                }
                animationEvent = runner.event;
                className = runner.className;
                var elementEvents = angular.element._data(runner.node);
                elementEvents = elementEvents && elementEvents.events;
                if (!parentElement) {
                    parentElement = afterElement ? afterElement.parent() : element.parent();
                }
                if (animationsDisabled(element, parentElement)) {
                    fireDOMOperation();
                    fireBeforeCallbackAsync();
                    fireAfterCallbackAsync();
                    closeAnimation();
                    return noopCancel;
                }
                var ngAnimateState = element.data(NG_ANIMATE_STATE) || {};
                var runningAnimations = ngAnimateState.active || {};
                var totalActiveAnimations = ngAnimateState.totalActive || 0;
                var lastAnimation = ngAnimateState.last;
                var skipAnimation = false;
                if (totalActiveAnimations > 0) {
                    var animationsToCancel = [];
                    if (!runner.isClassBased) {
                        if (animationEvent == "leave" && runningAnimations["ng-leave"]) {
                            skipAnimation = true;
                        } else {
                            for (var klass in runningAnimations) {
                                animationsToCancel.push(runningAnimations[klass]);
                            }
                            ngAnimateState = {};
                            cleanup(element, true);
                        }
                    } else if (lastAnimation.event == "setClass") {
                        animationsToCancel.push(lastAnimation);
                        cleanup(element, className);
                    } else if (runningAnimations[className]) {
                        var current = runningAnimations[className];
                        if (current.event == animationEvent) {
                            skipAnimation = true;
                        } else {
                            animationsToCancel.push(current);
                            cleanup(element, className);
                        }
                    }
                    if (animationsToCancel.length > 0) {
                        forEach(animationsToCancel, function(operation) {
                            operation.cancel();
                        });
                    }
                }
                if (runner.isClassBased && !runner.isSetClassOperation && animationEvent != "animate" && !skipAnimation) {
                    skipAnimation = animationEvent == "addClass" == element.hasClass(className);
                }
                if (skipAnimation) {
                    fireDOMOperation();
                    fireBeforeCallbackAsync();
                    fireAfterCallbackAsync();
                    fireDoneCallbackAsync();
                    return noopCancel;
                }
                runningAnimations = ngAnimateState.active || {};
                totalActiveAnimations = ngAnimateState.totalActive || 0;
                if (animationEvent == "leave") {
                    element.one("$destroy", function(e) {
                        var element = angular.element(this);
                        var state = element.data(NG_ANIMATE_STATE);
                        if (state) {
                            var activeLeaveAnimation = state.active["ng-leave"];
                            if (activeLeaveAnimation) {
                                activeLeaveAnimation.cancel();
                                cleanup(element, "ng-leave");
                            }
                        }
                    });
                }
                $$jqLite.addClass(element, NG_ANIMATE_CLASS_NAME);
                if (options && options.tempClasses) {
                    forEach(options.tempClasses, function(className) {
                        $$jqLite.addClass(element, className);
                    });
                }
                var localAnimationCount = globalAnimationCounter++;
                totalActiveAnimations++;
                runningAnimations[className] = runner;
                element.data(NG_ANIMATE_STATE, {
                    last: runner,
                    active: runningAnimations,
                    index: localAnimationCount,
                    totalActive: totalActiveAnimations
                });
                fireBeforeCallbackAsync();
                runner.before(function(cancelled) {
                    var data = element.data(NG_ANIMATE_STATE);
                    cancelled = cancelled || !data || !data.active[className] || runner.isClassBased && data.active[className].event != animationEvent;
                    fireDOMOperation();
                    if (cancelled === true) {
                        closeAnimation();
                    } else {
                        fireAfterCallbackAsync();
                        runner.after(closeAnimation);
                    }
                });
                return runner.cancel;
                function fireDOMCallback(animationPhase) {
                    var eventName = "$animate:" + animationPhase;
                    if (elementEvents && elementEvents[eventName] && elementEvents[eventName].length > 0) {
                        $$asyncCallback(function() {
                            element.triggerHandler(eventName, {
                                event: animationEvent,
                                className: className
                            });
                        });
                    }
                }
                function fireBeforeCallbackAsync() {
                    fireDOMCallback("before");
                }
                function fireAfterCallbackAsync() {
                    fireDOMCallback("after");
                }
                function fireDoneCallbackAsync() {
                    fireDOMCallback("close");
                    doneCallback();
                }
                function fireDOMOperation() {
                    if (!fireDOMOperation.hasBeenRun) {
                        fireDOMOperation.hasBeenRun = true;
                        domOperation();
                    }
                }
                function closeAnimation() {
                    if (!closeAnimation.hasBeenRun) {
                        if (runner) {
                            runner.applyStyles();
                        }
                        closeAnimation.hasBeenRun = true;
                        if (options && options.tempClasses) {
                            forEach(options.tempClasses, function(className) {
                                $$jqLite.removeClass(element, className);
                            });
                        }
                        var data = element.data(NG_ANIMATE_STATE);
                        if (data) {
                            if (runner && runner.isClassBased) {
                                cleanup(element, className);
                            } else {
                                $$asyncCallback(function() {
                                    var data = element.data(NG_ANIMATE_STATE) || {};
                                    if (localAnimationCount == data.index) {
                                        cleanup(element, className, animationEvent);
                                    }
                                });
                                element.data(NG_ANIMATE_STATE, data);
                            }
                        }
                        fireDoneCallbackAsync();
                    }
                }
            }
            function cancelChildAnimations(element) {
                var node = extractElementNode(element);
                if (node) {
                    var nodes = angular.isFunction(node.getElementsByClassName) ? node.getElementsByClassName(NG_ANIMATE_CLASS_NAME) : node.querySelectorAll("." + NG_ANIMATE_CLASS_NAME);
                    forEach(nodes, function(element) {
                        element = angular.element(element);
                        var data = element.data(NG_ANIMATE_STATE);
                        if (data && data.active) {
                            forEach(data.active, function(runner) {
                                runner.cancel();
                            });
                        }
                    });
                }
            }
            function cleanup(element, className) {
                if (isMatchingElement(element, $rootElement)) {
                    if (!rootAnimateState.disabled) {
                        rootAnimateState.running = false;
                        rootAnimateState.structural = false;
                    }
                } else if (className) {
                    var data = element.data(NG_ANIMATE_STATE) || {};
                    var removeAnimations = className === true;
                    if (!removeAnimations && data.active && data.active[className]) {
                        data.totalActive--;
                        delete data.active[className];
                    }
                    if (removeAnimations || !data.totalActive) {
                        $$jqLite.removeClass(element, NG_ANIMATE_CLASS_NAME);
                        element.removeData(NG_ANIMATE_STATE);
                    }
                }
            }
            function animationsDisabled(element, parentElement) {
                if (rootAnimateState.disabled) {
                    return true;
                }
                if (isMatchingElement(element, $rootElement)) {
                    return rootAnimateState.running;
                }
                var allowChildAnimations, parentRunningAnimation, hasParent;
                do {
                    if (parentElement.length === 0) break;
                    var isRoot = isMatchingElement(parentElement, $rootElement);
                    var state = isRoot ? rootAnimateState : parentElement.data(NG_ANIMATE_STATE) || {};
                    if (state.disabled) {
                        return true;
                    }
                    if (isRoot) {
                        hasParent = true;
                    }
                    if (allowChildAnimations !== false) {
                        var animateChildrenFlag = parentElement.data(NG_ANIMATE_CHILDREN);
                        if (angular.isDefined(animateChildrenFlag)) {
                            allowChildAnimations = animateChildrenFlag;
                        }
                    }
                    parentRunningAnimation = parentRunningAnimation || state.running || state.last && !state.last.isClassBased;
                } while (parentElement = parentElement.parent());
                return !hasParent || !allowChildAnimations && parentRunningAnimation;
            }
        } ]);
        $animateProvider.register("", [ "$window", "$sniffer", "$timeout", "$$animateReflow", function($window, $sniffer, $timeout, $$animateReflow) {
            var CSS_PREFIX = "", TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;
            if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
                CSS_PREFIX = "-webkit-";
                TRANSITION_PROP = "WebkitTransition";
                TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend";
            } else {
                TRANSITION_PROP = "transition";
                TRANSITIONEND_EVENT = "transitionend";
            }
            if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
                CSS_PREFIX = "-webkit-";
                ANIMATION_PROP = "WebkitAnimation";
                ANIMATIONEND_EVENT = "webkitAnimationEnd animationend";
            } else {
                ANIMATION_PROP = "animation";
                ANIMATIONEND_EVENT = "animationend";
            }
            var DURATION_KEY = "Duration";
            var PROPERTY_KEY = "Property";
            var DELAY_KEY = "Delay";
            var ANIMATION_ITERATION_COUNT_KEY = "IterationCount";
            var ANIMATION_PLAYSTATE_KEY = "PlayState";
            var NG_ANIMATE_PARENT_KEY = "$$ngAnimateKey";
            var NG_ANIMATE_CSS_DATA_KEY = "$$ngAnimateCSS3Data";
            var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
            var CLOSING_TIME_BUFFER = 1.5;
            var ONE_SECOND = 1e3;
            var lookupCache = {};
            var parentCounter = 0;
            var animationReflowQueue = [];
            var cancelAnimationReflow;
            function clearCacheAfterReflow() {
                if (!cancelAnimationReflow) {
                    cancelAnimationReflow = $$animateReflow(function() {
                        animationReflowQueue = [];
                        cancelAnimationReflow = null;
                        lookupCache = {};
                    });
                }
            }
            function afterReflow(element, callback) {
                if (cancelAnimationReflow) {
                    cancelAnimationReflow();
                }
                animationReflowQueue.push(callback);
                cancelAnimationReflow = $$animateReflow(function() {
                    forEach(animationReflowQueue, function(fn) {
                        fn();
                    });
                    animationReflowQueue = [];
                    cancelAnimationReflow = null;
                    lookupCache = {};
                });
            }
            var closingTimer = null;
            var closingTimestamp = 0;
            var animationElementQueue = [];
            function animationCloseHandler(element, totalTime) {
                var node = extractElementNode(element);
                element = angular.element(node);
                animationElementQueue.push(element);
                var futureTimestamp = Date.now() + totalTime;
                if (futureTimestamp <= closingTimestamp) {
                    return;
                }
                $timeout.cancel(closingTimer);
                closingTimestamp = futureTimestamp;
                closingTimer = $timeout(function() {
                    closeAllAnimations(animationElementQueue);
                    animationElementQueue = [];
                }, totalTime, false);
            }
            function closeAllAnimations(elements) {
                forEach(elements, function(element) {
                    var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
                    if (elementData) {
                        forEach(elementData.closeAnimationFns, function(fn) {
                            fn();
                        });
                    }
                });
            }
            function getElementAnimationDetails(element, cacheKey) {
                var data = cacheKey ? lookupCache[cacheKey] : null;
                if (!data) {
                    var transitionDuration = 0;
                    var transitionDelay = 0;
                    var animationDuration = 0;
                    var animationDelay = 0;
                    forEach(element, function(element) {
                        if (element.nodeType == ELEMENT_NODE) {
                            var elementStyles = $window.getComputedStyle(element) || {};
                            var transitionDurationStyle = elementStyles[TRANSITION_PROP + DURATION_KEY];
                            transitionDuration = Math.max(parseMaxTime(transitionDurationStyle), transitionDuration);
                            var transitionDelayStyle = elementStyles[TRANSITION_PROP + DELAY_KEY];
                            transitionDelay = Math.max(parseMaxTime(transitionDelayStyle), transitionDelay);
                            var animationDelayStyle = elementStyles[ANIMATION_PROP + DELAY_KEY];
                            animationDelay = Math.max(parseMaxTime(elementStyles[ANIMATION_PROP + DELAY_KEY]), animationDelay);
                            var aDuration = parseMaxTime(elementStyles[ANIMATION_PROP + DURATION_KEY]);
                            if (aDuration > 0) {
                                aDuration *= parseInt(elementStyles[ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY], 10) || 1;
                            }
                            animationDuration = Math.max(aDuration, animationDuration);
                        }
                    });
                    data = {
                        total: 0,
                        transitionDelay: transitionDelay,
                        transitionDuration: transitionDuration,
                        animationDelay: animationDelay,
                        animationDuration: animationDuration
                    };
                    if (cacheKey) {
                        lookupCache[cacheKey] = data;
                    }
                }
                return data;
            }
            function parseMaxTime(str) {
                var maxValue = 0;
                var values = isString(str) ? str.split(/\s*,\s*/) : [];
                forEach(values, function(value) {
                    maxValue = Math.max(parseFloat(value) || 0, maxValue);
                });
                return maxValue;
            }
            function getCacheKey(element) {
                var parentElement = element.parent();
                var parentID = parentElement.data(NG_ANIMATE_PARENT_KEY);
                if (!parentID) {
                    parentElement.data(NG_ANIMATE_PARENT_KEY, ++parentCounter);
                    parentID = parentCounter;
                }
                return parentID + "-" + extractElementNode(element).getAttribute("class");
            }
            function animateSetup(animationEvent, element, className, styles) {
                var structural = [ "ng-enter", "ng-leave", "ng-move" ].indexOf(className) >= 0;
                var cacheKey = getCacheKey(element);
                var eventCacheKey = cacheKey + " " + className;
                var itemIndex = lookupCache[eventCacheKey] ? ++lookupCache[eventCacheKey].total : 0;
                var stagger = {};
                if (itemIndex > 0) {
                    var staggerClassName = className + "-stagger";
                    var staggerCacheKey = cacheKey + " " + staggerClassName;
                    var applyClasses = !lookupCache[staggerCacheKey];
                    applyClasses && $$jqLite.addClass(element, staggerClassName);
                    stagger = getElementAnimationDetails(element, staggerCacheKey);
                    applyClasses && $$jqLite.removeClass(element, staggerClassName);
                }
                $$jqLite.addClass(element, className);
                var formerData = element.data(NG_ANIMATE_CSS_DATA_KEY) || {};
                var timings = getElementAnimationDetails(element, eventCacheKey);
                var transitionDuration = timings.transitionDuration;
                var animationDuration = timings.animationDuration;
                if (structural && transitionDuration === 0 && animationDuration === 0) {
                    $$jqLite.removeClass(element, className);
                    return false;
                }
                var blockTransition = styles || structural && transitionDuration > 0;
                var blockAnimation = animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
                var closeAnimationFns = formerData.closeAnimationFns || [];
                element.data(NG_ANIMATE_CSS_DATA_KEY, {
                    stagger: stagger,
                    cacheKey: eventCacheKey,
                    running: formerData.running || 0,
                    itemIndex: itemIndex,
                    blockTransition: blockTransition,
                    closeAnimationFns: closeAnimationFns
                });
                var node = extractElementNode(element);
                if (blockTransition) {
                    blockTransitions(node, true);
                    if (styles) {
                        element.css(styles);
                    }
                }
                if (blockAnimation) {
                    blockAnimations(node, true);
                }
                return true;
            }
            function animateRun(animationEvent, element, className, activeAnimationComplete, styles) {
                var node = extractElementNode(element);
                var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
                if (node.getAttribute("class").indexOf(className) == -1 || !elementData) {
                    activeAnimationComplete();
                    return;
                }
                var activeClassName = "";
                var pendingClassName = "";
                forEach(className.split(" "), function(klass, i) {
                    var prefix = (i > 0 ? " " : "") + klass;
                    activeClassName += prefix + "-active";
                    pendingClassName += prefix + "-pending";
                });
                var style = "";
                var appliedStyles = [];
                var itemIndex = elementData.itemIndex;
                var stagger = elementData.stagger;
                var staggerTime = 0;
                if (itemIndex > 0) {
                    var transitionStaggerDelay = 0;
                    if (stagger.transitionDelay > 0 && stagger.transitionDuration === 0) {
                        transitionStaggerDelay = stagger.transitionDelay * itemIndex;
                    }
                    var animationStaggerDelay = 0;
                    if (stagger.animationDelay > 0 && stagger.animationDuration === 0) {
                        animationStaggerDelay = stagger.animationDelay * itemIndex;
                        appliedStyles.push(CSS_PREFIX + "animation-play-state");
                    }
                    staggerTime = Math.round(Math.max(transitionStaggerDelay, animationStaggerDelay) * 100) / 100;
                }
                if (!staggerTime) {
                    $$jqLite.addClass(element, activeClassName);
                    if (elementData.blockTransition) {
                        blockTransitions(node, false);
                    }
                }
                var eventCacheKey = elementData.cacheKey + " " + activeClassName;
                var timings = getElementAnimationDetails(element, eventCacheKey);
                var maxDuration = Math.max(timings.transitionDuration, timings.animationDuration);
                if (maxDuration === 0) {
                    $$jqLite.removeClass(element, activeClassName);
                    animateClose(element, className);
                    activeAnimationComplete();
                    return;
                }
                if (!staggerTime && styles && Object.keys(styles).length > 0) {
                    if (!timings.transitionDuration) {
                        element.css("transition", timings.animationDuration + "s linear all");
                        appliedStyles.push("transition");
                    }
                    element.css(styles);
                }
                var maxDelay = Math.max(timings.transitionDelay, timings.animationDelay);
                var maxDelayTime = maxDelay * ONE_SECOND;
                if (appliedStyles.length > 0) {
                    var oldStyle = node.getAttribute("style") || "";
                    if (oldStyle.charAt(oldStyle.length - 1) !== ";") {
                        oldStyle += ";";
                    }
                    node.setAttribute("style", oldStyle + " " + style);
                }
                var startTime = Date.now();
                var css3AnimationEvents = ANIMATIONEND_EVENT + " " + TRANSITIONEND_EVENT;
                var animationTime = (maxDelay + maxDuration) * CLOSING_TIME_BUFFER;
                var totalTime = (staggerTime + animationTime) * ONE_SECOND;
                var staggerTimeout;
                if (staggerTime > 0) {
                    $$jqLite.addClass(element, pendingClassName);
                    staggerTimeout = $timeout(function() {
                        staggerTimeout = null;
                        if (timings.transitionDuration > 0) {
                            blockTransitions(node, false);
                        }
                        if (timings.animationDuration > 0) {
                            blockAnimations(node, false);
                        }
                        $$jqLite.addClass(element, activeClassName);
                        $$jqLite.removeClass(element, pendingClassName);
                        if (styles) {
                            if (timings.transitionDuration === 0) {
                                element.css("transition", timings.animationDuration + "s linear all");
                            }
                            element.css(styles);
                            appliedStyles.push("transition");
                        }
                    }, staggerTime * ONE_SECOND, false);
                }
                element.on(css3AnimationEvents, onAnimationProgress);
                elementData.closeAnimationFns.push(function() {
                    onEnd();
                    activeAnimationComplete();
                });
                elementData.running++;
                animationCloseHandler(element, totalTime);
                return onEnd;
                function onEnd() {
                    element.off(css3AnimationEvents, onAnimationProgress);
                    $$jqLite.removeClass(element, activeClassName);
                    $$jqLite.removeClass(element, pendingClassName);
                    if (staggerTimeout) {
                        $timeout.cancel(staggerTimeout);
                    }
                    animateClose(element, className);
                    var node = extractElementNode(element);
                    for (var i in appliedStyles) {
                        node.style.removeProperty(appliedStyles[i]);
                    }
                }
                function onAnimationProgress(event) {
                    event.stopPropagation();
                    var ev = event.originalEvent || event;
                    var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();
                    var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                    if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                        activeAnimationComplete();
                    }
                }
            }
            function blockTransitions(node, bool) {
                node.style[TRANSITION_PROP + PROPERTY_KEY] = bool ? "none" : "";
            }
            function blockAnimations(node, bool) {
                node.style[ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY] = bool ? "paused" : "";
            }
            function animateBefore(animationEvent, element, className, styles) {
                if (animateSetup(animationEvent, element, className, styles)) {
                    return function(cancelled) {
                        cancelled && animateClose(element, className);
                    };
                }
            }
            function animateAfter(animationEvent, element, className, afterAnimationComplete, styles) {
                if (element.data(NG_ANIMATE_CSS_DATA_KEY)) {
                    return animateRun(animationEvent, element, className, afterAnimationComplete, styles);
                } else {
                    animateClose(element, className);
                    afterAnimationComplete();
                }
            }
            function animate(animationEvent, element, className, animationComplete, options) {
                var preReflowCancellation = animateBefore(animationEvent, element, className, options.from);
                if (!preReflowCancellation) {
                    clearCacheAfterReflow();
                    animationComplete();
                    return;
                }
                var cancel = preReflowCancellation;
                afterReflow(element, function() {
                    cancel = animateAfter(animationEvent, element, className, animationComplete, options.to);
                });
                return function(cancelled) {
                    (cancel || noop)(cancelled);
                };
            }
            function animateClose(element, className) {
                $$jqLite.removeClass(element, className);
                var data = element.data(NG_ANIMATE_CSS_DATA_KEY);
                if (data) {
                    if (data.running) {
                        data.running--;
                    }
                    if (!data.running || data.running === 0) {
                        element.removeData(NG_ANIMATE_CSS_DATA_KEY);
                    }
                }
            }
            return {
                animate: function(element, className, from, to, animationCompleted, options) {
                    options = options || {};
                    options.from = from;
                    options.to = to;
                    return animate("animate", element, className, animationCompleted, options);
                },
                enter: function(element, animationCompleted, options) {
                    options = options || {};
                    return animate("enter", element, "ng-enter", animationCompleted, options);
                },
                leave: function(element, animationCompleted, options) {
                    options = options || {};
                    return animate("leave", element, "ng-leave", animationCompleted, options);
                },
                move: function(element, animationCompleted, options) {
                    options = options || {};
                    return animate("move", element, "ng-move", animationCompleted, options);
                },
                beforeSetClass: function(element, add, remove, animationCompleted, options) {
                    options = options || {};
                    var className = suffixClasses(remove, "-remove") + " " + suffixClasses(add, "-add");
                    var cancellationMethod = animateBefore("setClass", element, className, options.from);
                    if (cancellationMethod) {
                        afterReflow(element, animationCompleted);
                        return cancellationMethod;
                    }
                    clearCacheAfterReflow();
                    animationCompleted();
                },
                beforeAddClass: function(element, className, animationCompleted, options) {
                    options = options || {};
                    var cancellationMethod = animateBefore("addClass", element, suffixClasses(className, "-add"), options.from);
                    if (cancellationMethod) {
                        afterReflow(element, animationCompleted);
                        return cancellationMethod;
                    }
                    clearCacheAfterReflow();
                    animationCompleted();
                },
                beforeRemoveClass: function(element, className, animationCompleted, options) {
                    options = options || {};
                    var cancellationMethod = animateBefore("removeClass", element, suffixClasses(className, "-remove"), options.from);
                    if (cancellationMethod) {
                        afterReflow(element, animationCompleted);
                        return cancellationMethod;
                    }
                    clearCacheAfterReflow();
                    animationCompleted();
                },
                setClass: function(element, add, remove, animationCompleted, options) {
                    options = options || {};
                    remove = suffixClasses(remove, "-remove");
                    add = suffixClasses(add, "-add");
                    var className = remove + " " + add;
                    return animateAfter("setClass", element, className, animationCompleted, options.to);
                },
                addClass: function(element, className, animationCompleted, options) {
                    options = options || {};
                    return animateAfter("addClass", element, suffixClasses(className, "-add"), animationCompleted, options.to);
                },
                removeClass: function(element, className, animationCompleted, options) {
                    options = options || {};
                    return animateAfter("removeClass", element, suffixClasses(className, "-remove"), animationCompleted, options.to);
                }
            };
            function suffixClasses(classes, suffix) {
                var className = "";
                classes = isArray(classes) ? classes : classes.split(/\s+/);
                forEach(classes, function(klass, i) {
                    if (klass && klass.length > 0) {
                        className += (i > 0 ? " " : "") + klass + suffix;
                    }
                });
                return className;
            }
        } ]);
    } ]);
})(window, window.angular);

(function(window, angular, undefined) {
    "use strict";
    var ngTouch = angular.module("ngTouch", []);
    function nodeName_(element) {
        return angular.lowercase(element.nodeName || element[0] && element[0].nodeName);
    }
    ngTouch.factory("$swipe", [ function() {
        var MOVE_BUFFER_RADIUS = 10;
        var POINTER_EVENTS = {
            mouse: {
                start: "mousedown",
                move: "mousemove",
                end: "mouseup"
            },
            touch: {
                start: "touchstart",
                move: "touchmove",
                end: "touchend",
                cancel: "touchcancel"
            }
        };
        function getCoordinates(event) {
            var originalEvent = event.originalEvent || event;
            var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [ originalEvent ];
            var e = originalEvent.changedTouches && originalEvent.changedTouches[0] || touches[0];
            return {
                x: e.clientX,
                y: e.clientY
            };
        }
        function getEvents(pointerTypes, eventType) {
            var res = [];
            angular.forEach(pointerTypes, function(pointerType) {
                var eventName = POINTER_EVENTS[pointerType][eventType];
                if (eventName) {
                    res.push(eventName);
                }
            });
            return res.join(" ");
        }
        return {
            bind: function(element, eventHandlers, pointerTypes) {
                var totalX, totalY;
                var startCoords;
                var lastPos;
                var active = false;
                pointerTypes = pointerTypes || [ "mouse", "touch" ];
                element.on(getEvents(pointerTypes, "start"), function(event) {
                    startCoords = getCoordinates(event);
                    active = true;
                    totalX = 0;
                    totalY = 0;
                    lastPos = startCoords;
                    eventHandlers["start"] && eventHandlers["start"](startCoords, event);
                });
                var events = getEvents(pointerTypes, "cancel");
                if (events) {
                    element.on(events, function(event) {
                        active = false;
                        eventHandlers["cancel"] && eventHandlers["cancel"](event);
                    });
                }
                element.on(getEvents(pointerTypes, "move"), function(event) {
                    if (!active) return;
                    if (!startCoords) return;
                    var coords = getCoordinates(event);
                    totalX += Math.abs(coords.x - lastPos.x);
                    totalY += Math.abs(coords.y - lastPos.y);
                    lastPos = coords;
                    if (totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS) {
                        return;
                    }
                    if (totalY > totalX) {
                        active = false;
                        eventHandlers["cancel"] && eventHandlers["cancel"](event);
                        return;
                    } else {
                        event.preventDefault();
                        eventHandlers["move"] && eventHandlers["move"](coords, event);
                    }
                });
                element.on(getEvents(pointerTypes, "end"), function(event) {
                    if (!active) return;
                    active = false;
                    eventHandlers["end"] && eventHandlers["end"](getCoordinates(event), event);
                });
            }
        };
    } ]);
    ngTouch.config([ "$provide", function($provide) {
        $provide.decorator("ngClickDirective", [ "$delegate", function($delegate) {
            $delegate.shift();
            return $delegate;
        } ]);
    } ]);
    ngTouch.directive("ngClick", [ "$parse", "$timeout", "$rootElement", function($parse, $timeout, $rootElement) {
        var TAP_DURATION = 750;
        var MOVE_TOLERANCE = 12;
        var PREVENT_DURATION = 2500;
        var CLICKBUSTER_THRESHOLD = 25;
        var ACTIVE_CLASS_NAME = "ng-click-active";
        var lastPreventedTime;
        var touchCoordinates;
        var lastLabelClickCoordinates;
        function hit(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD;
        }
        function checkAllowableRegions(touchCoordinates, x, y) {
            for (var i = 0; i < touchCoordinates.length; i += 2) {
                if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) {
                    touchCoordinates.splice(i, i + 2);
                    return true;
                }
            }
            return false;
        }
        function onClick(event) {
            if (Date.now() - lastPreventedTime > PREVENT_DURATION) {
                return;
            }
            var touches = event.touches && event.touches.length ? event.touches : [ event ];
            var x = touches[0].clientX;
            var y = touches[0].clientY;
            if (x < 1 && y < 1) {
                return;
            }
            if (lastLabelClickCoordinates && lastLabelClickCoordinates[0] === x && lastLabelClickCoordinates[1] === y) {
                return;
            }
            if (lastLabelClickCoordinates) {
                lastLabelClickCoordinates = null;
            }
            if (nodeName_(event.target) === "label") {
                lastLabelClickCoordinates = [ x, y ];
            }
            if (checkAllowableRegions(touchCoordinates, x, y)) {
                return;
            }
            event.stopPropagation();
            event.preventDefault();
            event.target && event.target.blur && event.target.blur();
        }
        function onTouchStart(event) {
            var touches = event.touches && event.touches.length ? event.touches : [ event ];
            var x = touches[0].clientX;
            var y = touches[0].clientY;
            touchCoordinates.push(x, y);
            $timeout(function() {
                for (var i = 0; i < touchCoordinates.length; i += 2) {
                    if (touchCoordinates[i] == x && touchCoordinates[i + 1] == y) {
                        touchCoordinates.splice(i, i + 2);
                        return;
                    }
                }
            }, PREVENT_DURATION, false);
        }
        function preventGhostClick(x, y) {
            if (!touchCoordinates) {
                $rootElement[0].addEventListener("click", onClick, true);
                $rootElement[0].addEventListener("touchstart", onTouchStart, true);
                touchCoordinates = [];
            }
            lastPreventedTime = Date.now();
            checkAllowableRegions(touchCoordinates, x, y);
        }
        return function(scope, element, attr) {
            var clickHandler = $parse(attr.ngClick), tapping = false, tapElement, startTime, touchStartX, touchStartY;
            function resetState() {
                tapping = false;
                element.removeClass(ACTIVE_CLASS_NAME);
            }
            element.on("touchstart", function(event) {
                tapping = true;
                tapElement = event.target ? event.target : event.srcElement;
                if (tapElement.nodeType == 3) {
                    tapElement = tapElement.parentNode;
                }
                element.addClass(ACTIVE_CLASS_NAME);
                startTime = Date.now();
                var originalEvent = event.originalEvent || event;
                var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [ originalEvent ];
                var e = touches[0];
                touchStartX = e.clientX;
                touchStartY = e.clientY;
            });
            element.on("touchmove", function(event) {
                resetState();
            });
            element.on("touchcancel", function(event) {
                resetState();
            });
            element.on("touchend", function(event) {
                var diff = Date.now() - startTime;
                var originalEvent = event.originalEvent || event;
                var touches = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches : originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [ originalEvent ];
                var e = touches[0];
                var x = e.clientX;
                var y = e.clientY;
                var dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2));
                if (tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE) {
                    preventGhostClick(x, y);
                    if (tapElement) {
                        tapElement.blur();
                    }
                    if (!angular.isDefined(attr.disabled) || attr.disabled === false) {
                        element.triggerHandler("click", [ event ]);
                    }
                }
                resetState();
            });
            element.onclick = function(event) {};
            element.on("click", function(event, touchend) {
                scope.$apply(function() {
                    clickHandler(scope, {
                        $event: touchend || event
                    });
                });
            });
            element.on("mousedown", function(event) {
                element.addClass(ACTIVE_CLASS_NAME);
            });
            element.on("mousemove mouseup", function(event) {
                element.removeClass(ACTIVE_CLASS_NAME);
            });
        };
    } ]);
    function makeSwipeDirective(directiveName, direction, eventName) {
        ngTouch.directive(directiveName, [ "$parse", "$swipe", function($parse, $swipe) {
            var MAX_VERTICAL_DISTANCE = 75;
            var MAX_VERTICAL_RATIO = .3;
            var MIN_HORIZONTAL_DISTANCE = 30;
            return function(scope, element, attr) {
                var swipeHandler = $parse(attr[directiveName]);
                var startCoords, valid;
                function validSwipe(coords) {
                    if (!startCoords) return false;
                    var deltaY = Math.abs(coords.y - startCoords.y);
                    var deltaX = (coords.x - startCoords.x) * direction;
                    return valid && deltaY < MAX_VERTICAL_DISTANCE && deltaX > 0 && deltaX > MIN_HORIZONTAL_DISTANCE && deltaY / deltaX < MAX_VERTICAL_RATIO;
                }
                var pointerTypes = [ "touch" ];
                if (!angular.isDefined(attr["ngSwipeDisableMouse"])) {
                    pointerTypes.push("mouse");
                }
                $swipe.bind(element, {
                    start: function(coords, event) {
                        startCoords = coords;
                        valid = true;
                    },
                    cancel: function(event) {
                        valid = false;
                    },
                    end: function(coords, event) {
                        if (validSwipe(coords)) {
                            scope.$apply(function() {
                                element.triggerHandler(eventName);
                                swipeHandler(scope, {
                                    $event: event
                                });
                            });
                        }
                    }
                }, pointerTypes);
            };
        } ]);
    }
    makeSwipeDirective("ngSwipeLeft", -1, "swipeleft");
    makeSwipeDirective("ngSwipeRight", 1, "swiperight");
})(window, window.angular);

angular.module("ui.bootstrap", [ "ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.bindHtml", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.dropdown", "ui.bootstrap.modal", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.transition", "ui.bootstrap.typeahead" ]);

angular.module("ui.bootstrap.tpls", [ "template/accordion/accordion-group.html", "template/accordion/accordion.html", "template/alert/alert.html", "template/carousel/carousel.html", "template/carousel/slide.html", "template/datepicker/datepicker.html", "template/datepicker/day.html", "template/datepicker/month.html", "template/datepicker/popup.html", "template/datepicker/year.html", "template/modal/backdrop.html", "template/modal/window.html", "template/pagination/pager.html", "template/pagination/pagination.html", "template/tooltip/tooltip-html-popup.html", "template/tooltip/tooltip-html-unsafe-popup.html", "template/tooltip/tooltip-popup.html", "template/tooltip/tooltip-template-popup.html", "template/popover/popover-html.html", "template/popover/popover-template.html", "template/popover/popover.html", "template/progressbar/bar.html", "template/progressbar/progress.html", "template/progressbar/progressbar.html", "template/rating/rating.html", "template/tabs/tab.html", "template/tabs/tabset.html", "template/timepicker/timepicker.html", "template/typeahead/typeahead-match.html", "template/typeahead/typeahead-popup.html" ]);

angular.module("ui.bootstrap.collapse", []).directive("collapse", [ "$animate", function($animate) {
    return {
        link: function(scope, element, attrs) {
            function expand() {
                element.removeClass("collapse").addClass("collapsing").attr("aria-expanded", true).attr("aria-hidden", false);
                $animate.addClass(element, "in", {
                    to: {
                        height: element[0].scrollHeight + "px"
                    }
                }).then(expandDone);
            }
            function expandDone() {
                element.removeClass("collapsing");
                element.css({
                    height: "auto"
                });
            }
            function collapse() {
                if (!element.hasClass("collapse") && !element.hasClass("in")) {
                    return collapseDone();
                }
                element.css({
                    height: element[0].scrollHeight + "px"
                }).removeClass("collapse").addClass("collapsing").attr("aria-expanded", false).attr("aria-hidden", true);
                $animate.removeClass(element, "in", {
                    to: {
                        height: "0"
                    }
                }).then(collapseDone);
            }
            function collapseDone() {
                element.css({
                    height: "0"
                });
                element.removeClass("collapsing");
                element.addClass("collapse");
            }
            scope.$watch(attrs.collapse, function(shouldCollapse) {
                if (shouldCollapse) {
                    collapse();
                } else {
                    expand();
                }
            });
        }
    };
} ]);

angular.module("ui.bootstrap.accordion", [ "ui.bootstrap.collapse" ]).constant("accordionConfig", {
    closeOthers: true
}).controller("AccordionController", [ "$scope", "$attrs", "accordionConfig", function($scope, $attrs, accordionConfig) {
    this.groups = [];
    this.closeOthers = function(openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        if (closeOthers) {
            angular.forEach(this.groups, function(group) {
                if (group !== openGroup) {
                    group.isOpen = false;
                }
            });
        }
    };
    this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope);
        groupScope.$on("$destroy", function(event) {
            that.removeGroup(groupScope);
        });
    };
    this.removeGroup = function(group) {
        var index = this.groups.indexOf(group);
        if (index !== -1) {
            this.groups.splice(index, 1);
        }
    };
} ]).directive("accordion", function() {
    return {
        restrict: "EA",
        controller: "AccordionController",
        controllerAs: "accordion",
        transclude: true,
        replace: false,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/accordion/accordion.html";
        }
    };
}).directive("accordionGroup", function() {
    return {
        require: "^accordion",
        restrict: "EA",
        transclude: true,
        replace: true,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/accordion/accordion-group.html";
        },
        scope: {
            heading: "@",
            isOpen: "=?",
            isDisabled: "=?"
        },
        controller: function() {
            this.setHeading = function(element) {
                this.heading = element;
            };
        },
        link: function(scope, element, attrs, accordionCtrl) {
            accordionCtrl.addGroup(scope);
            scope.openClass = attrs.openClass || "panel-open";
            scope.panelClass = attrs.panelClass;
            scope.$watch("isOpen", function(value) {
                element.toggleClass(scope.openClass, value);
                if (value) {
                    accordionCtrl.closeOthers(scope);
                }
            });
            scope.toggleOpen = function($event) {
                if (!scope.isDisabled) {
                    if (!$event || $event.which === 32) {
                        scope.isOpen = !scope.isOpen;
                    }
                }
            };
        }
    };
}).directive("accordionHeading", function() {
    return {
        restrict: "EA",
        transclude: true,
        template: "",
        replace: true,
        require: "^accordionGroup",
        link: function(scope, element, attr, accordionGroupCtrl, transclude) {
            accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
        }
    };
}).directive("accordionTransclude", function() {
    return {
        require: "^accordionGroup",
        link: function(scope, element, attr, controller) {
            scope.$watch(function() {
                return controller[attr.accordionTransclude];
            }, function(heading) {
                if (heading) {
                    element.find("span").html("");
                    element.find("span").append(heading);
                }
            });
        }
    };
});

angular.module("ui.bootstrap.alert", []).controller("AlertController", [ "$scope", "$attrs", function($scope, $attrs) {
    $scope.closeable = !!$attrs.close;
    this.close = $scope.close;
} ]).directive("alert", function() {
    return {
        controller: "AlertController",
        controllerAs: "alert",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/alert/alert.html";
        },
        transclude: true,
        replace: true,
        scope: {
            type: "@",
            close: "&"
        }
    };
}).directive("dismissOnTimeout", [ "$timeout", function($timeout) {
    return {
        require: "alert",
        link: function(scope, element, attrs, alertCtrl) {
            $timeout(function() {
                alertCtrl.close();
            }, parseInt(attrs.dismissOnTimeout, 10));
        }
    };
} ]);

angular.module("ui.bootstrap.bindHtml", []).value("$bindHtmlUnsafeSuppressDeprecated", false).directive("bindHtmlUnsafe", [ "$log", "$bindHtmlUnsafeSuppressDeprecated", function($log, $bindHtmlUnsafeSuppressDeprecated) {
    return function(scope, element, attr) {
        if (!$bindHtmlUnsafeSuppressDeprecated) {
            $log.warn("bindHtmlUnsafe is now deprecated. Use ngBindHtml instead");
        }
        element.addClass("ng-binding").data("$binding", attr.bindHtmlUnsafe);
        scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
            element.html(value || "");
        });
    };
} ]);

angular.module("ui.bootstrap.buttons", []).constant("buttonConfig", {
    activeClass: "active",
    toggleEvent: "click"
}).controller("ButtonsController", [ "buttonConfig", function(buttonConfig) {
    this.activeClass = buttonConfig.activeClass || "active";
    this.toggleEvent = buttonConfig.toggleEvent || "click";
} ]).directive("btnRadio", function() {
    return {
        require: [ "btnRadio", "ngModel" ],
        controller: "ButtonsController",
        controllerAs: "buttons",
        link: function(scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            element.find("input").css({
                display: "none"
            });
            ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
            };
            element.bind(buttonsCtrl.toggleEvent, function() {
                if (attrs.disabled) {
                    return;
                }
                var isActive = element.hasClass(buttonsCtrl.activeClass);
                if (!isActive || angular.isDefined(attrs.uncheckable)) {
                    scope.$apply(function() {
                        ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));
                        ngModelCtrl.$render();
                    });
                }
            });
        }
    };
}).directive("btnCheckbox", [ "$document", function($document) {
    return {
        require: [ "btnCheckbox", "ngModel" ],
        controller: "ButtonsController",
        controllerAs: "button",
        link: function(scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            element.find("input").css({
                display: "none"
            });
            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, true);
            }
            function getFalseValue() {
                return getCheckboxValue(attrs.btnCheckboxFalse, false);
            }
            function getCheckboxValue(attributeValue, defaultValue) {
                var val = scope.$eval(attributeValue);
                return angular.isDefined(val) ? val : defaultValue;
            }
            ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
            };
            element.bind(buttonsCtrl.toggleEvent, function() {
                if (attrs.disabled) {
                    return;
                }
                scope.$apply(function() {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
                    ngModelCtrl.$render();
                });
            });
            element.on("keypress", function(e) {
                if (attrs.disabled || e.which !== 32 || $document[0].activeElement !== element[0]) {
                    return;
                }
                scope.$apply(function() {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
                    ngModelCtrl.$render();
                });
            });
        }
    };
} ]);

angular.module("ui.bootstrap.carousel", []).controller("CarouselController", [ "$scope", "$element", "$interval", "$animate", function($scope, $element, $interval, $animate) {
    var self = this, slides = self.slides = $scope.slides = [], NEW_ANIMATE = angular.version.minor >= 4, NO_TRANSITION = "uib-noTransition", SLIDE_DIRECTION = "uib-slideDirection", currentIndex = -1, currentInterval, isPlaying;
    self.currentSlide = null;
    var destroyed = false;
    self.select = $scope.select = function(nextSlide, direction) {
        var nextIndex = $scope.indexOfSlide(nextSlide);
        if (direction === undefined) {
            direction = nextIndex > self.getCurrentIndex() ? "next" : "prev";
        }
        if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {
            goNext(nextSlide, nextIndex, direction);
        }
    };
    function goNext(slide, index, direction) {
        if (destroyed) {
            return;
        }
        angular.extend(slide, {
            direction: direction,
            active: true
        });
        angular.extend(self.currentSlide || {}, {
            direction: direction,
            active: false
        });
        if ($animate.enabled() && !$scope.noTransition && !$scope.$currentTransition && slide.$element && self.slides.length > 1) {
            slide.$element.data(SLIDE_DIRECTION, slide.direction);
            if (self.currentSlide && self.currentSlide.$element) {
                self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);
            }
            $scope.$currentTransition = true;
            if (NEW_ANIMATE) {
                $animate.on("addClass", slide.$element, function(element, phase) {
                    if (phase === "close") {
                        $scope.$currentTransition = null;
                        $animate.off("addClass", element);
                    }
                });
            } else {
                slide.$element.one("$animate:close", function closeFn() {
                    $scope.$currentTransition = null;
                });
            }
        }
        self.currentSlide = slide;
        currentIndex = index;
        restartTimer();
    }
    $scope.$on("$destroy", function() {
        destroyed = true;
    });
    function getSlideByIndex(index) {
        if (angular.isUndefined(slides[index].index)) {
            return slides[index];
        }
        var i, len = slides.length;
        for (i = 0; i < slides.length; ++i) {
            if (slides[i].index == index) {
                return slides[i];
            }
        }
    }
    self.getCurrentIndex = function() {
        if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {
            return +self.currentSlide.index;
        }
        return currentIndex;
    };
    $scope.indexOfSlide = function(slide) {
        return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);
    };
    $scope.next = function() {
        var newIndex = (self.getCurrentIndex() + 1) % slides.length;
        if (newIndex === 0 && $scope.noWrap()) {
            $scope.pause();
            return;
        }
        return self.select(getSlideByIndex(newIndex), "next");
    };
    $scope.prev = function() {
        var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
        if ($scope.noWrap() && newIndex === slides.length - 1) {
            $scope.pause();
            return;
        }
        return self.select(getSlideByIndex(newIndex), "prev");
    };
    $scope.isActive = function(slide) {
        return self.currentSlide === slide;
    };
    $scope.$watch("interval", restartTimer);
    $scope.$on("$destroy", resetTimer);
    function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        if (!isNaN(interval) && interval > 0) {
            currentInterval = $interval(timerFn, interval);
        }
    }
    function resetTimer() {
        if (currentInterval) {
            $interval.cancel(currentInterval);
            currentInterval = null;
        }
    }
    function timerFn() {
        var interval = +$scope.interval;
        if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
            $scope.next();
        } else {
            $scope.pause();
        }
    }
    $scope.play = function() {
        if (!isPlaying) {
            isPlaying = true;
            restartTimer();
        }
    };
    $scope.pause = function() {
        if (!$scope.noPause) {
            isPlaying = false;
            resetTimer();
        }
    };
    self.addSlide = function(slide, element) {
        slide.$element = element;
        slides.push(slide);
        if (slides.length === 1 || slide.active) {
            self.select(slides[slides.length - 1]);
            if (slides.length == 1) {
                $scope.play();
            }
        } else {
            slide.active = false;
        }
    };
    self.removeSlide = function(slide) {
        if (angular.isDefined(slide.index)) {
            slides.sort(function(a, b) {
                return +a.index > +b.index;
            });
        }
        var index = slides.indexOf(slide);
        slides.splice(index, 1);
        if (slides.length > 0 && slide.active) {
            if (index >= slides.length) {
                self.select(slides[index - 1]);
            } else {
                self.select(slides[index]);
            }
        } else if (currentIndex > index) {
            currentIndex--;
        }
        if (slides.length === 0) {
            self.currentSlide = null;
        }
    };
    $scope.$watch("noTransition", function(noTransition) {
        $element.data(NO_TRANSITION, noTransition);
    });
} ]).directive("carousel", [ function() {
    return {
        restrict: "EA",
        transclude: true,
        replace: true,
        controller: "CarouselController",
        controllerAs: "carousel",
        require: "carousel",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/carousel/carousel.html";
        },
        scope: {
            interval: "=",
            noTransition: "=",
            noPause: "=",
            noWrap: "&"
        }
    };
} ]).directive("slide", function() {
    return {
        require: "^carousel",
        restrict: "EA",
        transclude: true,
        replace: true,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/carousel/slide.html";
        },
        scope: {
            active: "=?",
            actual: "=?",
            index: "=?"
        },
        link: function(scope, element, attrs, carouselCtrl) {
            carouselCtrl.addSlide(scope, element);
            scope.$on("$destroy", function() {
                carouselCtrl.removeSlide(scope);
            });
            scope.$watch("active", function(active) {
                if (active) {
                    carouselCtrl.select(scope);
                }
            });
        }
    };
}).animation(".item", [ "$injector", "$animate", function($injector, $animate) {
    var NO_TRANSITION = "uib-noTransition", SLIDE_DIRECTION = "uib-slideDirection", $animateCss = null;
    if ($injector.has("$animateCss")) {
        $animateCss = $injector.get("$animateCss");
    }
    function removeClass(element, className, callback) {
        element.removeClass(className);
        if (callback) {
            callback();
        }
    }
    return {
        beforeAddClass: function(element, className, done) {
            if (className == "active" && element.parent() && !element.parent().data(NO_TRANSITION)) {
                var stopped = false;
                var direction = element.data(SLIDE_DIRECTION);
                var directionClass = direction == "next" ? "left" : "right";
                var removeClassFn = removeClass.bind(this, element, directionClass + " " + direction, done);
                element.addClass(direction);
                if ($animateCss) {
                    $animateCss(element, {
                        addClass: directionClass
                    }).start().done(removeClassFn);
                } else {
                    $animate.addClass(element, directionClass).then(function() {
                        if (!stopped) {
                            removeClassFn();
                        }
                        done();
                    });
                }
                return function() {
                    stopped = true;
                };
            }
            done();
        },
        beforeRemoveClass: function(element, className, done) {
            if (className === "active" && element.parent() && !element.parent().data(NO_TRANSITION)) {
                var stopped = false;
                var direction = element.data(SLIDE_DIRECTION);
                var directionClass = direction == "next" ? "left" : "right";
                var removeClassFn = removeClass.bind(this, element, directionClass, done);
                if ($animateCss) {
                    $animateCss(element, {
                        addClass: directionClass
                    }).start().done(removeClassFn);
                } else {
                    $animate.addClass(element, directionClass).then(function() {
                        if (!stopped) {
                            removeClassFn();
                        }
                        done();
                    });
                }
                return function() {
                    stopped = true;
                };
            }
            done();
        }
    };
} ]);

angular.module("ui.bootstrap.dateparser", []).service("dateParser", [ "$log", "$locale", "orderByFilter", function($log, $locale, orderByFilter) {
    var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    this.parsers = {};
    var formatCodeToRegex = {
        yyyy: {
            regex: "\\d{4}",
            apply: function(value) {
                this.year = +value;
            }
        },
        yy: {
            regex: "\\d{2}",
            apply: function(value) {
                this.year = +value + 2e3;
            }
        },
        y: {
            regex: "\\d{1,4}",
            apply: function(value) {
                this.year = +value;
            }
        },
        MMMM: {
            regex: $locale.DATETIME_FORMATS.MONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
            }
        },
        MMM: {
            regex: $locale.DATETIME_FORMATS.SHORTMONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
            }
        },
        MM: {
            regex: "0[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1;
            }
        },
        M: {
            regex: "[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1;
            }
        },
        dd: {
            regex: "[0-2][0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value;
            }
        },
        d: {
            regex: "[1-2]?[0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value;
            }
        },
        EEEE: {
            regex: $locale.DATETIME_FORMATS.DAY.join("|")
        },
        EEE: {
            regex: $locale.DATETIME_FORMATS.SHORTDAY.join("|")
        },
        HH: {
            regex: "(?:0|1)[0-9]|2[0-3]",
            apply: function(value) {
                this.hours = +value;
            }
        },
        hh: {
            regex: "0[0-9]|1[0-2]",
            apply: function(value) {
                this.hours = +value;
            }
        },
        H: {
            regex: "1?[0-9]|2[0-3]",
            apply: function(value) {
                this.hours = +value;
            }
        },
        h: {
            regex: "[0-9]|1[0-2]",
            apply: function(value) {
                this.hours = +value;
            }
        },
        mm: {
            regex: "[0-5][0-9]",
            apply: function(value) {
                this.minutes = +value;
            }
        },
        m: {
            regex: "[0-9]|[1-5][0-9]",
            apply: function(value) {
                this.minutes = +value;
            }
        },
        sss: {
            regex: "[0-9][0-9][0-9]",
            apply: function(value) {
                this.milliseconds = +value;
            }
        },
        ss: {
            regex: "[0-5][0-9]",
            apply: function(value) {
                this.seconds = +value;
            }
        },
        s: {
            regex: "[0-9]|[1-5][0-9]",
            apply: function(value) {
                this.seconds = +value;
            }
        },
        a: {
            regex: $locale.DATETIME_FORMATS.AMPMS.join("|"),
            apply: function(value) {
                if (this.hours === 12) {
                    this.hours = 0;
                }
                if (value === "PM") {
                    this.hours += 12;
                }
            }
        }
    };
    function createParser(format) {
        var map = [], regex = format.split("");
        angular.forEach(formatCodeToRegex, function(data, code) {
            var index = format.indexOf(code);
            if (index > -1) {
                format = format.split("");
                regex[index] = "(" + data.regex + ")";
                format[index] = "$";
                for (var i = index + 1, n = index + code.length; i < n; i++) {
                    regex[i] = "";
                    format[i] = "$";
                }
                format = format.join("");
                map.push({
                    index: index,
                    apply: data.apply
                });
            }
        });
        return {
            regex: new RegExp("^" + regex.join("") + "$"),
            map: orderByFilter(map, "index")
        };
    }
    this.parse = function(input, format, baseDate) {
        if (!angular.isString(input) || !format) {
            return input;
        }
        format = $locale.DATETIME_FORMATS[format] || format;
        format = format.replace(SPECIAL_CHARACTERS_REGEXP, "\\$&");
        if (!this.parsers[format]) {
            this.parsers[format] = createParser(format);
        }
        var parser = this.parsers[format], regex = parser.regex, map = parser.map, results = input.match(regex);
        if (results && results.length) {
            var fields, dt;
            if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
                fields = {
                    year: baseDate.getFullYear(),
                    month: baseDate.getMonth(),
                    date: baseDate.getDate(),
                    hours: baseDate.getHours(),
                    minutes: baseDate.getMinutes(),
                    seconds: baseDate.getSeconds(),
                    milliseconds: baseDate.getMilliseconds()
                };
            } else {
                if (baseDate) {
                    $log.warn("dateparser:", "baseDate is not a valid date");
                }
                fields = {
                    year: 1900,
                    month: 0,
                    date: 1,
                    hours: 0,
                    minutes: 0,
                    seconds: 0,
                    milliseconds: 0
                };
            }
            for (var i = 1, n = results.length; i < n; i++) {
                var mapper = map[i - 1];
                if (mapper.apply) {
                    mapper.apply.call(fields, results[i]);
                }
            }
            if (isValid(fields.year, fields.month, fields.date)) {
                dt = new Date(fields.year, fields.month, fields.date, fields.hours, fields.minutes, fields.seconds, fields.milliseconds || 0);
            }
            return dt;
        }
    };
    function isValid(year, month, date) {
        if (date < 1) {
            return false;
        }
        if (month === 1 && date > 28) {
            return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
        }
        if (month === 3 || month === 5 || month === 8 || month === 10) {
            return date < 31;
        }
        return true;
    }
} ]);

angular.module("ui.bootstrap.position", []).factory("$position", [ "$document", "$window", function($document, $window) {
    function getStyle(el, cssprop) {
        if (el.currentStyle) {
            return el.currentStyle[cssprop];
        } else if ($window.getComputedStyle) {
            return $window.getComputedStyle(el)[cssprop];
        }
        return el.style[cssprop];
    }
    function isStaticPositioned(element) {
        return (getStyle(element, "position") || "static") === "static";
    }
    var parentOffsetEl = function(element) {
        var docDomEl = $document[0];
        var offsetParent = element.offsetParent || docDomEl;
        while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docDomEl;
    };
    return {
        position: function(element) {
            var elBCR = this.offset(element);
            var offsetParentBCR = {
                top: 0,
                left: 0
            };
            var offsetParentEl = parentOffsetEl(element[0]);
            if (offsetParentEl != $document[0]) {
                offsetParentBCR = this.offset(angular.element(offsetParentEl));
                offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
                offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
            }
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: elBCR.top - offsetParentBCR.top,
                left: elBCR.left - offsetParentBCR.left
            };
        },
        offset: function(element) {
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
                left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
            };
        },
        positionElements: function(hostEl, targetEl, positionStr, appendToBody) {
            var positionStrParts = positionStr.split("-");
            var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || "center";
            var hostElPos, targetElWidth, targetElHeight, targetElPos;
            hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);
            targetElWidth = targetEl.prop("offsetWidth");
            targetElHeight = targetEl.prop("offsetHeight");
            var shiftWidth = {
                center: function() {
                    return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
                },
                left: function() {
                    return hostElPos.left;
                },
                right: function() {
                    return hostElPos.left + hostElPos.width;
                }
            };
            var shiftHeight = {
                center: function() {
                    return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
                },
                top: function() {
                    return hostElPos.top;
                },
                bottom: function() {
                    return hostElPos.top + hostElPos.height;
                }
            };
            switch (pos0) {
              case "right":
                targetElPos = {
                    top: shiftHeight[pos1](),
                    left: shiftWidth[pos0]()
                };
                break;

              case "left":
                targetElPos = {
                    top: shiftHeight[pos1](),
                    left: hostElPos.left - targetElWidth
                };
                break;

              case "bottom":
                targetElPos = {
                    top: shiftHeight[pos0](),
                    left: shiftWidth[pos1]()
                };
                break;

              default:
                targetElPos = {
                    top: hostElPos.top - targetElHeight,
                    left: shiftWidth[pos1]()
                };
                break;
            }
            return targetElPos;
        }
    };
} ]);

angular.module("ui.bootstrap.datepicker", [ "ui.bootstrap.dateparser", "ui.bootstrap.position" ]).value("$datepickerSuppressError", false).constant("datepickerConfig", {
    formatDay: "dd",
    formatMonth: "MMMM",
    formatYear: "yyyy",
    formatDayHeader: "EEE",
    formatDayTitle: "MMMM yyyy",
    formatMonthTitle: "yyyy",
    datepickerMode: "day",
    minMode: "day",
    maxMode: "year",
    showWeeks: true,
    startingDay: 0,
    yearRange: 20,
    minDate: null,
    maxDate: null,
    shortcutPropagation: false
}).controller("DatepickerController", [ "$scope", "$attrs", "$parse", "$interpolate", "$log", "dateFilter", "datepickerConfig", "$datepickerSuppressError", function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {
    var self = this, ngModelCtrl = {
        $setViewValue: angular.noop
    };
    this.modes = [ "day", "month", "year" ];
    angular.forEach([ "formatDay", "formatMonth", "formatYear", "formatDayHeader", "formatDayTitle", "formatMonthTitle", "showWeeks", "startingDay", "yearRange", "shortcutPropagation" ], function(key, index) {
        self[key] = angular.isDefined($attrs[key]) ? index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key]) : datepickerConfig[key];
    });
    angular.forEach([ "minDate", "maxDate" ], function(key) {
        if ($attrs[key]) {
            $scope.$parent.$watch($parse($attrs[key]), function(value) {
                self[key] = value ? new Date(value) : null;
                self.refreshView();
            });
        } else {
            self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
        }
    });
    angular.forEach([ "minMode", "maxMode" ], function(key) {
        if ($attrs[key]) {
            $scope.$parent.$watch($parse($attrs[key]), function(value) {
                self[key] = angular.isDefined(value) ? value : $attrs[key];
                $scope[key] = self[key];
                if (key == "minMode" && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key]) || key == "maxMode" && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key])) {
                    $scope.datepickerMode = self[key];
                }
            });
        } else {
            self[key] = datepickerConfig[key] || null;
            $scope[key] = self[key];
        }
    });
    $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
    $scope.uniqueId = "datepicker-" + $scope.$id + "-" + Math.floor(Math.random() * 1e4);
    if (angular.isDefined($attrs.initDate)) {
        this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
        $scope.$parent.$watch($attrs.initDate, function(initDate) {
            if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
                self.activeDate = initDate;
                self.refreshView();
            }
        });
    } else {
        this.activeDate = new Date();
    }
    $scope.isActive = function(dateObject) {
        if (self.compare(dateObject.date, self.activeDate) === 0) {
            $scope.activeDateId = dateObject.uid;
            return true;
        }
        return false;
    };
    this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = function() {
            self.render();
        };
    };
    this.render = function() {
        if (ngModelCtrl.$viewValue) {
            var date = new Date(ngModelCtrl.$viewValue), isValid = !isNaN(date);
            if (isValid) {
                this.activeDate = date;
            } else if (!$datepickerSuppressError) {
                $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
            }
        }
        this.refreshView();
    };
    this.refreshView = function() {
        if (this.element) {
            this._refreshView();
            var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
            ngModelCtrl.$setValidity("dateDisabled", !date || this.element && !this.isDisabled(date));
        }
    };
    this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
        return {
            date: date,
            label: dateFilter(date, format),
            selected: model && this.compare(date, model) === 0,
            disabled: this.isDisabled(date),
            current: this.compare(date, new Date()) === 0,
            customClass: this.customClass(date)
        };
    };
    this.isDisabled = function(date) {
        return this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $attrs.dateDisabled && $scope.dateDisabled({
            date: date,
            mode: $scope.datepickerMode
        });
    };
    this.customClass = function(date) {
        return $scope.customClass({
            date: date,
            mode: $scope.datepickerMode
        });
    };
    this.split = function(arr, size) {
        var arrays = [];
        while (arr.length > 0) {
            arrays.push(arr.splice(0, size));
        }
        return arrays;
    };
    this.fixTimeZone = function(date) {
        var hours = date.getHours();
        date.setHours(hours === 23 ? hours + 2 : 0);
    };
    $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
            var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
            dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
            ngModelCtrl.$setViewValue(dt);
            ngModelCtrl.$render();
        } else {
            self.activeDate = date;
            $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
        }
    };
    $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0), month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1);
        self.refreshView();
    };
    $scope.toggleMode = function(direction) {
        direction = direction || 1;
        if ($scope.datepickerMode === self.maxMode && direction === 1 || $scope.datepickerMode === self.minMode && direction === -1) {
            return;
        }
        $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
    };
    $scope.keys = {
        13: "enter",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down"
    };
    var focusElement = function() {
        self.element[0].focus();
    };
    $scope.$on("datepicker.focus", focusElement);
    $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (!key || evt.shiftKey || evt.altKey) {
            return;
        }
        evt.preventDefault();
        if (!self.shortcutPropagation) {
            evt.stopPropagation();
        }
        if (key === "enter" || key === "space") {
            if (self.isDisabled(self.activeDate)) {
                return;
            }
            $scope.select(self.activeDate);
            focusElement();
        } else if (evt.ctrlKey && (key === "up" || key === "down")) {
            $scope.toggleMode(key === "up" ? 1 : -1);
            focusElement();
        } else {
            self.handleKeyDown(key, evt);
            self.refreshView();
        }
    };
} ]).directive("datepicker", function() {
    return {
        restrict: "EA",
        replace: true,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/datepicker/datepicker.html";
        },
        scope: {
            datepickerMode: "=?",
            dateDisabled: "&",
            customClass: "&",
            shortcutPropagation: "&?"
        },
        require: [ "datepicker", "^ngModel" ],
        controller: "DatepickerController",
        controllerAs: "datepicker",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            datepickerCtrl.init(ngModelCtrl);
        }
    };
}).directive("daypicker", [ "dateFilter", function(dateFilter) {
    return {
        restrict: "EA",
        replace: true,
        templateUrl: "template/datepicker/day.html",
        require: "^datepicker",
        link: function(scope, element, attrs, ctrl) {
            scope.showWeeks = ctrl.showWeeks;
            ctrl.step = {
                months: 1
            };
            ctrl.element = element;
            var DAYS_IN_MONTH = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
            function getDaysInMonth(year, month) {
                return month === 1 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
            }
            function getDates(startDate, n) {
                var dates = new Array(n), current = new Date(startDate), i = 0, date;
                while (i < n) {
                    date = new Date(current);
                    ctrl.fixTimeZone(date);
                    dates[i++] = date;
                    current.setDate(current.getDate() + 1);
                }
                return dates;
            }
            ctrl._refreshView = function() {
                var year = ctrl.activeDate.getFullYear(), month = ctrl.activeDate.getMonth(), firstDayOfMonth = new Date(year, month, 1), difference = ctrl.startingDay - firstDayOfMonth.getDay(), numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference, firstDate = new Date(firstDayOfMonth);
                if (numDisplayedFromPreviousMonth > 0) {
                    firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
                }
                var days = getDates(firstDate, 42);
                for (var i = 0; i < 42; i++) {
                    days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {
                        secondary: days[i].getMonth() !== month,
                        uid: scope.uniqueId + "-" + i
                    });
                }
                scope.labels = new Array(7);
                for (var j = 0; j < 7; j++) {
                    scope.labels[j] = {
                        abbr: dateFilter(days[j].date, ctrl.formatDayHeader),
                        full: dateFilter(days[j].date, "EEEE")
                    };
                }
                scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle);
                scope.rows = ctrl.split(days, 7);
                if (scope.showWeeks) {
                    scope.weekNumbers = [];
                    var thursdayIndex = (4 + 7 - ctrl.startingDay) % 7, numWeeks = scope.rows.length;
                    for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
                        scope.weekNumbers.push(getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
                    }
                }
            };
            ctrl.compare = function(date1, date2) {
                return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
            };
            function getISO8601WeekNumber(date) {
                var checkDate = new Date(date);
                checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
                var time = checkDate.getTime();
                checkDate.setMonth(0);
                checkDate.setDate(1);
                return Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
            }
            ctrl.handleKeyDown = function(key, evt) {
                var date = ctrl.activeDate.getDate();
                if (key === "left") {
                    date = date - 1;
                } else if (key === "up") {
                    date = date - 7;
                } else if (key === "right") {
                    date = date + 1;
                } else if (key === "down") {
                    date = date + 7;
                } else if (key === "pageup" || key === "pagedown") {
                    var month = ctrl.activeDate.getMonth() + (key === "pageup" ? -1 : 1);
                    ctrl.activeDate.setMonth(month, 1);
                    date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);
                } else if (key === "home") {
                    date = 1;
                } else if (key === "end") {
                    date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth());
                }
                ctrl.activeDate.setDate(date);
            };
            ctrl.refreshView();
        }
    };
} ]).directive("monthpicker", [ "dateFilter", function(dateFilter) {
    return {
        restrict: "EA",
        replace: true,
        templateUrl: "template/datepicker/month.html",
        require: "^datepicker",
        link: function(scope, element, attrs, ctrl) {
            ctrl.step = {
                years: 1
            };
            ctrl.element = element;
            ctrl._refreshView = function() {
                var months = new Array(12), year = ctrl.activeDate.getFullYear(), date;
                for (var i = 0; i < 12; i++) {
                    date = new Date(year, i, 1);
                    ctrl.fixTimeZone(date);
                    months[i] = angular.extend(ctrl.createDateObject(date, ctrl.formatMonth), {
                        uid: scope.uniqueId + "-" + i
                    });
                }
                scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle);
                scope.rows = ctrl.split(months, 3);
            };
            ctrl.compare = function(date1, date2) {
                return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
            };
            ctrl.handleKeyDown = function(key, evt) {
                var date = ctrl.activeDate.getMonth();
                if (key === "left") {
                    date = date - 1;
                } else if (key === "up") {
                    date = date - 3;
                } else if (key === "right") {
                    date = date + 1;
                } else if (key === "down") {
                    date = date + 3;
                } else if (key === "pageup" || key === "pagedown") {
                    var year = ctrl.activeDate.getFullYear() + (key === "pageup" ? -1 : 1);
                    ctrl.activeDate.setFullYear(year);
                } else if (key === "home") {
                    date = 0;
                } else if (key === "end") {
                    date = 11;
                }
                ctrl.activeDate.setMonth(date);
            };
            ctrl.refreshView();
        }
    };
} ]).directive("yearpicker", [ "dateFilter", function(dateFilter) {
    return {
        restrict: "EA",
        replace: true,
        templateUrl: "template/datepicker/year.html",
        require: "^datepicker",
        link: function(scope, element, attrs, ctrl) {
            var range = ctrl.yearRange;
            ctrl.step = {
                years: range
            };
            ctrl.element = element;
            function getStartingYear(year) {
                return parseInt((year - 1) / range, 10) * range + 1;
            }
            ctrl._refreshView = function() {
                var years = new Array(range), date;
                for (var i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i < range; i++) {
                    date = new Date(start + i, 0, 1);
                    ctrl.fixTimeZone(date);
                    years[i] = angular.extend(ctrl.createDateObject(date, ctrl.formatYear), {
                        uid: scope.uniqueId + "-" + i
                    });
                }
                scope.title = [ years[0].label, years[range - 1].label ].join(" - ");
                scope.rows = ctrl.split(years, 5);
            };
            ctrl.compare = function(date1, date2) {
                return date1.getFullYear() - date2.getFullYear();
            };
            ctrl.handleKeyDown = function(key, evt) {
                var date = ctrl.activeDate.getFullYear();
                if (key === "left") {
                    date = date - 1;
                } else if (key === "up") {
                    date = date - 5;
                } else if (key === "right") {
                    date = date + 1;
                } else if (key === "down") {
                    date = date + 5;
                } else if (key === "pageup" || key === "pagedown") {
                    date += (key === "pageup" ? -1 : 1) * ctrl.step.years;
                } else if (key === "home") {
                    date = getStartingYear(ctrl.activeDate.getFullYear());
                } else if (key === "end") {
                    date = getStartingYear(ctrl.activeDate.getFullYear()) + range - 1;
                }
                ctrl.activeDate.setFullYear(date);
            };
            ctrl.refreshView();
        }
    };
} ]).constant("datepickerPopupConfig", {
    datepickerPopup: "yyyy-MM-dd",
    datepickerPopupTemplateUrl: "template/datepicker/popup.html",
    datepickerTemplateUrl: "template/datepicker/datepicker.html",
    html5Types: {
        date: "yyyy-MM-dd",
        "datetime-local": "yyyy-MM-ddTHH:mm:ss.sss",
        month: "yyyy-MM"
    },
    currentText: "Today",
    clearText: "Clear",
    closeText: "Done",
    closeOnDateSelection: true,
    appendToBody: false,
    showButtonBar: true,
    onOpenFocus: true
}).directive("datepickerPopup", [ "$compile", "$parse", "$document", "$rootScope", "$position", "dateFilter", "dateParser", "datepickerPopupConfig", "$timeout", function($compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {
    return {
        restrict: "EA",
        require: "ngModel",
        scope: {
            isOpen: "=?",
            currentText: "@",
            clearText: "@",
            closeText: "@",
            dateDisabled: "&",
            customClass: "&"
        },
        link: function(scope, element, attrs, ngModel) {
            var dateFormat, closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection, appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody, onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus, datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl, datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl, cache = {};
            scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;
            scope.getText = function(key) {
                return scope[key + "Text"] || datepickerPopupConfig[key + "Text"];
            };
            scope.isDisabled = function(date) {
                if (date === "today") {
                    date = new Date();
                }
                return scope.watchData.minDate && scope.compare(date, cache.minDate) < 0 || scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0;
            };
            scope.compare = function(date1, date2) {
                return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
            };
            var isHtml5DateInput = false;
            if (datepickerPopupConfig.html5Types[attrs.type]) {
                dateFormat = datepickerPopupConfig.html5Types[attrs.type];
                isHtml5DateInput = true;
            } else {
                dateFormat = attrs.datepickerPopup || datepickerPopupConfig.datepickerPopup;
                attrs.$observe("datepickerPopup", function(value, oldValue) {
                    var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
                    if (newDateFormat !== dateFormat) {
                        dateFormat = newDateFormat;
                        ngModel.$modelValue = null;
                        if (!dateFormat) {
                            throw new Error("datepickerPopup must have a date format specified.");
                        }
                    }
                });
            }
            if (!dateFormat) {
                throw new Error("datepickerPopup must have a date format specified.");
            }
            if (isHtml5DateInput && attrs.datepickerPopup) {
                throw new Error("HTML5 date input types do not support custom formats.");
            }
            var popupEl = angular.element("<div datepicker-popup-wrap><div datepicker></div></div>");
            popupEl.attr({
                "ng-model": "date",
                "ng-change": "dateSelection(date)",
                "template-url": datepickerPopupTemplateUrl
            });
            function cameltoDash(string) {
                return string.replace(/([A-Z])/g, function($1) {
                    return "-" + $1.toLowerCase();
                });
            }
            var datepickerEl = angular.element(popupEl.children()[0]);
            datepickerEl.attr("template-url", datepickerTemplateUrl);
            if (isHtml5DateInput) {
                if (attrs.type === "month") {
                    datepickerEl.attr("datepicker-mode", '"month"');
                    datepickerEl.attr("min-mode", "month");
                }
            }
            if (attrs.datepickerOptions) {
                var options = scope.$parent.$eval(attrs.datepickerOptions);
                if (options && options.initDate) {
                    scope.initDate = options.initDate;
                    datepickerEl.attr("init-date", "initDate");
                    delete options.initDate;
                }
                angular.forEach(options, function(value, option) {
                    datepickerEl.attr(cameltoDash(option), value);
                });
            }
            scope.watchData = {};
            angular.forEach([ "minMode", "maxMode", "minDate", "maxDate", "datepickerMode", "initDate", "shortcutPropagation" ], function(key) {
                if (attrs[key]) {
                    var getAttribute = $parse(attrs[key]);
                    scope.$parent.$watch(getAttribute, function(value) {
                        scope.watchData[key] = value;
                        if (key === "minDate" || key === "maxDate") {
                            cache[key] = new Date(value);
                        }
                    });
                    datepickerEl.attr(cameltoDash(key), "watchData." + key);
                    if (key === "datepickerMode") {
                        var setAttribute = getAttribute.assign;
                        scope.$watch("watchData." + key, function(value, oldvalue) {
                            if (angular.isFunction(setAttribute) && value !== oldvalue) {
                                setAttribute(scope.$parent, value);
                            }
                        });
                    }
                }
            });
            if (attrs.dateDisabled) {
                datepickerEl.attr("date-disabled", "dateDisabled({ date: date, mode: mode })");
            }
            if (attrs.showWeeks) {
                datepickerEl.attr("show-weeks", attrs.showWeeks);
            }
            if (attrs.customClass) {
                datepickerEl.attr("custom-class", "customClass({ date: date, mode: mode })");
            }
            function parseDate(viewValue) {
                if (angular.isNumber(viewValue)) {
                    viewValue = new Date(viewValue);
                }
                if (!viewValue) {
                    return null;
                } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {
                    return viewValue;
                } else if (angular.isString(viewValue)) {
                    var date = dateParser.parse(viewValue, dateFormat, scope.date);
                    if (isNaN(date)) {
                        return undefined;
                    } else {
                        return date;
                    }
                } else {
                    return undefined;
                }
            }
            function validator(modelValue, viewValue) {
                var value = modelValue || viewValue;
                if (!attrs.ngRequired && !value) {
                    return true;
                }
                if (angular.isNumber(value)) {
                    value = new Date(value);
                }
                if (!value) {
                    return true;
                } else if (angular.isDate(value) && !isNaN(value)) {
                    return true;
                } else if (angular.isString(value)) {
                    var date = dateParser.parse(value, dateFormat);
                    return !isNaN(date);
                } else {
                    return false;
                }
            }
            if (!isHtml5DateInput) {
                ngModel.$$parserName = "date";
                ngModel.$validators.date = validator;
                ngModel.$parsers.unshift(parseDate);
                ngModel.$formatters.push(function(value) {
                    scope.date = value;
                    return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);
                });
            } else {
                ngModel.$formatters.push(function(value) {
                    scope.date = value;
                    return value;
                });
            }
            scope.dateSelection = function(dt) {
                if (angular.isDefined(dt)) {
                    scope.date = dt;
                }
                var date = scope.date ? dateFilter(scope.date, dateFormat) : null;
                element.val(date);
                ngModel.$setViewValue(date);
                if (closeOnDateSelection) {
                    scope.isOpen = false;
                    element[0].focus();
                }
            };
            ngModel.$viewChangeListeners.push(function() {
                scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);
            });
            var documentClickBind = function(event) {
                if (scope.isOpen && !(element[0].contains(event.target) || popupEl[0].contains(event.target))) {
                    scope.$apply(function() {
                        scope.isOpen = false;
                    });
                }
            };
            var inputKeydownBind = function(evt) {
                if (evt.which === 27 && scope.isOpen) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    scope.$apply(function() {
                        scope.isOpen = false;
                    });
                    element[0].focus();
                } else if (evt.which === 40 && !scope.isOpen) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    scope.$apply(function() {
                        scope.isOpen = true;
                    });
                }
            };
            element.bind("keydown", inputKeydownBind);
            scope.keydown = function(evt) {
                if (evt.which === 27) {
                    scope.isOpen = false;
                    element[0].focus();
                }
            };
            scope.$watch("isOpen", function(value) {
                if (value) {
                    scope.position = appendToBody ? $position.offset(element) : $position.position(element);
                    scope.position.top = scope.position.top + element.prop("offsetHeight");
                    $timeout(function() {
                        if (onOpenFocus) {
                            scope.$broadcast("datepicker.focus");
                        }
                        $document.bind("click", documentClickBind);
                    }, 0, false);
                } else {
                    $document.unbind("click", documentClickBind);
                }
            });
            scope.select = function(date) {
                if (date === "today") {
                    var today = new Date();
                    if (angular.isDate(scope.date)) {
                        date = new Date(scope.date);
                        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
                    } else {
                        date = new Date(today.setHours(0, 0, 0, 0));
                    }
                }
                scope.dateSelection(date);
            };
            scope.close = function() {
                scope.isOpen = false;
                element[0].focus();
            };
            var $popup = $compile(popupEl)(scope);
            popupEl.remove();
            if (appendToBody) {
                $document.find("body").append($popup);
            } else {
                element.after($popup);
            }
            scope.$on("$destroy", function() {
                if (scope.isOpen === true) {
                    if (!$rootScope.$$phase) {
                        scope.$apply(function() {
                            scope.isOpen = false;
                        });
                    }
                }
                $popup.remove();
                element.unbind("keydown", inputKeydownBind);
                $document.unbind("click", documentClickBind);
            });
        }
    };
} ]).directive("datepickerPopupWrap", function() {
    return {
        restrict: "EA",
        replace: true,
        transclude: true,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/datepicker/popup.html";
        }
    };
});

angular.module("ui.bootstrap.dropdown", [ "ui.bootstrap.position" ]).constant("dropdownConfig", {
    openClass: "open"
}).service("dropdownService", [ "$document", "$rootScope", function($document, $rootScope) {
    var openScope = null;
    this.open = function(dropdownScope) {
        if (!openScope) {
            $document.bind("click", closeDropdown);
            $document.bind("keydown", keybindFilter);
        }
        if (openScope && openScope !== dropdownScope) {
            openScope.isOpen = false;
        }
        openScope = dropdownScope;
    };
    this.close = function(dropdownScope) {
        if (openScope === dropdownScope) {
            openScope = null;
            $document.unbind("click", closeDropdown);
            $document.unbind("keydown", keybindFilter);
        }
    };
    var closeDropdown = function(evt) {
        if (!openScope) {
            return;
        }
        if (evt && openScope.getAutoClose() === "disabled") {
            return;
        }
        var toggleElement = openScope.getToggleElement();
        if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
            return;
        }
        var dropdownElement = openScope.getDropdownElement();
        if (evt && openScope.getAutoClose() === "outsideClick" && dropdownElement && dropdownElement[0].contains(evt.target)) {
            return;
        }
        openScope.isOpen = false;
        if (!$rootScope.$$phase) {
            openScope.$apply();
        }
    };
    var keybindFilter = function(evt) {
        if (evt.which === 27) {
            openScope.focusToggleElement();
            closeDropdown();
        } else if (openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen) {
            evt.preventDefault();
            evt.stopPropagation();
            openScope.focusDropdownEntry(evt.which);
        }
    };
} ]).controller("DropdownController", [ "$scope", "$attrs", "$parse", "dropdownConfig", "dropdownService", "$animate", "$position", "$document", "$compile", "$templateRequest", function($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate, $position, $document, $compile, $templateRequest) {
    var self = this, scope = $scope.$new(), templateScope, openClass = dropdownConfig.openClass, getIsOpen, setIsOpen = angular.noop, toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop, appendToBody = false, keynavEnabled = false, selectedOption = null, body = $document.find("body");
    this.init = function(element) {
        self.$element = element;
        if ($attrs.isOpen) {
            getIsOpen = $parse($attrs.isOpen);
            setIsOpen = getIsOpen.assign;
            $scope.$watch(getIsOpen, function(value) {
                scope.isOpen = !!value;
            });
        }
        appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
        keynavEnabled = angular.isDefined($attrs.keyboardNav);
        if (appendToBody && self.dropdownMenu) {
            body.append(self.dropdownMenu);
            body.addClass("dropdown");
            element.on("$destroy", function handleDestroyEvent() {
                self.dropdownMenu.remove();
            });
        }
    };
    this.toggle = function(open) {
        return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
    };
    this.isOpen = function() {
        return scope.isOpen;
    };
    scope.getToggleElement = function() {
        return self.toggleElement;
    };
    scope.getAutoClose = function() {
        return $attrs.autoClose || "always";
    };
    scope.getElement = function() {
        return self.$element;
    };
    scope.isKeynavEnabled = function() {
        return keynavEnabled;
    };
    scope.focusDropdownEntry = function(keyCode) {
        var elems = self.dropdownMenu ? angular.element(self.dropdownMenu).find("a") : angular.element(self.$element).find("ul").eq(0).find("a");
        switch (keyCode) {
          case 40:
            {
                if (!angular.isNumber(self.selectedOption)) {
                    self.selectedOption = 0;
                } else {
                    self.selectedOption = self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1;
                }
                break;
            }

          case 38:
            {
                if (!angular.isNumber(self.selectedOption)) {
                    self.selectedOption = elems.length - 1;
                } else {
                    self.selectedOption = self.selectedOption === 0 ? 0 : self.selectedOption - 1;
                }
                break;
            }
        }
        elems[self.selectedOption].focus();
    };
    scope.getDropdownElement = function() {
        return self.dropdownMenu;
    };
    scope.focusToggleElement = function() {
        if (self.toggleElement) {
            self.toggleElement[0].focus();
        }
    };
    scope.$watch("isOpen", function(isOpen, wasOpen) {
        if (appendToBody && self.dropdownMenu) {
            var pos = $position.positionElements(self.$element, self.dropdownMenu, "bottom-left", true);
            var css = {
                top: pos.top + "px",
                display: isOpen ? "block" : "none"
            };
            var rightalign = self.dropdownMenu.hasClass("dropdown-menu-right");
            if (!rightalign) {
                css.left = pos.left + "px";
                css.right = "auto";
            } else {
                css.left = "auto";
                css.right = window.innerWidth - (pos.left + self.$element.prop("offsetWidth")) + "px";
            }
            self.dropdownMenu.css(css);
        }
        var openContainer = appendToBody ? body : self.$element;
        $animate[isOpen ? "addClass" : "removeClass"](openContainer, openClass).then(function() {
            if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
                toggleInvoker($scope, {
                    open: !!isOpen
                });
            }
        });
        if (isOpen) {
            if (self.dropdownMenuTemplateUrl) {
                $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
                    templateScope = scope.$new();
                    $compile(tplContent.trim())(templateScope, function(dropdownElement) {
                        var newEl = dropdownElement;
                        self.dropdownMenu.replaceWith(newEl);
                        self.dropdownMenu = newEl;
                    });
                });
            }
            scope.focusToggleElement();
            dropdownService.open(scope);
        } else {
            if (self.dropdownMenuTemplateUrl) {
                if (templateScope) {
                    templateScope.$destroy();
                }
                var newEl = angular.element('<ul class="dropdown-menu"></ul>');
                self.dropdownMenu.replaceWith(newEl);
                self.dropdownMenu = newEl;
            }
            dropdownService.close(scope);
            self.selectedOption = null;
        }
        if (angular.isFunction(setIsOpen)) {
            setIsOpen($scope, isOpen);
        }
    });
    $scope.$on("$locationChangeSuccess", function() {
        if (scope.getAutoClose() !== "disabled") {
            scope.isOpen = false;
        }
    });
    var offDestroy = $scope.$on("$destroy", function() {
        scope.$destroy();
    });
    scope.$on("$destroy", offDestroy);
} ]).directive("dropdown", function() {
    return {
        controller: "DropdownController",
        link: function(scope, element, attrs, dropdownCtrl) {
            dropdownCtrl.init(element);
            element.addClass("dropdown");
        }
    };
}).directive("dropdownMenu", function() {
    return {
        restrict: "AC",
        require: "?^dropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (!dropdownCtrl) {
                return;
            }
            var tplUrl = attrs.templateUrl;
            if (tplUrl) {
                dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
            }
            if (!dropdownCtrl.dropdownMenu) {
                dropdownCtrl.dropdownMenu = element;
            }
        }
    };
}).directive("keyboardNav", function() {
    return {
        restrict: "A",
        require: "?^dropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            element.bind("keydown", function(e) {
                if ([ 38, 40 ].indexOf(e.which) !== -1) {
                    e.preventDefault();
                    e.stopPropagation();
                    var elems = dropdownCtrl.dropdownMenu.find("a");
                    switch (e.which) {
                      case 40:
                        {
                            if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                                dropdownCtrl.selectedOption = 0;
                            } else {
                                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length - 1 ? dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;
                            }
                            break;
                        }

                      case 38:
                        {
                            if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                                dropdownCtrl.selectedOption = elems.length - 1;
                            } else {
                                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ? 0 : dropdownCtrl.selectedOption - 1;
                            }
                            break;
                        }
                    }
                    elems[dropdownCtrl.selectedOption].focus();
                }
            });
        }
    };
}).directive("dropdownToggle", function() {
    return {
        require: "?^dropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (!dropdownCtrl) {
                return;
            }
            element.addClass("dropdown-toggle");
            dropdownCtrl.toggleElement = element;
            var toggleDropdown = function(event) {
                event.preventDefault();
                if (!element.hasClass("disabled") && !attrs.disabled) {
                    scope.$apply(function() {
                        dropdownCtrl.toggle();
                    });
                }
            };
            element.bind("click", toggleDropdown);
            element.attr({
                "aria-haspopup": true,
                "aria-expanded": false
            });
            scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
                element.attr("aria-expanded", !!isOpen);
            });
            scope.$on("$destroy", function() {
                element.unbind("click", toggleDropdown);
            });
        }
    };
});

angular.module("ui.bootstrap.modal", []).factory("$$stackedMap", function() {
    return {
        createNew: function() {
            var stack = [];
            return {
                add: function(key, value) {
                    stack.push({
                        key: key,
                        value: value
                    });
                },
                get: function(key) {
                    for (var i = 0; i < stack.length; i++) {
                        if (key == stack[i].key) {
                            return stack[i];
                        }
                    }
                },
                keys: function() {
                    var keys = [];
                    for (var i = 0; i < stack.length; i++) {
                        keys.push(stack[i].key);
                    }
                    return keys;
                },
                top: function() {
                    return stack[stack.length - 1];
                },
                remove: function(key) {
                    var idx = -1;
                    for (var i = 0; i < stack.length; i++) {
                        if (key == stack[i].key) {
                            idx = i;
                            break;
                        }
                    }
                    return stack.splice(idx, 1)[0];
                },
                removeTop: function() {
                    return stack.splice(stack.length - 1, 1)[0];
                },
                length: function() {
                    return stack.length;
                }
            };
        }
    };
}).factory("$$multiMap", function() {
    return {
        createNew: function() {
            var map = {};
            return {
                entries: function() {
                    return Object.keys(map).map(function(key) {
                        return {
                            key: key,
                            value: map[key]
                        };
                    });
                },
                get: function(key) {
                    return map[key];
                },
                hasKey: function(key) {
                    return !!map[key];
                },
                keys: function() {
                    return Object.keys(map);
                },
                put: function(key, value) {
                    if (!map[key]) {
                        map[key] = [];
                    }
                    map[key].push(value);
                },
                remove: function(key, value) {
                    var values = map[key];
                    if (!values) {
                        return;
                    }
                    var idx = values.indexOf(value);
                    if (idx !== -1) {
                        values.splice(idx, 1);
                    }
                    if (!values.length) {
                        delete map[key];
                    }
                }
            };
        }
    };
}).directive("modalBackdrop", [ "$animate", "$injector", "$modalStack", function($animate, $injector, $modalStack) {
    var $animateCss = null;
    if ($injector.has("$animateCss")) {
        $animateCss = $injector.get("$animateCss");
    }
    return {
        restrict: "EA",
        replace: true,
        templateUrl: "template/modal/backdrop.html",
        compile: function(tElement, tAttrs) {
            tElement.addClass(tAttrs.backdropClass);
            return linkFn;
        }
    };
    function linkFn(scope, element, attrs) {
        if (attrs.modalInClass) {
            if ($animateCss) {
                $animateCss(element, {
                    addClass: attrs.modalInClass
                }).start();
            } else {
                $animate.addClass(element, attrs.modalInClass);
            }
            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                var done = setIsAsync();
                if ($animateCss) {
                    $animateCss(element, {
                        removeClass: attrs.modalInClass
                    }).start().then(done);
                } else {
                    $animate.removeClass(element, attrs.modalInClass).then(done);
                }
            });
        }
    }
} ]).directive("modalWindow", [ "$modalStack", "$q", "$animate", "$injector", function($modalStack, $q, $animate, $injector) {
    var $animateCss = null;
    if ($injector.has("$animateCss")) {
        $animateCss = $injector.get("$animateCss");
    }
    return {
        restrict: "EA",
        scope: {
            index: "@"
        },
        replace: true,
        transclude: true,
        templateUrl: function(tElement, tAttrs) {
            return tAttrs.templateUrl || "template/modal/window.html";
        },
        link: function(scope, element, attrs) {
            element.addClass(attrs.windowClass || "");
            scope.size = attrs.size;
            scope.close = function(evt) {
                var modal = $modalStack.getTop();
                if (modal && modal.value.backdrop && modal.value.backdrop !== "static" && evt.target === evt.currentTarget) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    $modalStack.dismiss(modal.key, "backdrop click");
                }
            };
            scope.$isRendered = true;
            var modalRenderDeferObj = $q.defer();
            attrs.$observe("modalRender", function(value) {
                if (value == "true") {
                    modalRenderDeferObj.resolve();
                }
            });
            modalRenderDeferObj.promise.then(function() {
                var animationPromise = null;
                if (attrs.modalInClass) {
                    if ($animateCss) {
                        animationPromise = $animateCss(element, {
                            addClass: attrs.modalInClass
                        }).start();
                    } else {
                        animationPromise = $animate.addClass(element, attrs.modalInClass);
                    }
                    scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                        var done = setIsAsync();
                        if ($animateCss) {
                            $animateCss(element, {
                                removeClass: attrs.modalInClass
                            }).start().then(done);
                        } else {
                            $animate.removeClass(element, attrs.modalInClass).then(done);
                        }
                    });
                }
                $q.when(animationPromise).then(function() {
                    var inputsWithAutofocus = element[0].querySelectorAll("[autofocus]");
                    if (inputsWithAutofocus.length) {
                        inputsWithAutofocus[0].focus();
                    } else {
                        element[0].focus();
                    }
                });
                var modal = $modalStack.getTop();
                if (modal) {
                    $modalStack.modalRendered(modal.key);
                }
            });
        }
    };
} ]).directive("modalAnimationClass", [ function() {
    return {
        compile: function(tElement, tAttrs) {
            if (tAttrs.modalAnimation) {
                tElement.addClass(tAttrs.modalAnimationClass);
            }
        }
    };
} ]).directive("modalTransclude", function() {
    return {
        link: function($scope, $element, $attrs, controller, $transclude) {
            $transclude($scope.$parent, function(clone) {
                $element.empty();
                $element.append(clone);
            });
        }
    };
}).factory("$modalStack", [ "$animate", "$timeout", "$document", "$compile", "$rootScope", "$q", "$injector", "$$multiMap", "$$stackedMap", function($animate, $timeout, $document, $compile, $rootScope, $q, $injector, $$multiMap, $$stackedMap) {
    var $animateCss = null;
    if ($injector.has("$animateCss")) {
        $animateCss = $injector.get("$animateCss");
    }
    var OPENED_MODAL_CLASS = "modal-open";
    var backdropDomEl, backdropScope;
    var openedWindows = $$stackedMap.createNew();
    var openedClasses = $$multiMap.createNew();
    var $modalStack = {
        NOW_CLOSING_EVENT: "modal.stack.now-closing"
    };
    var focusableElementList;
    var focusIndex = 0;
    var tababbleSelector = "a[href], area[href], input:not([disabled]), " + "button:not([disabled]),select:not([disabled]), textarea:not([disabled]), " + "iframe, object, embed, *[tabindex], *[contenteditable=true]";
    function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
            if (openedWindows.get(opened[i]).value.backdrop) {
                topBackdropIndex = i;
            }
        }
        return topBackdropIndex;
    }
    $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        if (backdropScope) {
            backdropScope.index = newBackdropIndex;
        }
    });
    function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var body = $document.find("body").eq(0);
        var modalWindow = openedWindows.get(modalInstance).value;
        openedWindows.remove(modalInstance);
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
            var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
            openedClasses.remove(modalBodyClass, modalInstance);
            body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));
        });
        checkRemoveBackdrop();
        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
            elementToReceiveFocus.focus();
        } else {
            body.focus();
        }
    }
    function checkRemoveBackdrop() {
        if (backdropDomEl && backdropIndex() == -1) {
            var backdropScopeRef = backdropScope;
            removeAfterAnimate(backdropDomEl, backdropScope, function() {
                backdropScopeRef = null;
            });
            backdropDomEl = undefined;
            backdropScope = undefined;
        }
    }
    function removeAfterAnimate(domEl, scope, done) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function() {
            if (!asyncDeferred) {
                asyncDeferred = $q.defer();
                asyncPromise = asyncDeferred.promise;
            }
            return function asyncDone() {
                asyncDeferred.resolve();
            };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);
        return $q.when(asyncPromise).then(afterAnimating);
        function afterAnimating() {
            if (afterAnimating.done) {
                return;
            }
            afterAnimating.done = true;
            if ($animateCss) {
                $animateCss(domEl, {
                    event: "leave"
                }).start().then(function() {
                    domEl.remove();
                });
            } else {
                $animate.leave(domEl);
            }
            scope.$destroy();
            if (done) {
                done();
            }
        }
    }
    $document.bind("keydown", function(evt) {
        if (evt.isDefaultPrevented()) {
            return evt;
        }
        var modal = openedWindows.top();
        if (modal && modal.value.keyboard) {
            switch (evt.which) {
              case 27:
                {
                    evt.preventDefault();
                    $rootScope.$apply(function() {
                        $modalStack.dismiss(modal.key, "escape key press");
                    });
                    break;
                }

              case 9:
                {
                    $modalStack.loadFocusElementList(modal);
                    var focusChanged = false;
                    if (evt.shiftKey) {
                        if ($modalStack.isFocusInFirstItem(evt)) {
                            focusChanged = $modalStack.focusLastFocusableElement();
                        }
                    } else {
                        if ($modalStack.isFocusInLastItem(evt)) {
                            focusChanged = $modalStack.focusFirstFocusableElement();
                        }
                    }
                    if (focusChanged) {
                        evt.preventDefault();
                        evt.stopPropagation();
                    }
                    break;
                }
            }
        }
    });
    $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement, modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
        openedWindows.add(modalInstance, {
            deferred: modal.deferred,
            renderDeferred: modal.renderDeferred,
            modalScope: modal.scope,
            backdrop: modal.backdrop,
            keyboard: modal.keyboard,
            openedClass: modal.openedClass
        });
        openedClasses.put(modalBodyClass, modalInstance);
        var body = $document.find("body").eq(0), currBackdropIndex = backdropIndex();
        if (currBackdropIndex >= 0 && !backdropDomEl) {
            backdropScope = $rootScope.$new(true);
            backdropScope.index = currBackdropIndex;
            var angularBackgroundDomEl = angular.element('<div modal-backdrop="modal-backdrop"></div>');
            angularBackgroundDomEl.attr("backdrop-class", modal.backdropClass);
            if (modal.animation) {
                angularBackgroundDomEl.attr("modal-animation", "true");
            }
            backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);
            body.append(backdropDomEl);
        }
        var angularDomEl = angular.element('<div modal-window="modal-window"></div>');
        angularDomEl.attr({
            "template-url": modal.windowTemplateUrl,
            "window-class": modal.windowClass,
            size: modal.size,
            index: openedWindows.length() - 1,
            animate: "animate"
        }).html(modal.content);
        if (modal.animation) {
            angularDomEl.attr("modal-animation", "true");
        }
        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl;
        openedWindows.top().value.modalOpener = modalOpener;
        body.append(modalDomEl);
        body.addClass(modalBodyClass);
        $modalStack.clearFocusListCache();
    };
    function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast("modal.closing", resultOrReason, closing).defaultPrevented;
    }
    $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
            modalWindow.value.modalScope.$$uibDestructionScheduled = true;
            modalWindow.value.deferred.resolve(result);
            removeModalWindow(modalInstance, modalWindow.value.modalOpener);
            return true;
        }
        return !modalWindow;
    };
    $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
            modalWindow.value.modalScope.$$uibDestructionScheduled = true;
            modalWindow.value.deferred.reject(reason);
            removeModalWindow(modalInstance, modalWindow.value.modalOpener);
            return true;
        }
        return !modalWindow;
    };
    $modalStack.dismissAll = function(reason) {
        var topModal = this.getTop();
        while (topModal && this.dismiss(topModal.key, reason)) {
            topModal = this.getTop();
        }
    };
    $modalStack.getTop = function() {
        return openedWindows.top();
    };
    $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
            modalWindow.value.renderDeferred.resolve();
        }
    };
    $modalStack.focusFirstFocusableElement = function() {
        if (focusableElementList.length > 0) {
            focusableElementList[0].focus();
            return true;
        }
        return false;
    };
    $modalStack.focusLastFocusableElement = function() {
        if (focusableElementList.length > 0) {
            focusableElementList[focusableElementList.length - 1].focus();
            return true;
        }
        return false;
    };
    $modalStack.isFocusInFirstItem = function(evt) {
        if (focusableElementList.length > 0) {
            return (evt.target || evt.srcElement) == focusableElementList[0];
        }
        return false;
    };
    $modalStack.isFocusInLastItem = function(evt) {
        if (focusableElementList.length > 0) {
            return (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1];
        }
        return false;
    };
    $modalStack.clearFocusListCache = function() {
        focusableElementList = [];
        focusIndex = 0;
    };
    $modalStack.loadFocusElementList = function(modalWindow) {
        if (focusableElementList === undefined || !focusableElementList.length0) {
            if (modalWindow) {
                var modalDomE1 = modalWindow.value.modalDomEl;
                if (modalDomE1 && modalDomE1.length) {
                    focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);
                }
            }
        }
    };
    return $modalStack;
} ]).provider("$modal", function() {
    var $modalProvider = {
        options: {
            animation: true,
            backdrop: true,
            keyboard: true
        },
        $get: [ "$injector", "$rootScope", "$q", "$templateRequest", "$controller", "$modalStack", function($injector, $rootScope, $q, $templateRequest, $controller, $modalStack) {
            var $modal = {};
            function getTemplatePromise(options) {
                return options.template ? $q.when(options.template) : $templateRequest(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl);
            }
            function getResolvePromises(resolves) {
                var promisesArr = [];
                angular.forEach(resolves, function(value) {
                    if (angular.isFunction(value) || angular.isArray(value)) {
                        promisesArr.push($q.when($injector.invoke(value)));
                    } else if (angular.isString(value)) {
                        promisesArr.push($q.when($injector.get(value)));
                    } else {
                        promisesArr.push($q.when(value));
                    }
                });
                return promisesArr;
            }
            var promiseChain = null;
            $modal.getPromiseChain = function() {
                return promiseChain;
            };
            $modal.open = function(modalOptions) {
                var modalResultDeferred = $q.defer();
                var modalOpenedDeferred = $q.defer();
                var modalRenderDeferred = $q.defer();
                var modalInstance = {
                    result: modalResultDeferred.promise,
                    opened: modalOpenedDeferred.promise,
                    rendered: modalRenderDeferred.promise,
                    close: function(result) {
                        return $modalStack.close(modalInstance, result);
                    },
                    dismiss: function(reason) {
                        return $modalStack.dismiss(modalInstance, reason);
                    }
                };
                modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
                modalOptions.resolve = modalOptions.resolve || {};
                if (!modalOptions.template && !modalOptions.templateUrl) {
                    throw new Error("One of template or templateUrl options is required.");
                }
                var templateAndResolvePromise = $q.all([ getTemplatePromise(modalOptions) ].concat(getResolvePromises(modalOptions.resolve)));
                var samePromise;
                samePromise = promiseChain = $q.all([ promiseChain ]).then(function() {
                    return templateAndResolvePromise;
                }, function() {
                    return templateAndResolvePromise;
                }).then(function resolveSuccess(tplAndVars) {
                    var modalScope = (modalOptions.scope || $rootScope).$new();
                    modalScope.$close = modalInstance.close;
                    modalScope.$dismiss = modalInstance.dismiss;
                    modalScope.$on("$destroy", function() {
                        if (!modalScope.$$uibDestructionScheduled) {
                            modalScope.$dismiss("$uibUnscheduledDestruction");
                        }
                    });
                    var ctrlInstance, ctrlLocals = {};
                    var resolveIter = 1;
                    if (modalOptions.controller) {
                        ctrlLocals.$scope = modalScope;
                        ctrlLocals.$modalInstance = modalInstance;
                        angular.forEach(modalOptions.resolve, function(value, key) {
                            ctrlLocals[key] = tplAndVars[resolveIter++];
                        });
                        ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
                        if (modalOptions.controllerAs) {
                            if (modalOptions.bindToController) {
                                angular.extend(ctrlInstance, modalScope);
                            }
                            modalScope[modalOptions.controllerAs] = ctrlInstance;
                        }
                    }
                    $modalStack.open(modalInstance, {
                        scope: modalScope,
                        deferred: modalResultDeferred,
                        renderDeferred: modalRenderDeferred,
                        content: tplAndVars[0],
                        animation: modalOptions.animation,
                        backdrop: modalOptions.backdrop,
                        keyboard: modalOptions.keyboard,
                        backdropClass: modalOptions.backdropClass,
                        windowClass: modalOptions.windowClass,
                        windowTemplateUrl: modalOptions.windowTemplateUrl,
                        size: modalOptions.size,
                        openedClass: modalOptions.openedClass
                    });
                    modalOpenedDeferred.resolve(true);
                }, function resolveError(reason) {
                    modalOpenedDeferred.reject(reason);
                    modalResultDeferred.reject(reason);
                }).finally(function() {
                    if (promiseChain === samePromise) {
                        promiseChain = null;
                    }
                });
                return modalInstance;
            };
            return $modal;
        } ]
    };
    return $modalProvider;
});

angular.module("ui.bootstrap.pagination", []).controller("PaginationController", [ "$scope", "$attrs", "$parse", function($scope, $attrs, $parse) {
    var self = this, ngModelCtrl = {
        $setViewValue: angular.noop
    }, setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
    this.init = function(ngModelCtrl_, config) {
        ngModelCtrl = ngModelCtrl_;
        this.config = config;
        ngModelCtrl.$render = function() {
            self.render();
        };
        if ($attrs.itemsPerPage) {
            $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
                self.itemsPerPage = parseInt(value, 10);
                $scope.totalPages = self.calculateTotalPages();
            });
        } else {
            this.itemsPerPage = config.itemsPerPage;
        }
        $scope.$watch("totalItems", function() {
            $scope.totalPages = self.calculateTotalPages();
        });
        $scope.$watch("totalPages", function(value) {
            setNumPages($scope.$parent, value);
            if ($scope.page > value) {
                $scope.selectPage(value);
            } else {
                ngModelCtrl.$render();
            }
        });
    };
    this.calculateTotalPages = function() {
        var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
        return Math.max(totalPages || 0, 1);
    };
    this.render = function() {
        $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
    };
    $scope.selectPage = function(page, evt) {
        if (evt) {
            evt.preventDefault();
        }
        var clickAllowed = !$scope.ngDisabled || !evt;
        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
            if (evt && evt.target) {
                evt.target.blur();
            }
            ngModelCtrl.$setViewValue(page);
            ngModelCtrl.$render();
        }
    };
    $scope.getText = function(key) {
        return $scope[key + "Text"] || self.config[key + "Text"];
    };
    $scope.noPrevious = function() {
        return $scope.page === 1;
    };
    $scope.noNext = function() {
        return $scope.page === $scope.totalPages;
    };
} ]).constant("paginationConfig", {
    itemsPerPage: 10,
    boundaryLinks: false,
    directionLinks: true,
    firstText: "First",
    previousText: "Previous",
    nextText: "Next",
    lastText: "Last",
    rotate: true
}).directive("pagination", [ "$parse", "paginationConfig", function($parse, paginationConfig) {
    return {
        restrict: "EA",
        scope: {
            totalItems: "=",
            firstText: "@",
            previousText: "@",
            nextText: "@",
            lastText: "@",
            ngDisabled: "="
        },
        require: [ "pagination", "?ngModel" ],
        controller: "PaginationController",
        controllerAs: "pagination",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/pagination/pagination.html";
        },
        replace: true,
        link: function(scope, element, attrs, ctrls) {
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            if (!ngModelCtrl) {
                return;
            }
            var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize, rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
            scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
            scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;
            paginationCtrl.init(ngModelCtrl, paginationConfig);
            if (attrs.maxSize) {
                scope.$parent.$watch($parse(attrs.maxSize), function(value) {
                    maxSize = parseInt(value, 10);
                    paginationCtrl.render();
                });
            }
            function makePage(number, text, isActive) {
                return {
                    number: number,
                    text: text,
                    active: isActive
                };
            }
            function getPages(currentPage, totalPages) {
                var pages = [];
                var startPage = 1, endPage = totalPages;
                var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
                if (isMaxSized) {
                    if (rotate) {
                        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
                        endPage = startPage + maxSize - 1;
                        if (endPage > totalPages) {
                            endPage = totalPages;
                            startPage = endPage - maxSize + 1;
                        }
                    } else {
                        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;
                        endPage = Math.min(startPage + maxSize - 1, totalPages);
                    }
                }
                for (var number = startPage; number <= endPage; number++) {
                    var page = makePage(number, number, number === currentPage);
                    pages.push(page);
                }
                if (isMaxSized && !rotate) {
                    if (startPage > 1) {
                        var previousPageSet = makePage(startPage - 1, "...", false);
                        pages.unshift(previousPageSet);
                    }
                    if (endPage < totalPages) {
                        var nextPageSet = makePage(endPage + 1, "...", false);
                        pages.push(nextPageSet);
                    }
                }
                return pages;
            }
            var originalRender = paginationCtrl.render;
            paginationCtrl.render = function() {
                originalRender();
                if (scope.page > 0 && scope.page <= scope.totalPages) {
                    scope.pages = getPages(scope.page, scope.totalPages);
                }
            };
        }
    };
} ]).constant("pagerConfig", {
    itemsPerPage: 10,
    previousText: "« Previous",
    nextText: "Next »",
    align: true
}).directive("pager", [ "pagerConfig", function(pagerConfig) {
    return {
        restrict: "EA",
        scope: {
            totalItems: "=",
            previousText: "@",
            nextText: "@",
            ngDisabled: "="
        },
        require: [ "pager", "?ngModel" ],
        controller: "PaginationController",
        controllerAs: "pagination",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/pagination/pager.html";
        },
        replace: true,
        link: function(scope, element, attrs, ctrls) {
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            if (!ngModelCtrl) {
                return;
            }
            scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
            paginationCtrl.init(ngModelCtrl, pagerConfig);
        }
    };
} ]);

angular.module("ui.bootstrap.tooltip", [ "ui.bootstrap.position", "ui.bootstrap.bindHtml" ]).provider("$tooltip", function() {
    var defaultOptions = {
        placement: "top",
        animation: true,
        popupDelay: 0,
        useContentExp: false
    };
    var triggerMap = {
        mouseenter: "mouseleave",
        click: "click",
        focus: "blur",
        none: ""
    };
    var globalOptions = {};
    this.options = function(value) {
        angular.extend(globalOptions, value);
    };
    this.setTriggers = function setTriggers(triggers) {
        angular.extend(triggerMap, triggers);
    };
    function snake_case(name) {
        var regexp = /[A-Z]/g;
        var separator = "-";
        return name.replace(regexp, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    this.$get = [ "$window", "$compile", "$timeout", "$document", "$position", "$interpolate", "$rootScope", "$parse", function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse) {
        return function $tooltip(type, prefix, defaultTriggerShow, options) {
            options = angular.extend({}, defaultOptions, globalOptions, options);
            function getTriggers(trigger) {
                var show = (trigger || options.trigger || defaultTriggerShow).split(" ");
                var hide = show.map(function(trigger) {
                    return triggerMap[trigger] || trigger;
                });
                return {
                    show: show,
                    hide: hide
                };
            }
            var directiveName = snake_case(type);
            var startSym = $interpolate.startSymbol();
            var endSym = $interpolate.endSymbol();
            var template = "<div " + directiveName + "-popup " + 'title="' + startSym + "title" + endSym + '" ' + (options.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + startSym + "content" + endSym + '" ') + 'placement="' + startSym + "placement" + endSym + '" ' + 'popup-class="' + startSym + "popupClass" + endSym + '" ' + 'animation="animation" ' + 'is-open="isOpen"' + 'origin-scope="origScope" ' + ">" + "</div>";
            return {
                restrict: "EA",
                compile: function(tElem, tAttrs) {
                    var tooltipLinker = $compile(template);
                    return function link(scope, element, attrs, tooltipCtrl) {
                        var tooltip;
                        var tooltipLinkedScope;
                        var transitionTimeout;
                        var popupTimeout;
                        var positionTimeout;
                        var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
                        var triggers = getTriggers(undefined);
                        var hasEnableExp = angular.isDefined(attrs[prefix + "Enable"]);
                        var ttScope = scope.$new(true);
                        var repositionScheduled = false;
                        var isOpenExp = angular.isDefined(attrs[prefix + "IsOpen"]) ? $parse(attrs[prefix + "IsOpen"]) : false;
                        var positionTooltip = function() {
                            if (!tooltip) {
                                return;
                            }
                            if (!positionTimeout) {
                                positionTimeout = $timeout(function() {
                                    tooltip.css({
                                        top: 0,
                                        left: 0,
                                        width: "auto",
                                        height: "auto"
                                    });
                                    var ttBox = $position.position(tooltip);
                                    var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                                    ttCss.top += "px";
                                    ttCss.left += "px";
                                    ttCss.width = ttBox.width + "px";
                                    ttCss.height = ttBox.height + "px";
                                    tooltip.css(ttCss);
                                    positionTimeout = null;
                                }, 0, false);
                            }
                        };
                        ttScope.origScope = scope;
                        ttScope.isOpen = false;
                        function toggleTooltipBind() {
                            if (!ttScope.isOpen) {
                                showTooltipBind();
                            } else {
                                hideTooltipBind();
                            }
                        }
                        function showTooltipBind() {
                            if (hasEnableExp && !scope.$eval(attrs[prefix + "Enable"])) {
                                return;
                            }
                            prepareTooltip();
                            if (ttScope.popupDelay) {
                                if (!popupTimeout) {
                                    popupTimeout = $timeout(show, ttScope.popupDelay, false);
                                }
                            } else {
                                show();
                            }
                        }
                        function hideTooltipBind() {
                            hide();
                            if (!$rootScope.$$phase) {
                                $rootScope.$digest();
                            }
                        }
                        function show() {
                            popupTimeout = null;
                            if (transitionTimeout) {
                                $timeout.cancel(transitionTimeout);
                                transitionTimeout = null;
                            }
                            if (!(options.useContentExp ? ttScope.contentExp() : ttScope.content)) {
                                return angular.noop;
                            }
                            createTooltip();
                            ttScope.isOpen = true;
                            if (isOpenExp) {
                                isOpenExp.assign(ttScope.origScope, ttScope.isOpen);
                            }
                            if (!$rootScope.$$phase) {
                                ttScope.$apply();
                            }
                            tooltip.css({
                                display: "block"
                            });
                            positionTooltip();
                        }
                        function hide() {
                            ttScope.isOpen = false;
                            if (isOpenExp) {
                                isOpenExp.assign(ttScope.origScope, ttScope.isOpen);
                            }
                            $timeout.cancel(popupTimeout);
                            popupTimeout = null;
                            $timeout.cancel(positionTimeout);
                            positionTimeout = null;
                            if (ttScope.animation) {
                                if (!transitionTimeout) {
                                    transitionTimeout = $timeout(removeTooltip, 500);
                                }
                            } else {
                                removeTooltip();
                            }
                        }
                        function createTooltip() {
                            if (tooltip) {
                                removeTooltip();
                            }
                            tooltipLinkedScope = ttScope.$new();
                            tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                                if (appendToBody) {
                                    $document.find("body").append(tooltip);
                                } else {
                                    element.after(tooltip);
                                }
                            });
                            if (options.useContentExp) {
                                tooltipLinkedScope.$watch("contentExp()", function(val) {
                                    if (!val && ttScope.isOpen) {
                                        hide();
                                    }
                                });
                                tooltipLinkedScope.$watch(function() {
                                    if (!repositionScheduled) {
                                        repositionScheduled = true;
                                        tooltipLinkedScope.$$postDigest(function() {
                                            repositionScheduled = false;
                                            if (ttScope.isOpen) {
                                                positionTooltip();
                                            }
                                        });
                                    }
                                });
                            }
                        }
                        function removeTooltip() {
                            transitionTimeout = null;
                            if (tooltip) {
                                tooltip.remove();
                                tooltip = null;
                            }
                            if (tooltipLinkedScope) {
                                tooltipLinkedScope.$destroy();
                                tooltipLinkedScope = null;
                            }
                        }
                        function prepareTooltip() {
                            prepPopupClass();
                            prepPlacement();
                            prepPopupDelay();
                        }
                        ttScope.contentExp = function() {
                            return scope.$eval(attrs[type]);
                        };
                        if (!options.useContentExp) {
                            attrs.$observe(type, function(val) {
                                ttScope.content = val;
                                if (!val && ttScope.isOpen) {
                                    hide();
                                } else {
                                    positionTooltip();
                                }
                            });
                        }
                        attrs.$observe("disabled", function(val) {
                            if (popupTimeout && val) {
                                $timeout.cancel(popupTimeout);
                                popupTimeout = null;
                            }
                            if (val && ttScope.isOpen) {
                                hide();
                            }
                        });
                        attrs.$observe(prefix + "Title", function(val) {
                            ttScope.title = val;
                            positionTooltip();
                        });
                        attrs.$observe(prefix + "Placement", function() {
                            if (ttScope.isOpen) {
                                prepPlacement();
                                positionTooltip();
                            }
                        });
                        if (isOpenExp) {
                            scope.$watch(isOpenExp, function(val) {
                                if (val !== ttScope.isOpen) {
                                    toggleTooltipBind();
                                }
                            });
                        }
                        function prepPopupClass() {
                            ttScope.popupClass = attrs[prefix + "Class"];
                        }
                        function prepPlacement() {
                            var val = attrs[prefix + "Placement"];
                            ttScope.placement = angular.isDefined(val) ? val : options.placement;
                        }
                        function prepPopupDelay() {
                            var val = attrs[prefix + "PopupDelay"];
                            var delay = parseInt(val, 10);
                            ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                        }
                        var unregisterTriggers = function() {
                            triggers.show.forEach(function(trigger) {
                                element.unbind(trigger, showTooltipBind);
                            });
                            triggers.hide.forEach(function(trigger) {
                                element.unbind(trigger, hideTooltipBind);
                            });
                        };
                        function prepTriggers() {
                            var val = attrs[prefix + "Trigger"];
                            unregisterTriggers();
                            triggers = getTriggers(val);
                            if (triggers.show !== "none") {
                                triggers.show.forEach(function(trigger, idx) {
                                    if (trigger === triggers.hide[idx]) {
                                        element[0].addEventListener(trigger, toggleTooltipBind);
                                    } else if (trigger) {
                                        element[0].addEventListener(trigger, showTooltipBind);
                                        element[0].addEventListener(triggers.hide[idx], hideTooltipBind);
                                    }
                                });
                            }
                        }
                        prepTriggers();
                        var animation = scope.$eval(attrs[prefix + "Animation"]);
                        ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
                        var appendToBodyVal = scope.$eval(attrs[prefix + "AppendToBody"]);
                        appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;
                        if (appendToBody) {
                            scope.$on("$locationChangeSuccess", function closeTooltipOnLocationChangeSuccess() {
                                if (ttScope.isOpen) {
                                    hide();
                                }
                            });
                        }
                        scope.$on("$destroy", function onDestroyTooltip() {
                            $timeout.cancel(transitionTimeout);
                            $timeout.cancel(popupTimeout);
                            $timeout.cancel(positionTimeout);
                            unregisterTriggers();
                            removeTooltip();
                            ttScope = null;
                        });
                    };
                }
            };
        };
    } ];
}).directive("tooltipTemplateTransclude", [ "$animate", "$sce", "$compile", "$templateRequest", function($animate, $sce, $compile, $templateRequest) {
    return {
        link: function(scope, elem, attrs) {
            var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
            var changeCounter = 0, currentScope, previousElement, currentElement;
            var cleanupLastIncludeContent = function() {
                if (previousElement) {
                    previousElement.remove();
                    previousElement = null;
                }
                if (currentScope) {
                    currentScope.$destroy();
                    currentScope = null;
                }
                if (currentElement) {
                    $animate.leave(currentElement).then(function() {
                        previousElement = null;
                    });
                    previousElement = currentElement;
                    currentElement = null;
                }
            };
            scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {
                var thisChangeId = ++changeCounter;
                if (src) {
                    $templateRequest(src, true).then(function(response) {
                        if (thisChangeId !== changeCounter) {
                            return;
                        }
                        var newScope = origScope.$new();
                        var template = response;
                        var clone = $compile(template)(newScope, function(clone) {
                            cleanupLastIncludeContent();
                            $animate.enter(clone, elem);
                        });
                        currentScope = newScope;
                        currentElement = clone;
                        currentScope.$emit("$includeContentLoaded", src);
                    }, function() {
                        if (thisChangeId === changeCounter) {
                            cleanupLastIncludeContent();
                            scope.$emit("$includeContentError", src);
                        }
                    });
                    scope.$emit("$includeContentRequested", src);
                } else {
                    cleanupLastIncludeContent();
                }
            });
            scope.$on("$destroy", cleanupLastIncludeContent);
        }
    };
} ]).directive("tooltipClasses", function() {
    return {
        restrict: "A",
        link: function(scope, element, attrs) {
            if (scope.placement) {
                element.addClass(scope.placement);
            }
            if (scope.popupClass) {
                element.addClass(scope.popupClass);
            }
            if (scope.animation()) {
                element.addClass(attrs.tooltipAnimationClass);
            }
        }
    };
}).directive("tooltipPopup", function() {
    return {
        restrict: "EA",
        replace: true,
        scope: {
            content: "@",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-popup.html"
    };
}).directive("tooltip", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltip", "tooltip", "mouseenter");
} ]).directive("tooltipTemplatePopup", function() {
    return {
        restrict: "EA",
        replace: true,
        scope: {
            contentExp: "&",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&",
            originScope: "&"
        },
        templateUrl: "template/tooltip/tooltip-template-popup.html"
    };
}).directive("tooltipTemplate", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltipTemplate", "tooltip", "mouseenter", {
        useContentExp: true
    });
} ]).directive("tooltipHtmlPopup", function() {
    return {
        restrict: "EA",
        replace: true,
        scope: {
            contentExp: "&",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-html-popup.html"
    };
}).directive("tooltipHtml", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltipHtml", "tooltip", "mouseenter", {
        useContentExp: true
    });
} ]).directive("tooltipHtmlUnsafePopup", function() {
    return {
        restrict: "EA",
        replace: true,
        scope: {
            content: "@",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-html-unsafe-popup.html"
    };
}).value("tooltipHtmlUnsafeSuppressDeprecated", false).directive("tooltipHtmlUnsafe", [ "$tooltip", "tooltipHtmlUnsafeSuppressDeprecated", "$log", function($tooltip, tooltipHtmlUnsafeSuppressDeprecated, $log) {
    if (!tooltipHtmlUnsafeSuppressDeprecated) {
        $log.warn("tooltip-html-unsafe is now deprecated. Use tooltip-html or tooltip-template instead.");
    }
    return $tooltip("tooltipHtmlUnsafe", "tooltip", "mouseenter");
} ]);

angular.module("ui.bootstrap.popover", [ "ui.bootstrap.tooltip" ]).directive("popoverTemplatePopup", function() {
    return {
        restrict: "EA",
        replace: true,
        scope: {
            title: "@",
            contentExp: "&",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&",
            originScope: "&"
        },
        templateUrl: "template/popover/popover-template.html"
    };
}).directive("popoverTemplate", [ "$tooltip", function($tooltip) {
    return $tooltip("popoverTemplate", "popover", "click", {
        useContentExp: true
    });
} ]).directive("popoverHtmlPopup", function() {
    return {
        restrict: "EA",
        replace: true,
        scope: {
            contentExp: "&",
            title: "@",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/popover/popover-html.html"
    };
}).directive("popoverHtml", [ "$tooltip", function($tooltip) {
    return $tooltip("popoverHtml", "popover", "click", {
        useContentExp: true
    });
} ]).directive("popoverPopup", function() {
    return {
        restrict: "EA",
        replace: true,
        scope: {
            title: "@",
            content: "@",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/popover/popover.html"
    };
}).directive("popover", [ "$tooltip", function($tooltip) {
    return $tooltip("popover", "popover", "click");
} ]);

angular.module("ui.bootstrap.progressbar", []).constant("progressConfig", {
    animate: true,
    max: 100
}).value("$progressSuppressWarning", false).controller("ProgressController", [ "$scope", "$attrs", "progressConfig", function($scope, $attrs, progressConfig) {
    var self = this, animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.bars = [];
    $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;
    this.addBar = function(bar, element) {
        if (!animate) {
            element.css({
                transition: "none"
            });
        }
        this.bars.push(bar);
        bar.max = $scope.max;
        bar.$watch("value", function(value) {
            bar.recalculatePercentage();
        });
        bar.recalculatePercentage = function() {
            bar.percent = +(100 * bar.value / bar.max).toFixed(2);
            var totalPercentage = self.bars.reduce(function(total, bar) {
                return total + bar.percent;
            }, 0);
            if (totalPercentage > 100) {
                bar.percent -= totalPercentage - 100;
            }
        };
        bar.$on("$destroy", function() {
            element = null;
            self.removeBar(bar);
        });
    };
    this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
    };
    $scope.$watch("max", function(max) {
        self.bars.forEach(function(bar) {
            bar.max = $scope.max;
            bar.recalculatePercentage();
        });
    });
} ]).directive("uibProgress", function() {
    return {
        restrict: "EA",
        replace: true,
        transclude: true,
        controller: "ProgressController",
        require: "uibProgress",
        scope: {
            max: "=?"
        },
        templateUrl: "template/progressbar/progress.html"
    };
}).directive("progress", [ "$log", "$progressSuppressWarning", function($log, $progressSuppressWarning) {
    return {
        restrict: "EA",
        replace: true,
        transclude: true,
        controller: "ProgressController",
        require: "progress",
        scope: {
            max: "=?"
        },
        templateUrl: "template/progressbar/progress.html",
        link: function() {
            if ($progressSuppressWarning) {
                $log.warn("progress is now deprecated. Use uib-progress instead");
            }
        }
    };
} ]).directive("uibBar", function() {
    return {
        restrict: "EA",
        replace: true,
        transclude: true,
        require: "^uibProgress",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/bar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element);
        }
    };
}).directive("bar", [ "$log", "$progressSuppressWarning", function($log, $progressSuppressWarning) {
    return {
        restrict: "EA",
        replace: true,
        transclude: true,
        require: "^progress",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/bar.html",
        link: function(scope, element, attrs, progressCtrl) {
            if ($progressSuppressWarning) {
                $log.warn("bar is now deprecated. Use uib-bar instead");
            }
            progressCtrl.addBar(scope, element);
        }
    };
} ]).directive("progressbar", function() {
    return {
        restrict: "EA",
        replace: true,
        transclude: true,
        controller: "ProgressController",
        scope: {
            value: "=",
            max: "=?",
            type: "@"
        },
        templateUrl: "template/progressbar/progressbar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]));
        }
    };
});

angular.module("ui.bootstrap.rating", []).constant("ratingConfig", {
    max: 5,
    stateOn: null,
    stateOff: null,
    titles: [ "one", "two", "three", "four", "five" ]
}).controller("RatingController", [ "$scope", "$attrs", "ratingConfig", function($scope, $attrs, ratingConfig) {
    var ngModelCtrl = {
        $setViewValue: angular.noop
    };
    this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;
        ngModelCtrl.$formatters.push(function(value) {
            if (angular.isNumber(value) && value << 0 !== value) {
                value = Math.round(value);
            }
            return value;
        });
        this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
        this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
        var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
        this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ? tmpTitles : ratingConfig.titles;
        var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
        $scope.range = this.buildTemplateObjects(ratingStates);
    };
    this.buildTemplateObjects = function(states) {
        for (var i = 0, n = states.length; i < n; i++) {
            states[i] = angular.extend({
                index: i
            }, {
                stateOn: this.stateOn,
                stateOff: this.stateOff,
                title: this.getTitle(i)
            }, states[i]);
        }
        return states;
    };
    this.getTitle = function(index) {
        if (index >= this.titles.length) {
            return index + 1;
        } else {
            return this.titles[index];
        }
    };
    $scope.rate = function(value) {
        if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
            ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);
            ngModelCtrl.$render();
        }
    };
    $scope.enter = function(value) {
        if (!$scope.readonly) {
            $scope.value = value;
        }
        $scope.onHover({
            value: value
        });
    };
    $scope.reset = function() {
        $scope.value = ngModelCtrl.$viewValue;
        $scope.onLeave();
    };
    $scope.onKeydown = function(evt) {
        if (/(37|38|39|40)/.test(evt.which)) {
            evt.preventDefault();
            evt.stopPropagation();
            $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
        }
    };
    this.render = function() {
        $scope.value = ngModelCtrl.$viewValue;
    };
} ]).directive("rating", function() {
    return {
        restrict: "EA",
        require: [ "rating", "ngModel" ],
        scope: {
            readonly: "=?",
            onHover: "&",
            onLeave: "&"
        },
        controller: "RatingController",
        templateUrl: "template/rating/rating.html",
        replace: true,
        link: function(scope, element, attrs, ctrls) {
            var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ratingCtrl.init(ngModelCtrl);
        }
    };
});

angular.module("ui.bootstrap.tabs", []).controller("TabsetController", [ "$scope", function TabsetCtrl($scope) {
    var ctrl = this, tabs = ctrl.tabs = $scope.tabs = [];
    ctrl.select = function(selectedTab) {
        angular.forEach(tabs, function(tab) {
            if (tab.active && tab !== selectedTab) {
                tab.active = false;
                tab.onDeselect();
                selectedTab.selectCalled = false;
            }
        });
        selectedTab.active = true;
        if (!selectedTab.selectCalled) {
            selectedTab.onSelect();
            selectedTab.selectCalled = true;
        }
    };
    ctrl.addTab = function addTab(tab) {
        tabs.push(tab);
        if (tabs.length === 1 && tab.active !== false) {
            tab.active = true;
        } else if (tab.active) {
            ctrl.select(tab);
        } else {
            tab.active = false;
        }
    };
    ctrl.removeTab = function removeTab(tab) {
        var index = tabs.indexOf(tab);
        if (tab.active && tabs.length > 1 && !destroyed) {
            var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
            ctrl.select(tabs[newActiveIndex]);
        }
        tabs.splice(index, 1);
    };
    var destroyed;
    $scope.$on("$destroy", function() {
        destroyed = true;
    });
} ]).directive("tabset", function() {
    return {
        restrict: "EA",
        transclude: true,
        replace: true,
        scope: {
            type: "@"
        },
        controller: "TabsetController",
        templateUrl: "template/tabs/tabset.html",
        link: function(scope, element, attrs) {
            scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
            scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
        }
    };
}).directive("tab", [ "$parse", "$log", function($parse, $log) {
    return {
        require: "^tabset",
        restrict: "EA",
        replace: true,
        templateUrl: "template/tabs/tab.html",
        transclude: true,
        scope: {
            active: "=?",
            heading: "@",
            onSelect: "&select",
            onDeselect: "&deselect"
        },
        controller: function() {},
        link: function(scope, elm, attrs, tabsetCtrl, transclude) {
            scope.$watch("active", function(active) {
                if (active) {
                    tabsetCtrl.select(scope);
                }
            });
            scope.disabled = false;
            if (attrs.disable) {
                scope.$parent.$watch($parse(attrs.disable), function(value) {
                    scope.disabled = !!value;
                });
            }
            if (attrs.disabled) {
                $log.warn('Use of "disabled" attribute has been deprecated, please use "disable"');
                scope.$parent.$watch($parse(attrs.disabled), function(value) {
                    scope.disabled = !!value;
                });
            }
            scope.select = function() {
                if (!scope.disabled) {
                    scope.active = true;
                }
            };
            tabsetCtrl.addTab(scope);
            scope.$on("$destroy", function() {
                tabsetCtrl.removeTab(scope);
            });
            scope.$transcludeFn = transclude;
        }
    };
} ]).directive("tabHeadingTransclude", function() {
    return {
        restrict: "A",
        require: "^tab",
        link: function(scope, elm, attrs, tabCtrl) {
            scope.$watch("headingElement", function updateHeadingElement(heading) {
                if (heading) {
                    elm.html("");
                    elm.append(heading);
                }
            });
        }
    };
}).directive("tabContentTransclude", function() {
    return {
        restrict: "A",
        require: "^tabset",
        link: function(scope, elm, attrs) {
            var tab = scope.$eval(attrs.tabContentTransclude);
            tab.$transcludeFn(tab.$parent, function(contents) {
                angular.forEach(contents, function(node) {
                    if (isTabHeading(node)) {
                        tab.headingElement = node;
                    } else {
                        elm.append(node);
                    }
                });
            });
        }
    };
    function isTabHeading(node) {
        return node.tagName && (node.hasAttribute("tab-heading") || node.hasAttribute("data-tab-heading") || node.hasAttribute("x-tab-heading") || node.tagName.toLowerCase() === "tab-heading" || node.tagName.toLowerCase() === "data-tab-heading" || node.tagName.toLowerCase() === "x-tab-heading");
    }
});

angular.module("ui.bootstrap.timepicker", []).constant("timepickerConfig", {
    hourStep: 1,
    minuteStep: 1,
    showMeridian: true,
    meridians: null,
    readonlyInput: false,
    mousewheel: true,
    arrowkeys: true,
    showSpinners: true
}).controller("TimepickerController", [ "$scope", "$attrs", "$parse", "$log", "$locale", "timepickerConfig", function($scope, $attrs, $parse, $log, $locale, timepickerConfig) {
    var selected = new Date(), ngModelCtrl = {
        $setViewValue: angular.noop
    }, meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;
    this.init = function(ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;
        ngModelCtrl.$formatters.unshift(function(modelValue) {
            return modelValue ? new Date(modelValue) : null;
        });
        var hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1);
        var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
        if (mousewheel) {
            this.setupMousewheelEvents(hoursInputEl, minutesInputEl);
        }
        var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
        if (arrowkeys) {
            this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);
        }
        $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
        this.setupInputEvents(hoursInputEl, minutesInputEl);
    };
    var hourStep = timepickerConfig.hourStep;
    if ($attrs.hourStep) {
        $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
            hourStep = parseInt(value, 10);
        });
    }
    var minuteStep = timepickerConfig.minuteStep;
    if ($attrs.minuteStep) {
        $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
            minuteStep = parseInt(value, 10);
        });
    }
    var min;
    $scope.$parent.$watch($parse($attrs.min), function(value) {
        var dt = new Date(value);
        min = isNaN(dt) ? undefined : dt;
    });
    var max;
    $scope.$parent.$watch($parse($attrs.max), function(value) {
        var dt = new Date(value);
        max = isNaN(dt) ? undefined : dt;
    });
    $scope.noIncrementHours = function() {
        var incrementedSelected = addMinutes(selected, hourStep * 60);
        return incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
    };
    $scope.noDecrementHours = function() {
        var decrementedSelected = addMinutes(selected, -hourStep * 60);
        return decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
    };
    $scope.noIncrementMinutes = function() {
        var incrementedSelected = addMinutes(selected, minuteStep);
        return incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
    };
    $scope.noDecrementMinutes = function() {
        var decrementedSelected = addMinutes(selected, -minuteStep);
        return decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
    };
    $scope.noToggleMeridian = function() {
        if (selected.getHours() < 13) {
            return addMinutes(selected, 12 * 60) > max;
        } else {
            return addMinutes(selected, -12 * 60) < min;
        }
    };
    $scope.showMeridian = timepickerConfig.showMeridian;
    if ($attrs.showMeridian) {
        $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
            $scope.showMeridian = !!value;
            if (ngModelCtrl.$error.time) {
                var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
                if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                    selected.setHours(hours);
                    refresh();
                }
            } else {
                updateTemplate();
            }
        });
    }
    function getHoursFromTemplate() {
        var hours = parseInt($scope.hours, 10);
        var valid = $scope.showMeridian ? hours > 0 && hours < 13 : hours >= 0 && hours < 24;
        if (!valid) {
            return undefined;
        }
        if ($scope.showMeridian) {
            if (hours === 12) {
                hours = 0;
            }
            if ($scope.meridian === meridians[1]) {
                hours = hours + 12;
            }
        }
        return hours;
    }
    function getMinutesFromTemplate() {
        var minutes = parseInt($scope.minutes, 10);
        return minutes >= 0 && minutes < 60 ? minutes : undefined;
    }
    function pad(value) {
        return angular.isDefined(value) && value.toString().length < 2 ? "0" + value : value.toString();
    }
    this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {
        var isScrollingUp = function(e) {
            if (e.originalEvent) {
                e = e.originalEvent;
            }
            var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
            return e.detail || delta > 0;
        };
        hoursInputEl.bind("mousewheel wheel", function(e) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
            e.preventDefault();
        });
        minutesInputEl.bind("mousewheel wheel", function(e) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
            e.preventDefault();
        });
    };
    this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {
        hoursInputEl.bind("keydown", function(e) {
            if (e.which === 38) {
                e.preventDefault();
                $scope.incrementHours();
                $scope.$apply();
            } else if (e.which === 40) {
                e.preventDefault();
                $scope.decrementHours();
                $scope.$apply();
            }
        });
        minutesInputEl.bind("keydown", function(e) {
            if (e.which === 38) {
                e.preventDefault();
                $scope.incrementMinutes();
                $scope.$apply();
            } else if (e.which === 40) {
                e.preventDefault();
                $scope.decrementMinutes();
                $scope.$apply();
            }
        });
    };
    this.setupInputEvents = function(hoursInputEl, minutesInputEl) {
        if ($scope.readonlyInput) {
            $scope.updateHours = angular.noop;
            $scope.updateMinutes = angular.noop;
            return;
        }
        var invalidate = function(invalidHours, invalidMinutes) {
            ngModelCtrl.$setViewValue(null);
            ngModelCtrl.$setValidity("time", false);
            if (angular.isDefined(invalidHours)) {
                $scope.invalidHours = invalidHours;
            }
            if (angular.isDefined(invalidMinutes)) {
                $scope.invalidMinutes = invalidMinutes;
            }
        };
        $scope.updateHours = function() {
            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
            if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                selected.setHours(hours);
                if (selected < min || selected > max) {
                    invalidate(true);
                } else {
                    refresh("h");
                }
            } else {
                invalidate(true);
            }
        };
        hoursInputEl.bind("blur", function(e) {
            if (!$scope.invalidHours && $scope.hours < 10) {
                $scope.$apply(function() {
                    $scope.hours = pad($scope.hours);
                });
            }
        });
        $scope.updateMinutes = function() {
            var minutes = getMinutesFromTemplate(), hours = getHoursFromTemplate();
            if (angular.isDefined(minutes) && angular.isDefined(hours)) {
                selected.setMinutes(minutes);
                if (selected < min || selected > max) {
                    invalidate(undefined, true);
                } else {
                    refresh("m");
                }
            } else {
                invalidate(undefined, true);
            }
        };
        minutesInputEl.bind("blur", function(e) {
            if (!$scope.invalidMinutes && $scope.minutes < 10) {
                $scope.$apply(function() {
                    $scope.minutes = pad($scope.minutes);
                });
            }
        });
    };
    this.render = function() {
        var date = ngModelCtrl.$viewValue;
        if (isNaN(date)) {
            ngModelCtrl.$setValidity("time", false);
            $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
        } else {
            if (date) {
                selected = date;
            }
            if (selected < min || selected > max) {
                ngModelCtrl.$setValidity("time", false);
                $scope.invalidHours = true;
                $scope.invalidMinutes = true;
            } else {
                makeValid();
            }
            updateTemplate();
        }
    };
    function refresh(keyboardChange) {
        makeValid();
        ngModelCtrl.$setViewValue(new Date(selected));
        updateTemplate(keyboardChange);
    }
    function makeValid() {
        ngModelCtrl.$setValidity("time", true);
        $scope.invalidHours = false;
        $scope.invalidMinutes = false;
    }
    function updateTemplate(keyboardChange) {
        var hours = selected.getHours(), minutes = selected.getMinutes();
        if ($scope.showMeridian) {
            hours = hours === 0 || hours === 12 ? 12 : hours % 12;
        }
        $scope.hours = keyboardChange === "h" ? hours : pad(hours);
        if (keyboardChange !== "m") {
            $scope.minutes = pad(minutes);
        }
        $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
    }
    function addMinutes(date, minutes) {
        var dt = new Date(date.getTime() + minutes * 6e4);
        var newDate = new Date(date);
        newDate.setHours(dt.getHours(), dt.getMinutes());
        return newDate;
    }
    function addMinutesToSelected(minutes) {
        selected = addMinutes(selected, minutes);
        refresh();
    }
    $scope.showSpinners = angular.isDefined($attrs.showSpinners) ? $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;
    $scope.incrementHours = function() {
        if (!$scope.noIncrementHours()) {
            addMinutesToSelected(hourStep * 60);
        }
    };
    $scope.decrementHours = function() {
        if (!$scope.noDecrementHours()) {
            addMinutesToSelected(-hourStep * 60);
        }
    };
    $scope.incrementMinutes = function() {
        if (!$scope.noIncrementMinutes()) {
            addMinutesToSelected(minuteStep);
        }
    };
    $scope.decrementMinutes = function() {
        if (!$scope.noDecrementMinutes()) {
            addMinutesToSelected(-minuteStep);
        }
    };
    $scope.toggleMeridian = function() {
        if (!$scope.noToggleMeridian()) {
            addMinutesToSelected(12 * 60 * (selected.getHours() < 12 ? 1 : -1));
        }
    };
} ]).directive("timepicker", function() {
    return {
        restrict: "EA",
        require: [ "timepicker", "?^ngModel" ],
        controller: "TimepickerController",
        controllerAs: "timepicker",
        replace: true,
        scope: {},
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/timepicker/timepicker.html";
        },
        link: function(scope, element, attrs, ctrls) {
            var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            if (ngModelCtrl) {
                timepickerCtrl.init(ngModelCtrl, element.find("input"));
            }
        }
    };
});

angular.module("ui.bootstrap.transition", []).value("$transitionSuppressDeprecated", false).factory("$transition", [ "$q", "$timeout", "$rootScope", "$log", "$transitionSuppressDeprecated", function($q, $timeout, $rootScope, $log, $transitionSuppressDeprecated) {
    if (!$transitionSuppressDeprecated) {
        $log.warn("$transition is now deprecated. Use $animate from ngAnimate instead.");
    }
    var $transition = function(element, trigger, options) {
        options = options || {};
        var deferred = $q.defer();
        var endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"];
        var transitionEndHandler = function(event) {
            $rootScope.$apply(function() {
                element.unbind(endEventName, transitionEndHandler);
                deferred.resolve(element);
            });
        };
        if (endEventName) {
            element.bind(endEventName, transitionEndHandler);
        }
        $timeout(function() {
            if (angular.isString(trigger)) {
                element.addClass(trigger);
            } else if (angular.isFunction(trigger)) {
                trigger(element);
            } else if (angular.isObject(trigger)) {
                element.css(trigger);
            }
            if (!endEventName) {
                deferred.resolve(element);
            }
        });
        deferred.promise.cancel = function() {
            if (endEventName) {
                element.unbind(endEventName, transitionEndHandler);
            }
            deferred.reject("Transition cancelled");
        };
        return deferred.promise;
    };
    var transElement = document.createElement("trans");
    var transitionEndEventNames = {
        WebkitTransition: "webkitTransitionEnd",
        MozTransition: "transitionend",
        OTransition: "oTransitionEnd",
        transition: "transitionend"
    };
    var animationEndEventNames = {
        WebkitTransition: "webkitAnimationEnd",
        MozTransition: "animationend",
        OTransition: "oAnimationEnd",
        transition: "animationend"
    };
    function findEndEventName(endEventNames) {
        for (var name in endEventNames) {
            if (transElement.style[name] !== undefined) {
                return endEventNames[name];
            }
        }
    }
    $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
    $transition.animationEndEventName = findEndEventName(animationEndEventNames);
    return $transition;
} ]);

angular.module("ui.bootstrap.typeahead", [ "ui.bootstrap.position" ]).factory("typeaheadParser", [ "$parse", function($parse) {
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
    return {
        parse: function(input) {
            var match = input.match(TYPEAHEAD_REGEXP);
            if (!match) {
                throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' + ' but got "' + input + '".');
            }
            return {
                itemName: match[3],
                source: $parse(match[4]),
                viewMapper: $parse(match[2] || match[1]),
                modelMapper: $parse(match[1])
            };
        }
    };
} ]).directive("typeahead", [ "$compile", "$parse", "$q", "$timeout", "$document", "$window", "$rootScope", "$position", "typeaheadParser", function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {
    var HOT_KEYS = [ 9, 13, 27, 38, 40 ];
    var eventDebounceTime = 200;
    return {
        require: [ "ngModel", "^?ngModelOptions" ],
        link: function(originalScope, element, attrs, ctrls) {
            var modelCtrl = ctrls[0];
            var ngModelOptions = ctrls[1];
            var minLength = originalScope.$eval(attrs.typeaheadMinLength);
            if (!minLength && minLength !== 0) {
                minLength = 1;
            }
            var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
            var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
            var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
            var onSelectCallback = $parse(attrs.typeaheadOnSelect);
            var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
            var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;
            var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
            var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
            var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
            var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;
            var parsedModel = $parse(attrs.ngModel);
            var invokeModelSetter = $parse(attrs.ngModel + "($$$p)");
            var $setModelValue = function(scope, newValue) {
                if (angular.isFunction(parsedModel(originalScope)) && ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
                    return invokeModelSetter(scope, {
                        $$$p: newValue
                    });
                } else {
                    return parsedModel.assign(scope, newValue);
                }
            };
            var parserResult = typeaheadParser.parse(attrs.typeahead);
            var hasFocus;
            var selected;
            var scope = originalScope.$new();
            var offDestroy = originalScope.$on("$destroy", function() {
                scope.$destroy();
            });
            scope.$on("$destroy", offDestroy);
            var popupId = "typeahead-" + scope.$id + "-" + Math.floor(Math.random() * 1e4);
            element.attr({
                "aria-autocomplete": "list",
                "aria-expanded": false,
                "aria-owns": popupId
            });
            var popUpEl = angular.element("<div typeahead-popup></div>");
            popUpEl.attr({
                id: popupId,
                matches: "matches",
                active: "activeIdx",
                select: "select(activeIdx)",
                "move-in-progress": "moveInProgress",
                query: "query",
                position: "position"
            });
            if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
                popUpEl.attr("template-url", attrs.typeaheadTemplateUrl);
            }
            if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
                popUpEl.attr("popup-template-url", attrs.typeaheadPopupTemplateUrl);
            }
            var resetMatches = function() {
                scope.matches = [];
                scope.activeIdx = -1;
                element.attr("aria-expanded", false);
            };
            var getMatchId = function(index) {
                return popupId + "-option-" + index;
            };
            scope.$watch("activeIdx", function(index) {
                if (index < 0) {
                    element.removeAttr("aria-activedescendant");
                } else {
                    element.attr("aria-activedescendant", getMatchId(index));
                }
            });
            var inputIsExactMatch = function(inputValue, index) {
                if (scope.matches.length > index && inputValue) {
                    return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
                }
                return false;
            };
            var getMatchesAsync = function(inputValue) {
                var locals = {
                    $viewValue: inputValue
                };
                isLoadingSetter(originalScope, true);
                isNoResultsSetter(originalScope, false);
                $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
                    var onCurrentRequest = inputValue === modelCtrl.$viewValue;
                    if (onCurrentRequest && hasFocus) {
                        if (matches && matches.length > 0) {
                            scope.activeIdx = focusFirst ? 0 : -1;
                            isNoResultsSetter(originalScope, false);
                            scope.matches.length = 0;
                            for (var i = 0; i < matches.length; i++) {
                                locals[parserResult.itemName] = matches[i];
                                scope.matches.push({
                                    id: getMatchId(i),
                                    label: parserResult.viewMapper(scope, locals),
                                    model: matches[i]
                                });
                            }
                            scope.query = inputValue;
                            recalculatePosition();
                            element.attr("aria-expanded", true);
                            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
                                scope.select(0);
                            }
                        } else {
                            resetMatches();
                            isNoResultsSetter(originalScope, true);
                        }
                    }
                    if (onCurrentRequest) {
                        isLoadingSetter(originalScope, false);
                    }
                }, function() {
                    resetMatches();
                    isLoadingSetter(originalScope, false);
                    isNoResultsSetter(originalScope, true);
                });
            };
            if (appendToBody) {
                angular.element($window).bind("resize", fireRecalculating);
                $document.find("body").bind("scroll", fireRecalculating);
            }
            var timeoutEventPromise;
            scope.moveInProgress = false;
            function fireRecalculating() {
                if (!scope.moveInProgress) {
                    scope.moveInProgress = true;
                    scope.$digest();
                }
                if (timeoutEventPromise) {
                    $timeout.cancel(timeoutEventPromise);
                }
                timeoutEventPromise = $timeout(function() {
                    if (scope.matches.length) {
                        recalculatePosition();
                    }
                    scope.moveInProgress = false;
                    scope.$digest();
                }, eventDebounceTime);
            }
            function recalculatePosition() {
                scope.position = appendToBody ? $position.offset(element) : $position.position(element);
                scope.position.top += element.prop("offsetHeight");
            }
            resetMatches();
            scope.query = undefined;
            var timeoutPromise;
            var scheduleSearchWithTimeout = function(inputValue) {
                timeoutPromise = $timeout(function() {
                    getMatchesAsync(inputValue);
                }, waitTime);
            };
            var cancelPreviousTimeout = function() {
                if (timeoutPromise) {
                    $timeout.cancel(timeoutPromise);
                }
            };
            modelCtrl.$parsers.unshift(function(inputValue) {
                hasFocus = true;
                if (minLength === 0 || inputValue && inputValue.length >= minLength) {
                    if (waitTime > 0) {
                        cancelPreviousTimeout();
                        scheduleSearchWithTimeout(inputValue);
                    } else {
                        getMatchesAsync(inputValue);
                    }
                } else {
                    isLoadingSetter(originalScope, false);
                    cancelPreviousTimeout();
                    resetMatches();
                }
                if (isEditable) {
                    return inputValue;
                } else {
                    if (!inputValue) {
                        modelCtrl.$setValidity("editable", true);
                        return null;
                    } else {
                        modelCtrl.$setValidity("editable", false);
                        return undefined;
                    }
                }
            });
            modelCtrl.$formatters.push(function(modelValue) {
                var candidateViewValue, emptyViewValue;
                var locals = {};
                if (!isEditable) {
                    modelCtrl.$setValidity("editable", true);
                }
                if (inputFormatter) {
                    locals.$model = modelValue;
                    return inputFormatter(originalScope, locals);
                } else {
                    locals[parserResult.itemName] = modelValue;
                    candidateViewValue = parserResult.viewMapper(originalScope, locals);
                    locals[parserResult.itemName] = undefined;
                    emptyViewValue = parserResult.viewMapper(originalScope, locals);
                    return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
                }
            });
            scope.select = function(activeIdx) {
                var locals = {};
                var model, item;
                selected = true;
                locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
                model = parserResult.modelMapper(originalScope, locals);
                $setModelValue(originalScope, model);
                modelCtrl.$setValidity("editable", true);
                modelCtrl.$setValidity("parse", true);
                onSelectCallback(originalScope, {
                    $item: item,
                    $model: model,
                    $label: parserResult.viewMapper(originalScope, locals)
                });
                resetMatches();
                if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
                    $timeout(function() {
                        element[0].focus();
                    }, 0, false);
                }
            };
            element.bind("keydown", function(evt) {
                if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
                    return;
                }
                if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {
                    resetMatches();
                    scope.$digest();
                    return;
                }
                evt.preventDefault();
                if (evt.which === 40) {
                    scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
                    scope.$digest();
                } else if (evt.which === 38) {
                    scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
                    scope.$digest();
                } else if (evt.which === 13 || evt.which === 9) {
                    scope.$apply(function() {
                        scope.select(scope.activeIdx);
                    });
                } else if (evt.which === 27) {
                    evt.stopPropagation();
                    resetMatches();
                    scope.$digest();
                }
            });
            element.bind("blur", function() {
                if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
                    selected = true;
                    scope.$apply(function() {
                        scope.select(scope.activeIdx);
                    });
                }
                hasFocus = false;
                selected = false;
            });
            var dismissClickHandler = function(evt) {
                if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
                    resetMatches();
                    if (!$rootScope.$$phase) {
                        scope.$digest();
                    }
                }
            };
            $document.bind("click", dismissClickHandler);
            originalScope.$on("$destroy", function() {
                $document.unbind("click", dismissClickHandler);
                if (appendToBody) {
                    $popup.remove();
                }
                popUpEl.remove();
            });
            var $popup = $compile(popUpEl)(scope);
            if (appendToBody) {
                $document.find("body").append($popup);
            } else {
                element.after($popup);
            }
        }
    };
} ]).directive("typeaheadPopup", function() {
    return {
        restrict: "EA",
        scope: {
            matches: "=",
            query: "=",
            active: "=",
            position: "&",
            moveInProgress: "=",
            select: "&"
        },
        replace: true,
        templateUrl: function(element, attrs) {
            return attrs.popupTemplateUrl || "template/typeahead/typeahead-popup.html";
        },
        link: function(scope, element, attrs) {
            scope.templateUrl = attrs.templateUrl;
            scope.isOpen = function() {
                return scope.matches.length > 0;
            };
            scope.isActive = function(matchIdx) {
                return scope.active == matchIdx;
            };
            scope.selectActive = function(matchIdx) {
                scope.active = matchIdx;
            };
            scope.selectMatch = function(activeIdx) {
                scope.select({
                    activeIdx: activeIdx
                });
            };
        }
    };
}).directive("typeaheadMatch", [ "$templateRequest", "$compile", "$parse", function($templateRequest, $compile, $parse) {
    return {
        restrict: "EA",
        scope: {
            index: "=",
            match: "=",
            query: "="
        },
        link: function(scope, element, attrs) {
            var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || "template/typeahead/typeahead-match.html";
            $templateRequest(tplUrl).then(function(tplContent) {
                $compile(tplContent.trim())(scope, function(clonedElement) {
                    element.replaceWith(clonedElement);
                });
            });
        }
    };
} ]).filter("typeaheadHighlight", [ "$sce", "$injector", "$log", function($sce, $injector, $log) {
    var isSanitizePresent;
    isSanitizePresent = $injector.has("$sanitize");
    function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    }
    function containsHtml(matchItem) {
        return /<.*>/g.test(matchItem);
    }
    return function(matchItem, query) {
        if (!isSanitizePresent && containsHtml(matchItem)) {
            $log.warn("Unsafe use of typeahead please use ngSanitize");
        }
        matchItem = query ? ("" + matchItem).replace(new RegExp(escapeRegexp(query), "gi"), "<strong>$&</strong>") : matchItem;
        if (!isSanitizePresent) {
            matchItem = $sce.trustAsHtml(matchItem);
        }
        return matchItem;
    };
} ]);

angular.module("template/accordion/accordion-group.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/accordion/accordion-group.html", "<div class=\"panel {{panelClass || 'panel-default'}}\">\n" + '  <div class="panel-heading" ng-keypress="toggleOpen($event)">\n' + '    <h4 class="panel-title">\n' + '      <a href tabindex="0" class="accordion-toggle" ng-click="toggleOpen()" accordion-transclude="heading"><span ng-class="{\'text-muted\': isDisabled}">{{heading}}</span></a>\n' + "    </h4>\n" + "  </div>\n" + '  <div class="panel-collapse collapse" collapse="!isOpen">\n' + '\t  <div class="panel-body" ng-transclude></div>\n' + "  </div>\n" + "</div>\n" + "");
} ]);

angular.module("template/accordion/accordion.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/accordion/accordion.html", '<div class="panel-group" ng-transclude></div>');
} ]);

angular.module("template/alert/alert.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/alert/alert.html", "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\" role=\"alert\">\n" + '    <button ng-show="closeable" type="button" class="close" ng-click="close($event)">\n' + '        <span aria-hidden="true">&times;</span>\n' + '        <span class="sr-only">Close</span>\n' + "    </button>\n" + "    <div ng-transclude></div>\n" + "</div>\n" + "");
} ]);

angular.module("template/carousel/carousel.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/carousel/carousel.html", '<div ng-mouseenter="pause()" ng-mouseleave="play()" class="carousel" ng-swipe-right="prev()" ng-swipe-left="next()">\n' + '    <ol class="carousel-indicators" ng-show="slides.length > 1">\n' + '        <li ng-repeat="slide in slides | orderBy:indexOfSlide track by $index" ng-class="{active: isActive(slide)}" ng-click="select(slide)"></li>\n' + "    </ol>\n" + '    <div class="carousel-inner" ng-transclude></div>\n' + '    <a class="left carousel-control" ng-click="prev()" ng-show="slides.length > 1"><span class="glyphicon glyphicon-chevron-left"></span></a>\n' + '    <a class="right carousel-control" ng-click="next()" ng-show="slides.length > 1"><span class="glyphicon glyphicon-chevron-right"></span></a>\n' + "</div>\n" + "");
} ]);

angular.module("template/carousel/slide.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/carousel/slide.html", '<div ng-class="{\n' + "    'active': active\n" + '  }" class="item text-center" ng-transclude></div>\n' + "");
} ]);

angular.module("template/datepicker/datepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/datepicker.html", '<div ng-switch="datepickerMode" role="application" ng-keydown="keydown($event)">\n' + '  <daypicker ng-switch-when="day" tabindex="0"></daypicker>\n' + '  <monthpicker ng-switch-when="month" tabindex="0"></monthpicker>\n' + '  <yearpicker ng-switch-when="year" tabindex="0"></yearpicker>\n' + "</div>");
} ]);

angular.module("template/datepicker/day.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/day.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n' + "  <thead>\n" + "    <tr>\n" + '      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n' + '      <th colspan="{{::5 + showWeeks}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n' + '      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n' + "    </tr>\n" + "    <tr>\n" + '      <th ng-if="showWeeks" class="text-center"></th>\n' + '      <th ng-repeat="label in ::labels track by $index" class="text-center"><small aria-label="{{::label.full}}">{{::label.abbr}}</small></th>\n' + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + '    <tr ng-repeat="row in rows track by $index">\n' + '      <td ng-if="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>\n' + '      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{::dt.uid}}" ng-class="::dt.customClass">\n' + '        <button type="button" style="min-width:100%;" class="btn btn-default btn-sm" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="::{\'text-muted\': dt.secondary, \'text-info\': dt.current}">{{::dt.label}}</span></button>\n' + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
} ]);

angular.module("template/datepicker/month.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/month.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n' + "  <thead>\n" + "    <tr>\n" + '      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n' + '      <th><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n' + '      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n' + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + '    <tr ng-repeat="row in rows track by $index">\n' + '      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{::dt.uid}}" ng-class="::dt.customClass">\n' + '        <button type="button" style="min-width:100%;" class="btn btn-default" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n' + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
} ]);

angular.module("template/datepicker/popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/popup.html", '<ul class="dropdown-menu" ng-if="isOpen" style="display: block" ng-style="{top: position.top+\'px\', left: position.left+\'px\'}" ng-keydown="keydown($event)" ng-click="$event.stopPropagation()">\n' + "\t<li ng-transclude></li>\n" + '\t<li ng-if="showButtonBar" style="padding:10px 9px 2px">\n' + '\t\t<span class="btn-group pull-left">\n' + '\t\t\t<button type="button" class="btn btn-sm btn-info" ng-click="select(\'today\')" ng-disabled="isDisabled(\'today\')">{{ getText(\'current\') }}</button>\n' + '\t\t\t<button type="button" class="btn btn-sm btn-danger" ng-click="select(null)">{{ getText(\'clear\') }}</button>\n' + "\t\t</span>\n" + '\t\t<button type="button" class="btn btn-sm btn-success pull-right" ng-click="close()">{{ getText(\'close\') }}</button>\n' + "\t</li>\n" + "</ul>\n" + "");
} ]);

angular.module("template/datepicker/year.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/year.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n' + "  <thead>\n" + "    <tr>\n" + '      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n' + '      <th colspan="3"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n' + '      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n' + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + '    <tr ng-repeat="row in rows track by $index">\n' + '      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{::dt.uid}}">\n' + '        <button type="button" style="min-width:100%;" class="btn btn-default" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n' + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
} ]);

angular.module("template/modal/backdrop.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/modal/backdrop.html", '<div class="modal-backdrop"\n' + '     modal-animation-class="fade"\n' + '     modal-in-class="in"\n' + "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" + "></div>\n" + "");
} ]);

angular.module("template/modal/window.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/modal/window.html", '<div modal-render="{{$isRendered}}" tabindex="-1" role="dialog" class="modal"\n' + '    modal-animation-class="fade"\n' + '    modal-in-class="in"\n' + "\tng-style=\"{'z-index': 1050 + index*10, display: 'block'}\" ng-click=\"close($event)\">\n" + '    <div class="modal-dialog" ng-class="size ? \'modal-\' + size : \'\'"><div class="modal-content" modal-transclude></div></div>\n' + "</div>\n" + "");
} ]);

angular.module("template/pagination/pager.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/pagination/pager.html", '<ul class="pager">\n' + '  <li ng-class="{disabled: noPrevious()||ngDisabled, previous: align}"><a href ng-click="selectPage(page - 1, $event)">{{::getText(\'previous\')}}</a></li>\n' + '  <li ng-class="{disabled: noNext()||ngDisabled, next: align}"><a href ng-click="selectPage(page + 1, $event)">{{::getText(\'next\')}}</a></li>\n' + "</ul>\n" + "");
} ]);

angular.module("template/pagination/pagination.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/pagination/pagination.html", '<ul class="pagination">\n' + '  <li ng-if="::boundaryLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-first"><a href ng-click="selectPage(1, $event)">{{::getText(\'first\')}}</a></li>\n' + '  <li ng-if="::directionLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-prev"><a href ng-click="selectPage(page - 1, $event)">{{::getText(\'previous\')}}</a></li>\n' + '  <li ng-repeat="page in pages track by $index" ng-class="{active: page.active,disabled: ngDisabled&&!page.active}" class="pagination-page"><a href ng-click="selectPage(page.number, $event)">{{page.text}}</a></li>\n' + '  <li ng-if="::directionLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-next"><a href ng-click="selectPage(page + 1, $event)">{{::getText(\'next\')}}</a></li>\n' + '  <li ng-if="::boundaryLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-last"><a href ng-click="selectPage(totalPages, $event)">{{::getText(\'last\')}}</a></li>\n' + "</ul>\n" + "");
} ]);

angular.module("template/tooltip/tooltip-html-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-html-popup.html", '<div class="tooltip"\n' + '  tooltip-animation-class="fade"\n' + "  tooltip-classes\n" + '  ng-class="{ in: isOpen() }">\n' + '  <div class="tooltip-arrow"></div>\n' + '  <div class="tooltip-inner" ng-bind-html="contentExp()"></div>\n' + "</div>\n" + "");
} ]);

angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html", '<div class="tooltip"\n' + '  tooltip-animation-class="fade"\n' + "  tooltip-classes\n" + '  ng-class="{ in: isOpen() }">\n' + '  <div class="tooltip-arrow"></div>\n' + '  <div class="tooltip-inner" bind-html-unsafe="content"></div>\n' + "</div>\n" + "");
} ]);

angular.module("template/tooltip/tooltip-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-popup.html", '<div class="tooltip"\n' + '  tooltip-animation-class="fade"\n' + "  tooltip-classes\n" + '  ng-class="{ in: isOpen() }">\n' + '  <div class="tooltip-arrow"></div>\n' + '  <div class="tooltip-inner" ng-bind="content"></div>\n' + "</div>\n" + "");
} ]);

angular.module("template/tooltip/tooltip-template-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-template-popup.html", '<div class="tooltip"\n' + '  tooltip-animation-class="fade"\n' + "  tooltip-classes\n" + '  ng-class="{ in: isOpen() }">\n' + '  <div class="tooltip-arrow"></div>\n' + '  <div class="tooltip-inner"\n' + '    tooltip-template-transclude="contentExp()"\n' + '    tooltip-template-transclude-scope="originScope()"></div>\n' + "</div>\n" + "");
} ]);

angular.module("template/popover/popover-html.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/popover/popover-html.html", '<div class="popover"\n' + '  tooltip-animation-class="fade"\n' + "  tooltip-classes\n" + '  ng-class="{ in: isOpen() }">\n' + '  <div class="arrow"></div>\n' + "\n" + '  <div class="popover-inner">\n' + '      <h3 class="popover-title" ng-bind="title" ng-if="title"></h3>\n' + '      <div class="popover-content" ng-bind-html="contentExp()"></div>\n' + "  </div>\n" + "</div>\n" + "");
} ]);

angular.module("template/popover/popover-template.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/popover/popover-template.html", '<div class="popover"\n' + '  tooltip-animation-class="fade"\n' + "  tooltip-classes\n" + '  ng-class="{ in: isOpen() }">\n' + '  <div class="arrow"></div>\n' + "\n" + '  <div class="popover-inner">\n' + '      <h3 class="popover-title" ng-bind="title" ng-if="title"></h3>\n' + '      <div class="popover-content"\n' + '        tooltip-template-transclude="contentExp()"\n' + '        tooltip-template-transclude-scope="originScope()"></div>\n' + "  </div>\n" + "</div>\n" + "");
} ]);

angular.module("template/popover/popover.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/popover/popover.html", '<div class="popover"\n' + '  tooltip-animation-class="fade"\n' + "  tooltip-classes\n" + '  ng-class="{ in: isOpen() }">\n' + '  <div class="arrow"></div>\n' + "\n" + '  <div class="popover-inner">\n' + '      <h3 class="popover-title" ng-bind="title" ng-if="title"></h3>\n' + '      <div class="popover-content" ng-bind="content"></div>\n' + "  </div>\n" + "</div>\n" + "");
} ]);

angular.module("template/progressbar/bar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/bar.html", '<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" style="min-width: 0;" ng-transclude></div>\n' + "");
} ]);

angular.module("template/progressbar/progress.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/progress.html", '<div class="progress" ng-transclude></div>');
} ]);

angular.module("template/progressbar/progressbar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/progressbar.html", '<div class="progress">\n' + '  <div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" style="min-width: 0;" ng-transclude></div>\n' + "</div>\n" + "");
} ]);

angular.module("template/rating/rating.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/rating/rating.html", '<span ng-mouseleave="reset()" ng-keydown="onKeydown($event)" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="{{range.length}}" aria-valuenow="{{value}}">\n' + "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" + '    <i ng-repeat-end ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < value && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')" ng-attr-title="{{r.title}}" ></i>\n' + "</span>\n" + "");
} ]);

angular.module("template/tabs/tab.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tab.html", '<li ng-class="{active: active, disabled: disabled}">\n' + '  <a href ng-click="select()" tab-heading-transclude>{{heading}}</a>\n' + "</li>\n" + "");
} ]);

angular.module("template/tabs/tabset.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tabset.html", "<div>\n" + "  <ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" + '  <div class="tab-content">\n' + '    <div class="tab-pane" \n' + '         ng-repeat="tab in tabs" \n' + '         ng-class="{active: tab.active}"\n' + '         tab-content-transclude="tab">\n' + "    </div>\n" + "  </div>\n" + "</div>\n" + "");
} ]);

angular.module("template/timepicker/timepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/timepicker/timepicker.html", "<table>\n" + "  <tbody>\n" + '    <tr class="text-center" ng-show="::showSpinners">\n' + '      <td><a ng-click="incrementHours()" ng-class="{disabled: noIncrementHours()}" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n' + "      <td>&nbsp;</td>\n" + '      <td><a ng-click="incrementMinutes()" ng-class="{disabled: noIncrementMinutes()}" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n' + '      <td ng-show="showMeridian"></td>\n' + "    </tr>\n" + "    <tr>\n" + '      <td class="form-group" ng-class="{\'has-error\': invalidHours}">\n' + '        <input style="width:50px;" type="text" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2">\n' + "      </td>\n" + "      <td>:</td>\n" + '      <td class="form-group" ng-class="{\'has-error\': invalidMinutes}">\n' + '        <input style="width:50px;" type="text" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2">\n' + "      </td>\n" + '      <td ng-show="showMeridian"><button type="button" ng-class="{disabled: noToggleMeridian()}" class="btn btn-default text-center" ng-click="toggleMeridian()">{{meridian}}</button></td>\n' + "    </tr>\n" + '    <tr class="text-center" ng-show="::showSpinners">\n' + '      <td><a ng-click="decrementHours()" ng-class="{disabled: noDecrementHours()}" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n' + "      <td>&nbsp;</td>\n" + '      <td><a ng-click="decrementMinutes()" ng-class="{disabled: noDecrementMinutes()}" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n' + '      <td ng-show="showMeridian"></td>\n' + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
} ]);

angular.module("template/typeahead/typeahead-match.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/typeahead/typeahead-match.html", '<a href tabindex="-1" ng-bind-html="match.label | typeaheadHighlight:query"></a>\n' + "");
} ]);

angular.module("template/typeahead/typeahead-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/typeahead/typeahead-popup.html", '<ul class="dropdown-menu" ng-show="isOpen() && !moveInProgress" ng-style="{top: position().top+\'px\', left: position().left+\'px\'}" style="display: block;" role="listbox" aria-hidden="{{!isOpen()}}">\n' + '    <li ng-repeat="match in matches track by $index" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index)" role="option" id="{{::match.id}}">\n' + '        <div typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n' + "    </li>\n" + "</ul>\n" + "");
} ]);

!angular.$$csp() && angular.element(document).find("head").prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');

if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
    module.exports = "ui.router";
}

(function(window, angular, undefined) {
    "use strict";
    var isDefined = angular.isDefined, isFunction = angular.isFunction, isString = angular.isString, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy, toJson = angular.toJson;
    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {
            prototype: parent
        }))(), extra);
    }
    function merge(dst) {
        forEach(arguments, function(obj) {
            if (obj !== dst) {
                forEach(obj, function(value, key) {
                    if (!dst.hasOwnProperty(key)) dst[key] = value;
                });
            }
        });
        return dst;
    }
    function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
            if (first.path[n] !== second.path[n]) break;
            path.push(first.path[n]);
        }
        return path;
    }
    function objectKeys(object) {
        if (Object.keys) {
            return Object.keys(object);
        }
        var result = [];
        forEach(object, function(val, key) {
            result.push(key);
        });
        return result;
    }
    function indexOf(array, value) {
        if (Array.prototype.indexOf) {
            return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0, from = Number(arguments[2]) || 0;
        from = from < 0 ? Math.ceil(from) : Math.floor(from);
        if (from < 0) from += len;
        for (;from < len; from++) {
            if (from in array && array[from] === value) return from;
        }
        return -1;
    }
    function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];
        for (var i in parents) {
            if (!parents[i] || !parents[i].params) continue;
            parentParams = objectKeys(parents[i].params);
            if (!parentParams.length) continue;
            for (var j in parentParams) {
                if (indexOf(inheritList, parentParams[j]) >= 0) continue;
                inheritList.push(parentParams[j]);
                inherited[parentParams[j]] = currentParams[parentParams[j]];
            }
        }
        return extend({}, inherited, newParams);
    }
    function equalForKeys(a, b, keys) {
        if (!keys) {
            keys = [];
            for (var n in a) keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            if (a[k] != b[k]) return false;
        }
        return true;
    }
    function filterByKeys(keys, values) {
        var filtered = {};
        forEach(keys, function(name) {
            filtered[name] = values[name];
        });
        return filtered;
    }
    function indexBy(array, propName) {
        var result = {};
        forEach(array, function(item) {
            result[item[propName]] = item;
        });
        return result;
    }
    function pick(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        forEach(keys, function(key) {
            if (key in obj) copy[key] = obj[key];
        });
        return copy;
    }
    function omit(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) {
            if (indexOf(keys, key) == -1) copy[key] = obj[key];
        }
        return copy;
    }
    function pluck(collection, key) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
            result[i] = isFunction(key) ? key(val) : val[key];
        });
        return result;
    }
    function filter(collection, callback) {
        var array = isArray(collection);
        var result = array ? [] : {};
        forEach(collection, function(val, i) {
            if (callback(val, i)) {
                result[array ? result.length : i] = val;
            }
        });
        return result;
    }
    function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
            result[i] = callback(val, i);
        });
        return result;
    }
    angular.module("ui.router.util", [ "ng" ]);
    angular.module("ui.router.router", [ "ui.router.util" ]);
    angular.module("ui.router.state", [ "ui.router.router", "ui.router.util" ]);
    angular.module("ui.router", [ "ui.router.state" ]);
    angular.module("ui.router.compat", [ "ui.router" ]);
    $Resolve.$inject = [ "$q", "$injector" ];
    function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1, VISIT_DONE = 2, NOTHING = {}, NO_DEPENDENCIES = [], NO_LOCALS = NOTHING, NO_PARENT = extend($q.when(NOTHING), {
            $$promises: NOTHING,
            $$values: NOTHING
        });
        this.study = function(invocables) {
            if (!isObject(invocables)) throw new Error("'invocables' must be an object");
            var invocableKeys = objectKeys(invocables || {});
            var plan = [], cycle = [], visited = {};
            function visit(value, key) {
                if (visited[key] === VISIT_DONE) return;
                cycle.push(key);
                if (visited[key] === VISIT_IN_PROGRESS) {
                    cycle.splice(0, indexOf(cycle, key));
                    throw new Error("Cyclic dependency: " + cycle.join(" -> "));
                }
                visited[key] = VISIT_IN_PROGRESS;
                if (isString(value)) {
                    plan.push(key, [ function() {
                        return $injector.get(value);
                    } ], NO_DEPENDENCIES);
                } else {
                    var params = $injector.annotate(value);
                    forEach(params, function(param) {
                        if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
                    });
                    plan.push(key, value, params);
                }
                cycle.pop();
                visited[key] = VISIT_DONE;
            }
            forEach(invocables, visit);
            invocables = cycle = visited = null;
            function isResolve(value) {
                return isObject(value) && value.then && value.$$promises;
            }
            return function(locals, parent, self) {
                if (isResolve(locals) && self === undefined) {
                    self = parent;
                    parent = locals;
                    locals = null;
                }
                if (!locals) locals = NO_LOCALS; else if (!isObject(locals)) {
                    throw new Error("'locals' must be an object");
                }
                if (!parent) parent = NO_PARENT; else if (!isResolve(parent)) {
                    throw new Error("'parent' must be a promise returned by $resolve.resolve()");
                }
                var resolution = $q.defer(), result = resolution.promise, promises = result.$$promises = {}, values = extend({}, locals), wait = 1 + plan.length / 3, merged = false;
                function done() {
                    if (!--wait) {
                        if (!merged) merge(values, parent.$$values);
                        result.$$values = values;
                        result.$$promises = result.$$promises || true;
                        delete result.$$inheritedValues;
                        resolution.resolve(values);
                    }
                }
                function fail(reason) {
                    result.$$failure = reason;
                    resolution.reject(reason);
                }
                if (isDefined(parent.$$failure)) {
                    fail(parent.$$failure);
                    return result;
                }
                if (parent.$$inheritedValues) {
                    merge(values, omit(parent.$$inheritedValues, invocableKeys));
                }
                extend(promises, parent.$$promises);
                if (parent.$$values) {
                    merged = merge(values, omit(parent.$$values, invocableKeys));
                    result.$$inheritedValues = omit(parent.$$values, invocableKeys);
                    done();
                } else {
                    if (parent.$$inheritedValues) {
                        result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
                    }
                    parent.then(done, fail);
                }
                for (var i = 0, ii = plan.length; i < ii; i += 3) {
                    if (locals.hasOwnProperty(plan[i])) done(); else invoke(plan[i], plan[i + 1], plan[i + 2]);
                }
                function invoke(key, invocable, params) {
                    var invocation = $q.defer(), waitParams = 0;
                    function onfailure(reason) {
                        invocation.reject(reason);
                        fail(reason);
                    }
                    forEach(params, function(dep) {
                        if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                            waitParams++;
                            promises[dep].then(function(result) {
                                values[dep] = result;
                                if (!--waitParams) proceed();
                            }, onfailure);
                        }
                    });
                    if (!waitParams) proceed();
                    function proceed() {
                        if (isDefined(result.$$failure)) return;
                        try {
                            invocation.resolve($injector.invoke(invocable, self, values));
                            invocation.promise.then(function(result) {
                                values[key] = result;
                                done();
                            }, onfailure);
                        } catch (e) {
                            onfailure(e);
                        }
                    }
                    promises[key] = invocation.promise;
                }
                return result;
            };
        };
        this.resolve = function(invocables, locals, parent, self) {
            return this.study(invocables)(locals, parent, self);
        };
    }
    angular.module("ui.router.util").service("$resolve", $Resolve);
    $TemplateFactory.$inject = [ "$http", "$templateCache", "$injector" ];
    function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
            return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null;
        };
        this.fromString = function(template, params) {
            return isFunction(template) ? template(params) : template;
        };
        this.fromUrl = function(url, params) {
            if (isFunction(url)) url = url(params);
            if (url == null) return null; else return $http.get(url, {
                cache: $templateCache,
                headers: {
                    Accept: "text/html"
                }
            }).then(function(response) {
                return response.data;
            });
        };
        this.fromProvider = function(provider, params, locals) {
            return $injector.invoke(provider, null, locals || {
                params: params
            });
        };
    }
    angular.module("ui.router.util").service("$templateFactory", $TemplateFactory);
    var $$UMFP;
    function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({
            params: {}
        }, isObject(config) ? config : {});
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, compiled = "^", last = 0, m, segments = this.segments = [], parentParams = parentMatcher ? parentMatcher.params : {}, params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(), paramNames = [];
        function addParameter(id, type, config, location) {
            paramNames.push(id);
            if (parentParams[id]) return parentParams[id];
            if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
            if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
            params[id] = new $$UMFP.Param(id, type, config, location);
            return params[id];
        }
        function quoteRegExp(string, pattern, squash, optional) {
            var surroundPattern = [ "", "" ], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
            if (!pattern) return result;
            switch (squash) {
              case false:
                surroundPattern = [ "(", ")" + (optional ? "?" : "") ];
                break;

              case true:
                result = result.replace(/\/$/, "");
                surroundPattern = [ "(?:/(", ")|/)?" ];
                break;

              default:
                surroundPattern = [ "(" + squash + "|", ")?" ];
                break;
            }
            return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        this.source = pattern;
        function matchDetails(m, isSearch) {
            var id, regexp, segment, type, cfg, arrayMode;
            id = m[2] || m[3];
            cfg = config.params[id];
            segment = pattern.substring(last, m.index);
            regexp = isSearch ? m[4] : m[4] || (m[1] == "*" ? ".*" : null);
            if (regexp) {
                type = $$UMFP.type(regexp) || inherit($$UMFP.type("string"), {
                    pattern: new RegExp(regexp, config.caseInsensitive ? "i" : undefined)
                });
            }
            return {
                id: id,
                regexp: regexp,
                segment: segment,
                type: type,
                cfg: cfg
            };
        }
        var p, param, segment;
        while (m = placeholder.exec(pattern)) {
            p = matchDetails(m, false);
            if (p.segment.indexOf("?") >= 0) break;
            param = addParameter(p.id, p.type, p.cfg, "path");
            compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
            segments.push(p.segment);
            last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        var i = segment.indexOf("?");
        if (i >= 0) {
            var search = this.sourceSearch = segment.substring(i);
            segment = segment.substring(0, i);
            this.sourcePath = pattern.substring(0, last + i);
            if (search.length > 0) {
                last = 0;
                while (m = searchPlaceholder.exec(search)) {
                    p = matchDetails(m, true);
                    param = addParameter(p.id, p.type, p.cfg, "search");
                    last = placeholder.lastIndex;
                }
            }
        } else {
            this.sourcePath = pattern;
            this.sourceSearch = "";
        }
        compiled += quoteRegExp(segment) + (config.strict === false ? "/?" : "") + "$";
        segments.push(segment);
        this.regexp = new RegExp(compiled, config.caseInsensitive ? "i" : undefined);
        this.prefix = segments[0];
        this.$$paramNames = paramNames;
    }
    UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
            caseInsensitive: $$UMFP.caseInsensitive(),
            strict: $$UMFP.strictMode(),
            squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
    };
    UrlMatcher.prototype.toString = function() {
        return this.source;
    };
    UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m) return null;
        searchParams = searchParams || {};
        var paramNames = this.parameters(), nTotal = paramNames.length, nPath = this.segments.length - 1, values = {}, i, j, cfg, paramName;
        if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");
        function decodePathArray(string) {
            function reverseString(str) {
                return str.split("").reverse().join("");
            }
            function unquoteDashes(str) {
                return str.replace(/\\-/g, "-");
            }
            var split = reverseString(string).split(/-(?!\\)/);
            var allReversed = map(split, reverseString);
            return map(allReversed, unquoteDashes).reverse();
        }
        var param, paramVal;
        for (i = 0; i < nPath; i++) {
            paramName = paramNames[i];
            param = this.params[paramName];
            paramVal = m[i + 1];
            for (j = 0; j < param.replace.length; j++) {
                if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
            }
            if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);
            if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
            values[paramName] = param.value(paramVal);
        }
        for (;i < nTotal; i++) {
            paramName = paramNames[i];
            values[paramName] = this.params[paramName].value(searchParams[paramName]);
            param = this.params[paramName];
            paramVal = searchParams[paramName];
            for (j = 0; j < param.replace.length; j++) {
                if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
            }
            if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
            values[paramName] = param.value(paramVal);
        }
        return values;
    };
    UrlMatcher.prototype.parameters = function(param) {
        if (!isDefined(param)) return this.$$paramNames;
        return this.params[param] || null;
    };
    UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
    };
    UrlMatcher.prototype.format = function(values) {
        values = values || {};
        var segments = this.segments, params = this.parameters(), paramset = this.params;
        if (!this.validates(values)) return null;
        var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];
        function encodeDashes(str) {
            return encodeURIComponent(str).replace(/-/g, function(c) {
                return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        for (i = 0; i < nTotal; i++) {
            var isPathParam = i < nPath;
            var name = params[i], param = paramset[name], value = param.value(values[name]);
            var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
            var squash = isDefaultValue ? param.squash : false;
            var encoded = param.type.encode(value);
            if (isPathParam) {
                var nextSegment = segments[i + 1];
                var isFinalPathParam = i + 1 === nPath;
                if (squash === false) {
                    if (encoded != null) {
                        if (isArray(encoded)) {
                            result += map(encoded, encodeDashes).join("-");
                        } else {
                            result += encodeURIComponent(encoded);
                        }
                    }
                    result += nextSegment;
                } else if (squash === true) {
                    var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                    result += nextSegment.match(capture)[1];
                } else if (isString(squash)) {
                    result += squash + nextSegment;
                }
                if (isFinalPathParam && param.squash === true && result.slice(-1) === "/") result = result.slice(0, -1);
            } else {
                if (encoded == null || isDefaultValue && squash !== false) continue;
                if (!isArray(encoded)) encoded = [ encoded ];
                if (encoded.length === 0) continue;
                encoded = map(encoded, encodeURIComponent).join("&" + name + "=");
                result += (search ? "&" : "?") + (name + "=" + encoded);
                search = true;
            }
        }
        return result;
    };
    function Type(config) {
        extend(this, config);
    }
    Type.prototype.is = function(val, key) {
        return true;
    };
    Type.prototype.encode = function(val, key) {
        return val;
    };
    Type.prototype.decode = function(val, key) {
        return val;
    };
    Type.prototype.equals = function(a, b) {
        return a == b;
    };
    Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
    };
    Type.prototype.pattern = /.*/;
    Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
    };
    Type.prototype.$normalize = function(val) {
        return this.is(val) ? val : this.decode(val);
    };
    Type.prototype.$asArray = function(mode, isSearch) {
        if (!mode) return this;
        if (mode === "auto" && !isSearch) throw new Error("'auto' array mode is for query parameters only");
        function ArrayType(type, mode) {
            function bindTo(type, callbackName) {
                return function() {
                    return type[callbackName].apply(type, arguments);
                };
            }
            function arrayWrap(val) {
                return isArray(val) ? val : isDefined(val) ? [ val ] : [];
            }
            function arrayUnwrap(val) {
                switch (val.length) {
                  case 0:
                    return undefined;

                  case 1:
                    return mode === "auto" ? val[0] : val;

                  default:
                    return val;
                }
            }
            function falsey(val) {
                return !val;
            }
            function arrayHandler(callback, allTruthyMode) {
                return function handleArray(val) {
                    if (isArray(val) && val.length === 0) return val;
                    val = arrayWrap(val);
                    var result = map(val, callback);
                    if (allTruthyMode === true) return filter(result, falsey).length === 0;
                    return arrayUnwrap(result);
                };
            }
            function arrayEqualsHandler(callback) {
                return function handleArray(val1, val2) {
                    var left = arrayWrap(val1), right = arrayWrap(val2);
                    if (left.length !== right.length) return false;
                    for (var i = 0; i < left.length; i++) {
                        if (!callback(left[i], right[i])) return false;
                    }
                    return true;
                };
            }
            this.encode = arrayHandler(bindTo(type, "encode"));
            this.decode = arrayHandler(bindTo(type, "decode"));
            this.is = arrayHandler(bindTo(type, "is"), true);
            this.equals = arrayEqualsHandler(bindTo(type, "equals"));
            this.pattern = type.pattern;
            this.$normalize = arrayHandler(bindTo(type, "$normalize"));
            this.name = type.name;
            this.$arrayMode = mode;
        }
        return new ArrayType(this, mode);
    };
    function $UrlMatcherFactory() {
        $$UMFP = this;
        var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;
        function valToString(val) {
            return val != null ? val.toString().replace(/~/g, "~~").replace(/\//g, "~2F") : val;
        }
        function valFromString(val) {
            return val != null ? val.toString().replace(/~2F/g, "/").replace(/~~/g, "~") : val;
        }
        var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {
            string: {
                encode: valToString,
                decode: valFromString,
                is: function(val) {
                    return val == null || !isDefined(val) || typeof val === "string";
                },
                pattern: /[^\/]*/
            },
            int: {
                encode: valToString,
                decode: function(val) {
                    return parseInt(val, 10);
                },
                is: function(val) {
                    return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
            },
            bool: {
                encode: function(val) {
                    return val ? 1 : 0;
                },
                decode: function(val) {
                    return parseInt(val, 10) !== 0;
                },
                is: function(val) {
                    return val === true || val === false;
                },
                pattern: /0|1/
            },
            date: {
                encode: function(val) {
                    if (!this.is(val)) return undefined;
                    return [ val.getFullYear(), ("0" + (val.getMonth() + 1)).slice(-2), ("0" + val.getDate()).slice(-2) ].join("-");
                },
                decode: function(val) {
                    if (this.is(val)) return val;
                    var match = this.capture.exec(val);
                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                    return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                    return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^\/]*/
            },
            any: {
                encode: angular.identity,
                decode: angular.identity,
                equals: angular.equals,
                pattern: /.*/
            }
        };
        function getDefaultConfig() {
            return {
                strict: isStrictMode,
                caseInsensitive: isCaseInsensitive
            };
        }
        function isInjectable(value) {
            return isFunction(value) || isArray(value) && isFunction(value[value.length - 1]);
        }
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
            if (!isInjectable(config.value)) return config.value;
            if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
            return injector.invoke(config.value);
        };
        this.caseInsensitive = function(value) {
            if (isDefined(value)) isCaseInsensitive = value;
            return isCaseInsensitive;
        };
        this.strictMode = function(value) {
            if (isDefined(value)) isStrictMode = value;
            return isStrictMode;
        };
        this.defaultSquashPolicy = function(value) {
            if (!isDefined(value)) return defaultSquashPolicy;
            if (value !== true && value !== false && !isString(value)) throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
            defaultSquashPolicy = value;
            return value;
        };
        this.compile = function(pattern, config) {
            return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        };
        this.isMatcher = function(o) {
            if (!isObject(o)) return false;
            var result = true;
            forEach(UrlMatcher.prototype, function(val, name) {
                if (isFunction(val)) {
                    result = result && (isDefined(o[name]) && isFunction(o[name]));
                }
            });
            return result;
        };
        this.type = function(name, definition, definitionFn) {
            if (!isDefined(definition)) return $types[name];
            if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");
            $types[name] = new Type(extend({
                name: name
            }, definition));
            if (definitionFn) {
                typeQueue.push({
                    name: name,
                    def: definitionFn
                });
                if (!enqueue) flushTypeQueue();
            }
            return this;
        };
        function flushTypeQueue() {
            while (typeQueue.length) {
                var type = typeQueue.shift();
                if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                angular.extend($types[type.name], injector.invoke(type.def));
            }
        }
        forEach(defaultTypes, function(type, name) {
            $types[name] = new Type(extend({
                name: name
            }, type));
        });
        $types = inherit($types, {});
        this.$get = [ "$injector", function($injector) {
            injector = $injector;
            enqueue = false;
            flushTypeQueue();
            forEach(defaultTypes, function(type, name) {
                if (!$types[name]) $types[name] = new Type(type);
            });
            return this;
        } ];
        this.Param = function Param(id, type, config, location) {
            var self = this;
            config = unwrapShorthand(config);
            type = getType(config, type, location);
            var arrayMode = getArrayMode();
            type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
            if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined) config.value = "";
            var isOptional = config.value !== undefined;
            var squash = getSquashPolicy(config, isOptional);
            var replace = getReplace(config, arrayMode, isOptional, squash);
            function unwrapShorthand(config) {
                var keys = isObject(config) ? objectKeys(config) : [];
                var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
                if (isShorthand) config = {
                    value: config
                };
                config.$$fn = isInjectable(config.value) ? config.value : function() {
                    return config.value;
                };
                return config;
            }
            function getType(config, urlType, location) {
                if (config.type && urlType) throw new Error("Param '" + id + "' has two type configurations.");
                if (urlType) return urlType;
                if (!config.type) return location === "config" ? $types.any : $types.string;
                if (angular.isString(config.type)) return $types[config.type];
                if (config.type instanceof Type) return config.type;
                return new Type(config.type);
            }
            function getArrayMode() {
                var arrayDefaults = {
                    array: location === "search" ? "auto" : false
                };
                var arrayParamNomenclature = id.match(/\[\]$/) ? {
                    array: true
                } : {};
                return extend(arrayDefaults, arrayParamNomenclature, config).array;
            }
            function getSquashPolicy(config, isOptional) {
                var squash = config.squash;
                if (!isOptional || squash === false) return false;
                if (!isDefined(squash) || squash == null) return defaultSquashPolicy;
                if (squash === true || isString(squash)) return squash;
                throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
            }
            function getReplace(config, arrayMode, isOptional, squash) {
                var replace, configuredKeys, defaultPolicy = [ {
                    from: "",
                    to: isOptional || arrayMode ? undefined : ""
                }, {
                    from: null,
                    to: isOptional || arrayMode ? undefined : ""
                } ];
                replace = isArray(config.replace) ? config.replace : [];
                if (isString(squash)) replace.push({
                    from: squash,
                    to: undefined
                });
                configuredKeys = map(replace, function(item) {
                    return item.from;
                });
                return filter(defaultPolicy, function(item) {
                    return indexOf(configuredKeys, item.from) === -1;
                }).concat(replace);
            }
            function $$getDefaultValue() {
                if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
                var defaultValue = injector.invoke(config.$$fn);
                if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue)) throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
                return defaultValue;
            }
            function $value(value) {
                function hasReplaceVal(val) {
                    return function(obj) {
                        return obj.from === val;
                    };
                }
                function $replace(value) {
                    var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                        return obj.to;
                    });
                    return replacement.length ? replacement[0] : value;
                }
                value = $replace(value);
                return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
            }
            function toString() {
                return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
            }
            extend(this, {
                id: id,
                type: type,
                location: location,
                array: arrayMode,
                squash: squash,
                replace: replace,
                isOptional: isOptional,
                value: $value,
                dynamic: undefined,
                config: config,
                toString: toString
            });
        };
        function ParamSet(params) {
            extend(this, params || {});
        }
        ParamSet.prototype = {
            $$new: function() {
                return inherit(this, extend(new ParamSet(), {
                    $$parent: this
                }));
            },
            $$keys: function() {
                var keys = [], chain = [], parent = this, ignore = objectKeys(ParamSet.prototype);
                while (parent) {
                    chain.push(parent);
                    parent = parent.$$parent;
                }
                chain.reverse();
                forEach(chain, function(paramset) {
                    forEach(objectKeys(paramset), function(key) {
                        if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);
                    });
                });
                return keys;
            },
            $$values: function(paramValues) {
                var values = {}, self = this;
                forEach(self.$$keys(), function(key) {
                    values[key] = self[key].value(paramValues && paramValues[key]);
                });
                return values;
            },
            $$equals: function(paramValues1, paramValues2) {
                var equal = true, self = this;
                forEach(self.$$keys(), function(key) {
                    var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
                    if (!self[key].type.equals(left, right)) equal = false;
                });
                return equal;
            },
            $$validates: function $$validate(paramValues) {
                var keys = this.$$keys(), i, param, rawVal, normalized, encoded;
                for (i = 0; i < keys.length; i++) {
                    param = this[keys[i]];
                    rawVal = paramValues[keys[i]];
                    if ((rawVal === undefined || rawVal === null) && param.isOptional) break;
                    normalized = param.type.$normalize(rawVal);
                    if (!param.type.is(normalized)) return false;
                    encoded = param.type.encode(normalized);
                    if (angular.isString(encoded) && !param.type.pattern.exec(encoded)) return false;
                }
                return true;
            },
            $$parent: undefined
        };
        this.ParamSet = ParamSet;
    }
    angular.module("ui.router.util").provider("$urlMatcherFactory", $UrlMatcherFactory);
    angular.module("ui.router.util").run([ "$urlMatcherFactory", function($urlMatcherFactory) {} ]);
    $UrlRouterProvider.$inject = [ "$locationProvider", "$urlMatcherFactoryProvider" ];
    function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [], otherwise = null, interceptDeferred = false, listener;
        function regExpPrefix(re) {
            var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
            return prefix != null ? prefix[1].replace(/\\(.)/g, "$1") : "";
        }
        function interpolate(pattern, match) {
            return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
                return match[what === "$" ? 0 : Number(what)];
            });
        }
        this.rule = function(rule) {
            if (!isFunction(rule)) throw new Error("'rule' must be a function");
            rules.push(rule);
            return this;
        };
        this.otherwise = function(rule) {
            if (isString(rule)) {
                var redirect = rule;
                rule = function() {
                    return redirect;
                };
            } else if (!isFunction(rule)) throw new Error("'rule' must be a function");
            otherwise = rule;
            return this;
        };
        function handleIfMatch($injector, handler, match) {
            if (!match) return false;
            var result = $injector.invoke(handler, handler, {
                $match: match
            });
            return isDefined(result) ? result : true;
        }
        this.when = function(what, handler) {
            var redirect, handlerIsString = isString(handler);
            if (isString(what)) what = $urlMatcherFactory.compile(what);
            if (!handlerIsString && !isFunction(handler) && !isArray(handler)) throw new Error("invalid 'handler' in when()");
            var strategies = {
                matcher: function(what, handler) {
                    if (handlerIsString) {
                        redirect = $urlMatcherFactory.compile(handler);
                        handler = [ "$match", function($match) {
                            return redirect.format($match);
                        } ];
                    }
                    return extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
                    }, {
                        prefix: isString(what.prefix) ? what.prefix : ""
                    });
                },
                regex: function(what, handler) {
                    if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");
                    if (handlerIsString) {
                        redirect = handler;
                        handler = [ "$match", function($match) {
                            return interpolate(redirect, $match);
                        } ];
                    }
                    return extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path()));
                    }, {
                        prefix: regExpPrefix(what)
                    });
                }
            };
            var check = {
                matcher: $urlMatcherFactory.isMatcher(what),
                regex: what instanceof RegExp
            };
            for (var n in check) {
                if (check[n]) return this.rule(strategies[n](what, handler));
            }
            throw new Error("invalid 'what' in when()");
        };
        this.deferIntercept = function(defer) {
            if (defer === undefined) defer = true;
            interceptDeferred = defer;
        };
        this.$get = $get;
        $get.$inject = [ "$location", "$rootScope", "$injector", "$browser", "$sniffer" ];
        function $get($location, $rootScope, $injector, $browser, $sniffer) {
            var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;
            function appendBasePath(url, isHtml5, absolute) {
                if (baseHref === "/") return url;
                if (isHtml5) return baseHref.slice(0, -1) + url;
                if (absolute) return baseHref.slice(1) + url;
                return url;
            }
            function update(evt) {
                if (evt && evt.defaultPrevented) return;
                var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
                lastPushedUrl = undefined;
                function check(rule) {
                    var handled = rule($injector, $location);
                    if (!handled) return false;
                    if (isString(handled)) $location.replace().url(handled);
                    return true;
                }
                var n = rules.length, i;
                for (i = 0; i < n; i++) {
                    if (check(rules[i])) return;
                }
                if (otherwise) check(otherwise);
            }
            function listen() {
                listener = listener || $rootScope.$on("$locationChangeSuccess", update);
                return listener;
            }
            if (!interceptDeferred) listen();
            return {
                sync: function() {
                    update();
                },
                listen: function() {
                    return listen();
                },
                update: function(read) {
                    if (read) {
                        location = $location.url();
                        return;
                    }
                    if ($location.url() === location) return;
                    $location.url(location);
                    $location.replace();
                },
                push: function(urlMatcher, params, options) {
                    var url = urlMatcher.format(params || {});
                    if (url !== null && params && params["#"]) {
                        url += "#" + params["#"];
                    }
                    $location.url(url);
                    lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
                    if (options && options.replace) $location.replace();
                },
                href: function(urlMatcher, params, options) {
                    if (!urlMatcher.validates(params)) return null;
                    var isHtml5 = $locationProvider.html5Mode();
                    if (angular.isObject(isHtml5)) {
                        isHtml5 = isHtml5.enabled;
                    }
                    isHtml5 = isHtml5 && $sniffer.history;
                    var url = urlMatcher.format(params);
                    options = options || {};
                    if (!isHtml5 && url !== null) {
                        url = "#" + $locationProvider.hashPrefix() + url;
                    }
                    if (url !== null && params && params["#"]) {
                        url += "#" + params["#"];
                    }
                    url = appendBasePath(url, isHtml5, options.absolute);
                    if (!options.absolute || !url) {
                        return url;
                    }
                    var slash = !isHtml5 && url ? "/" : "", port = $location.port();
                    port = port === 80 || port === 443 ? "" : ":" + port;
                    return [ $location.protocol(), "://", $location.host(), port, slash, url ].join("");
                }
            };
        }
    }
    angular.module("ui.router.router").provider("$urlRouter", $UrlRouterProvider);
    $StateProvider.$inject = [ "$urlRouterProvider", "$urlMatcherFactoryProvider" ];
    function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root, states = {}, $state, queue = {}, abstractKey = "abstract";
        var stateBuilder = {
            parent: function(state) {
                if (isDefined(state.parent) && state.parent) return findState(state.parent);
                var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
                return compositeName ? findState(compositeName[1]) : root;
            },
            data: function(state) {
                if (state.parent && state.parent.data) {
                    state.data = state.self.data = inherit(state.parent.data, state.data);
                }
                return state.data;
            },
            url: function(state) {
                var url = state.url, config = {
                    params: state.params || {}
                };
                if (isString(url)) {
                    if (url.charAt(0) == "^") return $urlMatcherFactory.compile(url.substring(1), config);
                    return (state.parent.navigable || root).url.concat(url, config);
                }
                if (!url || $urlMatcherFactory.isMatcher(url)) return url;
                throw new Error("Invalid url '" + url + "' in state '" + state + "'");
            },
            navigable: function(state) {
                return state.url ? state : state.parent ? state.parent.navigable : null;
            },
            ownParams: function(state) {
                var params = state.url && state.url.params || new $$UMFP.ParamSet();
                forEach(state.params || {}, function(config, id) {
                    if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, "config");
                });
                return params;
            },
            params: function(state) {
                var ownParams = pick(state.ownParams, state.ownParams.$$keys());
                return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();
            },
            views: function(state) {
                var views = {};
                forEach(isDefined(state.views) ? state.views : {
                    "": state
                }, function(view, name) {
                    if (name.indexOf("@") < 0) name += "@" + state.parent.name;
                    views[name] = view;
                });
                return views;
            },
            path: function(state) {
                return state.parent ? state.parent.path.concat(state) : [];
            },
            includes: function(state) {
                var includes = state.parent ? extend({}, state.parent.includes) : {};
                includes[state.name] = true;
                return includes;
            },
            $delegates: {}
        };
        function isRelative(stateName) {
            return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }
        function findState(stateOrName, base) {
            if (!stateOrName) return undefined;
            var isStr = isString(stateOrName), name = isStr ? stateOrName : stateOrName.name, path = isRelative(name);
            if (path) {
                if (!base) throw new Error("No reference point given for path '" + name + "'");
                base = findState(base);
                var rel = name.split("."), i = 0, pathLength = rel.length, current = base;
                for (;i < pathLength; i++) {
                    if (rel[i] === "" && i === 0) {
                        current = base;
                        continue;
                    }
                    if (rel[i] === "^") {
                        if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                        current = current.parent;
                        continue;
                    }
                    break;
                }
                rel = rel.slice(i).join(".");
                name = current.name + (current.name && rel ? "." : "") + rel;
            }
            var state = states[name];
            if (state && (isStr || !isStr && (state === stateOrName || state.self === stateOrName))) {
                return state;
            }
            return undefined;
        }
        function queueState(parentName, state) {
            if (!queue[parentName]) {
                queue[parentName] = [];
            }
            queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
            var queued = queue[parentName] || [];
            while (queued.length) {
                registerState(queued.shift());
            }
        }
        function registerState(state) {
            state = inherit(state, {
                self: state,
                resolve: state.resolve || {},
                toString: function() {
                    return this.name;
                }
            });
            var name = state.name;
            if (!isString(name) || name.indexOf("@") >= 0) throw new Error("State must have a valid name");
            if (states.hasOwnProperty(name)) throw new Error("State '" + name + "' is already defined");
            var parentName = name.indexOf(".") !== -1 ? name.substring(0, name.lastIndexOf(".")) : isString(state.parent) ? state.parent : isObject(state.parent) && isString(state.parent.name) ? state.parent.name : "";
            if (parentName && !states[parentName]) {
                return queueState(parentName, state.self);
            }
            for (var key in stateBuilder) {
                if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
            }
            states[name] = state;
            if (!state[abstractKey] && state.url) {
                $urlRouterProvider.when(state.url, [ "$match", "$stateParams", function($match, $stateParams) {
                    if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                        $state.transitionTo(state, $match, {
                            inherit: true,
                            location: false
                        });
                    }
                } ]);
            }
            flushQueuedChildren(name);
            return state;
        }
        function isGlob(text) {
            return text.indexOf("*") > -1;
        }
        function doesStateMatchGlob(glob) {
            var globSegments = glob.split("."), segments = $state.$current.name.split(".");
            for (var i = 0, l = globSegments.length; i < l; i++) {
                if (globSegments[i] === "*") {
                    segments[i] = "*";
                }
            }
            if (globSegments[0] === "**") {
                segments = segments.slice(indexOf(segments, globSegments[1]));
                segments.unshift("**");
            }
            if (globSegments[globSegments.length - 1] === "**") {
                segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
                segments.push("**");
            }
            if (globSegments.length != segments.length) {
                return false;
            }
            return segments.join("") === globSegments.join("");
        }
        root = registerState({
            name: "",
            url: "^",
            views: null,
            abstract: true
        });
        root.navigable = null;
        this.decorator = decorator;
        function decorator(name, func) {
            if (isString(name) && !isDefined(func)) {
                return stateBuilder[name];
            }
            if (!isFunction(func) || !isString(name)) {
                return this;
            }
            if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
                stateBuilder.$delegates[name] = stateBuilder[name];
            }
            stateBuilder[name] = func;
            return this;
        }
        this.state = state;
        function state(name, definition) {
            if (isObject(name)) definition = name; else definition.name = name;
            registerState(definition);
            return this;
        }
        this.$get = $get;
        $get.$inject = [ "$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory" ];
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
            var TransitionSuperseded = $q.reject(new Error("transition superseded"));
            var TransitionPrevented = $q.reject(new Error("transition prevented"));
            var TransitionAborted = $q.reject(new Error("transition aborted"));
            var TransitionFailed = $q.reject(new Error("transition failed"));
            function handleRedirect(redirect, state, params, options) {
                var evt = $rootScope.$broadcast("$stateNotFound", redirect, state, params);
                if (evt.defaultPrevented) {
                    $urlRouter.update();
                    return TransitionAborted;
                }
                if (!evt.retry) {
                    return null;
                }
                if (options.$retry) {
                    $urlRouter.update();
                    return TransitionFailed;
                }
                var retryTransition = $state.transition = $q.when(evt.retry);
                retryTransition.then(function() {
                    if (retryTransition !== $state.transition) return TransitionSuperseded;
                    redirect.options.$retry = true;
                    return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
                }, function() {
                    return TransitionAborted;
                });
                $urlRouter.update();
                return retryTransition;
            }
            root.locals = {
                resolve: null,
                globals: {
                    $stateParams: {}
                }
            };
            $state = {
                params: {},
                current: root.self,
                $current: root,
                transition: null
            };
            $state.reload = function reload(state) {
                return $state.transitionTo($state.current, $stateParams, {
                    reload: state || true,
                    inherit: false,
                    notify: true
                });
            };
            $state.go = function go(to, params, options) {
                return $state.transitionTo(to, params, extend({
                    inherit: true,
                    relative: $state.$current
                }, options));
            };
            $state.transitionTo = function transitionTo(to, toParams, options) {
                toParams = toParams || {};
                options = extend({
                    location: true,
                    inherit: false,
                    relative: null,
                    notify: true,
                    reload: false,
                    $retry: false
                }, options || {});
                var from = $state.$current, fromParams = $state.params, fromPath = from.path;
                var evt, toState = findState(to, options.relative);
                var hash = toParams["#"];
                if (!isDefined(toState)) {
                    var redirect = {
                        to: to,
                        toParams: toParams,
                        options: options
                    };
                    var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
                    if (redirectResult) {
                        return redirectResult;
                    }
                    to = redirect.to;
                    toParams = redirect.toParams;
                    options = redirect.options;
                    toState = findState(to, options.relative);
                    if (!isDefined(toState)) {
                        if (!options.relative) throw new Error("No such state '" + to + "'");
                        throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
                    }
                }
                if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
                if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
                if (!toState.params.$$validates(toParams)) return TransitionFailed;
                toParams = toState.params.$$values(toParams);
                to = toState;
                var toPath = to.path;
                var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];
                if (!options.reload) {
                    while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                        locals = toLocals[keep] = state.locals;
                        keep++;
                        state = toPath[keep];
                    }
                } else if (isString(options.reload) || isObject(options.reload)) {
                    if (isObject(options.reload) && !options.reload.name) {
                        throw new Error("Invalid reload state object");
                    }
                    var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
                    if (options.reload && !reloadState) {
                        throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
                    }
                    while (state && state === fromPath[keep] && state !== reloadState) {
                        locals = toLocals[keep] = state.locals;
                        keep++;
                        state = toPath[keep];
                    }
                }
                if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
                    if (hash) toParams["#"] = hash;
                    $state.params = toParams;
                    copy($state.params, $stateParams);
                    copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);
                    if (options.location && to.navigable && to.navigable.url) {
                        $urlRouter.push(to.navigable.url, toParams, {
                            $$avoidResync: true,
                            replace: options.location === "replace"
                        });
                        $urlRouter.update(true);
                    }
                    $state.transition = null;
                    return $q.when($state.current);
                }
                toParams = filterByKeys(to.params.$$keys(), toParams || {});
                if (hash) toParams["#"] = hash;
                if (options.notify) {
                    if ($rootScope.$broadcast("$stateChangeStart", to.self, toParams, from.self, fromParams, options).defaultPrevented) {
                        $rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams);
                        if ($state.transition == null) $urlRouter.update();
                        return TransitionPrevented;
                    }
                }
                var resolved = $q.when(locals);
                for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
                    locals = toLocals[l] = inherit(locals);
                    resolved = resolveState(state, toParams, state === to, resolved, locals, options);
                }
                var transition = $state.transition = resolved.then(function() {
                    var l, entering, exiting;
                    if ($state.transition !== transition) return TransitionSuperseded;
                    for (l = fromPath.length - 1; l >= keep; l--) {
                        exiting = fromPath[l];
                        if (exiting.self.onExit) {
                            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                        }
                        exiting.locals = null;
                    }
                    for (l = keep; l < toPath.length; l++) {
                        entering = toPath[l];
                        entering.locals = toLocals[l];
                        if (entering.self.onEnter) {
                            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                        }
                    }
                    if ($state.transition !== transition) return TransitionSuperseded;
                    $state.$current = to;
                    $state.current = to.self;
                    $state.params = toParams;
                    copy($state.params, $stateParams);
                    $state.transition = null;
                    if (options.location && to.navigable) {
                        $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                            $$avoidResync: true,
                            replace: options.location === "replace"
                        });
                    }
                    if (options.notify) {
                        $rootScope.$broadcast("$stateChangeSuccess", to.self, toParams, from.self, fromParams);
                    }
                    $urlRouter.update(true);
                    return $state.current;
                }, function(error) {
                    if ($state.transition !== transition) return TransitionSuperseded;
                    $state.transition = null;
                    evt = $rootScope.$broadcast("$stateChangeError", to.self, toParams, from.self, fromParams, error);
                    if (!evt.defaultPrevented) {
                        $urlRouter.update();
                    }
                    return $q.reject(error);
                });
                return transition;
            };
            $state.is = function is(stateOrName, params, options) {
                options = extend({
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) {
                    return undefined;
                }
                if ($state.$current !== state) {
                    return false;
                }
                return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
            };
            $state.includes = function includes(stateOrName, params, options) {
                options = extend({
                    relative: $state.$current
                }, options || {});
                if (isString(stateOrName) && isGlob(stateOrName)) {
                    if (!doesStateMatchGlob(stateOrName)) {
                        return false;
                    }
                    stateOrName = $state.$current.name;
                }
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) {
                    return undefined;
                }
                if (!isDefined($state.$current.includes[state.name])) {
                    return false;
                }
                return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
            };
            $state.href = function href(stateOrName, params, options) {
                options = extend({
                    lossy: true,
                    inherit: true,
                    absolute: false,
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) return null;
                if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);
                var nav = state && options.lossy ? state.navigable : state;
                if (!nav || nav.url === undefined || nav.url === null) {
                    return null;
                }
                return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat("#"), params || {}), {
                    absolute: options.absolute
                });
            };
            $state.get = function(stateOrName, context) {
                if (arguments.length === 0) return map(objectKeys(states), function(name) {
                    return states[name].self;
                });
                var state = findState(stateOrName, context || $state.$current);
                return state && state.self ? state.self : null;
            };
            function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
                var $stateParams = paramsAreFiltered ? params : filterByKeys(state.params.$$keys(), params);
                var locals = {
                    $stateParams: $stateParams
                };
                dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
                var promises = [ dst.resolve.then(function(globals) {
                    dst.globals = globals;
                }) ];
                if (inherited) promises.push(inherited);
                function resolveViews() {
                    var viewsPromises = [];
                    forEach(state.views, function(view, name) {
                        var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};
                        injectables.$template = [ function() {
                            return $view.load(name, {
                                view: view,
                                locals: dst.globals,
                                params: $stateParams,
                                notify: options.notify
                            }) || "";
                        } ];
                        viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function(result) {
                            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                                var injectLocals = angular.extend({}, injectables, dst.globals);
                                result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                            } else {
                                result.$$controller = view.controller;
                            }
                            result.$$state = state;
                            result.$$controllerAs = view.controllerAs;
                            dst[name] = result;
                        }));
                    });
                    return $q.all(viewsPromises).then(function() {
                        return dst.globals;
                    });
                }
                return $q.all(promises).then(resolveViews).then(function(values) {
                    return dst;
                });
            }
            return $state;
        }
        function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
            function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
                function notSearchParam(key) {
                    return fromAndToState.params[key].location != "search";
                }
                var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
                var nonQueryParams = pick.apply({}, [ fromAndToState.params ].concat(nonQueryParamKeys));
                var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
                return nonQueryParamSet.$$equals(fromParams, toParams);
            }
            if (!options.reload && to === from && (locals === from.locals || to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams))) {
                return true;
            }
        }
    }
    angular.module("ui.router.state").factory("$stateParams", function() {
        return {};
    }).provider("$state", $StateProvider);
    $ViewProvider.$inject = [];
    function $ViewProvider() {
        this.$get = $get;
        $get.$inject = [ "$rootScope", "$templateFactory" ];
        function $get($rootScope, $templateFactory) {
            return {
                load: function load(name, options) {
                    var result, defaults = {
                        template: null,
                        controller: null,
                        view: null,
                        locals: null,
                        notify: true,
                        async: true,
                        params: {}
                    };
                    options = extend(defaults, options);
                    if (options.view) {
                        result = $templateFactory.fromConfig(options.view, options.params, options.locals);
                    }
                    return result;
                }
            };
        }
    }
    angular.module("ui.router.state").provider("$view", $ViewProvider);
    function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function() {
            useAnchorScroll = true;
        };
        this.$get = [ "$anchorScroll", "$timeout", function($anchorScroll, $timeout) {
            if (useAnchorScroll) {
                return $anchorScroll;
            }
            return function($element) {
                return $timeout(function() {
                    $element[0].scrollIntoView();
                }, 0, false);
            };
        } ];
    }
    angular.module("ui.router.state").provider("$uiViewScroll", $ViewScrollProvider);
    var ngMajorVer = angular.version.major;
    var ngMinorVer = angular.version.minor;
    $ViewDirective.$inject = [ "$state", "$injector", "$uiViewScroll", "$interpolate" ];
    function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
            return $injector.has ? function(service) {
                return $injector.has(service) ? $injector.get(service) : null;
            } : function(service) {
                try {
                    return $injector.get(service);
                } catch (e) {
                    return null;
                }
            };
        }
        var service = getService(), $animator = service("$animator"), $animate = service("$animate");
        function getRenderer(attrs, scope) {
            var statics = {
                enter: function(element, target, cb) {
                    target.after(element);
                    cb();
                },
                leave: function(element, cb) {
                    element.remove();
                    cb();
                }
            };
            if (!!attrs.noanimation) return statics;
            function animEnabled(element) {
                if (ngMajorVer === 1 && ngMinorVer >= 4) return !!$animate.enabled(element);
                if (ngMajorVer === 1 && ngMinorVer >= 2) return !!$animate.enabled();
                return !!$animator;
            }
            if ($animate) {
                return {
                    enter: function(element, target, cb) {
                        if (!animEnabled(element)) {
                            statics.enter(element, target, cb);
                        } else if (angular.version.minor > 2) {
                            $animate.enter(element, null, target).then(cb);
                        } else {
                            $animate.enter(element, null, target, cb);
                        }
                    },
                    leave: function(element, cb) {
                        if (!animEnabled(element)) {
                            statics.leave(element, cb);
                        } else if (angular.version.minor > 2) {
                            $animate.leave(element).then(cb);
                        } else {
                            $animate.leave(element, cb);
                        }
                    }
                };
            }
            if ($animator) {
                var animate = $animator && $animator(scope, attrs);
                return {
                    enter: function(element, target, cb) {
                        animate.enter(element, null, target);
                        cb();
                    },
                    leave: function(element, cb) {
                        animate.leave(element);
                        cb();
                    }
                };
            }
            return statics;
        }
        var directive = {
            restrict: "ECA",
            terminal: true,
            priority: 400,
            transclude: "element",
            compile: function(tElement, tAttrs, $transclude) {
                return function(scope, $element, attrs) {
                    var previousEl, currentEl, currentScope, latestLocals, onloadExp = attrs.onload || "", autoScrollExp = attrs.autoscroll, renderer = getRenderer(attrs, scope);
                    scope.$on("$stateChangeSuccess", function() {
                        updateView(false);
                    });
                    updateView(true);
                    function cleanupLastView() {
                        var _previousEl = previousEl;
                        var _currentScope = currentScope;
                        if (_currentScope) {
                            _currentScope._willBeDestroyed = true;
                        }
                        function cleanOld() {
                            if (_previousEl) {
                                _previousEl.remove();
                            }
                            if (_currentScope) {
                                _currentScope.$destroy();
                            }
                        }
                        if (currentEl) {
                            renderer.leave(currentEl, function() {
                                cleanOld();
                                previousEl = null;
                            });
                            previousEl = currentEl;
                        } else {
                            cleanOld();
                            previousEl = null;
                        }
                        currentEl = null;
                        currentScope = null;
                    }
                    function updateView(firstTime) {
                        var newScope, name = getUiViewName(scope, attrs, $element, $interpolate), previousLocals = name && $state.$current && $state.$current.locals[name];
                        if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed) return;
                        newScope = scope.$new();
                        latestLocals = $state.$current.locals[name];
                        newScope.$emit("$viewContentLoading", name);
                        var clone = $transclude(newScope, function(clone) {
                            renderer.enter(clone, $element, function onUiViewEnter() {
                                if (currentScope) {
                                    currentScope.$emit("$viewContentAnimationEnded");
                                }
                                if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                                    $uiViewScroll(clone);
                                }
                            });
                            cleanupLastView();
                        });
                        currentEl = clone;
                        currentScope = newScope;
                        currentScope.$emit("$viewContentLoaded", name);
                        currentScope.$eval(onloadExp);
                    }
                };
            }
        };
        return directive;
    }
    $ViewDirectiveFill.$inject = [ "$compile", "$controller", "$state", "$interpolate" ];
    function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
            restrict: "ECA",
            priority: -400,
            compile: function(tElement) {
                var initial = tElement.html();
                return function(scope, $element, attrs) {
                    var current = $state.$current, name = getUiViewName(scope, attrs, $element, $interpolate), locals = current && current.locals[name];
                    if (!locals) {
                        return;
                    }
                    $element.data("$uiView", {
                        name: name,
                        state: locals.$$state
                    });
                    $element.html(locals.$template ? locals.$template : initial);
                    var link = $compile($element.contents());
                    if (locals.$$controller) {
                        locals.$scope = scope;
                        locals.$element = $element;
                        var controller = $controller(locals.$$controller, locals);
                        if (locals.$$controllerAs) {
                            scope[locals.$$controllerAs] = controller;
                        }
                        $element.data("$ngControllerController", controller);
                        $element.children().data("$ngControllerController", controller);
                    }
                    link(scope);
                };
            }
        };
    }
    function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || "")(scope);
        var inherited = element.inheritedData("$uiView");
        return name.indexOf("@") >= 0 ? name : name + "@" + (inherited ? inherited.state.name : "");
    }
    angular.module("ui.router.state").directive("uiView", $ViewDirective);
    angular.module("ui.router.state").directive("uiView", $ViewDirectiveFill);
    function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/), parsed;
        if (preparsed) ref = current + "(" + preparsed[1] + ")";
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
        return {
            state: parsed[1],
            paramExpr: parsed[3] || null
        };
    }
    function stateContext(el) {
        var stateData = el.parent().inheritedData("$uiView");
        if (stateData && stateData.state && stateData.state.name) {
            return stateData.state;
        }
    }
    function getTypeInfo(el) {
        var isSvg = Object.prototype.toString.call(el.prop("href")) === "[object SVGAnimatedString]";
        var isForm = el[0].nodeName === "FORM";
        return {
            attr: isForm ? "action" : isSvg ? "xlink:href" : "href",
            isAnchor: el.prop("tagName").toUpperCase() === "A",
            clickable: !isForm
        };
    }
    function clickHook(el, $state, $timeout, type, current) {
        return function(e) {
            var button = e.which || e.button, target = current();
            if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr("target"))) {
                var transition = $timeout(function() {
                    $state.go(target.state, target.params, target.options);
                });
                e.preventDefault();
                var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;
                e.preventDefault = function() {
                    if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);
                };
            }
        };
    }
    function defaultOpts(el, $state) {
        return {
            relative: stateContext(el) || $state.$current,
            inherit: true
        };
    }
    $StateRefDirective.$inject = [ "$state", "$timeout" ];
    function $StateRefDirective($state, $timeout) {
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(scope, element, attrs, uiSrefActive) {
                var ref = parseStateRef(attrs.uiSref, $state.current.name);
                var def = {
                    state: ref.state,
                    href: null,
                    params: null
                };
                var type = getTypeInfo(element);
                var active = uiSrefActive[1] || uiSrefActive[0];
                def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});
                var update = function(val) {
                    if (val) def.params = angular.copy(val);
                    def.href = $state.href(ref.state, def.params, def.options);
                    if (active) active.$$addStateInfo(ref.state, def.params);
                    if (def.href !== null) attrs.$set(type.attr, def.href);
                };
                if (ref.paramExpr) {
                    scope.$watch(ref.paramExpr, function(val) {
                        if (val !== def.params) update(val);
                    }, true);
                    def.params = angular.copy(scope.$eval(ref.paramExpr));
                }
                update();
                if (!type.clickable) return;
                element.bind("click", clickHook(element, $state, $timeout, type, function() {
                    return def;
                }));
            }
        };
    }
    $StateRefDynamicDirective.$inject = [ "$state", "$timeout" ];
    function $StateRefDynamicDirective($state, $timeout) {
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(scope, element, attrs, uiSrefActive) {
                var type = getTypeInfo(element);
                var active = uiSrefActive[1] || uiSrefActive[0];
                var group = [ attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null ];
                var watch = "[" + group.map(function(val) {
                    return val || "null";
                }).join(", ") + "]";
                var def = {
                    state: null,
                    params: null,
                    options: null,
                    href: null
                };
                function runStateRefLink(group) {
                    def.state = group[0];
                    def.params = group[1];
                    def.options = group[2];
                    def.href = $state.href(def.state, def.params, def.options);
                    if (active) active.$$addStateInfo(def.state, def.params);
                    if (def.href) attrs.$set(type.attr, def.href);
                }
                scope.$watch(watch, runStateRefLink, true);
                runStateRefLink(scope.$eval(watch));
                if (!type.clickable) return;
                element.bind("click", clickHook(element, $state, $timeout, type, function() {
                    return def;
                }));
            }
        };
    }
    $StateRefActiveDirective.$inject = [ "$state", "$stateParams", "$interpolate" ];
    function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
            restrict: "A",
            controller: [ "$scope", "$element", "$attrs", "$timeout", function($scope, $element, $attrs, $timeout) {
                var states = [], activeClasses = {}, activeEqClass, uiSrefActive;
                activeEqClass = $interpolate($attrs.uiSrefActiveEq || "", false)($scope);
                try {
                    uiSrefActive = $scope.$eval($attrs.uiSrefActive);
                } catch (e) {}
                uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || "", false)($scope);
                if (isObject(uiSrefActive)) {
                    forEach(uiSrefActive, function(stateOrName, activeClass) {
                        if (isString(stateOrName)) {
                            var ref = parseStateRef(stateOrName, $state.current.name);
                            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                        }
                    });
                }
                this.$$addStateInfo = function(newState, newParams) {
                    if (isObject(uiSrefActive) && states.length > 0) {
                        return;
                    }
                    addState(newState, newParams, uiSrefActive);
                    update();
                };
                $scope.$on("$stateChangeSuccess", update);
                function addState(stateName, stateParams, activeClass) {
                    var state = $state.get(stateName, stateContext($element));
                    var stateHash = createStateHash(stateName, stateParams);
                    states.push({
                        state: state || {
                            name: stateName
                        },
                        params: stateParams,
                        hash: stateHash
                    });
                    activeClasses[stateHash] = activeClass;
                }
                function createStateHash(state, params) {
                    if (!isString(state)) {
                        throw new Error("state should be a string");
                    }
                    if (isObject(params)) {
                        return state + toJson(params);
                    }
                    params = $scope.$eval(params);
                    if (isObject(params)) {
                        return state + toJson(params);
                    }
                    return state;
                }
                function update() {
                    for (var i = 0; i < states.length; i++) {
                        if (anyMatch(states[i].state, states[i].params)) {
                            addClass($element, activeClasses[states[i].hash]);
                        } else {
                            removeClass($element, activeClasses[states[i].hash]);
                        }
                        if (exactMatch(states[i].state, states[i].params)) {
                            addClass($element, activeEqClass);
                        } else {
                            removeClass($element, activeEqClass);
                        }
                    }
                }
                function addClass(el, className) {
                    $timeout(function() {
                        el.addClass(className);
                    });
                }
                function removeClass(el, className) {
                    el.removeClass(className);
                }
                function anyMatch(state, params) {
                    return $state.includes(state.name, params);
                }
                function exactMatch(state, params) {
                    return $state.is(state.name, params);
                }
                update();
            } ]
        };
    }
    angular.module("ui.router.state").directive("uiSref", $StateRefDirective).directive("uiSrefActive", $StateRefActiveDirective).directive("uiSrefActiveEq", $StateRefActiveDirective).directive("uiState", $StateRefDynamicDirective);
    $IsStateFilter.$inject = [ "$state" ];
    function $IsStateFilter($state) {
        var isFilter = function(state, params) {
            return $state.is(state, params);
        };
        isFilter.$stateful = true;
        return isFilter;
    }
    $IncludedByStateFilter.$inject = [ "$state" ];
    function $IncludedByStateFilter($state) {
        var includesFilter = function(state, params, options) {
            return $state.includes(state, params, options);
        };
        includesFilter.$stateful = true;
        return includesFilter;
    }
    angular.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter);
})(window, window.angular);

angular.module("ui.alias", []).config([ "$compileProvider", "uiAliasConfig", function($compileProvider, uiAliasConfig) {
    "use strict";
    uiAliasConfig = uiAliasConfig || {};
    angular.forEach(uiAliasConfig, function(config, alias) {
        if (angular.isString(config)) {
            config = {
                replace: true,
                template: config
            };
        }
        $compileProvider.directive(alias, function() {
            return config;
        });
    });
} ]);

angular.module("ui.event", []).directive("uiEvent", [ "$parse", function($parse) {
    "use strict";
    return function($scope, elm, attrs) {
        var events = $scope.$eval(attrs.uiEvent);
        angular.forEach(events, function(uiEvent, eventName) {
            var fn = $parse(uiEvent);
            elm.bind(eventName, function(evt) {
                var params = Array.prototype.slice.call(arguments);
                params = params.splice(1);
                fn($scope, {
                    $event: evt,
                    $params: params
                });
                if (!$scope.$$phase) {
                    $scope.$apply();
                }
            });
        });
    };
} ]);

angular.module("ui.format", []).filter("format", function() {
    "use strict";
    return function(value, replace) {
        var target = value;
        if (angular.isString(target) && replace !== undefined) {
            if (!angular.isArray(replace) && !angular.isObject(replace)) {
                replace = [ replace ];
            }
            if (angular.isArray(replace)) {
                var rlen = replace.length;
                var rfx = function(str, i) {
                    i = parseInt(i, 10);
                    return i >= 0 && i < rlen ? replace[i] : str;
                };
                target = target.replace(/\$([0-9]+)/g, rfx);
            } else {
                angular.forEach(replace, function(value, key) {
                    target = target.split(":" + key).join(value);
                });
            }
        }
        return target;
    };
});

angular.module("ui.highlight", []).filter("highlight", function() {
    "use strict";
    return function(text, search, caseSensitive) {
        if (text && (search || angular.isNumber(search))) {
            text = text.toString();
            search = search.toString();
            if (caseSensitive) {
                return text.split(search).join('<span class="ui-match">' + search + "</span>");
            } else {
                return text.replace(new RegExp(search, "gi"), '<span class="ui-match">$&</span>');
            }
        } else {
            return text;
        }
    };
});

angular.module("ui.include", []).directive("uiInclude", [ "$http", "$templateCache", "$anchorScroll", "$compile", function($http, $templateCache, $anchorScroll, $compile) {
    "use strict";
    return {
        restrict: "ECA",
        terminal: true,
        compile: function(element, attr) {
            var srcExp = attr.uiInclude || attr.src, fragExp = attr.fragment || "", onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
            return function(scope, element) {
                var changeCounter = 0, childScope;
                var clearContent = function() {
                    if (childScope) {
                        childScope.$destroy();
                        childScope = null;
                    }
                    element.html("");
                };
                function ngIncludeWatchAction() {
                    var thisChangeId = ++changeCounter;
                    var src = scope.$eval(srcExp);
                    var fragment = scope.$eval(fragExp);
                    if (src) {
                        $http.get(src, {
                            cache: $templateCache
                        }).success(function(response) {
                            if (thisChangeId !== changeCounter) {
                                return;
                            }
                            if (childScope) {
                                childScope.$destroy();
                            }
                            childScope = scope.$new();
                            var contents;
                            if (fragment) {
                                contents = angular.element("<div/>").html(response).find(fragment);
                            } else {
                                contents = angular.element("<div/>").html(response).contents();
                            }
                            element.html(contents);
                            $compile(contents)(childScope);
                            if (angular.isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                $anchorScroll();
                            }
                            childScope.$emit("$includeContentLoaded");
                            scope.$eval(onloadExp);
                        }).error(function() {
                            if (thisChangeId === changeCounter) {
                                clearContent();
                            }
                        });
                    } else {
                        clearContent();
                    }
                }
                scope.$watch(fragExp, ngIncludeWatchAction);
                scope.$watch(srcExp, ngIncludeWatchAction);
            };
        }
    };
} ]);

angular.module("ui.indeterminate", []).directive("uiIndeterminate", [ function() {
    "use strict";
    return {
        compile: function(tElm, tAttrs) {
            if (!tAttrs.type || tAttrs.type.toLowerCase() !== "checkbox") {
                return angular.noop;
            }
            return function($scope, elm, attrs) {
                $scope.$watch(attrs.uiIndeterminate, function(newVal) {
                    elm[0].indeterminate = !!newVal;
                });
            };
        }
    };
} ]);

angular.module("ui.inflector", []).filter("inflector", function() {
    "use strict";
    function tokenize(text) {
        text = text.replace(/([A-Z])|([\-|\_])/g, function(_, $1) {
            return " " + ($1 || "");
        });
        return text.replace(/\s\s+/g, " ").trim().toLowerCase().split(" ");
    }
    function capitalizeTokens(tokens) {
        var result = [];
        angular.forEach(tokens, function(token) {
            result.push(token.charAt(0).toUpperCase() + token.substr(1));
        });
        return result;
    }
    var inflectors = {
        humanize: function(value) {
            return capitalizeTokens(tokenize(value)).join(" ");
        },
        underscore: function(value) {
            return tokenize(value).join("_");
        },
        variable: function(value) {
            value = tokenize(value);
            value = value[0] + capitalizeTokens(value.slice(1)).join("");
            return value;
        }
    };
    return function(text, inflector) {
        if (inflector !== false && angular.isString(text)) {
            inflector = inflector || "humanize";
            return inflectors[inflector](text);
        } else {
            return text;
        }
    };
});

angular.module("ui.jq", []).value("uiJqConfig", {}).directive("uiJq", [ "uiJqConfig", "$timeout", function uiJqInjectingFunction(uiJqConfig, $timeout) {
    "use strict";
    return {
        restrict: "A",
        compile: function uiJqCompilingFunction(tElm, tAttrs) {
            if (!angular.isFunction(tElm[tAttrs.uiJq])) {
                throw new Error('ui-jq: The "' + tAttrs.uiJq + '" function does not exist');
            }
            var options = uiJqConfig && uiJqConfig[tAttrs.uiJq];
            return function uiJqLinkingFunction(scope, elm, attrs) {
                if (attrs.ngModel && elm.is("select,input,textarea")) {
                    elm.bind("change", function() {
                        elm.trigger("input");
                    });
                }
                function createLinkOptions() {
                    var linkOptions = [];
                    if (attrs.uiOptions) {
                        linkOptions = scope.$eval("[" + attrs.uiOptions + "]");
                        if (angular.isObject(options) && angular.isObject(linkOptions[0])) {
                            linkOptions[0] = angular.extend({}, options, linkOptions[0]);
                        }
                    } else if (options) {
                        linkOptions = [ options ];
                    }
                    return linkOptions;
                }
                function callPlugin() {
                    $timeout(function() {
                        elm[attrs.uiJq].apply(elm, createLinkOptions());
                    }, 0, false);
                }
                if (attrs.uiRefresh) {
                    scope.$watch(attrs.uiRefresh, function() {
                        callPlugin();
                    });
                }
                callPlugin();
            };
        }
    };
} ]);

angular.module("ui.keypress", []).factory("keypressHelper", [ "$parse", function keypress($parse) {
    "use strict";
    var keysByCode = {
        8: "backspace",
        9: "tab",
        13: "enter",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        45: "insert",
        46: "delete"
    };
    var capitaliseFirstLetter = function(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    };
    return function(mode, scope, elm, attrs) {
        var params, combinations = [];
        params = scope.$eval(attrs["ui" + capitaliseFirstLetter(mode)]);
        angular.forEach(params, function(v, k) {
            var combination, expression;
            expression = $parse(v);
            angular.forEach(k.split(" "), function(variation) {
                combination = {
                    expression: expression,
                    keys: {}
                };
                angular.forEach(variation.split("-"), function(value) {
                    combination.keys[value] = true;
                });
                combinations.push(combination);
            });
        });
        elm.bind(mode, function(event) {
            var metaPressed = !!(event.metaKey && !event.ctrlKey);
            var altPressed = !!event.altKey;
            var ctrlPressed = !!event.ctrlKey;
            var shiftPressed = !!event.shiftKey;
            var keyCode = event.keyCode;
            if (mode === "keypress" && !shiftPressed && keyCode >= 97 && keyCode <= 122) {
                keyCode = keyCode - 32;
            }
            angular.forEach(combinations, function(combination) {
                var mainKeyPressed = combination.keys[keysByCode[keyCode]] || combination.keys[keyCode.toString()];
                var metaRequired = !!combination.keys.meta;
                var altRequired = !!combination.keys.alt;
                var ctrlRequired = !!combination.keys.ctrl;
                var shiftRequired = !!combination.keys.shift;
                if (mainKeyPressed && metaRequired === metaPressed && altRequired === altPressed && ctrlRequired === ctrlPressed && shiftRequired === shiftPressed) {
                    scope.$apply(function() {
                        combination.expression(scope, {
                            $event: event
                        });
                    });
                }
            });
        });
    };
} ]);

angular.module("ui.keypress").directive("uiKeydown", [ "keypressHelper", function(keypressHelper) {
    "use strict";
    return {
        link: function(scope, elm, attrs) {
            keypressHelper("keydown", scope, elm, attrs);
        }
    };
} ]);

angular.module("ui.keypress").directive("uiKeypress", [ "keypressHelper", function(keypressHelper) {
    "use strict";
    return {
        link: function(scope, elm, attrs) {
            keypressHelper("keypress", scope, elm, attrs);
        }
    };
} ]);

angular.module("ui.keypress").directive("uiKeyup", [ "keypressHelper", function(keypressHelper) {
    "use strict";
    return {
        link: function(scope, elm, attrs) {
            keypressHelper("keyup", scope, elm, attrs);
        }
    };
} ]);

angular.module("ui.mask", []).value("uiMaskConfig", {
    maskDefinitions: {
        "9": /\d/,
        A: /[a-zA-Z]/,
        "*": /[a-zA-Z0-9]/
    },
    clearOnBlur: true
}).directive("uiMask", [ "uiMaskConfig", "$parse", function(maskConfig, $parse) {
    "use strict";
    return {
        priority: 100,
        require: "ngModel",
        restrict: "A",
        compile: function uiMaskCompilingFunction() {
            var options = maskConfig;
            return function uiMaskLinkingFunction(scope, iElement, iAttrs, controller) {
                var maskProcessed = false, eventsBound = false, maskCaretMap, maskPatterns, maskPlaceholder, maskComponents, minRequiredLength, value, valueMasked, isValid, originalPlaceholder = iAttrs.placeholder, originalMaxlength = iAttrs.maxlength, oldValue, oldValueUnmasked, oldCaretPosition, oldSelectionLength;
                function initialize(maskAttr) {
                    if (!angular.isDefined(maskAttr)) {
                        return uninitialize();
                    }
                    processRawMask(maskAttr);
                    if (!maskProcessed) {
                        return uninitialize();
                    }
                    initializeElement();
                    bindEventListeners();
                    return true;
                }
                function initPlaceholder(placeholderAttr) {
                    if (!angular.isDefined(placeholderAttr)) {
                        return;
                    }
                    maskPlaceholder = placeholderAttr;
                    if (maskProcessed) {
                        eventHandler();
                    }
                }
                function formatter(fromModelValue) {
                    if (!maskProcessed) {
                        return fromModelValue;
                    }
                    value = unmaskValue(fromModelValue || "");
                    isValid = validateValue(value);
                    controller.$setValidity("mask", isValid);
                    return isValid && value.length ? maskValue(value) : undefined;
                }
                function parser(fromViewValue) {
                    if (!maskProcessed) {
                        return fromViewValue;
                    }
                    value = unmaskValue(fromViewValue || "");
                    isValid = validateValue(value);
                    controller.$viewValue = value.length ? maskValue(value) : "";
                    controller.$setValidity("mask", isValid);
                    if (value === "" && iAttrs.required) {
                        controller.$setValidity("required", !controller.$error.required);
                    }
                    return isValid ? value : undefined;
                }
                var linkOptions = {};
                if (iAttrs.uiOptions) {
                    linkOptions = scope.$eval("[" + iAttrs.uiOptions + "]");
                    if (angular.isObject(linkOptions[0])) {
                        linkOptions = function(original, current) {
                            for (var i in original) {
                                if (Object.prototype.hasOwnProperty.call(original, i)) {
                                    if (current[i] === undefined) {
                                        current[i] = angular.copy(original[i]);
                                    } else {
                                        angular.extend(current[i], original[i]);
                                    }
                                }
                            }
                            return current;
                        }(options, linkOptions[0]);
                    }
                } else {
                    linkOptions = options;
                }
                iAttrs.$observe("uiMask", initialize);
                iAttrs.$observe("placeholder", initPlaceholder);
                var modelViewValue = false;
                iAttrs.$observe("modelViewValue", function(val) {
                    if (val === "true") {
                        modelViewValue = true;
                    }
                });
                scope.$watch(iAttrs.ngModel, function(val) {
                    if (modelViewValue && val) {
                        var model = $parse(iAttrs.ngModel);
                        model.assign(scope, controller.$viewValue);
                    }
                });
                controller.$formatters.push(formatter);
                controller.$parsers.push(parser);
                function uninitialize() {
                    maskProcessed = false;
                    unbindEventListeners();
                    if (angular.isDefined(originalPlaceholder)) {
                        iElement.attr("placeholder", originalPlaceholder);
                    } else {
                        iElement.removeAttr("placeholder");
                    }
                    if (angular.isDefined(originalMaxlength)) {
                        iElement.attr("maxlength", originalMaxlength);
                    } else {
                        iElement.removeAttr("maxlength");
                    }
                    iElement.val(controller.$modelValue);
                    controller.$viewValue = controller.$modelValue;
                    return false;
                }
                function initializeElement() {
                    value = oldValueUnmasked = unmaskValue(controller.$viewValue || "");
                    valueMasked = oldValue = maskValue(value);
                    isValid = validateValue(value);
                    var viewValue = isValid && value.length ? valueMasked : "";
                    if (iAttrs.maxlength) {
                        iElement.attr("maxlength", maskCaretMap[maskCaretMap.length - 1] * 2);
                    }
                    iElement.attr("placeholder", maskPlaceholder);
                    iElement.val(viewValue);
                    controller.$viewValue = viewValue;
                }
                function bindEventListeners() {
                    if (eventsBound) {
                        return;
                    }
                    iElement.bind("blur", blurHandler);
                    iElement.bind("mousedown mouseup", mouseDownUpHandler);
                    iElement.bind("input keyup click focus", eventHandler);
                    eventsBound = true;
                }
                function unbindEventListeners() {
                    if (!eventsBound) {
                        return;
                    }
                    iElement.unbind("blur", blurHandler);
                    iElement.unbind("mousedown", mouseDownUpHandler);
                    iElement.unbind("mouseup", mouseDownUpHandler);
                    iElement.unbind("input", eventHandler);
                    iElement.unbind("keyup", eventHandler);
                    iElement.unbind("click", eventHandler);
                    iElement.unbind("focus", eventHandler);
                    eventsBound = false;
                }
                function validateValue(value) {
                    return value.length ? value.length >= minRequiredLength : true;
                }
                function unmaskValue(value) {
                    var valueUnmasked = "", maskPatternsCopy = maskPatterns.slice();
                    value = value.toString();
                    angular.forEach(maskComponents, function(component) {
                        value = value.replace(component, "");
                    });
                    angular.forEach(value.split(""), function(chr) {
                        if (maskPatternsCopy.length && maskPatternsCopy[0].test(chr)) {
                            valueUnmasked += chr;
                            maskPatternsCopy.shift();
                        }
                    });
                    return valueUnmasked;
                }
                function maskValue(unmaskedValue) {
                    var valueMasked = "", maskCaretMapCopy = maskCaretMap.slice();
                    angular.forEach(maskPlaceholder.split(""), function(chr, i) {
                        if (unmaskedValue.length && i === maskCaretMapCopy[0]) {
                            valueMasked += unmaskedValue.charAt(0) || "_";
                            unmaskedValue = unmaskedValue.substr(1);
                            maskCaretMapCopy.shift();
                        } else {
                            valueMasked += chr;
                        }
                    });
                    return valueMasked;
                }
                function getPlaceholderChar(i) {
                    var placeholder = iAttrs.placeholder;
                    if (typeof placeholder !== "undefined" && placeholder[i]) {
                        return placeholder[i];
                    } else {
                        return "_";
                    }
                }
                function getMaskComponents() {
                    return maskPlaceholder.replace(/[_]+/g, "_").replace(/([^_]+)([a-zA-Z0-9])([^_])/g, "$1$2_$3").split("_");
                }
                function processRawMask(mask) {
                    var characterCount = 0;
                    maskCaretMap = [];
                    maskPatterns = [];
                    maskPlaceholder = "";
                    if (typeof mask === "string") {
                        minRequiredLength = 0;
                        var isOptional = false, numberOfOptionalCharacters = 0, splitMask = mask.split("");
                        angular.forEach(splitMask, function(chr, i) {
                            if (linkOptions.maskDefinitions[chr]) {
                                maskCaretMap.push(characterCount);
                                maskPlaceholder += getPlaceholderChar(i - numberOfOptionalCharacters);
                                maskPatterns.push(linkOptions.maskDefinitions[chr]);
                                characterCount++;
                                if (!isOptional) {
                                    minRequiredLength++;
                                }
                            } else if (chr === "?") {
                                isOptional = true;
                                numberOfOptionalCharacters++;
                            } else {
                                maskPlaceholder += chr;
                                characterCount++;
                            }
                        });
                    }
                    maskCaretMap.push(maskCaretMap.slice().pop() + 1);
                    maskComponents = getMaskComponents();
                    maskProcessed = maskCaretMap.length > 1 ? true : false;
                }
                function blurHandler() {
                    if (linkOptions.clearOnBlur) {
                        oldCaretPosition = 0;
                        oldSelectionLength = 0;
                        if (!isValid || value.length === 0) {
                            valueMasked = "";
                            iElement.val("");
                            scope.$apply(function() {
                                controller.$setViewValue("");
                            });
                        }
                    }
                }
                function mouseDownUpHandler(e) {
                    if (e.type === "mousedown") {
                        iElement.bind("mouseout", mouseoutHandler);
                    } else {
                        iElement.unbind("mouseout", mouseoutHandler);
                    }
                }
                iElement.bind("mousedown mouseup", mouseDownUpHandler);
                function mouseoutHandler() {
                    oldSelectionLength = getSelectionLength(this);
                    iElement.unbind("mouseout", mouseoutHandler);
                }
                function eventHandler(e) {
                    e = e || {};
                    var eventWhich = e.which, eventType = e.type;
                    if (eventWhich === 16 || eventWhich === 91) {
                        return;
                    }
                    var val = iElement.val(), valOld = oldValue, valMasked, valUnmasked = unmaskValue(val), valUnmaskedOld = oldValueUnmasked, valAltered = false, caretPos = getCaretPosition(this) || 0, caretPosOld = oldCaretPosition || 0, caretPosDelta = caretPos - caretPosOld, caretPosMin = maskCaretMap[0], caretPosMax = maskCaretMap[valUnmasked.length] || maskCaretMap.slice().shift(), selectionLenOld = oldSelectionLength || 0, isSelected = getSelectionLength(this) > 0, wasSelected = selectionLenOld > 0, isAddition = val.length > valOld.length || selectionLenOld && val.length > valOld.length - selectionLenOld, isDeletion = val.length < valOld.length || selectionLenOld && val.length === valOld.length - selectionLenOld, isSelection = eventWhich >= 37 && eventWhich <= 40 && e.shiftKey, isKeyLeftArrow = eventWhich === 37, isKeyBackspace = eventWhich === 8 || eventType !== "keyup" && isDeletion && caretPosDelta === -1, isKeyDelete = eventWhich === 46 || eventType !== "keyup" && isDeletion && caretPosDelta === 0 && !wasSelected, caretBumpBack = (isKeyLeftArrow || isKeyBackspace || eventType === "click") && caretPos > caretPosMin;
                    oldSelectionLength = getSelectionLength(this);
                    if (isSelection || isSelected && (eventType === "click" || eventType === "keyup")) {
                        return;
                    }
                    if (eventType === "input" && isDeletion && !wasSelected && valUnmasked === valUnmaskedOld) {
                        while (isKeyBackspace && caretPos > caretPosMin && !isValidCaretPosition(caretPos)) {
                            caretPos--;
                        }
                        while (isKeyDelete && caretPos < caretPosMax && maskCaretMap.indexOf(caretPos) === -1) {
                            caretPos++;
                        }
                        var charIndex = maskCaretMap.indexOf(caretPos);
                        valUnmasked = valUnmasked.substring(0, charIndex) + valUnmasked.substring(charIndex + 1);
                        valAltered = true;
                    }
                    valMasked = maskValue(valUnmasked);
                    oldValue = valMasked;
                    oldValueUnmasked = valUnmasked;
                    iElement.val(valMasked);
                    if (valAltered) {
                        scope.$apply(function() {
                            controller.$setViewValue(valUnmasked);
                        });
                    }
                    if (isAddition && caretPos <= caretPosMin) {
                        caretPos = caretPosMin + 1;
                    }
                    if (caretBumpBack) {
                        caretPos--;
                    }
                    caretPos = caretPos > caretPosMax ? caretPosMax : caretPos < caretPosMin ? caretPosMin : caretPos;
                    while (!isValidCaretPosition(caretPos) && caretPos > caretPosMin && caretPos < caretPosMax) {
                        caretPos += caretBumpBack ? -1 : 1;
                    }
                    if (caretBumpBack && caretPos < caretPosMax || isAddition && !isValidCaretPosition(caretPosOld)) {
                        caretPos++;
                    }
                    oldCaretPosition = caretPos;
                    setCaretPosition(this, caretPos);
                }
                function isValidCaretPosition(pos) {
                    return maskCaretMap.indexOf(pos) > -1;
                }
                function getCaretPosition(input) {
                    if (!input) return 0;
                    if (input.selectionStart !== undefined) {
                        return input.selectionStart;
                    } else if (document.selection) {
                        input.focus();
                        var selection = document.selection.createRange();
                        selection.moveStart("character", input.value ? -input.value.length : 0);
                        return selection.text.length;
                    }
                    return 0;
                }
                function setCaretPosition(input, pos) {
                    if (!input) return 0;
                    if (input.offsetWidth === 0 || input.offsetHeight === 0) {
                        return;
                    }
                    if (input.setSelectionRange) {
                        input.focus();
                        input.setSelectionRange(pos, pos);
                    } else if (input.createTextRange) {
                        var range = input.createTextRange();
                        range.collapse(true);
                        range.moveEnd("character", pos);
                        range.moveStart("character", pos);
                        range.select();
                    }
                }
                function getSelectionLength(input) {
                    if (!input) return 0;
                    if (input.selectionStart !== undefined) {
                        return input.selectionEnd - input.selectionStart;
                    }
                    if (document.selection) {
                        return document.selection.createRange().text.length;
                    }
                    return 0;
                }
                if (!Array.prototype.indexOf) {
                    Array.prototype.indexOf = function(searchElement) {
                        if (this === null) {
                            throw new TypeError();
                        }
                        var t = Object(this);
                        var len = t.length >>> 0;
                        if (len === 0) {
                            return -1;
                        }
                        var n = 0;
                        if (arguments.length > 1) {
                            n = Number(arguments[1]);
                            if (n !== n) {
                                n = 0;
                            } else if (n !== 0 && n !== Infinity && n !== -Infinity) {
                                n = (n > 0 || -1) * Math.floor(Math.abs(n));
                            }
                        }
                        if (n >= len) {
                            return -1;
                        }
                        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
                        for (;k < len; k++) {
                            if (k in t && t[k] === searchElement) {
                                return k;
                            }
                        }
                        return -1;
                    };
                }
            };
        }
    };
} ]);

angular.module("ui.reset", []).value("uiResetConfig", null).directive("uiReset", [ "uiResetConfig", function(uiResetConfig) {
    "use strict";
    var resetValue = null;
    if (uiResetConfig !== undefined) {
        resetValue = uiResetConfig;
    }
    return {
        require: "ngModel",
        link: function(scope, elm, attrs, ctrl) {
            var aElement;
            aElement = angular.element('<a class="ui-reset" />');
            elm.wrap('<span class="ui-resetwrap" />').after(aElement);
            aElement.bind("click", function(e) {
                e.preventDefault();
                scope.$apply(function() {
                    if (attrs.uiReset) {
                        ctrl.$setViewValue(scope.$eval(attrs.uiReset));
                    } else {
                        ctrl.$setViewValue(resetValue);
                    }
                    ctrl.$render();
                });
            });
        }
    };
} ]);

angular.module("ui.route", []).directive("uiRoute", [ "$location", "$parse", function($location, $parse) {
    "use strict";
    return {
        restrict: "AC",
        scope: true,
        compile: function(tElement, tAttrs) {
            var useProperty;
            if (tAttrs.uiRoute) {
                useProperty = "uiRoute";
            } else if (tAttrs.ngHref) {
                useProperty = "ngHref";
            } else if (tAttrs.href) {
                useProperty = "href";
            } else {
                throw new Error("uiRoute missing a route or href property on " + tElement[0]);
            }
            return function($scope, elm, attrs) {
                var modelSetter = $parse(attrs.ngModel || attrs.routeModel || "$uiRoute").assign;
                var watcher = angular.noop;
                function staticWatcher(newVal) {
                    var hash = newVal.indexOf("#");
                    if (hash > -1) {
                        newVal = newVal.substr(hash + 1);
                    }
                    watcher = function watchHref() {
                        modelSetter($scope, $location.path().indexOf(newVal) > -1);
                    };
                    watcher();
                }
                function regexWatcher(newVal) {
                    var hash = newVal.indexOf("#");
                    if (hash > -1) {
                        newVal = newVal.substr(hash + 1);
                    }
                    watcher = function watchRegex() {
                        var regexp = new RegExp("^" + newVal + "$", [ "i" ]);
                        modelSetter($scope, regexp.test($location.path()));
                    };
                    watcher();
                }
                switch (useProperty) {
                  case "uiRoute":
                    if (attrs.uiRoute) {
                        regexWatcher(attrs.uiRoute);
                    } else {
                        attrs.$observe("uiRoute", regexWatcher);
                    }
                    break;

                  case "ngHref":
                    if (attrs.ngHref) {
                        staticWatcher(attrs.ngHref);
                    } else {
                        attrs.$observe("ngHref", staticWatcher);
                    }
                    break;

                  case "href":
                    staticWatcher(attrs.href);
                }
                $scope.$on("$routeChangeSuccess", function() {
                    watcher();
                });
                $scope.$on("$stateChangeSuccess", function() {
                    watcher();
                });
            };
        }
    };
} ]);

angular.module("ui.scroll.jqlite", [ "ui.scroll" ]).service("jqLiteExtras", [ "$log", "$window", function(console, window) {
    "use strict";
    return {
        registerFor: function(element) {
            var convertToPx, css, getMeasurements, getStyle, getWidthHeight, isWindow, scrollTo;
            css = angular.element.prototype.css;
            element.prototype.css = function(name, value) {
                var elem, self;
                self = this;
                elem = self[0];
                if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {
                    return css.call(self, name, value);
                }
            };
            isWindow = function(obj) {
                return obj && obj.document && obj.location && obj.alert && obj.setInterval;
            };
            scrollTo = function(self, direction, value) {
                var elem, method, preserve, prop, _ref;
                elem = self[0];
                _ref = {
                    top: [ "scrollTop", "pageYOffset", "scrollLeft" ],
                    left: [ "scrollLeft", "pageXOffset", "scrollTop" ]
                }[direction], method = _ref[0], prop = _ref[1], preserve = _ref[2];
                if (isWindow(elem)) {
                    if (angular.isDefined(value)) {
                        return elem.scrollTo(self[preserve].call(self), value);
                    } else {
                        if (prop in elem) {
                            return elem[prop];
                        } else {
                            return elem.document.documentElement[method];
                        }
                    }
                } else {
                    if (angular.isDefined(value)) {
                        return elem[method] = value;
                    } else {
                        return elem[method];
                    }
                }
            };
            if (window.getComputedStyle) {
                getStyle = function(elem) {
                    return window.getComputedStyle(elem, null);
                };
                convertToPx = function(elem, value) {
                    return parseFloat(value);
                };
            } else {
                getStyle = function(elem) {
                    return elem.currentStyle;
                };
                convertToPx = function(elem, value) {
                    var core_pnum, left, result, rnumnonpx, rs, rsLeft, style;
                    core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
                    rnumnonpx = new RegExp("^(" + core_pnum + ")(?!px)[a-z%]+$", "i");
                    if (!rnumnonpx.test(value)) {
                        return parseFloat(value);
                    } else {
                        style = elem.style;
                        left = style.left;
                        rs = elem.runtimeStyle;
                        rsLeft = rs && rs.left;
                        if (rs) {
                            rs.left = style.left;
                        }
                        style.left = value;
                        result = style.pixelLeft;
                        style.left = left;
                        if (rsLeft) {
                            rs.left = rsLeft;
                        }
                        return result;
                    }
                };
            }
            getMeasurements = function(elem, measure) {
                var base, borderA, borderB, computedMarginA, computedMarginB, computedStyle, dirA, dirB, marginA, marginB, paddingA, paddingB, _ref;
                if (isWindow(elem)) {
                    base = document.documentElement[{
                        height: "clientHeight",
                        width: "clientWidth"
                    }[measure]];
                    return {
                        base: base,
                        padding: 0,
                        border: 0,
                        margin: 0
                    };
                }
                _ref = {
                    width: [ elem.offsetWidth, "Left", "Right" ],
                    height: [ elem.offsetHeight, "Top", "Bottom" ]
                }[measure], base = _ref[0], dirA = _ref[1], dirB = _ref[2];
                computedStyle = getStyle(elem);
                paddingA = convertToPx(elem, computedStyle["padding" + dirA]) || 0;
                paddingB = convertToPx(elem, computedStyle["padding" + dirB]) || 0;
                borderA = convertToPx(elem, computedStyle["border" + dirA + "Width"]) || 0;
                borderB = convertToPx(elem, computedStyle["border" + dirB + "Width"]) || 0;
                computedMarginA = computedStyle["margin" + dirA];
                computedMarginB = computedStyle["margin" + dirB];
                marginA = convertToPx(elem, computedMarginA) || 0;
                marginB = convertToPx(elem, computedMarginB) || 0;
                return {
                    base: base,
                    padding: paddingA + paddingB,
                    border: borderA + borderB,
                    margin: marginA + marginB
                };
            };
            getWidthHeight = function(elem, direction, measure) {
                var computedStyle, measurements, result;
                measurements = getMeasurements(elem, direction);
                if (measurements.base > 0) {
                    return {
                        base: measurements.base - measurements.padding - measurements.border,
                        outer: measurements.base,
                        outerfull: measurements.base + measurements.margin
                    }[measure];
                } else {
                    computedStyle = getStyle(elem);
                    result = computedStyle[direction];
                    if (result < 0 || result === null) {
                        result = elem.style[direction] || 0;
                    }
                    result = parseFloat(result) || 0;
                    return {
                        base: result - measurements.padding - measurements.border,
                        outer: result,
                        outerfull: result + measurements.padding + measurements.border + measurements.margin
                    }[measure];
                }
            };
            return angular.forEach({
                before: function(newElem) {
                    var children, elem, i, parent, self, _i, _ref;
                    self = this;
                    elem = self[0];
                    parent = self.parent();
                    children = parent.contents();
                    if (children[0] === elem) {
                        return parent.prepend(newElem);
                    } else {
                        for (i = _i = 1, _ref = children.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
                            if (children[i] === elem) {
                                angular.element(children[i - 1]).after(newElem);
                                return;
                            }
                        }
                        throw new Error("invalid DOM structure " + elem.outerHTML);
                    }
                },
                height: function(value) {
                    var self;
                    self = this;
                    if (angular.isDefined(value)) {
                        if (angular.isNumber(value)) {
                            value = value + "px";
                        }
                        return css.call(self, "height", value);
                    } else {
                        return getWidthHeight(this[0], "height", "base");
                    }
                },
                outerHeight: function(option) {
                    return getWidthHeight(this[0], "height", option ? "outerfull" : "outer");
                },
                offset: function(value) {
                    var box, doc, docElem, elem, self, win;
                    self = this;
                    if (arguments.length) {
                        if (value === void 0) {
                            return self;
                        } else {
                            throw new Error("offset setter method is not implemented");
                        }
                    }
                    box = {
                        top: 0,
                        left: 0
                    };
                    elem = self[0];
                    doc = elem && elem.ownerDocument;
                    if (!doc) {
                        return;
                    }
                    docElem = doc.documentElement;
                    if (elem.getBoundingClientRect != null) {
                        box = elem.getBoundingClientRect();
                    }
                    win = doc.defaultView || doc.parentWindow;
                    return {
                        top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
                        left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
                    };
                },
                scrollTop: function(value) {
                    return scrollTo(this, "top", value);
                },
                scrollLeft: function(value) {
                    return scrollTo(this, "left", value);
                }
            }, function(value, key) {
                if (!element.prototype[key]) {
                    return element.prototype[key] = value;
                }
            });
        }
    };
} ]).run([ "$log", "$window", "jqLiteExtras", function(console, window, jqLiteExtras) {
    "use strict";
    if (!window.jQuery) {
        return jqLiteExtras.registerFor(angular.element);
    }
} ]);

angular.module("ui.scroll", []).directive("uiScrollViewport", [ "$log", function() {
    "use strict";
    return {
        controller: [ "$scope", "$element", function(scope, element) {
            this.viewport = element;
            return this;
        } ]
    };
} ]).directive("uiScroll", [ "$log", "$injector", "$rootScope", "$timeout", function(console, $injector, $rootScope, $timeout) {
    "use strict";
    return {
        require: [ "?^uiScrollViewport" ],
        transclude: "element",
        priority: 1e3,
        terminal: true,
        compile: function(elementTemplate, attr, linker) {
            return function($scope, element, $attr, controllers) {
                var adapter, adapterOnScope, adjustBuffer, adjustRowHeight, applyUpdate, bof, bottomVisiblePos, buffer, bufferPadding, bufferSize, builder, clipBottom, clipTop, datasource, datasourceName, doAdjustment, doDelete, doInsert, doUpdate, enqueueFetch, eof, eventListener, fetch, finalize, first, getValueChain, hideElementBeforeAppend, insert, isDatasourceValid, itemName, loading, log, match, next, pending, reload, removeFromBuffer, resizeAndScrollHandler, ridActual, scrollHeight, setValueChain, shouldLoadBottom, shouldLoadTop, showElementAfterRender, topVisible, topVisiblePos, viewport, viewportScope, wheelHandler;
                log = console.debug || console.log;
                match = $attr.uiScroll.match(/^\s*(\w+)\s+in\s+([\w\.]+)\s*$/);
                if (!match) {
                    throw new Error("Expected uiScroll in form of '_item_ in _datasource_' but got '" + $attr.uiScroll + "'");
                }
                itemName = match[1];
                datasourceName = match[2];
                getValueChain = function(targetScope, target) {
                    var chain;
                    if (!targetScope) {
                        return;
                    }
                    chain = target.match(/^([\w]+)\.(.+)$/);
                    if (!chain || chain.length !== 3) {
                        return targetScope[target];
                    }
                    return getValueChain(targetScope[chain[1]], chain[2]);
                };
                setValueChain = function(targetScope, target, value, doNotSet) {
                    var chain;
                    if (!targetScope || !target) {
                        return;
                    }
                    if (!(chain = target.match(/^([\w]+)\.(.+)$/))) {
                        if (target.indexOf(".") !== -1) {
                            return;
                        }
                    }
                    if (!chain || chain.length !== 3) {
                        if (!angular.isObject(targetScope[target]) && !doNotSet) {
                            return targetScope[target] = value;
                        }
                        return targetScope[target] = value;
                    }
                    if (!angular.isObject(targetScope[chain[1]]) && !doNotSet) {
                        targetScope[chain[1]] = {};
                    }
                    return setValueChain(targetScope[chain[1]], chain[2], value, doNotSet);
                };
                datasource = getValueChain($scope, datasourceName);
                isDatasourceValid = function() {
                    return angular.isObject(datasource) && typeof datasource.get === "function";
                };
                if (!isDatasourceValid()) {
                    datasource = $injector.get(datasourceName);
                    if (!isDatasourceValid()) {
                        throw new Error("" + datasourceName + " is not a valid datasource");
                    }
                }
                bufferSize = Math.max(3, +$attr.bufferSize || 10);
                bufferPadding = function() {
                    return viewport.outerHeight() * Math.max(.1, +$attr.padding || .1);
                };
                scrollHeight = function(elem) {
                    var _ref;
                    return (_ref = elem[0].scrollHeight) != null ? _ref : elem[0].document.documentElement.scrollHeight;
                };
                builder = null;
                linker($scope.$new(), function(template) {
                    var bottomPadding, createPadding, padding, repeaterType, topPadding, viewport;
                    repeaterType = template[0].localName;
                    if (repeaterType === "dl") {
                        throw new Error("ui-scroll directive does not support <" + template[0].localName + "> as a repeating tag: " + template[0].outerHTML);
                    }
                    if (repeaterType !== "li" && repeaterType !== "tr") {
                        repeaterType = "div";
                    }
                    viewport = controllers[0] && controllers[0].viewport ? controllers[0].viewport : angular.element(window);
                    viewport.css({
                        "overflow-y": "auto",
                        display: "block"
                    });
                    padding = function(repeaterType) {
                        var div, result, table;
                        switch (repeaterType) {
                          case "tr":
                            table = angular.element("<table><tr><td><div></div></td></tr></table>");
                            div = table.find("div");
                            result = table.find("tr");
                            result.paddingHeight = function() {
                                return div.height.apply(div, arguments);
                            };
                            return result;

                          default:
                            result = angular.element("<" + repeaterType + "></" + repeaterType + ">");
                            result.paddingHeight = result.height;
                            return result;
                        }
                    };
                    createPadding = function(padding, element, direction) {
                        element[{
                            top: "before",
                            bottom: "after"
                        }[direction]](padding);
                        return {
                            paddingHeight: function() {
                                return padding.paddingHeight.apply(padding, arguments);
                            },
                            insert: function(element) {
                                return padding[{
                                    top: "after",
                                    bottom: "before"
                                }[direction]](element);
                            }
                        };
                    };
                    topPadding = createPadding(padding(repeaterType), element, "top");
                    bottomPadding = createPadding(padding(repeaterType), element, "bottom");
                    $scope.$on("$destroy", template.remove);
                    return builder = {
                        viewport: viewport,
                        topPadding: topPadding.paddingHeight,
                        bottomPadding: bottomPadding.paddingHeight,
                        append: bottomPadding.insert,
                        prepend: topPadding.insert,
                        bottomDataPos: function() {
                            return scrollHeight(viewport) - bottomPadding.paddingHeight();
                        },
                        topDataPos: function() {
                            return topPadding.paddingHeight();
                        }
                    };
                });
                viewport = builder.viewport;
                viewportScope = viewport.scope() || $rootScope;
                topVisible = function(item) {
                    adapter.topVisible = item.scope[itemName];
                    adapter.topVisibleElement = item.element;
                    adapter.topVisibleScope = item.scope;
                    if ($attr.topVisible) {
                        setValueChain(viewportScope, $attr.topVisible, adapter.topVisible);
                    }
                    if ($attr.topVisibleElement) {
                        setValueChain(viewportScope, $attr.topVisibleElement, adapter.topVisibleElement);
                    }
                    if ($attr.topVisibleScope) {
                        setValueChain(viewportScope, $attr.topVisibleScope, adapter.topVisibleScope);
                    }
                    if (typeof datasource.topVisible === "function") {
                        return datasource.topVisible(item);
                    }
                };
                loading = function(value) {
                    adapter.isLoading = value;
                    if ($attr.isLoading) {
                        setValueChain($scope, $attr.isLoading, value);
                    }
                    if (typeof datasource.loading === "function") {
                        return datasource.loading(value);
                    }
                };
                ridActual = 0;
                first = 1;
                next = 1;
                buffer = [];
                pending = [];
                eof = false;
                bof = false;
                removeFromBuffer = function(start, stop) {
                    var i, _i;
                    for (i = _i = start; start <= stop ? _i < stop : _i > stop; i = start <= stop ? ++_i : --_i) {
                        buffer[i].scope.$destroy();
                        buffer[i].element.remove();
                    }
                    return buffer.splice(start, stop - start);
                };
                reload = function() {
                    ridActual++;
                    first = 1;
                    next = 1;
                    removeFromBuffer(0, buffer.length);
                    builder.topPadding(0);
                    builder.bottomPadding(0);
                    pending = [];
                    eof = false;
                    bof = false;
                    return adjustBuffer(ridActual);
                };
                bottomVisiblePos = function() {
                    return viewport.scrollTop() + viewport.outerHeight();
                };
                topVisiblePos = function() {
                    return viewport.scrollTop();
                };
                shouldLoadBottom = function() {
                    return !eof && builder.bottomDataPos() < bottomVisiblePos() + bufferPadding();
                };
                clipBottom = function() {
                    var bottomHeight, i, item, itemHeight, itemTop, newRow, overage, rowTop, _i, _ref;
                    bottomHeight = 0;
                    overage = 0;
                    for (i = _i = _ref = buffer.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
                        item = buffer[i];
                        itemTop = item.element.offset().top;
                        newRow = rowTop !== itemTop;
                        rowTop = itemTop;
                        if (newRow) {
                            itemHeight = item.element.outerHeight(true);
                        }
                        if (builder.bottomDataPos() - bottomHeight - itemHeight > bottomVisiblePos() + bufferPadding()) {
                            if (newRow) {
                                bottomHeight += itemHeight;
                            }
                            overage++;
                            eof = false;
                        } else {
                            if (newRow) {
                                break;
                            }
                            overage++;
                        }
                    }
                    if (overage > 0) {
                        builder.bottomPadding(builder.bottomPadding() + bottomHeight);
                        removeFromBuffer(buffer.length - overage, buffer.length);
                        return next -= overage;
                    }
                };
                shouldLoadTop = function() {
                    return !bof && builder.topDataPos() > topVisiblePos() - bufferPadding();
                };
                clipTop = function() {
                    var item, itemHeight, itemTop, newRow, overage, rowTop, topHeight, _i, _len;
                    topHeight = 0;
                    overage = 0;
                    for (_i = 0, _len = buffer.length; _i < _len; _i++) {
                        item = buffer[_i];
                        itemTop = item.element.offset().top;
                        newRow = rowTop !== itemTop;
                        rowTop = itemTop;
                        if (newRow) {
                            itemHeight = item.element.outerHeight(true);
                        }
                        if (builder.topDataPos() + topHeight + itemHeight < topVisiblePos() - bufferPadding()) {
                            if (newRow) {
                                topHeight += itemHeight;
                            }
                            overage++;
                            bof = false;
                        } else {
                            if (newRow) {
                                break;
                            }
                            overage++;
                        }
                    }
                    if (overage > 0) {
                        builder.topPadding(builder.topPadding() + topHeight);
                        removeFromBuffer(0, overage);
                        return first += overage;
                    }
                };
                enqueueFetch = function(rid, direction) {
                    if (!adapter.isLoading) {
                        loading(true);
                    }
                    if (pending.push(direction) === 1) {
                        return fetch(rid);
                    }
                };
                hideElementBeforeAppend = function(element) {
                    element.displayTemp = element.css("display");
                    return element.css("display", "none");
                };
                showElementAfterRender = function(element) {
                    if (element.hasOwnProperty("displayTemp")) {
                        return element.css("display", element.displayTemp);
                    }
                };
                insert = function(index, item) {
                    var itemScope, toBeAppended, wrapper;
                    itemScope = $scope.$new();
                    itemScope[itemName] = item;
                    toBeAppended = index > first;
                    itemScope.$index = index;
                    if (toBeAppended) {
                        itemScope.$index--;
                    }
                    wrapper = {
                        scope: itemScope
                    };
                    linker(itemScope, function(clone) {
                        wrapper.element = clone;
                        if (toBeAppended) {
                            if (index === next) {
                                hideElementBeforeAppend(clone);
                                builder.append(clone);
                                return buffer.push(wrapper);
                            } else {
                                buffer[index - first].element.after(clone);
                                return buffer.splice(index - first + 1, 0, wrapper);
                            }
                        } else {
                            hideElementBeforeAppend(clone);
                            builder.prepend(clone);
                            return buffer.unshift(wrapper);
                        }
                    });
                    return {
                        appended: toBeAppended,
                        wrapper: wrapper
                    };
                };
                adjustRowHeight = function(appended, wrapper) {
                    var newHeight;
                    if (appended) {
                        return builder.bottomPadding(Math.max(0, builder.bottomPadding() - wrapper.element.outerHeight(true)));
                    } else {
                        newHeight = builder.topPadding() - wrapper.element.outerHeight(true);
                        if (newHeight >= 0) {
                            return builder.topPadding(newHeight);
                        } else {
                            return viewport.scrollTop(viewport.scrollTop() + wrapper.element.outerHeight(true));
                        }
                    }
                };
                doAdjustment = function(rid, finalize) {
                    var item, itemHeight, itemTop, newRow, rowTop, topHeight, _i, _len, _results;
                    if (shouldLoadBottom()) {
                        enqueueFetch(rid, true);
                    } else {
                        if (shouldLoadTop()) {
                            enqueueFetch(rid, false);
                        }
                    }
                    if (finalize) {
                        finalize(rid);
                    }
                    if (pending.length === 0) {
                        topHeight = 0;
                        _results = [];
                        for (_i = 0, _len = buffer.length; _i < _len; _i++) {
                            item = buffer[_i];
                            itemTop = item.element.offset().top;
                            newRow = rowTop !== itemTop;
                            rowTop = itemTop;
                            if (newRow) {
                                itemHeight = item.element.outerHeight(true);
                            }
                            if (newRow && builder.topDataPos() + topHeight + itemHeight < topVisiblePos()) {
                                _results.push(topHeight += itemHeight);
                            } else {
                                if (newRow) {
                                    topVisible(item);
                                }
                                break;
                            }
                        }
                        return _results;
                    }
                };
                adjustBuffer = function(rid, newItems, finalize) {
                    if (newItems && newItems.length) {
                        return $timeout(function() {
                            var elt, itemTop, row, rowTop, rows, _i, _j, _len, _len1;
                            rows = [];
                            for (_i = 0, _len = newItems.length; _i < _len; _i++) {
                                row = newItems[_i];
                                elt = row.wrapper.element;
                                showElementAfterRender(elt);
                                itemTop = elt.offset().top;
                                if (rowTop !== itemTop) {
                                    rows.push(row);
                                    rowTop = itemTop;
                                }
                            }
                            for (_j = 0, _len1 = rows.length; _j < _len1; _j++) {
                                row = rows[_j];
                                adjustRowHeight(row.appended, row.wrapper);
                            }
                            return doAdjustment(rid, finalize);
                        });
                    } else {
                        return doAdjustment(rid, finalize);
                    }
                };
                finalize = function(rid, newItems) {
                    return adjustBuffer(rid, newItems, function() {
                        pending.shift();
                        if (pending.length === 0) {
                            return loading(false);
                        } else {
                            return fetch(rid);
                        }
                    });
                };
                fetch = function(rid) {
                    var direction;
                    direction = pending[0];
                    if (direction) {
                        if (buffer.length && !shouldLoadBottom()) {
                            return finalize(rid);
                        } else {
                            return datasource.get(next, bufferSize, function(result) {
                                var item, newItems, _i, _len;
                                if (rid && rid !== ridActual || $scope.$$destroyed) {
                                    return;
                                }
                                newItems = [];
                                if (result.length < bufferSize) {
                                    eof = true;
                                    builder.bottomPadding(0);
                                }
                                if (result.length > 0) {
                                    clipTop();
                                    for (_i = 0, _len = result.length; _i < _len; _i++) {
                                        item = result[_i];
                                        newItems.push(insert(++next, item));
                                    }
                                }
                                return finalize(rid, newItems);
                            });
                        }
                    } else {
                        if (buffer.length && !shouldLoadTop()) {
                            return finalize(rid);
                        } else {
                            return datasource.get(first - bufferSize, bufferSize, function(result) {
                                var i, newItems, _i, _ref;
                                if (rid && rid !== ridActual || $scope.$$destroyed) {
                                    return;
                                }
                                newItems = [];
                                if (result.length < bufferSize) {
                                    bof = true;
                                    builder.topPadding(0);
                                }
                                if (result.length > 0) {
                                    if (buffer.length) {
                                        clipBottom();
                                    }
                                    for (i = _i = _ref = result.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
                                        newItems.unshift(insert(--first, result[i]));
                                    }
                                }
                                return finalize(rid, newItems);
                            });
                        }
                    }
                };
                resizeAndScrollHandler = function() {
                    if (!$rootScope.$$phase && !adapter.isLoading) {
                        adjustBuffer();
                        return $scope.$apply();
                    }
                };
                wheelHandler = function(event) {
                    var scrollTop, yMax;
                    scrollTop = viewport[0].scrollTop;
                    yMax = viewport[0].scrollHeight - viewport[0].clientHeight;
                    if (scrollTop === 0 && !bof || scrollTop === yMax && !eof) {
                        return event.preventDefault();
                    }
                };
                viewport.bind("resize", resizeAndScrollHandler);
                viewport.bind("scroll", resizeAndScrollHandler);
                viewport.bind("mousewheel", wheelHandler);
                $scope.$watch(datasource.revision, reload);
                if (datasource.scope) {
                    eventListener = datasource.scope.$new();
                } else {
                    eventListener = $scope.$new();
                }
                $scope.$on("$destroy", function() {
                    var item, _i, _len;
                    for (_i = 0, _len = buffer.length; _i < _len; _i++) {
                        item = buffer[_i];
                        item.scope.$destroy();
                        item.element.remove();
                    }
                    viewport.unbind("resize", resizeAndScrollHandler);
                    viewport.unbind("scroll", resizeAndScrollHandler);
                    return viewport.unbind("mousewheel", wheelHandler);
                });
                adapter = {};
                adapter.isLoading = false;
                applyUpdate = function(wrapper, newItems) {
                    var i, inserted, item, ndx, newItem, oldItemNdx, _i, _j, _k, _len, _len1, _len2;
                    inserted = [];
                    if (angular.isArray(newItems)) {
                        if (newItems.length) {
                            if (newItems.length === 1 && newItems[0] === wrapper.scope[itemName]) {
                                return inserted;
                            } else {
                                ndx = wrapper.scope.$index;
                                if (ndx > first) {
                                    oldItemNdx = ndx - first;
                                } else {
                                    oldItemNdx = 1;
                                }
                                for (i = _i = 0, _len = newItems.length; _i < _len; i = ++_i) {
                                    newItem = newItems[i];
                                    inserted.push(insert(ndx + i, newItem));
                                }
                                removeFromBuffer(oldItemNdx, oldItemNdx + 1);
                                for (i = _j = 0, _len1 = buffer.length; _j < _len1; i = ++_j) {
                                    item = buffer[i];
                                    item.scope.$index = first + i;
                                }
                            }
                        } else {
                            removeFromBuffer(wrapper.scope.$index - first, wrapper.scope.$index - first + 1);
                            next--;
                            for (i = _k = 0, _len2 = buffer.length; _k < _len2; i = ++_k) {
                                item = buffer[i];
                                item.scope.$index = first + i;
                            }
                        }
                    }
                    return inserted;
                };
                adapter.applyUpdates = function(arg1, arg2) {
                    var inserted, wrapper, _i, _len, _ref, _ref1;
                    inserted = [];
                    ridActual++;
                    if (angular.isFunction(arg1)) {
                        _ref = buffer.slice(0);
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            wrapper = _ref[_i];
                            inserted.concat(inserted, applyUpdate(wrapper, arg1(wrapper.scope[itemName], wrapper.scope, wrapper.element)));
                        }
                    } else {
                        if (arg1 % 1 === 0) {
                            if (0 <= (_ref1 = arg1 - first - 1) && _ref1 < buffer.length) {
                                inserted = applyUpdate(buffer[arg1 - first], arg2);
                            }
                        } else {
                            throw new Error("applyUpdates - " + arg1 + " is not a valid index or outside of range");
                        }
                    }
                    return adjustBuffer(ridActual, inserted);
                };
                if ($attr.adapter) {
                    adapterOnScope = getValueChain($scope, $attr.adapter);
                    if (!adapterOnScope) {
                        setValueChain($scope, $attr.adapter, {});
                        adapterOnScope = getValueChain($scope, $attr.adapter);
                    }
                    angular.extend(adapterOnScope, adapter);
                    adapter = adapterOnScope;
                }
                doUpdate = function(locator, newItem) {
                    var wrapper, _fn, _i, _len, _ref;
                    if (angular.isFunction(locator)) {
                        _fn = function(wrapper) {
                            return locator(wrapper.scope);
                        };
                        for (_i = 0, _len = buffer.length; _i < _len; _i++) {
                            wrapper = buffer[_i];
                            _fn(wrapper);
                        }
                    } else {
                        if (0 <= (_ref = locator - first - 1) && _ref < buffer.length) {
                            buffer[locator - first - 1].scope[itemName] = newItem;
                        }
                    }
                    return null;
                };
                doDelete = function(locator) {
                    var i, item, temp, wrapper, _fn, _i, _j, _k, _len, _len1, _len2, _ref;
                    if (angular.isFunction(locator)) {
                        temp = [];
                        for (_i = 0, _len = buffer.length; _i < _len; _i++) {
                            item = buffer[_i];
                            temp.unshift(item);
                        }
                        _fn = function(wrapper) {
                            if (locator(wrapper.scope)) {
                                removeFromBuffer(temp.length - 1 - i, temp.length - i);
                                return next--;
                            }
                        };
                        for (i = _j = 0, _len1 = temp.length; _j < _len1; i = ++_j) {
                            wrapper = temp[i];
                            _fn(wrapper);
                        }
                    } else {
                        if (0 <= (_ref = locator - first - 1) && _ref < buffer.length) {
                            removeFromBuffer(locator - first - 1, locator - first);
                            next--;
                        }
                    }
                    for (i = _k = 0, _len2 = buffer.length; _k < _len2; i = ++_k) {
                        item = buffer[i];
                        item.scope.$index = first + i;
                    }
                    return adjustBuffer();
                };
                doInsert = function(locator, item) {
                    var i, inserted, _i, _len, _ref;
                    inserted = [];
                    if (angular.isFunction(locator)) {
                        throw new Error("not implemented - Insert with locator function");
                    } else {
                        if (0 <= (_ref = locator - first - 1) && _ref < buffer.length) {
                            inserted.push(insert(locator, item));
                            next++;
                        }
                    }
                    for (i = _i = 0, _len = buffer.length; _i < _len; i = ++_i) {
                        item = buffer[i];
                        item.scope.$index = first + i;
                    }
                    return adjustBuffer(null, inserted);
                };
                eventListener.$on("insert.item", function(event, locator, item) {
                    return doInsert(locator, item);
                });
                eventListener.$on("update.items", function(event, locator, newItem) {
                    return doUpdate(locator, newItem);
                });
                return eventListener.$on("delete.items", function(event, locator) {
                    return doDelete(locator);
                });
            };
        }
    };
} ]);

angular.module("ui.scrollfix", []).directive("uiScrollfix", [ "$window", function($window) {
    "use strict";
    function getWindowScrollTop() {
        if (angular.isDefined($window.pageYOffset)) {
            return $window.pageYOffset;
        } else {
            var iebody = document.compatMode && document.compatMode !== "BackCompat" ? document.documentElement : document.body;
            return iebody.scrollTop;
        }
    }
    return {
        require: "^?uiScrollfixTarget",
        link: function(scope, elm, attrs, uiScrollfixTarget) {
            var absolute = true, shift = 0, fixLimit, $target = uiScrollfixTarget && uiScrollfixTarget.$element || angular.element($window);
            if (!attrs.uiScrollfix) {
                absolute = false;
            } else if (typeof attrs.uiScrollfix === "string") {
                if (attrs.uiScrollfix.charAt(0) === "-") {
                    absolute = false;
                    shift = -parseFloat(attrs.uiScrollfix.substr(1));
                } else if (attrs.uiScrollfix.charAt(0) === "+") {
                    absolute = false;
                    shift = parseFloat(attrs.uiScrollfix.substr(1));
                }
            }
            fixLimit = absolute ? attrs.uiScrollfix : elm[0].offsetTop + shift;
            function onScroll() {
                var limit = absolute ? attrs.uiScrollfix : elm[0].offsetTop + shift;
                var offset = uiScrollfixTarget ? $target[0].scrollTop : getWindowScrollTop();
                if (!elm.hasClass("ui-scrollfix") && offset > limit) {
                    elm.addClass("ui-scrollfix");
                    fixLimit = limit;
                } else if (elm.hasClass("ui-scrollfix") && offset < fixLimit) {
                    elm.removeClass("ui-scrollfix");
                }
            }
            $target.on("scroll", onScroll);
            scope.$on("$destroy", function() {
                $target.off("scroll", onScroll);
            });
        }
    };
} ]).directive("uiScrollfixTarget", [ function() {
    "use strict";
    return {
        controller: [ "$element", function($element) {
            this.$element = $element;
        } ]
    };
} ]);

angular.module("ui.showhide", []).directive("uiShow", [ function() {
    "use strict";
    return function(scope, elm, attrs) {
        scope.$watch(attrs.uiShow, function(newVal) {
            if (newVal) {
                elm.addClass("ui-show");
            } else {
                elm.removeClass("ui-show");
            }
        });
    };
} ]).directive("uiHide", [ function() {
    "use strict";
    return function(scope, elm, attrs) {
        scope.$watch(attrs.uiHide, function(newVal) {
            if (newVal) {
                elm.addClass("ui-hide");
            } else {
                elm.removeClass("ui-hide");
            }
        });
    };
} ]).directive("uiToggle", [ function() {
    "use strict";
    return function(scope, elm, attrs) {
        scope.$watch(attrs.uiToggle, function(newVal) {
            if (newVal) {
                elm.removeClass("ui-hide").addClass("ui-show");
            } else {
                elm.removeClass("ui-show").addClass("ui-hide");
            }
        });
    };
} ]);

angular.module("ui.unique", []).filter("unique", [ "$parse", function($parse) {
    "use strict";
    return function(items, filterOn) {
        if (filterOn === false) {
            return items;
        }
        if ((filterOn || angular.isUndefined(filterOn)) && angular.isArray(items)) {
            var newItems = [], get = angular.isString(filterOn) ? $parse(filterOn) : function(item) {
                return item;
            };
            var extractValueToCompare = function(item) {
                return angular.isObject(item) ? get(item) : item;
            };
            angular.forEach(items, function(item) {
                var isDuplicate = false;
                for (var i = 0; i < newItems.length; i++) {
                    if (angular.equals(extractValueToCompare(newItems[i]), extractValueToCompare(item))) {
                        isDuplicate = true;
                        break;
                    }
                }
                if (!isDuplicate) {
                    newItems.push(item);
                }
            });
            items = newItems;
        }
        return items;
    };
} ]);

angular.module("ui.uploader", []).service("uiUploader", uiUploader);

uiUploader.$inject = [ "$log" ];

function uiUploader($log) {
    "use strict";
    var self = this;
    self.files = [];
    self.options = {};
    self.activeUploads = 0;
    $log.info("uiUploader loaded");
    function addFiles(files) {
        for (var i = 0; i < files.length; i++) {
            self.files.push(files[i]);
        }
    }
    function getFiles() {
        return self.files;
    }
    function startUpload(options) {
        self.options = options;
        for (var i = 0; i < self.files.length; i++) {
            if (self.activeUploads == self.options.concurrency) {
                break;
            }
            if (self.files[i].active) continue;
            ajaxUpload(self.files[i], self.options.url);
        }
    }
    function removeFile(file) {
        self.files.splice(self.files.indexOf(file), 1);
    }
    function removeAll() {
        self.files.splice(0, self.files.length);
    }
    return {
        addFiles: addFiles,
        getFiles: getFiles,
        files: self.files,
        startUpload: startUpload,
        removeFile: removeFile,
        removeAll: removeAll
    };
    function getHumanSize(bytes) {
        var sizes = [ "n/a", "bytes", "KiB", "MiB", "GiB", "TB", "PB", "EiB", "ZiB", "YiB" ];
        var i = +Math.floor(Math.log(bytes) / Math.log(1024));
        return (bytes / Math.pow(1024, i)).toFixed(i ? 1 : 0) + " " + sizes[isNaN(bytes) ? 0 : i + 1];
    }
    function ajaxUpload(file, url) {
        var xhr, formData, prop, data = "", key = "" || "file";
        self.activeUploads += 1;
        file.active = true;
        xhr = new window.XMLHttpRequest();
        formData = new window.FormData();
        xhr.open("POST", url);
        xhr.upload.onloadstart = function() {};
        xhr.upload.onprogress = function(event) {
            if (!event.lengthComputable) {
                return;
            }
            file.loaded = event.loaded;
            file.humanSize = getHumanSize(event.loaded);
            self.options.onProgress(file);
        };
        xhr.onload = function() {
            self.activeUploads -= 1;
            startUpload(self.options);
            self.options.onCompleted(file, xhr.responseText);
        };
        xhr.onerror = function() {};
        if (data) {
            for (prop in data) {
                if (data.hasOwnProperty(prop)) {
                    formData.append(prop, data[prop]);
                }
            }
        }
        formData.append(key, file, file.name);
        xhr.send(formData);
        return xhr;
    }
}

angular.module("ui.validate", []).directive("uiValidate", function() {
    "use strict";
    return {
        restrict: "A",
        require: "ngModel",
        link: function(scope, elm, attrs, ctrl) {
            var validateFn, validators = {}, validateExpr = scope.$eval(attrs.uiValidate);
            if (!validateExpr) {
                return;
            }
            if (angular.isString(validateExpr)) {
                validateExpr = {
                    validator: validateExpr
                };
            }
            angular.forEach(validateExpr, function(exprssn, key) {
                validateFn = function(valueToValidate) {
                    var expression = scope.$eval(exprssn, {
                        $value: valueToValidate
                    });
                    if (angular.isObject(expression) && angular.isFunction(expression.then)) {
                        expression.then(function() {
                            ctrl.$setValidity(key, true);
                        }, function() {
                            ctrl.$setValidity(key, false);
                        });
                        return valueToValidate;
                    } else if (expression) {
                        ctrl.$setValidity(key, true);
                        return valueToValidate;
                    } else {
                        ctrl.$setValidity(key, false);
                        return valueToValidate;
                    }
                };
                validators[key] = validateFn;
                ctrl.$formatters.push(validateFn);
                ctrl.$parsers.push(validateFn);
            });
            function apply_watch(watch) {
                if (angular.isString(watch)) {
                    scope.$watch(watch, function() {
                        angular.forEach(validators, function(validatorFn) {
                            validatorFn(ctrl.$modelValue);
                        });
                    });
                    return;
                }
                if (angular.isArray(watch)) {
                    angular.forEach(watch, function(expression) {
                        scope.$watch(expression, function() {
                            angular.forEach(validators, function(validatorFn) {
                                validatorFn(ctrl.$modelValue);
                            });
                        });
                    });
                    return;
                }
                if (angular.isObject(watch)) {
                    angular.forEach(watch, function(expression, validatorKey) {
                        if (angular.isString(expression)) {
                            scope.$watch(expression, function() {
                                validators[validatorKey](ctrl.$modelValue);
                            });
                        }
                        if (angular.isArray(expression)) {
                            angular.forEach(expression, function(intExpression) {
                                scope.$watch(intExpression, function() {
                                    validators[validatorKey](ctrl.$modelValue);
                                });
                            });
                        }
                    });
                }
            }
            if (attrs.uiValidateWatch) {
                apply_watch(scope.$eval(attrs.uiValidateWatch));
            }
        }
    };
});

angular.module("ui.utils", [ "ui.event", "ui.format", "ui.highlight", "ui.include", "ui.indeterminate", "ui.inflector", "ui.jq", "ui.keypress", "ui.mask", "ui.reset", "ui.route", "ui.scrollfix", "ui.scroll", "ui.scroll.jqlite", "ui.showhide", "ui.unique", "ui.validate" ]);

!function(a, b) {
    return "function" == typeof define && define.amd ? void define("angular-file-upload", [ "angular" ], function(a) {
        return b(a);
    }) : b(a);
}("undefined" == typeof angular ? null : angular, function(a) {
    var b = a.module("angularFileUpload", []);
    return b.value("fileUploaderOptions", {
        url: "/",
        alias: "file",
        headers: {},
        queue: [],
        progress: 0,
        autoUpload: !1,
        removeAfterUpload: !1,
        method: "POST",
        filters: [],
        formData: [],
        queueLimit: Number.MAX_VALUE,
        withCredentials: !1
    }).factory("FileUploader", [ "fileUploaderOptions", "$rootScope", "$http", "$window", "$compile", function(b, c, d, e, f) {
        function g(c) {
            var d = a.copy(b);
            a.extend(this, d, c, {
                isUploading: !1,
                _nextIndex: 0,
                _failFilterIndex: -1,
                _directives: {
                    select: [],
                    drop: [],
                    over: []
                }
            }), this.filters.unshift({
                name: "queueLimit",
                fn: this._queueLimitFilter
            }), this.filters.unshift({
                name: "folder",
                fn: this._folderFilter
            });
        }
        function h(b) {
            var c = a.isElement(b), d = c ? b.value : b, e = a.isString(d) ? "FakePath" : "Object", f = "_createFrom" + e;
            this[f](d);
        }
        function i(b, c, d) {
            var e = a.isElement(c), f = e ? a.element(c) : null, h = e ? null : c;
            a.extend(this, {
                url: b.url,
                alias: b.alias,
                headers: a.copy(b.headers),
                formData: a.copy(b.formData),
                removeAfterUpload: b.removeAfterUpload,
                withCredentials: b.withCredentials,
                method: b.method
            }, d, {
                uploader: b,
                file: new g.FileLikeObject(c),
                isReady: !1,
                isUploading: !1,
                isUploaded: !1,
                isSuccess: !1,
                isCancel: !1,
                isError: !1,
                progress: 0,
                index: null,
                _file: h,
                _input: f
            }), f && this._replaceNode(f);
        }
        function j(b) {
            a.extend(this, b), this.uploader._directives[this.prop].push(this), this._saveLinks(), 
            this.bind();
        }
        function k(a) {
            k.super_.apply(this, arguments), this.uploader.isHTML5 || this.element.removeAttr("multiple"), 
            this.element.prop("value", null);
        }
        function l(a) {
            l.super_.apply(this, arguments);
        }
        function m(a) {
            m.super_.apply(this, arguments);
        }
        return g.prototype.isHTML5 = !(!e.File || !e.FormData), g.prototype.addToQueue = function(b, c, d) {
            var e = this.isArrayLikeObject(b) ? b : [ b ], f = this._getFilters(d), h = this.queue.length, i = [];
            a.forEach(e, function(a) {
                var b = new g.FileLikeObject(a);
                if (this._isValidFile(b, f, c)) {
                    var d = new g.FileItem(this, a, c);
                    i.push(d), this.queue.push(d), this._onAfterAddingFile(d);
                } else {
                    var e = f[this._failFilterIndex];
                    this._onWhenAddingFileFailed(b, e, c);
                }
            }, this), this.queue.length !== h && (this._onAfterAddingAll(i), this.progress = this._getTotalProgress()), 
            this._render(), this.autoUpload && this.uploadAll();
        }, g.prototype.removeFromQueue = function(a) {
            var b = this.getIndexOfItem(a), c = this.queue[b];
            c.isUploading && c.cancel(), this.queue.splice(b, 1), c._destroy(), this.progress = this._getTotalProgress();
        }, g.prototype.clearQueue = function() {
            for (;this.queue.length; ) this.queue[0].remove();
            this.progress = 0;
        }, g.prototype.uploadItem = function(a) {
            var b = this.getIndexOfItem(a), c = this.queue[b], d = this.isHTML5 ? "_xhrTransport" : "_iframeTransport";
            c._prepareToUploading(), this.isUploading || (this.isUploading = !0, this[d](c));
        }, g.prototype.cancelItem = function(a) {
            var b = this.getIndexOfItem(a), c = this.queue[b], d = this.isHTML5 ? "_xhr" : "_form";
            c && c.isUploading && c[d].abort();
        }, g.prototype.uploadAll = function() {
            var b = this.getNotUploadedItems().filter(function(a) {
                return !a.isUploading;
            });
            b.length && (a.forEach(b, function(a) {
                a._prepareToUploading();
            }), b[0].upload());
        }, g.prototype.cancelAll = function() {
            var b = this.getNotUploadedItems();
            a.forEach(b, function(a) {
                a.cancel();
            });
        }, g.prototype.isFile = function(a) {
            var b = e.File;
            return b && a instanceof b;
        }, g.prototype.isFileLikeObject = function(a) {
            return a instanceof g.FileLikeObject;
        }, g.prototype.isArrayLikeObject = function(b) {
            return a.isObject(b) && "length" in b;
        }, g.prototype.getIndexOfItem = function(b) {
            return a.isNumber(b) ? b : this.queue.indexOf(b);
        }, g.prototype.getNotUploadedItems = function() {
            return this.queue.filter(function(a) {
                return !a.isUploaded;
            });
        }, g.prototype.getReadyItems = function() {
            return this.queue.filter(function(a) {
                return a.isReady && !a.isUploading;
            }).sort(function(a, b) {
                return a.index - b.index;
            });
        }, g.prototype.destroy = function() {
            a.forEach(this._directives, function(b) {
                a.forEach(this._directives[b], function(a) {
                    a.destroy();
                }, this);
            }, this);
        }, g.prototype.onAfterAddingAll = function(a) {}, g.prototype.onAfterAddingFile = function(a) {}, 
        g.prototype.onWhenAddingFileFailed = function(a, b, c) {}, g.prototype.onBeforeUploadItem = function(a) {}, 
        g.prototype.onProgressItem = function(a, b) {}, g.prototype.onProgressAll = function(a) {}, 
        g.prototype.onSuccessItem = function(a, b, c, d) {}, g.prototype.onErrorItem = function(a, b, c, d) {}, 
        g.prototype.onCancelItem = function(a, b, c, d) {}, g.prototype.onCompleteItem = function(a, b, c, d) {}, 
        g.prototype.onCompleteAll = function() {}, g.prototype._getTotalProgress = function(a) {
            if (this.removeAfterUpload) return a || 0;
            var b = this.getNotUploadedItems().length, c = b ? this.queue.length - b : this.queue.length, d = 100 / this.queue.length, e = (a || 0) * d / 100;
            return Math.round(c * d + e);
        }, g.prototype._getFilters = function(b) {
            if (a.isUndefined(b)) return this.filters;
            if (a.isArray(b)) return b;
            var c = b.match(/[^\s,]+/g);
            return this.filters.filter(function(a) {
                return -1 !== c.indexOf(a.name);
            }, this);
        }, g.prototype._render = function() {
            c.$$phase || c.$apply();
        }, g.prototype._folderFilter = function(a) {
            return !(!a.size && !a.type);
        }, g.prototype._queueLimitFilter = function() {
            return this.queue.length < this.queueLimit;
        }, g.prototype._isValidFile = function(a, b, c) {
            return this._failFilterIndex = -1, b.length ? b.every(function(b) {
                return this._failFilterIndex++, b.fn.call(this, a, c);
            }, this) : !0;
        }, g.prototype._isSuccessCode = function(a) {
            return a >= 200 && 300 > a || 304 === a;
        }, g.prototype._transformResponse = function(b, c) {
            var e = this._headersGetter(c);
            return a.forEach(d.defaults.transformResponse, function(a) {
                b = a(b, e);
            }), b;
        }, g.prototype._parseHeaders = function(b) {
            var c, d, e, f = {};
            return b ? (a.forEach(b.split("\n"), function(a) {
                e = a.indexOf(":"), c = a.slice(0, e).trim().toLowerCase(), d = a.slice(e + 1).trim(), 
                c && (f[c] = f[c] ? f[c] + ", " + d : d);
            }), f) : f;
        }, g.prototype._headersGetter = function(a) {
            return function(b) {
                return b ? a[b.toLowerCase()] || null : a;
            };
        }, g.prototype._xhrTransport = function(b) {
            var c = b._xhr = new XMLHttpRequest(), d = new FormData(), e = this;
            if (e._onBeforeUploadItem(b), a.forEach(b.formData, function(b) {
                a.forEach(b, function(a, b) {
                    d.append(b, a);
                });
            }), "number" != typeof b._file.size) throw new TypeError("The file specified is no longer valid");
            d.append(b.alias, b._file, b.file.name), c.upload.onprogress = function(a) {
                var c = Math.round(a.lengthComputable ? 100 * a.loaded / a.total : 0);
                e._onProgressItem(b, c);
            }, c.onload = function() {
                var a = e._parseHeaders(c.getAllResponseHeaders()), d = e._transformResponse(c.response, a), f = e._isSuccessCode(c.status) ? "Success" : "Error", g = "_on" + f + "Item";
                e[g](b, d, c.status, a), e._onCompleteItem(b, d, c.status, a);
            }, c.onerror = function() {
                var a = e._parseHeaders(c.getAllResponseHeaders()), d = e._transformResponse(c.response, a);
                e._onErrorItem(b, d, c.status, a), e._onCompleteItem(b, d, c.status, a);
            }, c.onabort = function() {
                var a = e._parseHeaders(c.getAllResponseHeaders()), d = e._transformResponse(c.response, a);
                e._onCancelItem(b, d, c.status, a), e._onCompleteItem(b, d, c.status, a);
            }, c.open(b.method, b.url, !0), c.withCredentials = b.withCredentials, a.forEach(b.headers, function(a, b) {
                c.setRequestHeader(b, a);
            }), c.send(d), this._render();
        }, g.prototype._iframeTransport = function(b) {
            var c = a.element('<form style="display: none;" />'), d = a.element('<iframe name="iframeTransport' + Date.now() + '">'), e = b._input, f = this;
            b._form && b._form.replaceWith(e), b._form = c, f._onBeforeUploadItem(b), e.prop("name", b.alias), 
            a.forEach(b.formData, function(b) {
                a.forEach(b, function(b, d) {
                    var e = a.element('<input type="hidden" name="' + d + '" />');
                    e.val(b), c.append(e);
                });
            }), c.prop({
                action: b.url,
                method: "POST",
                target: d.prop("name"),
                enctype: "multipart/form-data",
                encoding: "multipart/form-data"
            }), d.bind("load", function() {
                try {
                    var a = d[0].contentDocument.body.innerHTML;
                } catch (c) {}
                var e = {
                    response: a,
                    status: 200,
                    dummy: !0
                }, g = {}, h = f._transformResponse(e.response, g);
                f._onSuccessItem(b, h, e.status, g), f._onCompleteItem(b, h, e.status, g);
            }), c.abort = function() {
                var a, g = {
                    status: 0,
                    dummy: !0
                }, h = {};
                d.unbind("load").prop("src", "javascript:false;"), c.replaceWith(e), f._onCancelItem(b, a, g.status, h), 
                f._onCompleteItem(b, a, g.status, h);
            }, e.after(c), c.append(e).append(d), c[0].submit(), this._render();
        }, g.prototype._onWhenAddingFileFailed = function(a, b, c) {
            this.onWhenAddingFileFailed(a, b, c);
        }, g.prototype._onAfterAddingFile = function(a) {
            this.onAfterAddingFile(a);
        }, g.prototype._onAfterAddingAll = function(a) {
            this.onAfterAddingAll(a);
        }, g.prototype._onBeforeUploadItem = function(a) {
            a._onBeforeUpload(), this.onBeforeUploadItem(a);
        }, g.prototype._onProgressItem = function(a, b) {
            var c = this._getTotalProgress(b);
            this.progress = c, a._onProgress(b), this.onProgressItem(a, b), this.onProgressAll(c), 
            this._render();
        }, g.prototype._onSuccessItem = function(a, b, c, d) {
            a._onSuccess(b, c, d), this.onSuccessItem(a, b, c, d);
        }, g.prototype._onErrorItem = function(a, b, c, d) {
            a._onError(b, c, d), this.onErrorItem(a, b, c, d);
        }, g.prototype._onCancelItem = function(a, b, c, d) {
            a._onCancel(b, c, d), this.onCancelItem(a, b, c, d);
        }, g.prototype._onCompleteItem = function(b, c, d, e) {
            b._onComplete(c, d, e), this.onCompleteItem(b, c, d, e);
            var f = this.getReadyItems()[0];
            return this.isUploading = !1, a.isDefined(f) ? void f.upload() : (this.onCompleteAll(), 
            this.progress = this._getTotalProgress(), void this._render());
        }, g.isFile = g.prototype.isFile, g.isFileLikeObject = g.prototype.isFileLikeObject, 
        g.isArrayLikeObject = g.prototype.isArrayLikeObject, g.isHTML5 = g.prototype.isHTML5, 
        g.inherit = function(a, b) {
            a.prototype = Object.create(b.prototype), a.prototype.constructor = a, a.super_ = b;
        }, g.FileLikeObject = h, g.FileItem = i, g.FileDirective = j, g.FileSelect = k, 
        g.FileDrop = l, g.FileOver = m, h.prototype._createFromFakePath = function(a) {
            this.lastModifiedDate = null, this.size = null, this.type = "like/" + a.slice(a.lastIndexOf(".") + 1).toLowerCase(), 
            this.name = a.slice(a.lastIndexOf("/") + a.lastIndexOf("\\") + 2);
        }, h.prototype._createFromObject = function(b) {
            this.lastModifiedDate = a.copy(b.lastModifiedDate), this.size = b.size, this.type = b.type, 
            this.name = b.name;
        }, i.prototype.upload = function() {
            try {
                this.uploader.uploadItem(this);
            } catch (a) {
                this.uploader._onCompleteItem(this, "", 0, []), this.uploader._onErrorItem(this, "", 0, []);
            }
        }, i.prototype.cancel = function() {
            this.uploader.cancelItem(this);
        }, i.prototype.remove = function() {
            this.uploader.removeFromQueue(this);
        }, i.prototype.onBeforeUpload = function() {}, i.prototype.onProgress = function(a) {}, 
        i.prototype.onSuccess = function(a, b, c) {}, i.prototype.onError = function(a, b, c) {}, 
        i.prototype.onCancel = function(a, b, c) {}, i.prototype.onComplete = function(a, b, c) {}, 
        i.prototype._onBeforeUpload = function() {
            this.isReady = !0, this.isUploading = !0, this.isUploaded = !1, this.isSuccess = !1, 
            this.isCancel = !1, this.isError = !1, this.progress = 0, this.onBeforeUpload();
        }, i.prototype._onProgress = function(a) {
            this.progress = a, this.onProgress(a);
        }, i.prototype._onSuccess = function(a, b, c) {
            this.isReady = !1, this.isUploading = !1, this.isUploaded = !0, this.isSuccess = !0, 
            this.isCancel = !1, this.isError = !1, this.progress = 100, this.index = null, this.onSuccess(a, b, c);
        }, i.prototype._onError = function(a, b, c) {
            this.isReady = !1, this.isUploading = !1, this.isUploaded = !0, this.isSuccess = !1, 
            this.isCancel = !1, this.isError = !0, this.progress = 0, this.index = null, this.onError(a, b, c);
        }, i.prototype._onCancel = function(a, b, c) {
            this.isReady = !1, this.isUploading = !1, this.isUploaded = !1, this.isSuccess = !1, 
            this.isCancel = !0, this.isError = !1, this.progress = 0, this.index = null, this.onCancel(a, b, c);
        }, i.prototype._onComplete = function(a, b, c) {
            this.onComplete(a, b, c), this.removeAfterUpload && this.remove();
        }, i.prototype._destroy = function() {
            this._input && this._input.remove(), this._form && this._form.remove(), delete this._form, 
            delete this._input;
        }, i.prototype._prepareToUploading = function() {
            this.index = this.index || ++this.uploader._nextIndex, this.isReady = !0;
        }, i.prototype._replaceNode = function(a) {
            var b = f(a.clone())(a.scope());
            b.prop("value", null), a.css("display", "none"), a.after(b);
        }, j.prototype.events = {}, j.prototype.bind = function() {
            for (var a in this.events) {
                var b = this.events[a];
                this.element.bind(a, this[b]);
            }
        }, j.prototype.unbind = function() {
            for (var a in this.events) this.element.unbind(a, this.events[a]);
        }, j.prototype.destroy = function() {
            var a = this.uploader._directives[this.prop].indexOf(this);
            this.uploader._directives[this.prop].splice(a, 1), this.unbind();
        }, j.prototype._saveLinks = function() {
            for (var a in this.events) {
                var b = this.events[a];
                this[b] = this[b].bind(this);
            }
        }, g.inherit(k, j), k.prototype.events = {
            $destroy: "destroy",
            change: "onChange"
        }, k.prototype.prop = "select", k.prototype.getOptions = function() {}, k.prototype.getFilters = function() {}, 
        k.prototype.isEmptyAfterSelection = function() {
            return !!this.element.attr("multiple");
        }, k.prototype.onChange = function() {
            var a = this.uploader.isHTML5 ? this.element[0].files : this.element[0], b = this.getOptions(), c = this.getFilters();
            this.uploader.isHTML5 || this.destroy(), this.uploader.addToQueue(a, b, c), this.isEmptyAfterSelection() && this.element.prop("value", null);
        }, g.inherit(l, j), l.prototype.events = {
            $destroy: "destroy",
            drop: "onDrop",
            dragover: "onDragOver",
            dragleave: "onDragLeave"
        }, l.prototype.prop = "drop", l.prototype.getOptions = function() {}, l.prototype.getFilters = function() {}, 
        l.prototype.onDrop = function(b) {
            var c = this._getTransfer(b);
            if (c) {
                var d = this.getOptions(), e = this.getFilters();
                this._preventAndStop(b), a.forEach(this.uploader._directives.over, this._removeOverClass, this), 
                this.uploader.addToQueue(c.files, d, e);
            }
        }, l.prototype.onDragOver = function(b) {
            var c = this._getTransfer(b);
            this._haveFiles(c.types) && (c.dropEffect = "copy", this._preventAndStop(b), a.forEach(this.uploader._directives.over, this._addOverClass, this));
        }, l.prototype.onDragLeave = function(b) {
            b.currentTarget === this.element[0] && (this._preventAndStop(b), a.forEach(this.uploader._directives.over, this._removeOverClass, this));
        }, l.prototype._getTransfer = function(a) {
            return a.dataTransfer ? a.dataTransfer : a.originalEvent.dataTransfer;
        }, l.prototype._preventAndStop = function(a) {
            a.preventDefault(), a.stopPropagation();
        }, l.prototype._haveFiles = function(a) {
            return a ? a.indexOf ? -1 !== a.indexOf("Files") : a.contains ? a.contains("Files") : !1 : !1;
        }, l.prototype._addOverClass = function(a) {
            a.addOverClass();
        }, l.prototype._removeOverClass = function(a) {
            a.removeOverClass();
        }, g.inherit(m, j), m.prototype.events = {
            $destroy: "destroy"
        }, m.prototype.prop = "over", m.prototype.overClass = "nv-file-over", m.prototype.addOverClass = function() {
            this.element.addClass(this.getOverClass());
        }, m.prototype.removeOverClass = function() {
            this.element.removeClass(this.getOverClass());
        }, m.prototype.getOverClass = function() {
            return this.overClass;
        }, g;
    } ]).directive("nvFileSelect", [ "$parse", "FileUploader", function(a, b) {
        return {
            link: function(c, d, e) {
                var f = c.$eval(e.uploader);
                if (!(f instanceof b)) throw new TypeError('"Uploader" must be an instance of FileUploader');
                var g = new b.FileSelect({
                    uploader: f,
                    element: d
                });
                g.getOptions = a(e.options).bind(g, c), g.getFilters = function() {
                    return e.filters;
                };
            }
        };
    } ]).directive("nvFileDrop", [ "$parse", "FileUploader", function(a, b) {
        return {
            link: function(c, d, e) {
                var f = c.$eval(e.uploader);
                if (!(f instanceof b)) throw new TypeError('"Uploader" must be an instance of FileUploader');
                if (f.isHTML5) {
                    var g = new b.FileDrop({
                        uploader: f,
                        element: d
                    });
                    g.getOptions = a(e.options).bind(g, c), g.getFilters = function() {
                        return e.filters;
                    };
                }
            }
        };
    } ]).directive("nvFileOver", [ "FileUploader", function(a) {
        return {
            link: function(b, c, d) {
                var e = b.$eval(d.uploader);
                if (!(e instanceof a)) throw new TypeError('"Uploader" must be an instance of FileUploader');
                var f = new a.FileOver({
                    uploader: e,
                    element: c
                });
                f.getOverClass = function() {
                    return d.overClass || this.overClass;
                };
            }
        };
    } ]), b;
});

!function(a, b) {
    "use strict";
    return "function" == typeof define && define.amd ? void define([ "angular" ], function(a) {
        return b(a);
    }) : b(a);
}(window.angular || null, function(a) {
    "use strict";
    var b = a.module("ngTable", []);
    return b.value("ngTableDefaults", {
        params: {},
        settings: {}
    }), b.factory("NgTableParams", [ "$q", "$log", "ngTableDefaults", function(b, c, d) {
        var e = function(a) {
            return !isNaN(parseFloat(a)) && isFinite(a);
        }, f = function(f, g) {
            var h = this, i = function() {
                k.debugMode && c.debug && c.debug.apply(this, arguments);
            };
            this.data = [], this.parameters = function(b, c) {
                if (c = c || !1, a.isDefined(b)) {
                    for (var d in b) {
                        var f = b[d];
                        if (c && d.indexOf("[") >= 0) {
                            for (var g = d.split(/\[(.*)\]/).reverse(), h = "", k = 0, l = g.length; l > k; k++) {
                                var m = g[k];
                                if ("" !== m) {
                                    var n = f;
                                    f = {}, f[h = m] = e(n) ? parseFloat(n) : n;
                                }
                            }
                            "sorting" === h && (j[h] = {}), j[h] = a.extend(j[h] || {}, f[h]);
                        } else j[d] = e(b[d]) ? parseFloat(b[d]) : b[d];
                    }
                    return i("ngTable: set parameters", j), this;
                }
                return j;
            }, this.settings = function(b) {
                return a.isDefined(b) ? (a.isArray(b.data) && (b.total = b.data.length), k = a.extend(k, b), 
                i("ngTable: set settings", k), this) : k;
            }, this.page = function(b) {
                return a.isDefined(b) ? this.parameters({
                    page: b
                }) : j.page;
            }, this.total = function(b) {
                return a.isDefined(b) ? this.settings({
                    total: b
                }) : k.total;
            }, this.count = function(b) {
                return a.isDefined(b) ? this.parameters({
                    count: b,
                    page: 1
                }) : j.count;
            }, this.filter = function(b) {
                return a.isDefined(b) ? this.parameters({
                    filter: b,
                    page: 1
                }) : j.filter;
            }, this.sorting = function(b) {
                if (2 == arguments.length) {
                    var c = {};
                    return c[b] = arguments[1], this.parameters({
                        sorting: c
                    }), this;
                }
                return a.isDefined(b) ? this.parameters({
                    sorting: b
                }) : j.sorting;
            }, this.isSortBy = function(b, c) {
                return a.isDefined(j.sorting[b]) && a.equals(j.sorting[b], c);
            }, this.orderBy = function() {
                var a = [];
                for (var b in j.sorting) a.push(("asc" === j.sorting[b] ? "+" : "-") + b);
                return a;
            }, this.getData = function(b, c) {
                return b.resolve(a.isArray(this.data) && a.isObject(c) ? this.data.slice((c.page() - 1) * c.count(), c.page() * c.count()) : []), 
                b.promise;
            }, this.getGroups = function(c, d) {
                var e = b.defer();
                return e.promise.then(function(b) {
                    var e = {};
                    a.forEach(b, function(b) {
                        var c = a.isFunction(d) ? d(b) : b[d];
                        e[c] = e[c] || {
                            data: []
                        }, e[c].value = c, e[c].data.push(b);
                    });
                    var f = [];
                    for (var g in e) f.push(e[g]);
                    i("ngTable: refresh groups", f), c.resolve(f);
                }), this.getData(e, h);
            }, this.generatePagesArray = function(a, b, c, d) {
                var e, f, g, h, i;
                if (d = d && 6 > d ? 6 : d, i = [], h = Math.ceil(b / c), h > 1) {
                    i.push({
                        type: "prev",
                        number: Math.max(1, a - 1),
                        active: a > 1
                    }), i.push({
                        type: "first",
                        number: 1,
                        active: a > 1,
                        current: 1 === a
                    }), f = Math.round((k.paginationMaxBlocks - k.paginationMinBlocks) / 2), g = Math.max(2, a - f), 
                    e = Math.min(h - 1, a + 2 * f - (a - g)), g = Math.max(2, g - (2 * f - (e - g)));
                    for (var j = g; e >= j; ) i.push(j === g && 2 !== j || j === e && j !== h - 1 ? {
                        type: "more",
                        active: !1
                    } : {
                        type: "page",
                        number: j,
                        active: a !== j,
                        current: a === j
                    }), j++;
                    i.push({
                        type: "last",
                        number: h,
                        active: a !== h,
                        current: a === h
                    }), i.push({
                        type: "next",
                        number: Math.min(h, a + 1),
                        active: h > a
                    });
                }
                return i;
            }, this.url = function(b) {
                b = b || !1;
                var c = b ? [] : {};
                for (var d in j) if (j.hasOwnProperty(d)) {
                    var e = j[d], f = encodeURIComponent(d);
                    if ("object" == typeof e) {
                        for (var g in e) if (!a.isUndefined(e[g]) && "" !== e[g]) {
                            var h = f + "[" + encodeURIComponent(g) + "]";
                            b ? c.push(h + "=" + e[g]) : c[h] = e[g];
                        }
                    } else a.isFunction(e) || a.isUndefined(e) || "" === e || (b ? c.push(f + "=" + encodeURIComponent(e)) : c[f] = encodeURIComponent(e));
                }
                return c;
            }, this.reload = function() {
                var a = b.defer(), c = this, d = null;
                if (k.$scope) return k.$loading = !0, d = k.groupBy ? k.getGroups(a, k.groupBy, this) : k.getData(a, this), 
                i("ngTable: reload data"), d || (d = a.promise), d.then(function(a) {
                    return k.$loading = !1, i("ngTable: current scope", k.$scope), k.groupBy ? (c.data = a, 
                    k.$scope && (k.$scope.$groups = a)) : (c.data = a, k.$scope && (k.$scope.$data = a)), 
                    k.$scope && (k.$scope.pages = c.generatePagesArray(c.page(), c.total(), c.count()), 
                    k.$scope.$emit("ngTableAfterReloadData")), a;
                });
            }, this.reloadPages = function() {
                var a = this;
                k.$scope.pages = a.generatePagesArray(a.page(), a.total(), a.count());
            };
            var j = this.$params = {
                page: 1,
                count: 1,
                filter: {},
                sorting: {},
                group: {},
                groupBy: null
            };
            a.extend(j, d.params);
            var k = {
                $scope: null,
                $loading: !1,
                data: null,
                total: 0,
                defaultSort: "desc",
                filterDelay: 750,
                counts: [ 10, 25, 50, 100 ],
                paginationMaxBlocks: 11,
                paginationMinBlocks: 5,
                sortingIndicator: "span",
                getGroups: this.getGroups,
                getData: this.getData
            };
            return a.extend(k, d.settings), this.settings(g), this.parameters(f, !0), this;
        };
        return f;
    } ]), b.factory("ngTableParams", [ "NgTableParams", function(a) {
        return a;
    } ]), b.controller("ngTableController", [ "$scope", "NgTableParams", "$timeout", "$parse", "$compile", "$attrs", "$element", "ngTableColumn", function(b, c, d, e, f, g, h, i) {
        function j() {
            b.params.$params.page = 1;
        }
        var k = !0;
        b.$filterRow = {}, b.$loading = !1, b.hasOwnProperty("params") || (b.params = new c(), 
        b.params.isNullInstance = !0), b.params.settings().$scope = b;
        var l = function() {
            var a = 0;
            return function(b, c) {
                d.cancel(a), a = d(b, c);
            };
        }();
        b.$watch("params.$params", function(c, d) {
            if (c !== d) {
                if (b.params.settings().$scope = b, a.equals(c.filter, d.filter)) b.params.reload(); else {
                    var e = k ? a.noop : j;
                    l(function() {
                        e(), b.params.reload();
                    }, b.params.settings().filterDelay);
                }
                b.params.isNullInstance || (k = !1);
            }
        }, !0), this.compileDirectiveTemplates = function() {
            if (!h.hasClass("ng-table")) {
                b.templates = {
                    header: g.templateHeader ? g.templateHeader : "ng-table/header.html",
                    pagination: g.templatePagination ? g.templatePagination : "ng-table/pager.html"
                }, h.addClass("ng-table");
                var c = null;
                0 === h.find("> thead").length && (c = a.element(document.createElement("thead")).attr("ng-include", "templates.header"), 
                h.prepend(c));
                var d = a.element(document.createElement("div")).attr({
                    "ng-table-pagination": "params",
                    "template-url": "templates.pagination"
                });
                h.after(d), c && f(c)(b), f(d)(b);
            }
        }, this.loadFilterData = function(c) {
            a.forEach(c, function(c) {
                var d;
                return d = c.filterData(b, {
                    $column: c
                }), d ? a.isObject(d) && a.isObject(d.promise) ? (delete c.filterData, d.promise.then(function(b) {
                    a.isArray(b) || a.isFunction(b) || a.isObject(b) ? a.isArray(b) && b.unshift({
                        title: "-",
                        id: ""
                    }) : b = [], c.data = b;
                })) : c.data = d : void delete c.filterData;
            });
        }, this.buildColumns = function(a) {
            return a.map(function(a) {
                return i.buildColumn(a, b);
            });
        }, this.setupBindingsToInternalScope = function(c) {
            var d = e(c);
            b.$watch(d, function(c) {
                a.isUndefined(c) || (b.paramsModel = d, b.params = c);
            }, !1), g.showFilter && b.$parent.$watch(g.showFilter, function(a) {
                b.show_filter = a;
            }), g.disableFilter && b.$parent.$watch(g.disableFilter, function(a) {
                b.$filterRow.disabled = a;
            });
        }, b.sortBy = function(a, c) {
            var d = a.sortable && a.sortable();
            if (d) {
                var e = b.params.settings().defaultSort, f = "asc" === e ? "desc" : "asc", g = b.params.sorting() && b.params.sorting()[d] && b.params.sorting()[d] === e, h = c.ctrlKey || c.metaKey ? b.params.sorting() : {};
                h[d] = g ? f : e, b.params.parameters({
                    sorting: h
                });
            }
        };
    } ]), b.factory("ngTableColumn", [ function() {
        function b(b, d) {
            var e = Object.create(b);
            for (var f in c) void 0 === e[f] && (e[f] = c[f]), a.isFunction(e[f]) || !function(a) {
                e[a] = function() {
                    return b[a];
                };
            }(f), function(a) {
                var c = e[a];
                e[a] = function() {
                    return 0 === arguments.length ? c.call(b, d) : c.apply(b, arguments);
                };
            }(f);
            return e;
        }
        var c = {
            class: function() {
                return "";
            },
            filter: function() {
                return !1;
            },
            filterData: a.noop,
            headerTemplateURL: function() {
                return !1;
            },
            headerTitle: function() {
                return "";
            },
            sortable: function() {
                return !1;
            },
            show: function() {
                return !0;
            },
            title: function() {
                return "";
            },
            titleAlt: function() {
                return "";
            }
        };
        return {
            buildColumn: b
        };
    } ]), b.directive("ngTable", [ "$q", "$parse", function(b, c) {
        return {
            restrict: "A",
            priority: 1001,
            scope: !0,
            controller: "ngTableController",
            compile: function(b) {
                var d = [], e = 0, f = null;
                return a.forEach(a.element(b.find("tr")), function(b) {
                    b = a.element(b), b.hasClass("ng-table-group") || f || (f = b);
                }), f ? (a.forEach(f.find("td"), function(b) {
                    var f = a.element(b);
                    if (!f.attr("ignore-cell") || "true" !== f.attr("ignore-cell")) {
                        var g = function(a) {
                            return f.attr("x-data-" + a) || f.attr("data-" + a) || f.attr(a);
                        }, h = function(b) {
                            var e = g(b);
                            return e ? function(b, f) {
                                return c(e)(b, a.extend(f || {}, {
                                    $columns: d
                                }));
                            } : void 0;
                        }, i = g("title-alt") || g("title");
                        i && f.attr("data-title-text", "{{" + i + "}}"), d.push({
                            id: e++,
                            title: h("title"),
                            titleAlt: h("title-alt"),
                            headerTitle: h("header-title"),
                            sortable: h("sortable"),
                            class: h("header-class"),
                            filter: h("filter"),
                            headerTemplateURL: h("header"),
                            filterData: h("filter-data"),
                            show: f.attr("ng-show") ? function(a) {
                                return c(f.attr("ng-show"))(a);
                            } : void 0
                        });
                    }
                }), function(a, b, c, e) {
                    a.$columns = d = e.buildColumns(d), e.setupBindingsToInternalScope(c.ngTable), e.loadFilterData(d), 
                    e.compileDirectiveTemplates();
                }) : void 0;
            }
        };
    } ]), b.directive("ngTableDynamic", [ "$parse", function() {
        function b(a) {
            if (!a || a.indexOf(" with ") > -1) {
                var b = a.split(/\s+with\s+/);
                return {
                    tableParams: b[0],
                    columns: b[1]
                };
            }
            throw new Error("Parse error (expected example: ng-table-dynamic='tableParams with cols')");
        }
        return {
            restrict: "A",
            priority: 1001,
            scope: !0,
            controller: "ngTableController",
            compile: function(c) {
                var d;
                return a.forEach(a.element(c.find("tr")), function(b) {
                    b = a.element(b), b.hasClass("ng-table-group") || d || (d = b);
                }), d ? (a.forEach(d.find("td"), function(b) {
                    var c = a.element(b), d = function(a) {
                        return c.attr("x-data-" + a) || c.attr("data-" + a) || c.attr(a);
                    }, e = d("title");
                    e || c.attr("data-title-text", "{{$columns[$index].titleAlt(this) || $columns[$index].title(this)}}");
                    var f = c.attr("ng-show");
                    f || c.attr("ng-show", "$columns[$index].show(this)");
                }), function(a, c, d, e) {
                    var f = b(d.ngTableDynamic);
                    e.setupBindingsToInternalScope(f.tableParams), e.compileDirectiveTemplates(), a.$watchCollection(f.columns, function(b) {
                        a.$columns = e.buildColumns(b), e.loadFilterData(a.$columns);
                    });
                }) : void 0;
            }
        };
    } ]), b.directive("ngTablePagination", [ "$compile", function(b) {
        return {
            restrict: "A",
            scope: {
                params: "=ngTablePagination",
                templateUrl: "="
            },
            replace: !1,
            link: function(c, d) {
                var e = c.params.settings();
                e.$scope.$on("ngTableAfterReloadData", function() {
                    var a = c.params.page(), b = c.params.total(), d = c.params.count(), f = e.paginationMaxBlocks;
                    c.pages = c.params.generatePagesArray(a, b, d, f);
                }, !0), c.$watch("templateUrl", function(e) {
                    if (!a.isUndefined(e)) {
                        var f = a.element(document.createElement("div"));
                        f.attr({
                            "ng-include": "templateUrl"
                        }), d.append(f), b(f)(c);
                    }
                });
            }
        };
    } ]), a.module("ngTable").run([ "$templateCache", function(a) {
        a.put("ng-table/filters/select-multiple.html", '<select ng-options="data.id as data.title for data in $column.data" ng-disabled="$filterRow.disabled" multiple ng-multiple="true" ng-model="params.filter()[name]" ng-show="filter==\'select-multiple\'" class="filter filter-select-multiple form-control" name="{{name}}"> </select>'), 
        a.put("ng-table/filters/select.html", '<select ng-options="data.id as data.title for data in $column.data" ng-disabled="$filterRow.disabled" ng-model="params.filter()[name]" ng-show="filter==\'select\'" class="filter filter-select form-control" name="{{name}}"> </select>'), 
        a.put("ng-table/filters/text.html", '<input type="text" name="{{name}}" ng-disabled="$filterRow.disabled" ng-model="params.filter()[name]" ng-if="filter==\'text\'" class="input-filter form-control"/>'), 
        a.put("ng-table/header.html", '<tr> <th title="{{$column.headerTitle(this)}}" ng-repeat="$column in $columns | orderBy:\'position\'" ng-class="{ \'sortable\': $column.sortable(this), \'sort-asc\': params.sorting()[$column.sortable(this)]==\'asc\', \'sort-desc\': params.sorting()[$column.sortable(this)]==\'desc\' }" ng-click="sortBy($column, $event)" ng-show="$column.show(this)" ng-init="template=$column.headerTemplateURL(this)" class="header {{$column.class(this)}}"> <div ng-if="!template" ng-show="!template" class="ng-table-header" ng-class="{\'sort-indicator\': params.settings().sortingIndicator==\'div\'}"> <span ng-bind="$column.title(this)" ng-class="{\'sort-indicator\': params.settings().sortingIndicator==\'span\'}"></span> </div> <div ng-if="template" ng-show="template" ng-include="template"></div> </th> </tr> <tr ng-show="show_filter" class="ng-table-filters"> <th data-title-text="{{$column.titleAlt(this) || $column.title(this)}}" ng-repeat="$column in $columns | orderBy:\'position\'" ng-show="$column.show(this)" class="filter"> <div ng-repeat="(name, filter) in $column.filter(this)"> <div ng-if="filter.indexOf(\'/\') !==-1" ng-include="filter"></div> <div ng-if="filter.indexOf(\'/\')===-1" ng-include="\'ng-table/filters/\' + filter + \'.html\'"></div> </div> </th> </tr> '), 
        a.put("ng-table/pager.html", '<div class="ng-cloak ng-table-pager" ng-if="params.data.length"> <div ng-if="params.settings().counts.length" class="ng-table-counts btn-group pull-right"> <button ng-repeat="count in params.settings().counts" type="button" ng-class="{\'active\':params.count()==count}" ng-click="params.count(count)" class="btn btn-default"> <span ng-bind="count"></span> </button> </div> <ul class="pagination ng-table-pagination"> <li ng-class="{\'disabled\': !page.active && !page.current, \'active\': page.current}" ng-repeat="page in pages" ng-switch="page.type"> <a ng-switch-when="prev" ng-click="params.page(page.number)" href="">&laquo;</a> <a ng-switch-when="first" ng-click="params.page(page.number)" href=""><span ng-bind="page.number"></span></a> <a ng-switch-when="page" ng-click="params.page(page.number)" href=""><span ng-bind="page.number"></span></a> <a ng-switch-when="more" ng-click="params.page(page.number)" href="">&#8230;</a> <a ng-switch-when="last" ng-click="params.page(page.number)" href=""><span ng-bind="page.number"></span></a> <a ng-switch-when="next" ng-click="params.page(page.number)" href="">&raquo;</a> </li> </ul> </div> ');
    } ]), b;
});

(function() {
    var restangular = angular.module("restangular", []);
    restangular.provider("Restangular", function() {
        var Configurer = {};
        Configurer.init = function(object, config) {
            object.configuration = config;
            var safeMethods = [ "get", "head", "options", "trace", "getlist" ];
            config.isSafe = function(operation) {
                return _.includes(safeMethods, operation.toLowerCase());
            };
            var absolutePattern = /^https?:\/\//i;
            config.isAbsoluteUrl = function(string) {
                return _.isUndefined(config.absoluteUrl) || _.isNull(config.absoluteUrl) ? string && absolutePattern.test(string) : config.absoluteUrl;
            };
            config.absoluteUrl = _.isUndefined(config.absoluteUrl) ? true : config.absoluteUrl;
            object.setSelfLinkAbsoluteUrl = function(value) {
                config.absoluteUrl = value;
            };
            config.baseUrl = _.isUndefined(config.baseUrl) ? "" : config.baseUrl;
            object.setBaseUrl = function(newBaseUrl) {
                config.baseUrl = /\/$/.test(newBaseUrl) ? newBaseUrl.substring(0, newBaseUrl.length - 1) : newBaseUrl;
                return this;
            };
            config.extraFields = config.extraFields || [];
            object.setExtraFields = function(newExtraFields) {
                config.extraFields = newExtraFields;
                return this;
            };
            config.defaultHttpFields = config.defaultHttpFields || {};
            object.setDefaultHttpFields = function(values) {
                config.defaultHttpFields = values;
                return this;
            };
            config.withHttpValues = function(httpLocalConfig, obj) {
                return _.defaults(obj, httpLocalConfig, config.defaultHttpFields);
            };
            config.encodeIds = _.isUndefined(config.encodeIds) ? true : config.encodeIds;
            object.setEncodeIds = function(encode) {
                config.encodeIds = encode;
            };
            config.defaultRequestParams = config.defaultRequestParams || {
                get: {},
                post: {},
                put: {},
                remove: {},
                common: {}
            };
            object.setDefaultRequestParams = function(param1, param2) {
                var methods = [], params = param2 || param1;
                if (!_.isUndefined(param2)) {
                    if (_.isArray(param1)) {
                        methods = param1;
                    } else {
                        methods.push(param1);
                    }
                } else {
                    methods.push("common");
                }
                _.each(methods, function(method) {
                    config.defaultRequestParams[method] = params;
                });
                return this;
            };
            object.requestParams = config.defaultRequestParams;
            config.defaultHeaders = config.defaultHeaders || {};
            object.setDefaultHeaders = function(headers) {
                config.defaultHeaders = headers;
                object.defaultHeaders = config.defaultHeaders;
                return this;
            };
            object.defaultHeaders = config.defaultHeaders;
            config.methodOverriders = config.methodOverriders || [];
            object.setMethodOverriders = function(values) {
                var overriders = _.extend([], values);
                if (config.isOverridenMethod("delete", overriders)) {
                    overriders.push("remove");
                }
                config.methodOverriders = overriders;
                return this;
            };
            config.jsonp = _.isUndefined(config.jsonp) ? false : config.jsonp;
            object.setJsonp = function(active) {
                config.jsonp = active;
            };
            config.isOverridenMethod = function(method, values) {
                var search = values || config.methodOverriders;
                return !_.isUndefined(_.find(search, function(one) {
                    return one.toLowerCase() === method.toLowerCase();
                }));
            };
            config.urlCreator = config.urlCreator || "path";
            object.setUrlCreator = function(name) {
                if (!_.has(config.urlCreatorFactory, name)) {
                    throw new Error("URL Path selected isn't valid");
                }
                config.urlCreator = name;
                return this;
            };
            config.restangularFields = config.restangularFields || {
                id: "id",
                route: "route",
                parentResource: "parentResource",
                restangularCollection: "restangularCollection",
                cannonicalId: "__cannonicalId",
                etag: "restangularEtag",
                selfLink: "href",
                get: "get",
                getList: "getList",
                put: "put",
                post: "post",
                remove: "remove",
                head: "head",
                trace: "trace",
                options: "options",
                patch: "patch",
                getRestangularUrl: "getRestangularUrl",
                getRequestedUrl: "getRequestedUrl",
                putElement: "putElement",
                addRestangularMethod: "addRestangularMethod",
                getParentList: "getParentList",
                clone: "clone",
                ids: "ids",
                httpConfig: "_$httpConfig",
                reqParams: "reqParams",
                one: "one",
                all: "all",
                several: "several",
                oneUrl: "oneUrl",
                allUrl: "allUrl",
                customPUT: "customPUT",
                customPOST: "customPOST",
                customDELETE: "customDELETE",
                customGET: "customGET",
                customGETLIST: "customGETLIST",
                customOperation: "customOperation",
                doPUT: "doPUT",
                doPOST: "doPOST",
                doDELETE: "doDELETE",
                doGET: "doGET",
                doGETLIST: "doGETLIST",
                fromServer: "fromServer",
                withConfig: "withConfig",
                withHttpConfig: "withHttpConfig",
                singleOne: "singleOne",
                plain: "plain",
                save: "save",
                restangularized: "restangularized"
            };
            object.setRestangularFields = function(resFields) {
                config.restangularFields = _.extend(config.restangularFields, resFields);
                return this;
            };
            config.isRestangularized = function(obj) {
                return !!obj[config.restangularFields.restangularized];
            };
            config.setFieldToElem = function(field, elem, value) {
                var properties = field.split(".");
                var idValue = elem;
                _.each(_.initial(properties), function(prop) {
                    idValue[prop] = {};
                    idValue = idValue[prop];
                });
                idValue[_.last(properties)] = value;
                return this;
            };
            config.getFieldFromElem = function(field, elem) {
                var properties = field.split(".");
                var idValue = elem;
                _.each(properties, function(prop) {
                    if (idValue) {
                        idValue = idValue[prop];
                    }
                });
                return angular.copy(idValue);
            };
            config.setIdToElem = function(elem, id) {
                config.setFieldToElem(config.restangularFields.id, elem, id);
                return this;
            };
            config.getIdFromElem = function(elem) {
                return config.getFieldFromElem(config.restangularFields.id, elem);
            };
            config.isValidId = function(elemId) {
                return "" !== elemId && !_.isUndefined(elemId) && !_.isNull(elemId);
            };
            config.setUrlToElem = function(elem, url) {
                config.setFieldToElem(config.restangularFields.selfLink, elem, url);
                return this;
            };
            config.getUrlFromElem = function(elem) {
                return config.getFieldFromElem(config.restangularFields.selfLink, elem);
            };
            config.useCannonicalId = _.isUndefined(config.useCannonicalId) ? false : config.useCannonicalId;
            object.setUseCannonicalId = function(value) {
                config.useCannonicalId = value;
                return this;
            };
            config.getCannonicalIdFromElem = function(elem) {
                var cannonicalId = elem[config.restangularFields.cannonicalId];
                var actualId = config.isValidId(cannonicalId) ? cannonicalId : config.getIdFromElem(elem);
                return actualId;
            };
            config.responseInterceptors = config.responseInterceptors || [];
            config.defaultResponseInterceptor = function(data) {
                return data;
            };
            config.responseExtractor = function(data, operation, what, url, response, deferred) {
                var interceptors = angular.copy(config.responseInterceptors);
                interceptors.push(config.defaultResponseInterceptor);
                var theData = data;
                _.each(interceptors, function(interceptor) {
                    theData = interceptor(theData, operation, what, url, response, deferred);
                });
                return theData;
            };
            object.addResponseInterceptor = function(extractor) {
                config.responseInterceptors.push(extractor);
                return this;
            };
            config.errorInterceptors = config.errorInterceptors || [];
            object.addErrorInterceptor = function(interceptor) {
                config.errorInterceptors.push(interceptor);
                return this;
            };
            object.setResponseInterceptor = object.addResponseInterceptor;
            object.setResponseExtractor = object.addResponseInterceptor;
            object.setErrorInterceptor = object.addErrorInterceptor;
            config.requestInterceptors = config.requestInterceptors || [];
            config.defaultInterceptor = function(element, operation, path, url, headers, params, httpConfig) {
                return {
                    element: element,
                    headers: headers,
                    params: params,
                    httpConfig: httpConfig
                };
            };
            config.fullRequestInterceptor = function(element, operation, path, url, headers, params, httpConfig) {
                var interceptors = angular.copy(config.requestInterceptors);
                var defaultRequest = config.defaultInterceptor(element, operation, path, url, headers, params, httpConfig);
                return _.reduce(interceptors, function(request, interceptor) {
                    return _.extend(request, interceptor(request.element, operation, path, url, request.headers, request.params, request.httpConfig));
                }, defaultRequest);
            };
            object.addRequestInterceptor = function(interceptor) {
                config.requestInterceptors.push(function(elem, operation, path, url, headers, params, httpConfig) {
                    return {
                        headers: headers,
                        params: params,
                        element: interceptor(elem, operation, path, url),
                        httpConfig: httpConfig
                    };
                });
                return this;
            };
            object.setRequestInterceptor = object.addRequestInterceptor;
            object.addFullRequestInterceptor = function(interceptor) {
                config.requestInterceptors.push(interceptor);
                return this;
            };
            object.setFullRequestInterceptor = object.addFullRequestInterceptor;
            config.onBeforeElemRestangularized = config.onBeforeElemRestangularized || function(elem) {
                return elem;
            };
            object.setOnBeforeElemRestangularized = function(post) {
                config.onBeforeElemRestangularized = post;
                return this;
            };
            object.setRestangularizePromiseInterceptor = function(interceptor) {
                config.restangularizePromiseInterceptor = interceptor;
                return this;
            };
            config.onElemRestangularized = config.onElemRestangularized || function(elem) {
                return elem;
            };
            object.setOnElemRestangularized = function(post) {
                config.onElemRestangularized = post;
                return this;
            };
            config.shouldSaveParent = config.shouldSaveParent || function() {
                return true;
            };
            object.setParentless = function(values) {
                if (_.isArray(values)) {
                    config.shouldSaveParent = function(route) {
                        return !_.includes(values, route);
                    };
                } else if (_.isBoolean(values)) {
                    config.shouldSaveParent = function() {
                        return !values;
                    };
                }
                return this;
            };
            config.suffix = _.isUndefined(config.suffix) ? null : config.suffix;
            object.setRequestSuffix = function(newSuffix) {
                config.suffix = newSuffix;
                return this;
            };
            config.transformers = config.transformers || {};
            object.addElementTransformer = function(type, secondArg, thirdArg) {
                var isCollection = null;
                var transformer = null;
                if (arguments.length === 2) {
                    transformer = secondArg;
                } else {
                    transformer = thirdArg;
                    isCollection = secondArg;
                }
                var typeTransformers = config.transformers[type];
                if (!typeTransformers) {
                    typeTransformers = config.transformers[type] = [];
                }
                typeTransformers.push(function(coll, elem) {
                    if (_.isNull(isCollection) || coll === isCollection) {
                        return transformer(elem);
                    }
                    return elem;
                });
                return object;
            };
            object.extendCollection = function(route, fn) {
                return object.addElementTransformer(route, true, fn);
            };
            object.extendModel = function(route, fn) {
                return object.addElementTransformer(route, false, fn);
            };
            config.transformElem = function(elem, isCollection, route, Restangular, force) {
                if (!force && !config.transformLocalElements && !elem[config.restangularFields.fromServer]) {
                    return elem;
                }
                var typeTransformers = config.transformers[route];
                var changedElem = elem;
                if (typeTransformers) {
                    _.each(typeTransformers, function(transformer) {
                        changedElem = transformer(isCollection, changedElem);
                    });
                }
                return config.onElemRestangularized(changedElem, isCollection, route, Restangular);
            };
            config.transformLocalElements = _.isUndefined(config.transformLocalElements) ? false : config.transformLocalElements;
            object.setTransformOnlyServerElements = function(active) {
                config.transformLocalElements = !active;
            };
            config.fullResponse = _.isUndefined(config.fullResponse) ? false : config.fullResponse;
            object.setFullResponse = function(full) {
                config.fullResponse = full;
                return this;
            };
            config.urlCreatorFactory = {};
            var BaseCreator = function() {};
            BaseCreator.prototype.setConfig = function(config) {
                this.config = config;
                return this;
            };
            BaseCreator.prototype.parentsArray = function(current) {
                var parents = [];
                while (current) {
                    parents.push(current);
                    current = current[this.config.restangularFields.parentResource];
                }
                return parents.reverse();
            };
            function RestangularResource(config, $http, url, configurer) {
                var resource = {};
                _.each(_.keys(configurer), function(key) {
                    var value = configurer[key];
                    value.params = _.extend({}, value.params, config.defaultRequestParams[value.method.toLowerCase()]);
                    if (_.isEmpty(value.params)) {
                        delete value.params;
                    }
                    if (config.isSafe(value.method)) {
                        resource[key] = function() {
                            return $http(_.extend(value, {
                                url: url
                            }));
                        };
                    } else {
                        resource[key] = function(data) {
                            return $http(_.extend(value, {
                                url: url,
                                data: data
                            }));
                        };
                    }
                });
                return resource;
            }
            BaseCreator.prototype.resource = function(current, $http, localHttpConfig, callHeaders, callParams, what, etag, operation) {
                var params = _.defaults(callParams || {}, this.config.defaultRequestParams.common);
                var headers = _.defaults(callHeaders || {}, this.config.defaultHeaders);
                if (etag) {
                    if (!config.isSafe(operation)) {
                        headers["If-Match"] = etag;
                    } else {
                        headers["If-None-Match"] = etag;
                    }
                }
                var url = this.base(current);
                if (what) {
                    var add = "";
                    if (!/\/$/.test(url)) {
                        add += "/";
                    }
                    add += what;
                    url += add;
                }
                if (this.config.suffix && url.indexOf(this.config.suffix, url.length - this.config.suffix.length) === -1 && !this.config.getUrlFromElem(current)) {
                    url += this.config.suffix;
                }
                current[this.config.restangularFields.httpConfig] = undefined;
                return RestangularResource(this.config, $http, url, {
                    getList: this.config.withHttpValues(localHttpConfig, {
                        method: "GET",
                        params: params,
                        headers: headers
                    }),
                    get: this.config.withHttpValues(localHttpConfig, {
                        method: "GET",
                        params: params,
                        headers: headers
                    }),
                    jsonp: this.config.withHttpValues(localHttpConfig, {
                        method: "jsonp",
                        params: params,
                        headers: headers
                    }),
                    put: this.config.withHttpValues(localHttpConfig, {
                        method: "PUT",
                        params: params,
                        headers: headers
                    }),
                    post: this.config.withHttpValues(localHttpConfig, {
                        method: "POST",
                        params: params,
                        headers: headers
                    }),
                    remove: this.config.withHttpValues(localHttpConfig, {
                        method: "DELETE",
                        params: params,
                        headers: headers
                    }),
                    head: this.config.withHttpValues(localHttpConfig, {
                        method: "HEAD",
                        params: params,
                        headers: headers
                    }),
                    trace: this.config.withHttpValues(localHttpConfig, {
                        method: "TRACE",
                        params: params,
                        headers: headers
                    }),
                    options: this.config.withHttpValues(localHttpConfig, {
                        method: "OPTIONS",
                        params: params,
                        headers: headers
                    }),
                    patch: this.config.withHttpValues(localHttpConfig, {
                        method: "PATCH",
                        params: params,
                        headers: headers
                    })
                });
            };
            var Path = function() {};
            Path.prototype = new BaseCreator();
            Path.prototype.normalizeUrl = function(url) {
                var parts = /(http[s]?:\/\/)?(.*)?/.exec(url);
                parts[2] = parts[2].replace(/[\\\/]+/g, "/");
                return typeof parts[1] !== "undefined" ? parts[1] + parts[2] : parts[2];
            };
            Path.prototype.base = function(current) {
                var __this = this;
                return _.reduce(this.parentsArray(current), function(acum, elem) {
                    var elemUrl;
                    var elemSelfLink = __this.config.getUrlFromElem(elem);
                    if (elemSelfLink) {
                        if (__this.config.isAbsoluteUrl(elemSelfLink)) {
                            return elemSelfLink;
                        } else {
                            elemUrl = elemSelfLink;
                        }
                    } else {
                        elemUrl = elem[__this.config.restangularFields.route];
                        if (elem[__this.config.restangularFields.restangularCollection]) {
                            var ids = elem[__this.config.restangularFields.ids];
                            if (ids) {
                                elemUrl += "/" + ids.join(",");
                            }
                        } else {
                            var elemId;
                            if (__this.config.useCannonicalId) {
                                elemId = __this.config.getCannonicalIdFromElem(elem);
                            } else {
                                elemId = __this.config.getIdFromElem(elem);
                            }
                            if (config.isValidId(elemId) && !elem.singleOne) {
                                elemUrl += "/" + (__this.config.encodeIds ? encodeURIComponent(elemId) : elemId);
                            }
                        }
                    }
                    acum = acum.replace(/\/$/, "") + "/" + elemUrl;
                    return __this.normalizeUrl(acum);
                }, this.config.baseUrl);
            };
            Path.prototype.fetchUrl = function(current, what) {
                var baseUrl = this.base(current);
                if (what) {
                    baseUrl += "/" + what;
                }
                return baseUrl;
            };
            Path.prototype.fetchRequestedUrl = function(current, what) {
                var url = this.fetchUrl(current, what);
                var params = current[config.restangularFields.reqParams];
                function sortedKeys(obj) {
                    var keys = [];
                    for (var key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            keys.push(key);
                        }
                    }
                    return keys.sort();
                }
                function forEachSorted(obj, iterator, context) {
                    var keys = sortedKeys(obj);
                    for (var i = 0; i < keys.length; i++) {
                        iterator.call(context, obj[keys[i]], keys[i]);
                    }
                    return keys;
                }
                function encodeUriQuery(val, pctEncodeSpaces) {
                    return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
                }
                if (!params) {
                    return url + (this.config.suffix || "");
                }
                var parts = [];
                forEachSorted(params, function(value, key) {
                    if (value === null || value === undefined) {
                        return;
                    }
                    if (!angular.isArray(value)) {
                        value = [ value ];
                    }
                    angular.forEach(value, function(v) {
                        if (angular.isObject(v)) {
                            v = angular.toJson(v);
                        }
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v));
                    });
                });
                return url + (this.config.suffix || "") + (url.indexOf("?") === -1 ? "?" : "&") + parts.join("&");
            };
            config.urlCreatorFactory.path = Path;
        };
        var globalConfiguration = {};
        Configurer.init(this, globalConfiguration);
        this.$get = [ "$http", "$q", function($http, $q) {
            function createServiceForConfiguration(config) {
                var service = {};
                var urlHandler = new config.urlCreatorFactory[config.urlCreator]();
                urlHandler.setConfig(config);
                function restangularizeBase(parent, elem, route, reqParams, fromServer) {
                    elem[config.restangularFields.route] = route;
                    elem[config.restangularFields.getRestangularUrl] = _.bind(urlHandler.fetchUrl, urlHandler, elem);
                    elem[config.restangularFields.getRequestedUrl] = _.bind(urlHandler.fetchRequestedUrl, urlHandler, elem);
                    elem[config.restangularFields.addRestangularMethod] = _.bind(addRestangularMethodFunction, elem);
                    elem[config.restangularFields.clone] = _.bind(copyRestangularizedElement, elem, elem);
                    elem[config.restangularFields.reqParams] = _.isEmpty(reqParams) ? null : reqParams;
                    elem[config.restangularFields.withHttpConfig] = _.bind(withHttpConfig, elem);
                    elem[config.restangularFields.plain] = _.bind(stripRestangular, elem, elem);
                    elem[config.restangularFields.restangularized] = true;
                    elem[config.restangularFields.one] = _.bind(one, elem, elem);
                    elem[config.restangularFields.all] = _.bind(all, elem, elem);
                    elem[config.restangularFields.several] = _.bind(several, elem, elem);
                    elem[config.restangularFields.oneUrl] = _.bind(oneUrl, elem, elem);
                    elem[config.restangularFields.allUrl] = _.bind(allUrl, elem, elem);
                    elem[config.restangularFields.fromServer] = !!fromServer;
                    if (parent && config.shouldSaveParent(route)) {
                        var parentId = config.getIdFromElem(parent);
                        var parentUrl = config.getUrlFromElem(parent);
                        var restangularFieldsForParent = _.union(_.values(_.pick(config.restangularFields, [ "route", "singleOne", "parentResource" ])), config.extraFields);
                        var parentResource = _.pick(parent, restangularFieldsForParent);
                        if (config.isValidId(parentId)) {
                            config.setIdToElem(parentResource, parentId, route);
                        }
                        if (config.isValidId(parentUrl)) {
                            config.setUrlToElem(parentResource, parentUrl, route);
                        }
                        elem[config.restangularFields.parentResource] = parentResource;
                    } else {
                        elem[config.restangularFields.parentResource] = null;
                    }
                    return elem;
                }
                function one(parent, route, id, singleOne) {
                    var error;
                    if (_.isNumber(route) || _.isNumber(parent)) {
                        error = "You're creating a Restangular entity with the number ";
                        error += "instead of the route or the parent. For example, you can't call .one(12).";
                        throw new Error(error);
                    }
                    if (_.isUndefined(route)) {
                        error = "You're creating a Restangular entity either without the path. ";
                        error += "For example you can't call .one(). Please check if your arguments are valid.";
                        throw new Error(error);
                    }
                    var elem = {};
                    config.setIdToElem(elem, id, route);
                    config.setFieldToElem(config.restangularFields.singleOne, elem, singleOne);
                    return restangularizeElem(parent, elem, route, false);
                }
                function all(parent, route) {
                    return restangularizeCollection(parent, [], route, false);
                }
                function several(parent, route) {
                    var collection = [];
                    collection[config.restangularFields.ids] = Array.prototype.splice.call(arguments, 2);
                    return restangularizeCollection(parent, collection, route, false);
                }
                function oneUrl(parent, route, url) {
                    if (!route) {
                        throw new Error("Route is mandatory when creating new Restangular objects.");
                    }
                    var elem = {};
                    config.setUrlToElem(elem, url, route);
                    return restangularizeElem(parent, elem, route, false);
                }
                function allUrl(parent, route, url) {
                    if (!route) {
                        throw new Error("Route is mandatory when creating new Restangular objects.");
                    }
                    var elem = {};
                    config.setUrlToElem(elem, url, route);
                    return restangularizeCollection(parent, elem, route, false);
                }
                function restangularizePromise(promise, isCollection, valueToFill) {
                    promise.call = _.bind(promiseCall, promise);
                    promise.get = _.bind(promiseGet, promise);
                    promise[config.restangularFields.restangularCollection] = isCollection;
                    if (isCollection) {
                        promise.push = _.bind(promiseCall, promise, "push");
                    }
                    promise.$object = valueToFill;
                    if (config.restangularizePromiseInterceptor) {
                        config.restangularizePromiseInterceptor(promise);
                    }
                    return promise;
                }
                function promiseCall(method) {
                    var deferred = $q.defer();
                    var callArgs = arguments;
                    var filledValue = {};
                    this.then(function(val) {
                        var params = Array.prototype.slice.call(callArgs, 1);
                        var func = val[method];
                        func.apply(val, params);
                        filledValue = val;
                        deferred.resolve(val);
                    });
                    return restangularizePromise(deferred.promise, this[config.restangularFields.restangularCollection], filledValue);
                }
                function promiseGet(what) {
                    var deferred = $q.defer();
                    var filledValue = {};
                    this.then(function(val) {
                        filledValue = val[what];
                        deferred.resolve(filledValue);
                    });
                    return restangularizePromise(deferred.promise, this[config.restangularFields.restangularCollection], filledValue);
                }
                function resolvePromise(deferred, response, data, filledValue) {
                    _.extend(filledValue, data);
                    if (config.fullResponse) {
                        return deferred.resolve(_.extend(response, {
                            data: data
                        }));
                    } else {
                        deferred.resolve(data);
                    }
                }
                function stripRestangular(elem) {
                    if (_.isArray(elem)) {
                        var array = [];
                        _.each(elem, function(value) {
                            array.push(config.isRestangularized(value) ? stripRestangular(value) : value);
                        });
                        return array;
                    } else {
                        return _.omit(elem, _.values(_.omit(config.restangularFields, "id")));
                    }
                }
                function addCustomOperation(elem) {
                    elem[config.restangularFields.customOperation] = _.bind(customFunction, elem);
                    _.each([ "put", "post", "get", "delete" ], function(oper) {
                        _.each([ "do", "custom" ], function(alias) {
                            var callOperation = oper === "delete" ? "remove" : oper;
                            var name = alias + oper.toUpperCase();
                            var callFunction;
                            if (callOperation !== "put" && callOperation !== "post") {
                                callFunction = customFunction;
                            } else {
                                callFunction = function(operation, elem, path, params, headers) {
                                    return _.bind(customFunction, this)(operation, path, params, headers, elem);
                                };
                            }
                            elem[name] = _.bind(callFunction, elem, callOperation);
                        });
                    });
                    elem[config.restangularFields.customGETLIST] = _.bind(fetchFunction, elem);
                    elem[config.restangularFields.doGETLIST] = elem[config.restangularFields.customGETLIST];
                }
                function copyRestangularizedElement(fromElement, toElement) {
                    var copiedElement = angular.copy(fromElement, toElement);
                    return restangularizeElem(copiedElement[config.restangularFields.parentResource], copiedElement, copiedElement[config.restangularFields.route], true);
                }
                function restangularizeElem(parent, element, route, fromServer, collection, reqParams) {
                    var elem = config.onBeforeElemRestangularized(element, false, route);
                    var localElem = restangularizeBase(parent, elem, route, reqParams, fromServer);
                    if (config.useCannonicalId) {
                        localElem[config.restangularFields.cannonicalId] = config.getIdFromElem(localElem);
                    }
                    if (collection) {
                        localElem[config.restangularFields.getParentList] = function() {
                            return collection;
                        };
                    }
                    localElem[config.restangularFields.restangularCollection] = false;
                    localElem[config.restangularFields.get] = _.bind(getFunction, localElem);
                    localElem[config.restangularFields.getList] = _.bind(fetchFunction, localElem);
                    localElem[config.restangularFields.put] = _.bind(putFunction, localElem);
                    localElem[config.restangularFields.post] = _.bind(postFunction, localElem);
                    localElem[config.restangularFields.remove] = _.bind(deleteFunction, localElem);
                    localElem[config.restangularFields.head] = _.bind(headFunction, localElem);
                    localElem[config.restangularFields.trace] = _.bind(traceFunction, localElem);
                    localElem[config.restangularFields.options] = _.bind(optionsFunction, localElem);
                    localElem[config.restangularFields.patch] = _.bind(patchFunction, localElem);
                    localElem[config.restangularFields.save] = _.bind(save, localElem);
                    addCustomOperation(localElem);
                    return config.transformElem(localElem, false, route, service, true);
                }
                function restangularizeCollection(parent, element, route, fromServer, reqParams) {
                    var elem = config.onBeforeElemRestangularized(element, true, route);
                    var localElem = restangularizeBase(parent, elem, route, reqParams, fromServer);
                    localElem[config.restangularFields.restangularCollection] = true;
                    localElem[config.restangularFields.post] = _.bind(postFunction, localElem, null);
                    localElem[config.restangularFields.remove] = _.bind(deleteFunction, localElem);
                    localElem[config.restangularFields.head] = _.bind(headFunction, localElem);
                    localElem[config.restangularFields.trace] = _.bind(traceFunction, localElem);
                    localElem[config.restangularFields.putElement] = _.bind(putElementFunction, localElem);
                    localElem[config.restangularFields.options] = _.bind(optionsFunction, localElem);
                    localElem[config.restangularFields.patch] = _.bind(patchFunction, localElem);
                    localElem[config.restangularFields.get] = _.bind(getById, localElem);
                    localElem[config.restangularFields.getList] = _.bind(fetchFunction, localElem, null);
                    addCustomOperation(localElem);
                    return config.transformElem(localElem, true, route, service, true);
                }
                function restangularizeCollectionAndElements(parent, element, route) {
                    var collection = restangularizeCollection(parent, element, route, false);
                    _.each(collection, function(elem) {
                        restangularizeElem(parent, elem, route, false);
                    });
                    return collection;
                }
                function getById(id, reqParams, headers) {
                    return this.customGET(id.toString(), reqParams, headers);
                }
                function putElementFunction(idx, params, headers) {
                    var __this = this;
                    var elemToPut = this[idx];
                    var deferred = $q.defer();
                    var filledArray = [];
                    filledArray = config.transformElem(filledArray, true, elemToPut[config.restangularFields.route], service);
                    elemToPut.put(params, headers).then(function(serverElem) {
                        var newArray = copyRestangularizedElement(__this);
                        newArray[idx] = serverElem;
                        filledArray = newArray;
                        deferred.resolve(newArray);
                    }, function(response) {
                        deferred.reject(response);
                    });
                    return restangularizePromise(deferred.promise, true, filledArray);
                }
                function parseResponse(resData, operation, route, fetchUrl, response, deferred) {
                    var data = config.responseExtractor(resData, operation, route, fetchUrl, response, deferred);
                    var etag = response.headers("ETag");
                    if (data && etag) {
                        data[config.restangularFields.etag] = etag;
                    }
                    return data;
                }
                function fetchFunction(what, reqParams, headers) {
                    var __this = this;
                    var deferred = $q.defer();
                    var operation = "getList";
                    var url = urlHandler.fetchUrl(this, what);
                    var whatFetched = what || __this[config.restangularFields.route];
                    var request = config.fullRequestInterceptor(null, operation, whatFetched, url, headers || {}, reqParams || {}, this[config.restangularFields.httpConfig] || {});
                    var filledArray = [];
                    filledArray = config.transformElem(filledArray, true, whatFetched, service);
                    var method = "getList";
                    if (config.jsonp) {
                        method = "jsonp";
                    }
                    var okCallback = function(response) {
                        var resData = response.data;
                        var fullParams = response.config.params;
                        var data = parseResponse(resData, operation, whatFetched, url, response, deferred);
                        if (_.isUndefined(data) || "" === data) {
                            data = [];
                        }
                        if (!_.isArray(data)) {
                            throw new Error("Response for getList SHOULD be an array and not an object or something else");
                        }
                        var processedData = _.map(data, function(elem) {
                            if (!__this[config.restangularFields.restangularCollection]) {
                                return restangularizeElem(__this, elem, what, true, data);
                            } else {
                                return restangularizeElem(__this[config.restangularFields.parentResource], elem, __this[config.restangularFields.route], true, data);
                            }
                        });
                        processedData = _.extend(data, processedData);
                        if (!__this[config.restangularFields.restangularCollection]) {
                            resolvePromise(deferred, response, restangularizeCollection(__this, processedData, what, true, fullParams), filledArray);
                        } else {
                            resolvePromise(deferred, response, restangularizeCollection(__this[config.restangularFields.parentResource], processedData, __this[config.restangularFields.route], true, fullParams), filledArray);
                        }
                    };
                    urlHandler.resource(this, $http, request.httpConfig, request.headers, request.params, what, this[config.restangularFields.etag], operation)[method]().then(okCallback, function error(response) {
                        if (response.status === 304 && __this[config.restangularFields.restangularCollection]) {
                            resolvePromise(deferred, response, __this, filledArray);
                        } else if (_.every(config.errorInterceptors, function(cb) {
                            return cb(response, deferred, okCallback) !== false;
                        })) {
                            deferred.reject(response);
                        }
                    });
                    return restangularizePromise(deferred.promise, true, filledArray);
                }
                function withHttpConfig(httpConfig) {
                    this[config.restangularFields.httpConfig] = httpConfig;
                    return this;
                }
                function save(params, headers) {
                    if (this[config.restangularFields.fromServer]) {
                        return this[config.restangularFields.put](params, headers);
                    } else {
                        return _.bind(elemFunction, this)("post", undefined, params, undefined, headers);
                    }
                }
                function elemFunction(operation, what, params, obj, headers) {
                    var __this = this;
                    var deferred = $q.defer();
                    var resParams = params || {};
                    var route = what || this[config.restangularFields.route];
                    var fetchUrl = urlHandler.fetchUrl(this, what);
                    var callObj = obj || this;
                    var etag = callObj[config.restangularFields.etag] || (operation !== "post" ? this[config.restangularFields.etag] : null);
                    if (_.isObject(callObj) && config.isRestangularized(callObj)) {
                        callObj = stripRestangular(callObj);
                    }
                    var request = config.fullRequestInterceptor(callObj, operation, route, fetchUrl, headers || {}, resParams || {}, this[config.restangularFields.httpConfig] || {});
                    var filledObject = {};
                    filledObject = config.transformElem(filledObject, false, route, service);
                    var okCallback = function(response) {
                        var resData = response.data;
                        var fullParams = response.config.params;
                        var elem = parseResponse(resData, operation, route, fetchUrl, response, deferred);
                        if (elem) {
                            var data;
                            if (operation === "post" && !__this[config.restangularFields.restangularCollection]) {
                                data = restangularizeElem(__this[config.restangularFields.parentResource], elem, route, true, null, fullParams);
                                resolvePromise(deferred, response, data, filledObject);
                            } else {
                                data = restangularizeElem(__this[config.restangularFields.parentResource], elem, __this[config.restangularFields.route], true, null, fullParams);
                                data[config.restangularFields.singleOne] = __this[config.restangularFields.singleOne];
                                resolvePromise(deferred, response, data, filledObject);
                            }
                        } else {
                            resolvePromise(deferred, response, undefined, filledObject);
                        }
                    };
                    var errorCallback = function(response) {
                        if (response.status === 304 && config.isSafe(operation)) {
                            resolvePromise(deferred, response, __this, filledObject);
                        } else if (_.every(config.errorInterceptors, function(cb) {
                            return cb(response, deferred, okCallback) !== false;
                        })) {
                            deferred.reject(response);
                        }
                    };
                    var callOperation = operation;
                    var callHeaders = _.extend({}, request.headers);
                    var isOverrideOperation = config.isOverridenMethod(operation);
                    if (isOverrideOperation) {
                        callOperation = "post";
                        callHeaders = _.extend(callHeaders, {
                            "X-HTTP-Method-Override": operation === "remove" ? "DELETE" : operation.toUpperCase()
                        });
                    } else if (config.jsonp && callOperation === "get") {
                        callOperation = "jsonp";
                    }
                    if (config.isSafe(operation)) {
                        if (isOverrideOperation) {
                            urlHandler.resource(this, $http, request.httpConfig, callHeaders, request.params, what, etag, callOperation)[callOperation]({}).then(okCallback, errorCallback);
                        } else {
                            urlHandler.resource(this, $http, request.httpConfig, callHeaders, request.params, what, etag, callOperation)[callOperation]().then(okCallback, errorCallback);
                        }
                    } else {
                        urlHandler.resource(this, $http, request.httpConfig, callHeaders, request.params, what, etag, callOperation)[callOperation](request.element).then(okCallback, errorCallback);
                    }
                    return restangularizePromise(deferred.promise, false, filledObject);
                }
                function getFunction(params, headers) {
                    return _.bind(elemFunction, this)("get", undefined, params, undefined, headers);
                }
                function deleteFunction(params, headers) {
                    return _.bind(elemFunction, this)("remove", undefined, params, undefined, headers);
                }
                function putFunction(params, headers) {
                    return _.bind(elemFunction, this)("put", undefined, params, undefined, headers);
                }
                function postFunction(what, elem, params, headers) {
                    return _.bind(elemFunction, this)("post", what, params, elem, headers);
                }
                function headFunction(params, headers) {
                    return _.bind(elemFunction, this)("head", undefined, params, undefined, headers);
                }
                function traceFunction(params, headers) {
                    return _.bind(elemFunction, this)("trace", undefined, params, undefined, headers);
                }
                function optionsFunction(params, headers) {
                    return _.bind(elemFunction, this)("options", undefined, params, undefined, headers);
                }
                function patchFunction(elem, params, headers) {
                    return _.bind(elemFunction, this)("patch", undefined, params, elem, headers);
                }
                function customFunction(operation, path, params, headers, elem) {
                    return _.bind(elemFunction, this)(operation, path, params, elem, headers);
                }
                function addRestangularMethodFunction(name, operation, path, defaultParams, defaultHeaders, defaultElem) {
                    var bindedFunction;
                    if (operation === "getList") {
                        bindedFunction = _.bind(fetchFunction, this, path);
                    } else {
                        bindedFunction = _.bind(customFunction, this, operation, path);
                    }
                    var createdFunction = function(params, headers, elem) {
                        var callParams = _.defaults({
                            params: params,
                            headers: headers,
                            elem: elem
                        }, {
                            params: defaultParams,
                            headers: defaultHeaders,
                            elem: defaultElem
                        });
                        return bindedFunction(callParams.params, callParams.headers, callParams.elem);
                    };
                    if (config.isSafe(operation)) {
                        this[name] = createdFunction;
                    } else {
                        this[name] = function(elem, params, headers) {
                            return createdFunction(params, headers, elem);
                        };
                    }
                }
                function withConfigurationFunction(configurer) {
                    var newConfig = angular.copy(_.omit(config, "configuration"));
                    Configurer.init(newConfig, newConfig);
                    configurer(newConfig);
                    return createServiceForConfiguration(newConfig);
                }
                function toService(route, parent) {
                    var knownCollectionMethods = _.values(config.restangularFields);
                    var serv = {};
                    var collection = (parent || service).all(route);
                    serv.one = _.bind(one, parent || service, parent, route);
                    serv.post = _.bind(collection.post, collection);
                    serv.getList = _.bind(collection.getList, collection);
                    for (var prop in collection) {
                        if (collection.hasOwnProperty(prop) && _.isFunction(collection[prop]) && !_.includes(knownCollectionMethods, prop)) {
                            serv[prop] = _.bind(collection[prop], collection);
                        }
                    }
                    return serv;
                }
                Configurer.init(service, config);
                service.copy = _.bind(copyRestangularizedElement, service);
                service.service = _.bind(toService, service);
                service.withConfig = _.bind(withConfigurationFunction, service);
                service.one = _.bind(one, service, null);
                service.all = _.bind(all, service, null);
                service.several = _.bind(several, service, null);
                service.oneUrl = _.bind(oneUrl, service, null);
                service.allUrl = _.bind(allUrl, service, null);
                service.stripRestangular = _.bind(stripRestangular, service);
                service.restangularizeElement = _.bind(restangularizeElem, service);
                service.restangularizeCollection = _.bind(restangularizeCollectionAndElements, service);
                return service;
            }
            return createServiceForConfiguration(globalConfiguration);
        } ];
    });
})();

(function(window, angular, undefined) {
    "use strict";
    var isDefined = angular.isDefined, isFunction = angular.isFunction, isString = angular.isString, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy, equals = angular.equals, noop = angular.noop;
    function globToPattern(str) {
        var reg = str.replace(/[.+^$()|{}]/g, function(match, offset, s) {
            return s[offset - 1] === "\\" ? match : "\\" + match;
        });
        reg = reg.replace(/[?*]/g, function(match, offset, s) {
            if (s[offset - 1] === "\\") {
                return match;
            }
            return match === "?" ? "." : ".*";
        });
        reg = reg.replace(/\\([dDsSwWtrnvfbB0cxu])/g, "$1");
        return "^" + reg + "$";
    }
    function globsToPatterns(globs) {
        var patterns = [];
        if (isString(globs)) {
            globs = globs.split(" ");
        }
        if (isArray(globs)) {
            for (var i = 0; i < globs.length; i++) {
                patterns.push(globToPattern(globs[i]));
            }
        }
        return patterns;
    }
    function matchAny(patterns, str) {
        if (isArray(patterns)) {
            for (var i = 0; i < patterns.length; i++) {
                if (!!str.match(patterns[i])) {
                    return true;
                }
            }
        }
        return false;
    }
    function matchGlobs(globs, str) {
        return matchAny(globsToPatterns(globs), str);
    }
    var uiRouterMenusModule = angular.module("ui.router.menus", [ "ng", "ui.router" ]);
    uiRouterMenusModule.directive("menus", [ "$menus", function($menus) {
        return {
            link: {
                restrict: "EA",
                scope: {
                    menus: "=",
                    type: "@",
                    include: "@",
                    tag: "@"
                },
                pre: function link(scope, element, attrs) {
                    var menuOptions = {};
                    if (isDefined(attrs.type)) {
                        menuOptions.type = attrs.type;
                    }
                    if (isDefined(attrs.include)) {
                        menuOptions.include = attrs.include;
                    }
                    if (isDefined(attrs.tag)) {
                        menuOptions.tag = attrs.tag;
                    }
                    scope[attrs.menus] = $menus.get(menuOptions);
                }
            }
        };
    } ]);
    uiRouterMenusModule.service("$menus", [ "$state", function($state) {
        var menus;
        function compile(state) {
            if (!state.menu) {
                return null;
            }
            var menu;
            if (typeof state.menu === "string") {
                menu = {
                    name: state.menu,
                    state: state
                };
            } else {
                menu = state.menu;
                menu.state = state;
            }
            return menu;
        }
        this.findMenu = function(stateName) {
            for (var i = 0; i < menus.length; i++) {
                if (stateName === menus[i].state.name) {
                    return menus[i];
                }
            }
            return null;
        };
        this.parent = function(stateName) {
            var menu = this.findMenu(stateName);
            if (menu) {
                if (isDefined(menu.state.parent) && menu.state.parent) {
                    return this.findMenu(menu.state.parent);
                }
                var compositeName = /^(.+)\.[^.]+$/.exec(menu.state.name);
                return compositeName ? this.findMenu(compositeName[1]) : null;
            }
            return null;
        };
        this.findByParent = function(stateName) {
            var self = this;
            var result = menus.filter(function(menu) {
                var parent = self.parent(menu.state.name);
                return !!parent && stateName === parent.state.name;
            });
            return result;
        };
        this.getTree = function(menu) {
            var self = this, nodes;
            if (!menu) {
                nodes = menus.filter(function(menu) {
                    return !self.parent(menu.state.name);
                });
            } else {
                nodes = this.findByParent(menu.state.name);
            }
            forEach(nodes, function(node) {
                node.children = self.getTree(node);
                node.hasChild = isDefined(node.children) && isArray(node.children) ? !!node.children.length : false;
            });
            return nodes;
        };
        this.get = function(options) {
            options = options || {};
            menus = [];
            var states = $state.get();
            var includes = options.include || null;
            if (includes) {
                includes = globsToPatterns(includes);
                states = states.filter(function(state) {
                    return matchAny(includes, state.name);
                });
            }
            var tags = options.tag || null;
            if (tags) {
                tags = globsToPatterns(tags);
            }
            forEach(states, function(state) {
                var menu = compile(state);
                if (menu) {
                    if (tags) {
                        if (isDefined(menu.tag)) {
                            if (matchAny(tags, menu.tag)) {
                                menus.push(menu);
                            }
                        }
                    } else {
                        menus.push(menu);
                    }
                }
            });
            var type = options.type || "list";
            if (type === "tree") {
                return this.getTree();
            }
            return menus;
        };
    } ]);
})(window, window.angular);

(function(window, angular, undefined) {
    "use strict";
    angular.module("satellizer", []).constant("satellizer.config", {
        httpInterceptor: true,
        loginOnSignup: true,
        baseUrl: "/",
        loginRedirect: "/",
        logoutRedirect: "/",
        signupRedirect: "/login",
        loginUrl: "/auth/login",
        signupUrl: "/auth/signup",
        loginRoute: "/login",
        signupRoute: "/signup",
        tokenRoot: false,
        tokenName: "token",
        tokenPrefix: "satellizer",
        unlinkUrl: "/auth/unlink/",
        unlinkMethod: "get",
        authHeader: "Authorization",
        authToken: "Bearer",
        withCredentials: true,
        platform: "browser",
        storage: "localStorage",
        providers: {
            google: {
                name: "google",
                url: "/auth/google",
                authorizationEndpoint: "https://accounts.google.com/o/oauth2/auth",
                redirectUri: window.location.origin || window.location.protocol + "//" + window.location.host,
                scope: [ "profile", "email" ],
                scopePrefix: "openid",
                scopeDelimiter: " ",
                requiredUrlParams: [ "scope" ],
                optionalUrlParams: [ "display" ],
                display: "popup",
                type: "2.0",
                popupOptions: {
                    width: 452,
                    height: 633
                }
            },
            facebook: {
                name: "facebook",
                url: "/auth/facebook",
                authorizationEndpoint: "https://www.facebook.com/v2.3/dialog/oauth",
                redirectUri: window.location.origin + "/" || window.location.protocol + "//" + window.location.host + "/",
                scope: [ "email" ],
                scopeDelimiter: ",",
                requiredUrlParams: [ "display", "scope" ],
                display: "popup",
                type: "2.0",
                popupOptions: {
                    width: 580,
                    height: 400
                }
            },
            linkedin: {
                name: "linkedin",
                url: "/auth/linkedin",
                authorizationEndpoint: "https://www.linkedin.com/uas/oauth2/authorization",
                redirectUri: window.location.origin || window.location.protocol + "//" + window.location.host,
                requiredUrlParams: [ "state" ],
                scope: [ "r_emailaddress" ],
                scopeDelimiter: " ",
                state: "STATE",
                type: "2.0",
                popupOptions: {
                    width: 527,
                    height: 582
                }
            },
            github: {
                name: "github",
                url: "/auth/github",
                authorizationEndpoint: "https://github.com/login/oauth/authorize",
                redirectUri: window.location.origin || window.location.protocol + "//" + window.location.host,
                optionalUrlParams: [ "scope" ],
                scope: [ "user:email" ],
                scopeDelimiter: " ",
                type: "2.0",
                popupOptions: {
                    width: 1020,
                    height: 618
                }
            },
            yahoo: {
                name: "yahoo",
                url: "/auth/yahoo",
                authorizationEndpoint: "https://api.login.yahoo.com/oauth2/request_auth",
                redirectUri: window.location.origin || window.location.protocol + "//" + window.location.host,
                scope: [],
                scopeDelimiter: ",",
                type: "2.0",
                popupOptions: {
                    width: 559,
                    height: 519
                }
            },
            twitter: {
                name: "twitter",
                url: "/auth/twitter",
                type: "1.0",
                popupOptions: {
                    width: 495,
                    height: 645
                }
            },
            live: {
                name: "live",
                url: "/auth/live",
                authorizationEndpoint: "https://login.live.com/oauth20_authorize.srf",
                redirectUri: window.location.origin || window.location.protocol + "//" + window.location.host,
                scope: [ "wl.emails" ],
                scopeDelimiter: " ",
                requiredUrlParams: [ "display", "scope" ],
                display: "popup",
                type: "2.0",
                popupOptions: {
                    width: 500,
                    height: 560
                }
            }
        }
    }).provider("$auth", [ "satellizer.config", function(config) {
        Object.defineProperties(this, {
            baseUrl: {
                get: function() {
                    return config.baseUrl;
                },
                set: function(value) {
                    config.baseUrl = value;
                }
            },
            httpInterceptor: {
                get: function() {
                    return config.httpInterceptor;
                },
                set: function(value) {
                    config.httpInterceptor = value;
                }
            },
            loginOnSignup: {
                get: function() {
                    return config.loginOnSignup;
                },
                set: function(value) {
                    config.loginOnSignup = value;
                }
            },
            logoutRedirect: {
                get: function() {
                    return config.logoutRedirect;
                },
                set: function(value) {
                    config.logoutRedirect = value;
                }
            },
            loginRedirect: {
                set: function(value) {
                    config.loginRedirect = value;
                },
                get: function() {
                    return config.loginRedirect;
                }
            },
            signupRedirect: {
                get: function() {
                    return config.signupRedirect;
                },
                set: function(value) {
                    config.signupRedirect = value;
                }
            },
            loginUrl: {
                get: function() {
                    return config.loginUrl;
                },
                set: function(value) {
                    config.loginUrl = value;
                }
            },
            signupUrl: {
                get: function() {
                    return config.signupUrl;
                },
                set: function(value) {
                    config.signupUrl = value;
                }
            },
            loginRoute: {
                get: function() {
                    return config.loginRoute;
                },
                set: function(value) {
                    config.loginRoute = value;
                }
            },
            signupRoute: {
                get: function() {
                    return config.signupRoute;
                },
                set: function(value) {
                    config.signupRoute = value;
                }
            },
            tokenRoot: {
                get: function() {
                    return config.tokenRoot;
                },
                set: function(value) {
                    config.tokenRoot = value;
                }
            },
            tokenName: {
                get: function() {
                    return config.tokenName;
                },
                set: function(value) {
                    config.tokenName = value;
                }
            },
            tokenPrefix: {
                get: function() {
                    return config.tokenPrefix;
                },
                set: function(value) {
                    config.tokenPrefix = value;
                }
            },
            unlinkUrl: {
                get: function() {
                    return config.unlinkUrl;
                },
                set: function(value) {
                    config.unlinkUrl = value;
                }
            },
            authHeader: {
                get: function() {
                    return config.authHeader;
                },
                set: function(value) {
                    config.authHeader = value;
                }
            },
            authToken: {
                get: function() {
                    return config.authToken;
                },
                set: function(value) {
                    config.authToken = value;
                }
            },
            withCredentials: {
                get: function() {
                    return config.withCredentials;
                },
                set: function(value) {
                    config.withCredentials = value;
                }
            },
            unlinkMethod: {
                get: function() {
                    return config.unlinkMethod;
                },
                set: function(value) {
                    config.unlinkMethod = value;
                }
            },
            platform: {
                get: function() {
                    return config.platform;
                },
                set: function(value) {
                    config.platform = value;
                }
            }
        });
        angular.forEach(Object.keys(config.providers), function(provider) {
            this[provider] = function(params) {
                return angular.extend(config.providers[provider], params);
            };
        }, this);
        var oauth = function(params) {
            config.providers[params.name] = config.providers[params.name] || {};
            angular.extend(config.providers[params.name], params);
        };
        this.oauth1 = function(params) {
            oauth(params);
            config.providers[params.name].type = "1.0";
        };
        this.oauth2 = function(params) {
            oauth(params);
            config.providers[params.name].type = "2.0";
        };
        this.$get = [ "$q", "satellizer.shared", "satellizer.local", "satellizer.oauth", function($q, shared, local, oauth) {
            var $auth = {};
            $auth.authenticate = function(name, userData) {
                return oauth.authenticate(name, false, userData);
            };
            $auth.login = function(user, redirect) {
                return local.login(user, redirect);
            };
            $auth.signup = function(user) {
                return local.signup(user);
            };
            $auth.logout = function(redirect) {
                return shared.logout(redirect);
            };
            $auth.isAuthenticated = function() {
                return shared.isAuthenticated();
            };
            $auth.link = function(name, userData) {
                return oauth.authenticate(name, true, userData);
            };
            $auth.unlink = function(provider) {
                return oauth.unlink(provider);
            };
            $auth.getToken = function() {
                return shared.getToken();
            };
            $auth.setToken = function(token, redirect) {
                shared.setToken({
                    access_token: token
                }, redirect);
            };
            $auth.removeToken = function() {
                return shared.removeToken();
            };
            $auth.getPayload = function() {
                return shared.getPayload();
            };
            return $auth;
        } ];
    } ]).factory("satellizer.shared", [ "$q", "$window", "$location", "satellizer.config", "satellizer.storage", function($q, $window, $location, config, storage) {
        var shared = {};
        var tokenName = config.tokenPrefix ? config.tokenPrefix + "_" + config.tokenName : config.tokenName;
        shared.getToken = function() {
            return storage.get(tokenName);
        };
        shared.getPayload = function() {
            var token = storage.get(tokenName);
            if (token && token.split(".").length === 3) {
                var base64Url = token.split(".")[1];
                var base64 = base64Url.replace("-", "+").replace("_", "/");
                return JSON.parse($window.atob(base64));
            }
        };
        shared.setToken = function(response, redirect) {
            var accessToken = response && response.access_token;
            var token;
            if (accessToken) {
                if (angular.isObject(accessToken) && angular.isObject(accessToken.data)) {
                    response = accessToken;
                } else if (angular.isString(accessToken)) {
                    token = accessToken;
                }
            }
            if (!token && response) {
                token = config.tokenRoot && response.data[config.tokenRoot] ? response.data[config.tokenRoot][config.tokenName] : response.data[config.tokenName];
            }
            if (!token) {
                var tokenPath = config.tokenRoot ? config.tokenRoot + "." + config.tokenName : config.tokenName;
                throw new Error('Expecting a token named "' + tokenPath + '" but instead got: ' + JSON.stringify(response.data));
            }
            storage.set(tokenName, token);
            if (config.loginRedirect && !redirect) {
                $location.path(config.loginRedirect);
            } else if (redirect && angular.isString(redirect)) {
                $location.path(encodeURI(redirect));
            }
        };
        shared.removeToken = function() {
            storage.remove(tokenName);
        };
        shared.isAuthenticated = function() {
            var token = storage.get(tokenName);
            if (token) {
                if (token.split(".").length === 3) {
                    var base64Url = token.split(".")[1];
                    var base64 = base64Url.replace("-", "+").replace("_", "/");
                    var exp = JSON.parse($window.atob(base64)).exp;
                    if (exp) {
                        return Math.round(new Date().getTime() / 1e3) <= exp;
                    }
                }
                return true;
            }
            return false;
        };
        shared.logout = function(redirect) {
            storage.remove(tokenName);
            if (config.logoutRedirect && !redirect) {
                $location.url(config.logoutRedirect);
            } else if (angular.isString(redirect)) {
                $location.url(redirect);
            }
            return $q.when();
        };
        return shared;
    } ]).factory("satellizer.oauth", [ "$q", "$http", "satellizer.config", "satellizer.shared", "satellizer.Oauth1", "satellizer.Oauth2", function($q, $http, config, shared, Oauth1, Oauth2) {
        var oauth = {};
        oauth.authenticate = function(name, redirect, userData) {
            var provider = config.providers[name].type === "1.0" ? new Oauth1() : new Oauth2();
            var deferred = $q.defer();
            provider.open(config.providers[name], userData || {}).then(function(response) {
                shared.setToken(response, redirect);
                deferred.resolve(response);
            }).catch(function(error) {
                deferred.reject(error);
            });
            return deferred.promise;
        };
        oauth.unlink = function(provider) {
            if (config.unlinkMethod === "get") {
                return $http.get(config.unlinkUrl + provider);
            } else if (config.unlinkMethod === "post") {
                return $http.post(config.unlinkUrl, provider);
            }
        };
        return oauth;
    } ]).factory("satellizer.local", [ "$q", "$http", "$location", "satellizer.utils", "satellizer.shared", "satellizer.config", function($q, $http, $location, utils, shared, config) {
        var local = {};
        local.login = function(user, redirect) {
            var loginUrl = config.baseUrl ? utils.joinUrl(config.baseUrl, config.loginUrl) : config.loginUrl;
            return $http.post(loginUrl, user).then(function(response) {
                shared.setToken(response, redirect);
                return response;
            });
        };
        local.signup = function(user) {
            var signupUrl = config.baseUrl ? utils.joinUrl(config.baseUrl, config.signupUrl) : config.signupUrl;
            return $http.post(signupUrl, user).then(function(response) {
                if (config.loginOnSignup) {
                    shared.setToken(response);
                } else if (config.signupRedirect) {
                    $location.path(config.signupRedirect);
                }
                return response;
            });
        };
        return local;
    } ]).factory("satellizer.Oauth2", [ "$q", "$http", "$window", "satellizer.popup", "satellizer.utils", "satellizer.config", "satellizer.storage", function($q, $http, $window, popup, utils, config, storage) {
        return function() {
            var defaults = {
                url: null,
                name: null,
                state: null,
                scope: null,
                scopeDelimiter: null,
                clientId: null,
                redirectUri: null,
                popupOptions: null,
                authorizationEndpoint: null,
                responseParams: null,
                requiredUrlParams: null,
                optionalUrlParams: null,
                defaultUrlParams: [ "response_type", "client_id", "redirect_uri" ],
                responseType: "code"
            };
            var oauth2 = {};
            oauth2.open = function(options, userData) {
                angular.extend(defaults, options);
                var stateName = defaults.name + "_state";
                if (angular.isFunction(defaults.state)) {
                    storage.set(stateName, defaults.state());
                } else if (angular.isString(defaults.state)) {
                    storage.set(stateName, defaults.state);
                }
                var url = defaults.authorizationEndpoint + "?" + oauth2.buildQueryString();
                return popup.open(url, defaults.popupOptions, defaults.redirectUri).then(function(oauthData) {
                    if (defaults.responseType === "token") {
                        return oauthData;
                    }
                    if (oauthData.state && oauthData.state !== storage.get(stateName)) {
                        return $q.reject("OAuth 2.0 state parameter mismatch.");
                    }
                    return oauth2.exchangeForToken(oauthData, userData);
                });
            };
            oauth2.exchangeForToken = function(oauthData, userData) {
                var data = angular.extend({}, userData, {
                    code: oauthData.code,
                    clientId: defaults.clientId,
                    redirectUri: defaults.redirectUri
                });
                if (oauthData.state) {
                    data.state = oauthData.state;
                }
                angular.forEach(defaults.responseParams, function(param) {
                    data[param] = oauthData[param];
                });
                var exchangeForTokenUrl = config.baseUrl ? utils.joinUrl(config.baseUrl, defaults.url) : defaults.url;
                return $http.post(exchangeForTokenUrl, data, {
                    withCredentials: config.withCredentials
                });
            };
            oauth2.buildQueryString = function() {
                var keyValuePairs = [];
                var urlParams = [ "defaultUrlParams", "requiredUrlParams", "optionalUrlParams" ];
                angular.forEach(urlParams, function(params) {
                    angular.forEach(defaults[params], function(paramName) {
                        var camelizedName = utils.camelCase(paramName);
                        var paramValue = defaults[camelizedName];
                        if (paramName === "state") {
                            var stateName = defaults.name + "_state";
                            paramValue = encodeURIComponent(storage.get(stateName));
                        }
                        if (paramName === "scope" && Array.isArray(paramValue)) {
                            paramValue = paramValue.join(defaults.scopeDelimiter);
                            if (defaults.scopePrefix) {
                                paramValue = [ defaults.scopePrefix, paramValue ].join(defaults.scopeDelimiter);
                            }
                        }
                        keyValuePairs.push([ paramName, paramValue ]);
                    });
                });
                return keyValuePairs.map(function(pair) {
                    return pair.join("=");
                }).join("&");
            };
            return oauth2;
        };
    } ]).factory("satellizer.Oauth1", [ "$q", "$http", "satellizer.popup", "satellizer.config", "satellizer.utils", function($q, $http, popup, config, utils) {
        return function() {
            var defaults = {
                url: null,
                name: null,
                popupOptions: null,
                redirectUri: null
            };
            var oauth1 = {};
            oauth1.open = function(options, userData) {
                angular.extend(defaults, options);
                var popupUrl = config.baseUrl ? utils.joinUrl(config.baseUrl, defaults.url) : defaults.url;
                return popup.open(popupUrl, defaults.popupOptions, defaults.redirectUri).then(function(response) {
                    return oauth1.exchangeForToken(response, userData);
                });
            };
            oauth1.exchangeForToken = function(oauthData, userData) {
                var data = angular.extend({}, userData, oauthData);
                var qs = oauth1.buildQueryString(data);
                var exchangeForTokenUrl = config.baseUrl ? utils.joinUrl(config.baseUrl, defaults.url) : defaults.url;
                return $http.get(exchangeForTokenUrl + "?" + qs);
            };
            oauth1.buildQueryString = function(obj) {
                var str = [];
                angular.forEach(obj, function(value, key) {
                    str.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
                });
                return str.join("&");
            };
            return oauth1;
        };
    } ]).factory("satellizer.popup", [ "$q", "$interval", "$window", "$location", "satellizer.config", "satellizer.utils", function($q, $interval, $window, $location, config, utils) {
        var popupWindow = null;
        var polling = null;
        var popup = {};
        popup.popupWindow = popupWindow;
        popup.open = function(url, options, redirectUri) {
            var optionsString = popup.stringifyOptions(popup.prepareOptions(options || {}));
            popupWindow = window.open(url, "_blank", optionsString);
            if (popupWindow && popupWindow.focus) {
                popupWindow.focus();
            }
            if (config.platform === "mobile") {
                return popup.eventListener(redirectUri);
            }
            return popup.pollPopup();
        };
        popup.eventListener = function(redirectUri) {
            var deferred = $q.defer();
            popupWindow.addEventListener("loadstart", function(event) {
                if (event.url.indexOf(redirectUri) !== 0) {
                    return;
                }
                var parser = document.createElement("a");
                parser.href = event.url;
                if (parser.search || parser.hash) {
                    var queryParams = parser.search.substring(1).replace(/\/$/, "");
                    var hashParams = parser.hash.substring(1).replace(/\/$/, "");
                    var hash = utils.parseQueryString(hashParams);
                    var qs = utils.parseQueryString(queryParams);
                    angular.extend(qs, hash);
                    if (qs.error) {
                        deferred.reject({
                            error: qs.error
                        });
                    } else {
                        deferred.resolve(qs);
                    }
                    popupWindow.close();
                }
            });
            popupWindow.addEventListener("exit", function() {
                deferred.reject({
                    data: "Provider Popup was closed"
                });
            });
            popupWindow.addEventListener("loaderror", function() {
                deferred.reject({
                    data: "Authorization Failed"
                });
            });
            return deferred.promise;
        };
        popup.pollPopup = function() {
            var deferred = $q.defer();
            polling = $interval(function() {
                try {
                    var documentOrigin = document.location.host + ":" + document.location.port, popupWindowOrigin = popupWindow.location.host + ":" + popupWindow.location.port;
                    if (popupWindowOrigin === documentOrigin && (popupWindow.location.search || popupWindow.location.hash)) {
                        var queryParams = popupWindow.location.search.substring(1).replace(/\/$/, "");
                        var hashParams = popupWindow.location.hash.substring(1).replace(/\/$/, "");
                        var hash = utils.parseQueryString(hashParams);
                        var qs = utils.parseQueryString(queryParams);
                        angular.extend(qs, hash);
                        if (qs.error) {
                            deferred.reject({
                                error: qs.error
                            });
                        } else {
                            deferred.resolve(qs);
                        }
                        popupWindow.close();
                        $interval.cancel(polling);
                    }
                } catch (error) {}
                if (!popupWindow) {
                    $interval.cancel(polling);
                    deferred.reject({
                        data: "Provider Popup Blocked"
                    });
                } else if (popupWindow.closed || popupWindow.closed === undefined) {
                    $interval.cancel(polling);
                    deferred.reject({
                        data: "Authorization Failed"
                    });
                }
            }, 35);
            return deferred.promise;
        };
        popup.prepareOptions = function(options) {
            var width = options.width || 500;
            var height = options.height || 500;
            return angular.extend({
                width: width,
                height: height,
                left: $window.screenX + ($window.outerWidth - width) / 2,
                top: $window.screenY + ($window.outerHeight - height) / 2.5
            }, options);
        };
        popup.stringifyOptions = function(options) {
            var parts = [];
            angular.forEach(options, function(value, key) {
                parts.push(key + "=" + value);
            });
            return parts.join(",");
        };
        return popup;
    } ]).service("satellizer.utils", function() {
        this.camelCase = function(name) {
            return name.replace(/([\:\-\_]+(.))/g, function(_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter;
            });
        };
        this.parseQueryString = function(keyValue) {
            var obj = {}, key, value;
            angular.forEach((keyValue || "").split("&"), function(keyValue) {
                if (keyValue) {
                    value = keyValue.split("=");
                    key = decodeURIComponent(value[0]);
                    obj[key] = angular.isDefined(value[1]) ? decodeURIComponent(value[1]) : true;
                }
            });
            return obj;
        };
        this.joinUrl = function() {
            var joined = Array.prototype.slice.call(arguments, 0).join("/");
            var normalize = function(str) {
                return str.replace(/[\/]+/g, "/").replace(/\/\?/g, "?").replace(/\/\#/g, "#").replace(/\:\//g, "://");
            };
            return normalize(joined);
        };
    }).factory("satellizer.storage", [ "satellizer.config", function(config) {
        switch (config.storage) {
          case "localStorage":
            if ("localStorage" in window && window["localStorage"] !== null) {
                return {
                    get: function(key) {
                        return localStorage.getItem(key);
                    },
                    set: function(key, value) {
                        return localStorage.setItem(key, value);
                    },
                    remove: function(key) {
                        return localStorage.removeItem(key);
                    }
                };
            } else {
                console.warn("Warning: Local Storage is disabled or unavailable. Satellizer will not work correctly.");
                return {
                    get: function(key) {
                        return undefined;
                    },
                    set: function(key, value) {
                        return undefined;
                    },
                    remove: function(key) {
                        return undefined;
                    }
                };
            }
            break;

          case "sessionStorage":
            if ("sessionStorage" in window && window["sessionStorage"] !== null) {
                return {
                    get: function(key) {
                        return sessionStorage.getItem(key);
                    },
                    set: function(key, value) {
                        return sessionStorage.setItem(key, value);
                    },
                    remove: function(key) {
                        return sessionStorage.removeItem(key);
                    }
                };
            } else {
                console.warn("Warning: Session Storage is disabled or unavailable. Satellizer will not work correctly.");
                return {
                    get: function(key) {
                        return undefined;
                    },
                    set: function(key, value) {
                        return undefined;
                    },
                    remove: function(key) {
                        return undefined;
                    }
                };
            }
            break;
        }
    } ]).factory("satellizer.interceptor", [ "$q", "satellizer.config", "satellizer.storage", function($q, config, storage) {
        var tokenName = config.tokenPrefix ? config.tokenPrefix + "_" + config.tokenName : config.tokenName;
        return {
            request: function(httpConfig) {
                var token = storage.get(tokenName);
                if (token && config.httpInterceptor) {
                    if (config.authHeader && config.authToken) {
                        token = config.authToken + " " + token;
                    }
                    httpConfig.headers[config.authHeader] = token;
                }
                return httpConfig;
            },
            responseError: function(response) {
                return $q.reject(response);
            }
        };
    } ]).config([ "$httpProvider", function($httpProvider) {
        $httpProvider.interceptors.push("satellizer.interceptor");
    } ]);
})(window, window.angular);

(function() {
    var object = typeof exports != "undefined" ? exports : this;
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    function InvalidCharacterError(message) {
        this.message = message;
    }
    InvalidCharacterError.prototype = new Error();
    InvalidCharacterError.prototype.name = "InvalidCharacterError";
    object.btoa || (object.btoa = function(input) {
        var str = String(input);
        for (var block, charCode, idx = 0, map = chars, output = ""; str.charAt(idx | 0) || (map = "=", 
        idx % 1); output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
            charCode = str.charCodeAt(idx += 3 / 4);
            if (charCode > 255) {
                throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
            }
            block = block << 8 | charCode;
        }
        return output;
    });
    object.atob || (object.atob = function(input) {
        var str = String(input).replace(/=+$/, "");
        if (str.length % 4 == 1) {
            throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
        }
        for (var bc = 0, bs, buffer, idx = 0, output = ""; buffer = str.charAt(idx++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, 
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
            buffer = chars.indexOf(buffer);
        }
        return output;
    });
})();

(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define([], function() {
            return factory();
        });
    } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
    } else {
        factory();
    }
})(this, function() {
    runTranslate.$inject = [ "$translate" ];
    $translate.$inject = [ "$STORAGE_KEY", "$windowProvider", "$translateSanitizationProvider", "pascalprechtTranslateOverrider" ];
    $translateDefaultInterpolation.$inject = [ "$interpolate", "$translateSanitization" ];
    translateDirective.$inject = [ "$translate", "$interpolate", "$compile", "$parse", "$rootScope" ];
    translateAttrDirective.$inject = [ "$translate", "$rootScope" ];
    translateCloakDirective.$inject = [ "$translate", "$rootScope" ];
    translateFilterFactory.$inject = [ "$parse", "$translate" ];
    $translationCache.$inject = [ "$cacheFactory" ];
    angular.module("pascalprecht.translate", [ "ng" ]).run(runTranslate);
    function runTranslate($translate) {
        "use strict";
        var key = $translate.storageKey(), storage = $translate.storage();
        var fallbackFromIncorrectStorageValue = function() {
            var preferred = $translate.preferredLanguage();
            if (angular.isString(preferred)) {
                $translate.use(preferred);
            } else {
                storage.put(key, $translate.use());
            }
        };
        fallbackFromIncorrectStorageValue.displayName = "fallbackFromIncorrectStorageValue";
        if (storage) {
            if (!storage.get(key)) {
                fallbackFromIncorrectStorageValue();
            } else {
                $translate.use(storage.get(key))["catch"](fallbackFromIncorrectStorageValue);
            }
        } else if (angular.isString($translate.preferredLanguage())) {
            $translate.use($translate.preferredLanguage());
        }
    }
    runTranslate.displayName = "runTranslate";
    angular.module("pascalprecht.translate").provider("$translateSanitization", $translateSanitizationProvider);
    function $translateSanitizationProvider() {
        "use strict";
        var $sanitize, $sce, currentStrategy = null, hasConfiguredStrategy = false, hasShownNoStrategyConfiguredWarning = false, strategies;
        strategies = {
            sanitize: function(value, mode) {
                if (mode === "text") {
                    value = htmlSanitizeValue(value);
                }
                return value;
            },
            escape: function(value, mode) {
                if (mode === "text") {
                    value = htmlEscapeValue(value);
                }
                return value;
            },
            sanitizeParameters: function(value, mode) {
                if (mode === "params") {
                    value = mapInterpolationParameters(value, htmlSanitizeValue);
                }
                return value;
            },
            escapeParameters: function(value, mode) {
                if (mode === "params") {
                    value = mapInterpolationParameters(value, htmlEscapeValue);
                }
                return value;
            },
            sce: function(value, mode, context) {
                if (mode === "text") {
                    value = htmlTrustValue(value);
                } else if (mode === "params") {
                    if (context !== "filter") {
                        value = mapInterpolationParameters(value, htmlEscapeValue);
                    }
                }
                return value;
            },
            sceParameters: function(value, mode) {
                if (mode === "params") {
                    value = mapInterpolationParameters(value, htmlTrustValue);
                }
                return value;
            }
        };
        strategies.escaped = strategies.escapeParameters;
        this.addStrategy = function(strategyName, strategyFunction) {
            strategies[strategyName] = strategyFunction;
            return this;
        };
        this.removeStrategy = function(strategyName) {
            delete strategies[strategyName];
            return this;
        };
        this.useStrategy = function(strategy) {
            hasConfiguredStrategy = true;
            currentStrategy = strategy;
            return this;
        };
        this.$get = [ "$injector", "$log", function($injector, $log) {
            var cachedStrategyMap = {};
            var applyStrategies = function(value, mode, context, selectedStrategies) {
                angular.forEach(selectedStrategies, function(selectedStrategy) {
                    if (angular.isFunction(selectedStrategy)) {
                        value = selectedStrategy(value, mode, context);
                    } else if (angular.isFunction(strategies[selectedStrategy])) {
                        value = strategies[selectedStrategy](value, mode, context);
                    } else if (angular.isString(strategies[selectedStrategy])) {
                        if (!cachedStrategyMap[strategies[selectedStrategy]]) {
                            try {
                                cachedStrategyMap[strategies[selectedStrategy]] = $injector.get(strategies[selectedStrategy]);
                            } catch (e) {
                                cachedStrategyMap[strategies[selectedStrategy]] = function() {};
                                throw new Error("pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: '" + selectedStrategy + "'");
                            }
                        }
                        value = cachedStrategyMap[strategies[selectedStrategy]](value, mode, context);
                    } else {
                        throw new Error("pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: '" + selectedStrategy + "'");
                    }
                });
                return value;
            };
            var showNoStrategyConfiguredWarning = function() {
                if (!hasConfiguredStrategy && !hasShownNoStrategyConfiguredWarning) {
                    $log.warn("pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details.");
                    hasShownNoStrategyConfiguredWarning = true;
                }
            };
            if ($injector.has("$sanitize")) {
                $sanitize = $injector.get("$sanitize");
            }
            if ($injector.has("$sce")) {
                $sce = $injector.get("$sce");
            }
            return {
                useStrategy: function(self) {
                    return function(strategy) {
                        self.useStrategy(strategy);
                    };
                }(this),
                sanitize: function(value, mode, strategy, context) {
                    if (!currentStrategy) {
                        showNoStrategyConfiguredWarning();
                    }
                    if (!strategy && strategy !== null) {
                        strategy = currentStrategy;
                    }
                    if (!strategy) {
                        return value;
                    }
                    if (!context) {
                        context = "service";
                    }
                    var selectedStrategies = angular.isArray(strategy) ? strategy : [ strategy ];
                    return applyStrategies(value, mode, context, selectedStrategies);
                }
            };
        } ];
        var htmlEscapeValue = function(value) {
            var element = angular.element("<div></div>");
            element.text(value);
            return element.html();
        };
        var htmlSanitizeValue = function(value) {
            if (!$sanitize) {
                throw new Error("pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as 'escape'.");
            }
            return $sanitize(value);
        };
        var htmlTrustValue = function(value) {
            if (!$sce) {
                throw new Error("pascalprecht.translate.$translateSanitization: Error cannot find $sce service.");
            }
            return $sce.trustAsHtml(value);
        };
        var mapInterpolationParameters = function(value, iteratee, stack) {
            if (angular.isDate(value)) {
                return value;
            } else if (angular.isObject(value)) {
                var result = angular.isArray(value) ? [] : {};
                if (!stack) {
                    stack = [];
                } else {
                    if (stack.indexOf(value) > -1) {
                        throw new Error("pascalprecht.translate.$translateSanitization: Error cannot interpolate parameter due recursive object");
                    }
                }
                stack.push(value);
                angular.forEach(value, function(propertyValue, propertyKey) {
                    if (angular.isFunction(propertyValue)) {
                        return;
                    }
                    result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee, stack);
                });
                stack.splice(-1, 1);
                return result;
            } else if (angular.isNumber(value)) {
                return value;
            } else if (value === true || value === false) {
                return value;
            } else if (!angular.isUndefined(value) && value !== null) {
                return iteratee(value);
            } else {
                return value;
            }
        };
    }
    angular.module("pascalprecht.translate").constant("pascalprechtTranslateOverrider", {}).provider("$translate", $translate);
    function $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {
        "use strict";
        var $translationTable = {}, $preferredLanguage, $availableLanguageKeys = [], $languageKeyAliases, $fallbackLanguage, $fallbackWasString, $uses, $nextLang, $storageFactory, $storageKey = $STORAGE_KEY, $storagePrefix, $missingTranslationHandlerFactory, $interpolationFactory, $interpolatorFactories = [], $loaderFactory, $cloakClassName = "translate-cloak", $loaderOptions, $notFoundIndicatorLeft, $notFoundIndicatorRight, $postCompilingEnabled = false, $forceAsyncReloadEnabled = false, $nestedObjectDelimeter = ".", $isReady = false, $keepContent = false, loaderCache, directivePriority = 0, statefulFilter = true, postProcessFn, uniformLanguageTagResolver = "default", languageTagResolver = {
            default: function(tag) {
                return (tag || "").split("-").join("_");
            },
            java: function(tag) {
                var temp = (tag || "").split("-").join("_");
                var parts = temp.split("_");
                return parts.length > 1 ? parts[0].toLowerCase() + "_" + parts[1].toUpperCase() : temp;
            },
            bcp47: function(tag) {
                var temp = (tag || "").split("_").join("-");
                var parts = temp.split("-");
                switch (parts.length) {
                  case 1:
                    parts[0] = parts[0].toLowerCase();
                    break;

                  case 2:
                    parts[0] = parts[0].toLowerCase();
                    if (parts[1].length === 4) {
                        parts[1] = parts[1].charAt(0).toUpperCase() + parts[1].slice(1).toLowerCase();
                    } else {
                        parts[1] = parts[1].toUpperCase();
                    }
                    break;

                  case 3:
                    parts[0] = parts[0].toLowerCase();
                    parts[1] = parts[1].charAt(0).toUpperCase() + parts[1].slice(1).toLowerCase();
                    parts[2] = parts[2].toUpperCase();
                    break;

                  default:
                    return temp;
                }
                return parts.join("-");
            },
            "iso639-1": function(tag) {
                var temp = (tag || "").split("_").join("-");
                var parts = temp.split("-");
                return parts[0].toLowerCase();
            }
        };
        var version = "2.18.1";
        var getFirstBrowserLanguage = function() {
            if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) {
                return pascalprechtTranslateOverrider.getLocale();
            }
            var nav = $windowProvider.$get().navigator, browserLanguagePropertyKeys = [ "language", "browserLanguage", "systemLanguage", "userLanguage" ], i, language;
            if (angular.isArray(nav.languages)) {
                for (i = 0; i < nav.languages.length; i++) {
                    language = nav.languages[i];
                    if (language && language.length) {
                        return language;
                    }
                }
            }
            for (i = 0; i < browserLanguagePropertyKeys.length; i++) {
                language = nav[browserLanguagePropertyKeys[i]];
                if (language && language.length) {
                    return language;
                }
            }
            return null;
        };
        getFirstBrowserLanguage.displayName = "angular-translate/service: getFirstBrowserLanguage";
        var getLocale = function() {
            var locale = getFirstBrowserLanguage() || "";
            if (languageTagResolver[uniformLanguageTagResolver]) {
                locale = languageTagResolver[uniformLanguageTagResolver](locale);
            }
            return locale;
        };
        getLocale.displayName = "angular-translate/service: getLocale";
        var indexOf = function(array, searchElement) {
            for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] === searchElement) {
                    return i;
                }
            }
            return -1;
        };
        var trim = function() {
            return this.toString().replace(/^\s+|\s+$/g, "");
        };
        var lowercase = function(string) {
            return angular.isString(string) ? string.toLowerCase() : string;
        };
        var negotiateLocale = function(preferred) {
            if (!preferred) {
                return;
            }
            var avail = [], locale = lowercase(preferred), i = 0, n = $availableLanguageKeys.length;
            for (;i < n; i++) {
                avail.push(lowercase($availableLanguageKeys[i]));
            }
            i = indexOf(avail, locale);
            if (i > -1) {
                return $availableLanguageKeys[i];
            }
            if ($languageKeyAliases) {
                var alias;
                for (var langKeyAlias in $languageKeyAliases) {
                    if ($languageKeyAliases.hasOwnProperty(langKeyAlias)) {
                        var hasWildcardKey = false;
                        var hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) && lowercase(langKeyAlias) === lowercase(preferred);
                        if (langKeyAlias.slice(-1) === "*") {
                            hasWildcardKey = lowercase(langKeyAlias.slice(0, -1)) === lowercase(preferred.slice(0, langKeyAlias.length - 1));
                        }
                        if (hasExactKey || hasWildcardKey) {
                            alias = $languageKeyAliases[langKeyAlias];
                            if (indexOf(avail, lowercase(alias)) > -1) {
                                return alias;
                            }
                        }
                    }
                }
            }
            var parts = preferred.split("_");
            if (parts.length > 1 && indexOf(avail, lowercase(parts[0])) > -1) {
                return parts[0];
            }
            return;
        };
        var translations = function(langKey, translationTable) {
            if (!langKey && !translationTable) {
                return $translationTable;
            }
            if (langKey && !translationTable) {
                if (angular.isString(langKey)) {
                    return $translationTable[langKey];
                }
            } else {
                if (!angular.isObject($translationTable[langKey])) {
                    $translationTable[langKey] = {};
                }
                angular.extend($translationTable[langKey], flatObject(translationTable));
            }
            return this;
        };
        this.translations = translations;
        this.cloakClassName = function(name) {
            if (!name) {
                return $cloakClassName;
            }
            $cloakClassName = name;
            return this;
        };
        this.nestedObjectDelimeter = function(delimiter) {
            if (!delimiter) {
                return $nestedObjectDelimeter;
            }
            $nestedObjectDelimeter = delimiter;
            return this;
        };
        var flatObject = function(data, path, result, prevKey) {
            var key, keyWithPath, keyWithShortPath, val;
            if (!path) {
                path = [];
            }
            if (!result) {
                result = {};
            }
            for (key in data) {
                if (!Object.prototype.hasOwnProperty.call(data, key)) {
                    continue;
                }
                val = data[key];
                if (angular.isObject(val)) {
                    flatObject(val, path.concat(key), result, key);
                } else {
                    keyWithPath = path.length ? "" + path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key : key;
                    if (path.length && key === prevKey) {
                        keyWithShortPath = "" + path.join($nestedObjectDelimeter);
                        result[keyWithShortPath] = "@:" + keyWithPath;
                    }
                    result[keyWithPath] = val;
                }
            }
            return result;
        };
        flatObject.displayName = "flatObject";
        this.addInterpolation = function(factory) {
            $interpolatorFactories.push(factory);
            return this;
        };
        this.useMessageFormatInterpolation = function() {
            return this.useInterpolation("$translateMessageFormatInterpolation");
        };
        this.useInterpolation = function(factory) {
            $interpolationFactory = factory;
            return this;
        };
        this.useSanitizeValueStrategy = function(value) {
            $translateSanitizationProvider.useStrategy(value);
            return this;
        };
        this.preferredLanguage = function(langKey) {
            if (langKey) {
                setupPreferredLanguage(langKey);
                return this;
            }
            return $preferredLanguage;
        };
        var setupPreferredLanguage = function(langKey) {
            if (langKey) {
                $preferredLanguage = langKey;
            }
            return $preferredLanguage;
        };
        this.translationNotFoundIndicator = function(indicator) {
            this.translationNotFoundIndicatorLeft(indicator);
            this.translationNotFoundIndicatorRight(indicator);
            return this;
        };
        this.translationNotFoundIndicatorLeft = function(indicator) {
            if (!indicator) {
                return $notFoundIndicatorLeft;
            }
            $notFoundIndicatorLeft = indicator;
            return this;
        };
        this.translationNotFoundIndicatorRight = function(indicator) {
            if (!indicator) {
                return $notFoundIndicatorRight;
            }
            $notFoundIndicatorRight = indicator;
            return this;
        };
        this.fallbackLanguage = function(langKey) {
            fallbackStack(langKey);
            return this;
        };
        var fallbackStack = function(langKey) {
            if (langKey) {
                if (angular.isString(langKey)) {
                    $fallbackWasString = true;
                    $fallbackLanguage = [ langKey ];
                } else if (angular.isArray(langKey)) {
                    $fallbackWasString = false;
                    $fallbackLanguage = langKey;
                }
                if (angular.isString($preferredLanguage) && indexOf($fallbackLanguage, $preferredLanguage) < 0) {
                    $fallbackLanguage.push($preferredLanguage);
                }
                return this;
            } else {
                if ($fallbackWasString) {
                    return $fallbackLanguage[0];
                } else {
                    return $fallbackLanguage;
                }
            }
        };
        this.use = function(langKey) {
            if (langKey) {
                if (!$translationTable[langKey] && !$loaderFactory) {
                    throw new Error("$translateProvider couldn't find translationTable for langKey: '" + langKey + "'");
                }
                $uses = langKey;
                return this;
            }
            return $uses;
        };
        this.resolveClientLocale = function() {
            return getLocale();
        };
        var storageKey = function(key) {
            if (!key) {
                if ($storagePrefix) {
                    return $storagePrefix + $storageKey;
                }
                return $storageKey;
            }
            $storageKey = key;
            return this;
        };
        this.storageKey = storageKey;
        this.useUrlLoader = function(url, options) {
            return this.useLoader("$translateUrlLoader", angular.extend({
                url: url
            }, options));
        };
        this.useStaticFilesLoader = function(options) {
            return this.useLoader("$translateStaticFilesLoader", options);
        };
        this.useLoader = function(loaderFactory, options) {
            $loaderFactory = loaderFactory;
            $loaderOptions = options || {};
            return this;
        };
        this.useLocalStorage = function() {
            return this.useStorage("$translateLocalStorage");
        };
        this.useCookieStorage = function() {
            return this.useStorage("$translateCookieStorage");
        };
        this.useStorage = function(storageFactory) {
            $storageFactory = storageFactory;
            return this;
        };
        this.storagePrefix = function(prefix) {
            if (!prefix) {
                return prefix;
            }
            $storagePrefix = prefix;
            return this;
        };
        this.useMissingTranslationHandlerLog = function() {
            return this.useMissingTranslationHandler("$translateMissingTranslationHandlerLog");
        };
        this.useMissingTranslationHandler = function(factory) {
            $missingTranslationHandlerFactory = factory;
            return this;
        };
        this.usePostCompiling = function(value) {
            $postCompilingEnabled = !!value;
            return this;
        };
        this.forceAsyncReload = function(value) {
            $forceAsyncReloadEnabled = !!value;
            return this;
        };
        this.uniformLanguageTag = function(options) {
            if (!options) {
                options = {};
            } else if (angular.isString(options)) {
                options = {
                    standard: options
                };
            }
            uniformLanguageTagResolver = options.standard;
            return this;
        };
        this.determinePreferredLanguage = function(fn) {
            var locale = fn && angular.isFunction(fn) ? fn() : getLocale();
            if (!$availableLanguageKeys.length) {
                $preferredLanguage = locale;
            } else {
                $preferredLanguage = negotiateLocale(locale) || locale;
            }
            return this;
        };
        this.registerAvailableLanguageKeys = function(languageKeys, aliases) {
            if (languageKeys) {
                $availableLanguageKeys = languageKeys;
                if (aliases) {
                    $languageKeyAliases = aliases;
                }
                return this;
            }
            return $availableLanguageKeys;
        };
        this.useLoaderCache = function(cache) {
            if (cache === false) {
                loaderCache = undefined;
            } else if (cache === true) {
                loaderCache = true;
            } else if (typeof cache === "undefined") {
                loaderCache = "$translationCache";
            } else if (cache) {
                loaderCache = cache;
            }
            return this;
        };
        this.directivePriority = function(priority) {
            if (priority === undefined) {
                return directivePriority;
            } else {
                directivePriority = priority;
                return this;
            }
        };
        this.statefulFilter = function(state) {
            if (state === undefined) {
                return statefulFilter;
            } else {
                statefulFilter = state;
                return this;
            }
        };
        this.postProcess = function(fn) {
            if (fn) {
                postProcessFn = fn;
            } else {
                postProcessFn = undefined;
            }
            return this;
        };
        this.keepContent = function(value) {
            $keepContent = !!value;
            return this;
        };
        this.$get = [ "$log", "$injector", "$rootScope", "$q", function($log, $injector, $rootScope, $q) {
            var Storage, defaultInterpolator = $injector.get($interpolationFactory || "$translateDefaultInterpolation"), pendingLoader = false, interpolatorHashMap = {}, langPromises = {}, fallbackIndex, startFallbackIteration;
            var $translate = function(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage, sanitizeStrategy) {
                if (!$uses && $preferredLanguage) {
                    $uses = $preferredLanguage;
                }
                var uses = forceLanguage && forceLanguage !== $uses ? negotiateLocale(forceLanguage) || forceLanguage : $uses;
                if (forceLanguage) {
                    loadTranslationsIfMissing(forceLanguage);
                }
                if (angular.isArray(translationId)) {
                    var translateAll = function(translationIds) {
                        var results = {};
                        var promises = [];
                        var translate = function(translationId) {
                            var deferred = $q.defer();
                            var regardless = function(value) {
                                results[translationId] = value;
                                deferred.resolve([ translationId, value ]);
                            };
                            $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage, sanitizeStrategy).then(regardless, regardless);
                            return deferred.promise;
                        };
                        for (var i = 0, c = translationIds.length; i < c; i++) {
                            promises.push(translate(translationIds[i]));
                        }
                        return $q.all(promises).then(function() {
                            return results;
                        });
                    };
                    return translateAll(translationId);
                }
                var deferred = $q.defer();
                if (translationId) {
                    translationId = trim.apply(translationId);
                }
                var promiseToWaitFor = function() {
                    var promise = langPromises[uses] || langPromises[$preferredLanguage];
                    fallbackIndex = 0;
                    if ($storageFactory && !promise) {
                        var langKey = Storage.get($storageKey);
                        promise = langPromises[langKey];
                        if ($fallbackLanguage && $fallbackLanguage.length) {
                            var index = indexOf($fallbackLanguage, langKey);
                            fallbackIndex = index === 0 ? 1 : 0;
                            if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {
                                $fallbackLanguage.push($preferredLanguage);
                            }
                        }
                    }
                    return promise;
                }();
                if (!promiseToWaitFor) {
                    determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy).then(deferred.resolve, deferred.reject);
                } else {
                    var promiseResolved = function() {
                        if (!forceLanguage) {
                            uses = $uses;
                        }
                        determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy).then(deferred.resolve, deferred.reject);
                    };
                    promiseResolved.displayName = "promiseResolved";
                    promiseToWaitFor["finally"](promiseResolved)["catch"](angular.noop);
                }
                return deferred.promise;
            };
            var applyNotFoundIndicators = function(translationId) {
                if ($notFoundIndicatorLeft) {
                    translationId = [ $notFoundIndicatorLeft, translationId ].join(" ");
                }
                if ($notFoundIndicatorRight) {
                    translationId = [ translationId, $notFoundIndicatorRight ].join(" ");
                }
                return translationId;
            };
            var useLanguage = function(key) {
                $uses = key;
                if ($storageFactory) {
                    Storage.put($translate.storageKey(), $uses);
                }
                $rootScope.$emit("$translateChangeSuccess", {
                    language: key
                });
                defaultInterpolator.setLocale($uses);
                var eachInterpolator = function(interpolator, id) {
                    interpolatorHashMap[id].setLocale($uses);
                };
                eachInterpolator.displayName = "eachInterpolatorLocaleSetter";
                angular.forEach(interpolatorHashMap, eachInterpolator);
                $rootScope.$emit("$translateChangeEnd", {
                    language: key
                });
            };
            var loadAsync = function(key) {
                if (!key) {
                    throw "No language key specified for loading.";
                }
                var deferred = $q.defer();
                $rootScope.$emit("$translateLoadingStart", {
                    language: key
                });
                pendingLoader = true;
                var cache = loaderCache;
                if (typeof cache === "string") {
                    cache = $injector.get(cache);
                }
                var loaderOptions = angular.extend({}, $loaderOptions, {
                    key: key,
                    $http: angular.extend({}, {
                        cache: cache
                    }, $loaderOptions.$http)
                });
                var onLoaderSuccess = function(data) {
                    var translationTable = {};
                    $rootScope.$emit("$translateLoadingSuccess", {
                        language: key
                    });
                    if (angular.isArray(data)) {
                        angular.forEach(data, function(table) {
                            angular.extend(translationTable, flatObject(table));
                        });
                    } else {
                        angular.extend(translationTable, flatObject(data));
                    }
                    pendingLoader = false;
                    deferred.resolve({
                        key: key,
                        table: translationTable
                    });
                    $rootScope.$emit("$translateLoadingEnd", {
                        language: key
                    });
                };
                onLoaderSuccess.displayName = "onLoaderSuccess";
                var onLoaderError = function(key) {
                    $rootScope.$emit("$translateLoadingError", {
                        language: key
                    });
                    deferred.reject(key);
                    $rootScope.$emit("$translateLoadingEnd", {
                        language: key
                    });
                };
                onLoaderError.displayName = "onLoaderError";
                $injector.get($loaderFactory)(loaderOptions).then(onLoaderSuccess, onLoaderError);
                return deferred.promise;
            };
            if ($storageFactory) {
                Storage = $injector.get($storageFactory);
                if (!Storage.get || !Storage.put) {
                    throw new Error("Couldn't use storage '" + $storageFactory + "', missing get() or put() method!");
                }
            }
            if ($interpolatorFactories.length) {
                var eachInterpolationFactory = function(interpolatorFactory) {
                    var interpolator = $injector.get(interpolatorFactory);
                    interpolator.setLocale($preferredLanguage || $uses);
                    interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;
                };
                eachInterpolationFactory.displayName = "interpolationFactoryAdder";
                angular.forEach($interpolatorFactories, eachInterpolationFactory);
            }
            var getTranslationTable = function(langKey) {
                var deferred = $q.defer();
                if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {
                    deferred.resolve($translationTable[langKey]);
                } else if (langPromises[langKey]) {
                    var onResolve = function(data) {
                        translations(data.key, data.table);
                        deferred.resolve(data.table);
                    };
                    onResolve.displayName = "translationTableResolver";
                    langPromises[langKey].then(onResolve, deferred.reject);
                } else {
                    deferred.reject();
                }
                return deferred.promise;
            };
            var getFallbackTranslation = function(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                var deferred = $q.defer();
                var onResolve = function(translationTable) {
                    if (Object.prototype.hasOwnProperty.call(translationTable, translationId) && translationTable[translationId] !== null) {
                        Interpolator.setLocale(langKey);
                        var translation = translationTable[translationId];
                        if (translation.substr(0, 2) === "@:") {
                            getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator, sanitizeStrategy).then(deferred.resolve, deferred.reject);
                        } else {
                            var interpolatedValue = Interpolator.interpolate(translationTable[translationId], interpolateParams, "service", sanitizeStrategy, translationId);
                            interpolatedValue = applyPostProcessing(translationId, translationTable[translationId], interpolatedValue, interpolateParams, langKey);
                            deferred.resolve(interpolatedValue);
                        }
                        Interpolator.setLocale($uses);
                    } else {
                        deferred.reject();
                    }
                };
                onResolve.displayName = "fallbackTranslationResolver";
                getTranslationTable(langKey).then(onResolve, deferred.reject);
                return deferred.promise;
            };
            var getFallbackTranslationInstant = function(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                var result, translationTable = $translationTable[langKey];
                if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId) && translationTable[translationId] !== null) {
                    Interpolator.setLocale(langKey);
                    result = Interpolator.interpolate(translationTable[translationId], interpolateParams, "filter", sanitizeStrategy, translationId);
                    result = applyPostProcessing(translationId, translationTable[translationId], result, interpolateParams, langKey, sanitizeStrategy);
                    if (!angular.isString(result) && angular.isFunction(result.$$unwrapTrustedValue)) {
                        var result2 = result.$$unwrapTrustedValue();
                        if (result2.substr(0, 2) === "@:") {
                            return getFallbackTranslationInstant(langKey, result2.substr(2), interpolateParams, Interpolator, sanitizeStrategy);
                        }
                    } else if (result.substr(0, 2) === "@:") {
                        return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator, sanitizeStrategy);
                    }
                    Interpolator.setLocale($uses);
                }
                return result;
            };
            var translateByHandler = function(translationId, interpolateParams, defaultTranslationText, sanitizeStrategy) {
                if ($missingTranslationHandlerFactory) {
                    return $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams, defaultTranslationText, sanitizeStrategy);
                } else {
                    return translationId;
                }
            };
            var resolveForFallbackLanguage = function(fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy) {
                var deferred = $q.defer();
                if (fallbackLanguageIndex < $fallbackLanguage.length) {
                    var langKey = $fallbackLanguage[fallbackLanguageIndex];
                    getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy).then(function(data) {
                        deferred.resolve(data);
                    }, function() {
                        return resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy).then(deferred.resolve, deferred.reject);
                    });
                } else {
                    if (defaultTranslationText) {
                        deferred.resolve(defaultTranslationText);
                    } else {
                        var missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, defaultTranslationText);
                        if ($missingTranslationHandlerFactory && missingTranslationHandlerTranslation) {
                            deferred.resolve(missingTranslationHandlerTranslation);
                        } else {
                            deferred.reject(applyNotFoundIndicators(translationId));
                        }
                    }
                }
                return deferred.promise;
            };
            var resolveForFallbackLanguageInstant = function(fallbackLanguageIndex, translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                var result;
                if (fallbackLanguageIndex < $fallbackLanguage.length) {
                    var langKey = $fallbackLanguage[fallbackLanguageIndex];
                    result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy);
                    if (!result && result !== "") {
                        result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator);
                    }
                }
                return result;
            };
            var fallbackTranslation = function(translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy) {
                return resolveForFallbackLanguage(startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex, translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy);
            };
            var fallbackTranslationInstant = function(translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                return resolveForFallbackLanguageInstant(startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex, translationId, interpolateParams, Interpolator, sanitizeStrategy);
            };
            var determineTranslation = function(translationId, interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy) {
                var deferred = $q.defer();
                var table = uses ? $translationTable[uses] : $translationTable, Interpolator = interpolationId ? interpolatorHashMap[interpolationId] : defaultInterpolator;
                if (table && Object.prototype.hasOwnProperty.call(table, translationId) && table[translationId] !== null) {
                    var translation = table[translationId];
                    if (translation.substr(0, 2) === "@:") {
                        $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy).then(deferred.resolve, deferred.reject);
                    } else {
                        var resolvedTranslation = Interpolator.interpolate(translation, interpolateParams, "service", sanitizeStrategy, translationId);
                        resolvedTranslation = applyPostProcessing(translationId, translation, resolvedTranslation, interpolateParams, uses);
                        deferred.resolve(resolvedTranslation);
                    }
                } else {
                    var missingTranslationHandlerTranslation;
                    if ($missingTranslationHandlerFactory && !pendingLoader) {
                        missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, defaultTranslationText);
                    }
                    if (uses && $fallbackLanguage && $fallbackLanguage.length) {
                        fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy).then(function(translation) {
                            deferred.resolve(translation);
                        }, function(_translationId) {
                            deferred.reject(applyNotFoundIndicators(_translationId));
                        });
                    } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
                        if (defaultTranslationText) {
                            deferred.resolve(defaultTranslationText);
                        } else {
                            deferred.resolve(missingTranslationHandlerTranslation);
                        }
                    } else {
                        if (defaultTranslationText) {
                            deferred.resolve(defaultTranslationText);
                        } else {
                            deferred.reject(applyNotFoundIndicators(translationId));
                        }
                    }
                }
                return deferred.promise;
            };
            var determineTranslationInstant = function(translationId, interpolateParams, interpolationId, uses, sanitizeStrategy) {
                var result, table = uses ? $translationTable[uses] : $translationTable, Interpolator = defaultInterpolator;
                if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId)) {
                    Interpolator = interpolatorHashMap[interpolationId];
                }
                if (table && Object.prototype.hasOwnProperty.call(table, translationId) && table[translationId] !== null) {
                    var translation = table[translationId];
                    if (translation.substr(0, 2) === "@:") {
                        result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId, uses, sanitizeStrategy);
                    } else {
                        result = Interpolator.interpolate(translation, interpolateParams, "filter", sanitizeStrategy, translationId);
                        result = applyPostProcessing(translationId, translation, result, interpolateParams, uses, sanitizeStrategy);
                    }
                } else {
                    var missingTranslationHandlerTranslation;
                    if ($missingTranslationHandlerFactory && !pendingLoader) {
                        missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, sanitizeStrategy);
                    }
                    if (uses && $fallbackLanguage && $fallbackLanguage.length) {
                        fallbackIndex = 0;
                        result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator, sanitizeStrategy);
                    } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
                        result = missingTranslationHandlerTranslation;
                    } else {
                        result = applyNotFoundIndicators(translationId);
                    }
                }
                return result;
            };
            var clearNextLangAndPromise = function(key) {
                if ($nextLang === key) {
                    $nextLang = undefined;
                }
                langPromises[key] = undefined;
            };
            var applyPostProcessing = function(translationId, translation, resolvedTranslation, interpolateParams, uses, sanitizeStrategy) {
                var fn = postProcessFn;
                if (fn) {
                    if (typeof fn === "string") {
                        fn = $injector.get(fn);
                    }
                    if (fn) {
                        return fn(translationId, translation, resolvedTranslation, interpolateParams, uses, sanitizeStrategy);
                    }
                }
                return resolvedTranslation;
            };
            var loadTranslationsIfMissing = function(key) {
                if (!$translationTable[key] && $loaderFactory && !langPromises[key]) {
                    langPromises[key] = loadAsync(key).then(function(translation) {
                        translations(translation.key, translation.table);
                        return translation;
                    });
                }
            };
            $translate.preferredLanguage = function(langKey) {
                if (langKey) {
                    setupPreferredLanguage(langKey);
                }
                return $preferredLanguage;
            };
            $translate.cloakClassName = function() {
                return $cloakClassName;
            };
            $translate.nestedObjectDelimeter = function() {
                return $nestedObjectDelimeter;
            };
            $translate.fallbackLanguage = function(langKey) {
                if (langKey !== undefined && langKey !== null) {
                    fallbackStack(langKey);
                    if ($loaderFactory) {
                        if ($fallbackLanguage && $fallbackLanguage.length) {
                            for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
                                if (!langPromises[$fallbackLanguage[i]]) {
                                    langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]);
                                }
                            }
                        }
                    }
                    $translate.use($translate.use());
                }
                if ($fallbackWasString) {
                    return $fallbackLanguage[0];
                } else {
                    return $fallbackLanguage;
                }
            };
            $translate.useFallbackLanguage = function(langKey) {
                if (langKey !== undefined && langKey !== null) {
                    if (!langKey) {
                        startFallbackIteration = 0;
                    } else {
                        var langKeyPosition = indexOf($fallbackLanguage, langKey);
                        if (langKeyPosition > -1) {
                            startFallbackIteration = langKeyPosition;
                        }
                    }
                }
            };
            $translate.proposedLanguage = function() {
                return $nextLang;
            };
            $translate.storage = function() {
                return Storage;
            };
            $translate.negotiateLocale = negotiateLocale;
            $translate.use = function(key) {
                if (!key) {
                    return $uses;
                }
                var deferred = $q.defer();
                deferred.promise.then(null, angular.noop);
                $rootScope.$emit("$translateChangeStart", {
                    language: key
                });
                var aliasedKey = negotiateLocale(key);
                if ($availableLanguageKeys.length > 0 && !aliasedKey) {
                    return $q.reject(key);
                }
                if (aliasedKey) {
                    key = aliasedKey;
                }
                $nextLang = key;
                if (($forceAsyncReloadEnabled || !$translationTable[key]) && $loaderFactory && !langPromises[key]) {
                    langPromises[key] = loadAsync(key).then(function(translation) {
                        translations(translation.key, translation.table);
                        deferred.resolve(translation.key);
                        if ($nextLang === key) {
                            useLanguage(translation.key);
                        }
                        return translation;
                    }, function(key) {
                        $rootScope.$emit("$translateChangeError", {
                            language: key
                        });
                        deferred.reject(key);
                        $rootScope.$emit("$translateChangeEnd", {
                            language: key
                        });
                        return $q.reject(key);
                    });
                    langPromises[key]["finally"](function() {
                        clearNextLangAndPromise(key);
                    })["catch"](angular.noop);
                } else if (langPromises[key]) {
                    langPromises[key].then(function(translation) {
                        if ($nextLang === translation.key) {
                            useLanguage(translation.key);
                        }
                        deferred.resolve(translation.key);
                        return translation;
                    }, function(key) {
                        if (!$uses && $fallbackLanguage && $fallbackLanguage.length > 0 && $fallbackLanguage[0] !== key) {
                            return $translate.use($fallbackLanguage[0]).then(deferred.resolve, deferred.reject);
                        } else {
                            return deferred.reject(key);
                        }
                    });
                } else {
                    deferred.resolve(key);
                    useLanguage(key);
                }
                return deferred.promise;
            };
            $translate.resolveClientLocale = function() {
                return getLocale();
            };
            $translate.storageKey = function() {
                return storageKey();
            };
            $translate.isPostCompilingEnabled = function() {
                return $postCompilingEnabled;
            };
            $translate.isForceAsyncReloadEnabled = function() {
                return $forceAsyncReloadEnabled;
            };
            $translate.isKeepContent = function() {
                return $keepContent;
            };
            $translate.refresh = function(langKey) {
                if (!$loaderFactory) {
                    throw new Error("Couldn't refresh translation table, no loader registered!");
                }
                $rootScope.$emit("$translateRefreshStart", {
                    language: langKey
                });
                var deferred = $q.defer(), updatedLanguages = {};
                function loadNewData(languageKey) {
                    var promise = loadAsync(languageKey);
                    langPromises[languageKey] = promise;
                    promise.then(function(data) {
                        $translationTable[languageKey] = {};
                        translations(languageKey, data.table);
                        updatedLanguages[languageKey] = true;
                    }, angular.noop);
                    return promise;
                }
                deferred.promise.then(function() {
                    for (var key in $translationTable) {
                        if ($translationTable.hasOwnProperty(key)) {
                            if (!(key in updatedLanguages)) {
                                delete $translationTable[key];
                            }
                        }
                    }
                    if ($uses) {
                        useLanguage($uses);
                    }
                }, angular.noop)["finally"](function() {
                    $rootScope.$emit("$translateRefreshEnd", {
                        language: langKey
                    });
                });
                if (!langKey) {
                    var languagesToReload = $fallbackLanguage && $fallbackLanguage.slice() || [];
                    if ($uses && languagesToReload.indexOf($uses) === -1) {
                        languagesToReload.push($uses);
                    }
                    $q.all(languagesToReload.map(loadNewData)).then(deferred.resolve, deferred.reject);
                } else if ($translationTable[langKey]) {
                    loadNewData(langKey).then(deferred.resolve, deferred.reject);
                } else {
                    deferred.reject();
                }
                return deferred.promise;
            };
            $translate.instant = function(translationId, interpolateParams, interpolationId, forceLanguage, sanitizeStrategy) {
                var uses = forceLanguage && forceLanguage !== $uses ? negotiateLocale(forceLanguage) || forceLanguage : $uses;
                if (translationId === null || angular.isUndefined(translationId)) {
                    return translationId;
                }
                if (forceLanguage) {
                    loadTranslationsIfMissing(forceLanguage);
                }
                if (angular.isArray(translationId)) {
                    var results = {};
                    for (var i = 0, c = translationId.length; i < c; i++) {
                        results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId, forceLanguage, sanitizeStrategy);
                    }
                    return results;
                }
                if (angular.isString(translationId) && translationId.length < 1) {
                    return translationId;
                }
                if (translationId) {
                    translationId = trim.apply(translationId);
                }
                var result, possibleLangKeys = [];
                if ($preferredLanguage) {
                    possibleLangKeys.push($preferredLanguage);
                }
                if (uses) {
                    possibleLangKeys.push(uses);
                }
                if ($fallbackLanguage && $fallbackLanguage.length) {
                    possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);
                }
                for (var j = 0, d = possibleLangKeys.length; j < d; j++) {
                    var possibleLangKey = possibleLangKeys[j];
                    if ($translationTable[possibleLangKey]) {
                        if (typeof $translationTable[possibleLangKey][translationId] !== "undefined") {
                            result = determineTranslationInstant(translationId, interpolateParams, interpolationId, uses, sanitizeStrategy);
                        }
                    }
                    if (typeof result !== "undefined") {
                        break;
                    }
                }
                if (!result && result !== "") {
                    if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {
                        result = applyNotFoundIndicators(translationId);
                    } else {
                        result = defaultInterpolator.interpolate(translationId, interpolateParams, "filter", sanitizeStrategy);
                        var missingTranslationHandlerTranslation;
                        if ($missingTranslationHandlerFactory && !pendingLoader) {
                            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, sanitizeStrategy);
                        }
                        if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
                            result = missingTranslationHandlerTranslation;
                        }
                    }
                }
                return result;
            };
            $translate.versionInfo = function() {
                return version;
            };
            $translate.loaderCache = function() {
                return loaderCache;
            };
            $translate.directivePriority = function() {
                return directivePriority;
            };
            $translate.statefulFilter = function() {
                return statefulFilter;
            };
            $translate.isReady = function() {
                return $isReady;
            };
            var $onReadyDeferred = $q.defer();
            $onReadyDeferred.promise.then(function() {
                $isReady = true;
            });
            $translate.onReady = function(fn) {
                var deferred = $q.defer();
                if (angular.isFunction(fn)) {
                    deferred.promise.then(fn);
                }
                if ($isReady) {
                    deferred.resolve();
                } else {
                    $onReadyDeferred.promise.then(deferred.resolve);
                }
                return deferred.promise;
            };
            $translate.getAvailableLanguageKeys = function() {
                if ($availableLanguageKeys.length > 0) {
                    return $availableLanguageKeys;
                }
                return null;
            };
            $translate.getTranslationTable = function(langKey) {
                langKey = langKey || $translate.use();
                if (langKey && $translationTable[langKey]) {
                    return angular.copy($translationTable[langKey]);
                }
                return null;
            };
            var globalOnReadyListener = $rootScope.$on("$translateReady", function() {
                $onReadyDeferred.resolve();
                globalOnReadyListener();
                globalOnReadyListener = null;
            });
            var globalOnChangeListener = $rootScope.$on("$translateChangeEnd", function() {
                $onReadyDeferred.resolve();
                globalOnChangeListener();
                globalOnChangeListener = null;
            });
            if ($loaderFactory) {
                if (angular.equals($translationTable, {})) {
                    if ($translate.use()) {
                        $translate.use($translate.use());
                    }
                }
                if ($fallbackLanguage && $fallbackLanguage.length) {
                    var processAsyncResult = function(translation) {
                        translations(translation.key, translation.table);
                        $rootScope.$emit("$translateChangeEnd", {
                            language: translation.key
                        });
                        return translation;
                    };
                    for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
                        var fallbackLanguageId = $fallbackLanguage[i];
                        if ($forceAsyncReloadEnabled || !$translationTable[fallbackLanguageId]) {
                            langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult);
                        }
                    }
                }
            } else {
                $rootScope.$emit("$translateReady", {
                    language: $translate.use()
                });
            }
            return $translate;
        } ];
    }
    $translate.displayName = "displayName";
    angular.module("pascalprecht.translate").factory("$translateDefaultInterpolation", $translateDefaultInterpolation);
    function $translateDefaultInterpolation($interpolate, $translateSanitization) {
        "use strict";
        var $translateInterpolator = {}, $locale, $identifier = "default";
        $translateInterpolator.setLocale = function(locale) {
            $locale = locale;
        };
        $translateInterpolator.getInterpolationIdentifier = function() {
            return $identifier;
        };
        $translateInterpolator.useSanitizeValueStrategy = function(value) {
            $translateSanitization.useStrategy(value);
            return this;
        };
        $translateInterpolator.interpolate = function(value, interpolationParams, context, sanitizeStrategy, translationId) {
            interpolationParams = interpolationParams || {};
            interpolationParams = $translateSanitization.sanitize(interpolationParams, "params", sanitizeStrategy, context);
            var interpolatedText;
            if (angular.isNumber(value)) {
                interpolatedText = "" + value;
            } else if (angular.isString(value)) {
                interpolatedText = $interpolate(value)(interpolationParams);
                interpolatedText = $translateSanitization.sanitize(interpolatedText, "text", sanitizeStrategy, context);
            } else {
                interpolatedText = "";
            }
            return interpolatedText;
        };
        return $translateInterpolator;
    }
    $translateDefaultInterpolation.displayName = "$translateDefaultInterpolation";
    angular.module("pascalprecht.translate").constant("$STORAGE_KEY", "NG_TRANSLATE_LANG_KEY");
    angular.module("pascalprecht.translate").directive("translate", translateDirective);
    function translateDirective($translate, $interpolate, $compile, $parse, $rootScope) {
        "use strict";
        var trim = function() {
            return this.toString().replace(/^\s+|\s+$/g, "");
        };
        var lowercase = function(string) {
            return angular.isString(string) ? string.toLowerCase() : string;
        };
        return {
            restrict: "AE",
            scope: true,
            priority: $translate.directivePriority(),
            compile: function(tElement, tAttr) {
                var translateValuesExist = tAttr.translateValues ? tAttr.translateValues : undefined;
                var translateInterpolation = tAttr.translateInterpolation ? tAttr.translateInterpolation : undefined;
                var translateSanitizeStrategyExist = tAttr.translateSanitizeStrategy ? tAttr.translateSanitizeStrategy : undefined;
                var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);
                var interpolateRegExp = "^(.*)(" + $interpolate.startSymbol() + ".*" + $interpolate.endSymbol() + ")(.*)", watcherRegExp = "^(.*)" + $interpolate.startSymbol() + "(.*)" + $interpolate.endSymbol() + "(.*)";
                return function linkFn(scope, iElement, iAttr) {
                    scope.interpolateParams = {};
                    scope.preText = "";
                    scope.postText = "";
                    scope.translateNamespace = getTranslateNamespace(scope);
                    var translationIds = {};
                    var initInterpolationParams = function(interpolateParams, iAttr, tAttr) {
                        if (iAttr.translateValues) {
                            angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent));
                        }
                        if (translateValueExist) {
                            for (var attr in tAttr) {
                                if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === "translateValue" && attr !== "translateValues") {
                                    var attributeName = lowercase(attr.substr(14, 1)) + attr.substr(15);
                                    interpolateParams[attributeName] = tAttr[attr];
                                }
                            }
                        }
                    };
                    var observeElementTranslation = function(translationId) {
                        if (angular.isFunction(observeElementTranslation._unwatchOld)) {
                            observeElementTranslation._unwatchOld();
                            observeElementTranslation._unwatchOld = undefined;
                        }
                        if (angular.equals(translationId, "") || !angular.isDefined(translationId)) {
                            var iElementText = trim.apply(iElement.text());
                            var interpolateMatches = iElementText.match(interpolateRegExp);
                            if (angular.isArray(interpolateMatches)) {
                                scope.preText = interpolateMatches[1];
                                scope.postText = interpolateMatches[3];
                                translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);
                                var watcherMatches = iElementText.match(watcherRegExp);
                                if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {
                                    observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function(newValue) {
                                        translationIds.translate = newValue;
                                        updateTranslations();
                                    });
                                }
                            } else {
                                translationIds.translate = !iElementText ? undefined : iElementText;
                            }
                        } else {
                            translationIds.translate = translationId;
                        }
                        updateTranslations();
                    };
                    var observeAttributeTranslation = function(translateAttr) {
                        iAttr.$observe(translateAttr, function(translationId) {
                            translationIds[translateAttr] = translationId;
                            updateTranslations();
                        });
                    };
                    initInterpolationParams(scope.interpolateParams, iAttr, tAttr);
                    var firstAttributeChangedEvent = true;
                    iAttr.$observe("translate", function(translationId) {
                        if (typeof translationId === "undefined") {
                            observeElementTranslation("");
                        } else {
                            if (translationId !== "" || !firstAttributeChangedEvent) {
                                translationIds.translate = translationId;
                                updateTranslations();
                            }
                        }
                        firstAttributeChangedEvent = false;
                    });
                    for (var translateAttr in iAttr) {
                        if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === "translateAttr" && translateAttr.length > 13) {
                            observeAttributeTranslation(translateAttr);
                        }
                    }
                    iAttr.$observe("translateDefault", function(value) {
                        scope.defaultText = value;
                        updateTranslations();
                    });
                    if (translateSanitizeStrategyExist) {
                        iAttr.$observe("translateSanitizeStrategy", function(value) {
                            scope.sanitizeStrategy = $parse(value)(scope.$parent);
                            updateTranslations();
                        });
                    }
                    if (translateValuesExist) {
                        iAttr.$observe("translateValues", function(interpolateParams) {
                            if (interpolateParams) {
                                scope.$parent.$watch(function() {
                                    angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));
                                });
                            }
                        });
                    }
                    if (translateValueExist) {
                        var observeValueAttribute = function(attrName) {
                            iAttr.$observe(attrName, function(value) {
                                var attributeName = lowercase(attrName.substr(14, 1)) + attrName.substr(15);
                                scope.interpolateParams[attributeName] = value;
                            });
                        };
                        for (var attr in iAttr) {
                            if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === "translateValue" && attr !== "translateValues") {
                                observeValueAttribute(attr);
                            }
                        }
                    }
                    var updateTranslations = function() {
                        for (var key in translationIds) {
                            if (translationIds.hasOwnProperty(key) && translationIds[key] !== undefined) {
                                updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText, scope.translateNamespace);
                            }
                        }
                    };
                    var updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText, translateNamespace) {
                        if (translationId) {
                            if (translateNamespace && translationId.charAt(0) === ".") {
                                translationId = translateNamespace + translationId;
                            }
                            $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText, scope.translateLanguage, scope.sanitizeStrategy).then(function(translation) {
                                applyTranslation(translation, scope, true, translateAttr);
                            }, function(translationId) {
                                applyTranslation(translationId, scope, false, translateAttr);
                            });
                        } else {
                            applyTranslation(translationId, scope, false, translateAttr);
                        }
                    };
                    var applyTranslation = function(value, scope, successful, translateAttr) {
                        if (!successful) {
                            if (typeof scope.defaultText !== "undefined") {
                                value = scope.defaultText;
                            }
                        }
                        if (translateAttr === "translate") {
                            if (successful || !successful && !$translate.isKeepContent() && typeof iAttr.translateKeepContent === "undefined") {
                                iElement.empty().append(scope.preText + value + scope.postText);
                            }
                            var globallyEnabled = $translate.isPostCompilingEnabled();
                            var locallyDefined = typeof tAttr.translateCompile !== "undefined";
                            var locallyEnabled = locallyDefined && tAttr.translateCompile !== "false";
                            if (globallyEnabled && !locallyDefined || locallyEnabled) {
                                $compile(iElement.contents())(scope);
                            }
                        } else {
                            var attributeName = iAttr.$attr[translateAttr];
                            if (attributeName.substr(0, 5) === "data-") {
                                attributeName = attributeName.substr(5);
                            }
                            attributeName = attributeName.substr(15);
                            iElement.attr(attributeName, value);
                        }
                    };
                    if (translateValuesExist || translateValueExist || iAttr.translateDefault) {
                        scope.$watch("interpolateParams", updateTranslations, true);
                    }
                    scope.$on("translateLanguageChanged", updateTranslations);
                    var unbind = $rootScope.$on("$translateChangeSuccess", updateTranslations);
                    if (iElement.text().length) {
                        if (iAttr.translate) {
                            observeElementTranslation(iAttr.translate);
                        } else {
                            observeElementTranslation("");
                        }
                    } else if (iAttr.translate) {
                        observeElementTranslation(iAttr.translate);
                    }
                    updateTranslations();
                    scope.$on("$destroy", unbind);
                };
            }
        };
    }
    function getTranslateNamespace(scope) {
        "use strict";
        if (scope.translateNamespace) {
            return scope.translateNamespace;
        }
        if (scope.$parent) {
            return getTranslateNamespace(scope.$parent);
        }
    }
    translateDirective.displayName = "translateDirective";
    angular.module("pascalprecht.translate").directive("translateAttr", translateAttrDirective);
    function translateAttrDirective($translate, $rootScope) {
        "use strict";
        return {
            restrict: "A",
            priority: $translate.directivePriority(),
            link: function linkFn(scope, element, attr) {
                var translateAttr, translateValues, translateSanitizeStrategy, previousAttributes = {};
                var updateTranslations = function() {
                    angular.forEach(translateAttr, function(translationId, attributeName) {
                        if (!translationId) {
                            return;
                        }
                        previousAttributes[attributeName] = true;
                        if (scope.translateNamespace && translationId.charAt(0) === ".") {
                            translationId = scope.translateNamespace + translationId;
                        }
                        $translate(translationId, translateValues, attr.translateInterpolation, undefined, scope.translateLanguage, translateSanitizeStrategy).then(function(translation) {
                            element.attr(attributeName, translation);
                        }, function(translationId) {
                            element.attr(attributeName, translationId);
                        });
                    });
                    angular.forEach(previousAttributes, function(flag, attributeName) {
                        if (!translateAttr[attributeName]) {
                            element.removeAttr(attributeName);
                            delete previousAttributes[attributeName];
                        }
                    });
                };
                watchAttribute(scope, attr.translateAttr, function(newValue) {
                    translateAttr = newValue;
                }, updateTranslations);
                watchAttribute(scope, attr.translateValues, function(newValue) {
                    translateValues = newValue;
                }, updateTranslations);
                watchAttribute(scope, attr.translateSanitizeStrategy, function(newValue) {
                    translateSanitizeStrategy = newValue;
                }, updateTranslations);
                if (attr.translateValues) {
                    scope.$watch(attr.translateValues, updateTranslations, true);
                }
                scope.$on("translateLanguageChanged", updateTranslations);
                var unbind = $rootScope.$on("$translateChangeSuccess", updateTranslations);
                updateTranslations();
                scope.$on("$destroy", unbind);
            }
        };
    }
    function watchAttribute(scope, attribute, valueCallback, changeCallback) {
        "use strict";
        if (!attribute) {
            return;
        }
        if (attribute.substr(0, 2) === "::") {
            attribute = attribute.substr(2);
        } else {
            scope.$watch(attribute, function(newValue) {
                valueCallback(newValue);
                changeCallback();
            }, true);
        }
        valueCallback(scope.$eval(attribute));
    }
    translateAttrDirective.displayName = "translateAttrDirective";
    angular.module("pascalprecht.translate").directive("translateCloak", translateCloakDirective);
    function translateCloakDirective($translate, $rootScope) {
        "use strict";
        return {
            compile: function(tElement) {
                var applyCloak = function(element) {
                    element.addClass($translate.cloakClassName());
                }, removeCloak = function(element) {
                    element.removeClass($translate.cloakClassName());
                };
                applyCloak(tElement);
                return function linkFn(scope, iElement, iAttr) {
                    var iRemoveCloak = removeCloak.bind(this, iElement), iApplyCloak = applyCloak.bind(this, iElement);
                    if (iAttr.translateCloak && iAttr.translateCloak.length) {
                        iAttr.$observe("translateCloak", function(translationId) {
                            $translate(translationId).then(iRemoveCloak, iApplyCloak);
                        });
                        $rootScope.$on("$translateChangeSuccess", function() {
                            $translate(iAttr.translateCloak).then(iRemoveCloak, iApplyCloak);
                        });
                    } else {
                        $translate.onReady(iRemoveCloak);
                    }
                };
            }
        };
    }
    translateCloakDirective.displayName = "translateCloakDirective";
    angular.module("pascalprecht.translate").directive("translateNamespace", translateNamespaceDirective);
    function translateNamespaceDirective() {
        "use strict";
        return {
            restrict: "A",
            scope: true,
            compile: function() {
                return {
                    pre: function(scope, iElement, iAttrs) {
                        scope.translateNamespace = _getTranslateNamespace(scope);
                        if (scope.translateNamespace && iAttrs.translateNamespace.charAt(0) === ".") {
                            scope.translateNamespace += iAttrs.translateNamespace;
                        } else {
                            scope.translateNamespace = iAttrs.translateNamespace;
                        }
                    }
                };
            }
        };
    }
    function _getTranslateNamespace(scope) {
        "use strict";
        if (scope.translateNamespace) {
            return scope.translateNamespace;
        }
        if (scope.$parent) {
            return _getTranslateNamespace(scope.$parent);
        }
    }
    translateNamespaceDirective.displayName = "translateNamespaceDirective";
    angular.module("pascalprecht.translate").directive("translateLanguage", translateLanguageDirective);
    function translateLanguageDirective() {
        "use strict";
        return {
            restrict: "A",
            scope: true,
            compile: function() {
                return function linkFn(scope, iElement, iAttrs) {
                    iAttrs.$observe("translateLanguage", function(newTranslateLanguage) {
                        scope.translateLanguage = newTranslateLanguage;
                    });
                    scope.$watch("translateLanguage", function() {
                        scope.$broadcast("translateLanguageChanged");
                    });
                };
            }
        };
    }
    translateLanguageDirective.displayName = "translateLanguageDirective";
    angular.module("pascalprecht.translate").filter("translate", translateFilterFactory);
    function translateFilterFactory($parse, $translate) {
        "use strict";
        var translateFilter = function(translationId, interpolateParams, interpolation, forceLanguage) {
            if (!angular.isObject(interpolateParams)) {
                var ctx = this || {
                    __SCOPE_IS_NOT_AVAILABLE: "More info at https://github.com/angular/angular.js/commit/8863b9d04c722b278fa93c5d66ad1e578ad6eb1f"
                };
                interpolateParams = $parse(interpolateParams)(ctx);
            }
            return $translate.instant(translationId, interpolateParams, interpolation, forceLanguage);
        };
        if ($translate.statefulFilter()) {
            translateFilter.$stateful = true;
        }
        return translateFilter;
    }
    translateFilterFactory.displayName = "translateFilterFactory";
    angular.module("pascalprecht.translate").factory("$translationCache", $translationCache);
    function $translationCache($cacheFactory) {
        "use strict";
        return $cacheFactory("translations");
    }
    $translationCache.displayName = "$translationCache";
    return "pascalprecht.translate";
});

!function() {
    "use strict";
    var a = angular.module("translate.sub", []);
    a.provider("$translate", [ function() {
        var a = [], n = "en-US";
        this.translations = function(e, s) {
            angular.isDefined(e) && angular.isDefined(s) && (a[e] = angular.copy(s), n = e);
        }, this.$get = [ function() {
            return {
                instant: function(e) {
                    return angular.isDefined(e) && angular.isDefined(a[n][e]) ? a[n][e] : "";
                }
            };
        } ];
    } ]), a.filter("translate", [ "$translate", function(a) {
        return function(n) {
            return a.instant(n);
        };
    } ]);
    var n;
    try {
        angular.module("pascalprecht.translate"), n = angular.module("dialogs.controllers", [ "ui.bootstrap.modal", "pascalprecht.translate" ]);
    } catch (e) {
        n = angular.module("dialogs.controllers", [ "ui.bootstrap.modal", "translate.sub" ]);
    }
    n.controller("errorDialogCtrl", [ "$scope", "$uibModalInstance", "$translate", "data", function(a, n, e, s) {
        a.header = angular.isDefined(s.header) ? s.header : e.instant("DIALOGS_ERROR"), 
        a.msg = angular.isDefined(s.msg) ? s.msg : e.instant("DIALOGS_ERROR_MSG"), a.icon = angular.isDefined(s.fa) && angular.equals(s.fa, !0) ? "fa fa-warning" : "glyphicon glyphicon-warning-sign", 
        a.close = function() {
            n.close(), a.$destroy();
        };
    } ]), n.controller("waitDialogCtrl", [ "$scope", "$uibModalInstance", "$translate", "$timeout", "data", function(a, n, e, s, o) {
        a.header = angular.isDefined(o.header) ? o.header : e.instant("DIALOGS_PLEASE_WAIT_ELIPS"), 
        a.msg = angular.isDefined(o.msg) ? o.msg : e.instant("DIALOGS_PLEASE_WAIT_MSG"), 
        a.progress = angular.isDefined(o.progress) ? o.progress : 100, a.icon = angular.isDefined(o.fa) && angular.equals(o.fa, !0) ? "fa fa-clock-o" : "glyphicon glyphicon-time", 
        a.$on("dialogs.wait.complete", function() {
            s(function() {
                n.close(), a.$destroy();
            });
        }), a.$on("dialogs.wait.message", function(n, e) {
            a.msg = angular.isDefined(e.msg) ? e.msg : a.msg;
        }), a.$on("dialogs.wait.progress", function(n, e) {
            a.msg = angular.isDefined(e.msg) ? e.msg : a.msg, a.progress = angular.isDefined(e.progress) ? e.progress : a.progress;
        }), a.getProgress = function() {
            return {
                width: a.progress + "%"
            };
        };
    } ]), n.controller("notifyDialogCtrl", [ "$scope", "$uibModalInstance", "$translate", "data", function(a, n, e, s) {
        a.header = angular.isDefined(s.header) ? s.header : e.instant("DIALOGS_NOTIFICATION"), 
        a.msg = angular.isDefined(s.msg) ? s.msg : e.instant("DIALOGS_NOTIFICATION_MSG"), 
        a.icon = angular.isDefined(s.fa) && angular.equals(s.fa, !0) ? "fa fa-info" : "glyphicon glyphicon-info-sign", 
        a.close = function() {
            n.close(), a.$destroy();
        };
    } ]), n.controller("confirmDialogCtrl", [ "$scope", "$uibModalInstance", "$translate", "data", function(a, n, e, s) {
        a.header = angular.isDefined(s.header) ? s.header : e.instant("DIALOGS_CONFIRMATION"), 
        a.msg = angular.isDefined(s.msg) ? s.msg : e.instant("DIALOGS_CONFIRMATION_MSG"), 
        a.icon = angular.isDefined(s.fa) && angular.equals(s.fa, !0) ? "fa fa-check" : "glyphicon glyphicon-check", 
        a.no = function() {
            n.dismiss("no");
        }, a.yes = function() {
            n.close("yes");
        };
    } ]), angular.module("dialogs.services", [ "ui.bootstrap.modal", "dialogs.controllers" ]).provider("dialogs", [ function() {
        var a = !0, n = !0, e = "dialogs-default", s = "dialogs-backdrop-default", o = !0, t = null, l = "lg", r = !1, i = !1, d = function(o) {
            var t = {};
            return o = o || {}, t.kb = angular.isDefined(o.keyboard) ? !!o.keyboard : n, t.bd = angular.isDefined(o.backdrop) ? o.backdrop : a, 
            t.bdc = angular.isDefined(o.backdropClass) ? o.backdropClass : s, t.ws = !angular.isDefined(o.size) || "sm" !== o.size && "lg" !== o.size && "md" !== o.size ? l : o.size, 
            t.wc = angular.isDefined(o.windowClass) ? o.windowClass : e, t.anim = angular.isDefined(o.animation) ? !!o.animation : r, 
            t;
        };
        this.useBackdrop = function(n) {
            angular.isDefined(n) && (a = n);
        }, this.useEscClose = function(a) {
            angular.isDefined(a) && (n = angular.equals(a, 0) || angular.equals(a, "false") || angular.equals(a, "no") || angular.equals(a, null) || angular.equals(a, !1) ? !1 : !0);
        }, this.useClass = function(a) {
            angular.isDefined(a) && (e = a);
        }, this.useCopy = function(a) {
            angular.isDefined(a) && (o = angular.equals(a, 0) || angular.equals(a, "false") || angular.equals(a, "no") || angular.equals(a, null) || angular.equals(a, !1) ? !1 : !0);
        }, this.setWindowTmpl = function(a) {
            angular.isDefined(a) && (t = a);
        }, this.setSize = function(a) {
            angular.isDefined(a) && (l = angular.equals(a, "sm") || angular.equals(a, "lg") || angular.equals(a, "md") ? a : l);
        }, this.useAnimation = function() {
            r = !0;
        }, this.useFontAwesome = function() {
            i = !0;
        }, this.$get = [ "$uibModal", function(a) {
            return {
                error: function(n, e, s) {
                    return s = d(s), a.open({
                        templateUrl: "/dialogs/error.html",
                        controller: "errorDialogCtrl",
                        backdrop: s.bd,
                        backdropClass: s.bdc,
                        keyboard: s.kb,
                        windowClass: s.wc,
                        size: s.ws,
                        animation: s.anim,
                        resolve: {
                            data: function() {
                                return {
                                    header: angular.copy(n),
                                    msg: angular.copy(e),
                                    fa: i
                                };
                            }
                        }
                    });
                },
                wait: function(n, e, s, o) {
                    return o = d(o), a.open({
                        templateUrl: "/dialogs/wait.html",
                        controller: "waitDialogCtrl",
                        backdrop: o.bd,
                        backdropClass: o.bdc,
                        keyboard: o.kb,
                        windowClass: o.wc,
                        size: o.ws,
                        animation: o.anim,
                        resolve: {
                            data: function() {
                                return {
                                    header: angular.copy(n),
                                    msg: angular.copy(e),
                                    progress: angular.copy(s),
                                    fa: i
                                };
                            }
                        }
                    });
                },
                notify: function(n, e, s) {
                    return s = d(s), a.open({
                        templateUrl: "/dialogs/notify.html",
                        controller: "notifyDialogCtrl",
                        backdrop: s.bd,
                        backdropClass: s.bdc,
                        keyboard: s.kb,
                        windowClass: s.wc,
                        size: s.ws,
                        animation: s.anim,
                        resolve: {
                            data: function() {
                                return {
                                    header: angular.copy(n),
                                    msg: angular.copy(e),
                                    fa: i
                                };
                            }
                        }
                    });
                },
                confirm: function(n, e, s) {
                    return s = d(s), a.open({
                        templateUrl: "/dialogs/confirm.html",
                        controller: "confirmDialogCtrl",
                        backdrop: s.bd,
                        backdropClass: s.bdc,
                        keyboard: s.kb,
                        windowClass: s.wc,
                        size: s.ws,
                        animation: s.anim,
                        resolve: {
                            data: function() {
                                return {
                                    header: angular.copy(n),
                                    msg: angular.copy(e),
                                    fa: i
                                };
                            }
                        }
                    });
                },
                create: function(n, e, s, t, l) {
                    var r = t && angular.isDefined(t.copy) ? t.copy : o;
                    return t = d(t), a.open({
                        templateUrl: n,
                        controller: e,
                        controllerAs: l,
                        keyboard: t.kb,
                        backdrop: t.bd,
                        backdropClass: t.bdc,
                        windowClass: t.wc,
                        size: t.ws,
                        animation: t.anim,
                        resolve: {
                            data: function() {
                                return r ? angular.copy(s) : s;
                            }
                        }
                    });
                }
            };
        } ];
    } ]), angular.module("dialogs.main", [ "dialogs.services", "ngSanitize" ]).config([ "$translateProvider", "dialogsProvider", function(a, n) {
        try {
            angular.module("pascalprecht.translate");
        } catch (e) {
            a.translations("en-US", {
                DIALOGS_ERROR: "Error",
                DIALOGS_ERROR_MSG: "An unknown error has occurred.",
                DIALOGS_CLOSE: "Close",
                DIALOGS_PLEASE_WAIT: "Please Wait",
                DIALOGS_PLEASE_WAIT_ELIPS: "Please Wait...",
                DIALOGS_PLEASE_WAIT_MSG: "Waiting on operation to complete.",
                DIALOGS_PERCENT_COMPLETE: "% Complete",
                DIALOGS_NOTIFICATION: "Notification",
                DIALOGS_NOTIFICATION_MSG: "Unknown application notification.",
                DIALOGS_CONFIRMATION: "Confirmation",
                DIALOGS_CONFIRMATION_MSG: "Confirmation required.",
                DIALOGS_OK: "OK",
                DIALOGS_YES: "Yes",
                DIALOGS_NO: "No"
            });
        }
        try {
            var s = document.styleSheets;
            a: for (var o = s.length - 1; o >= 0; o--) {
                var t = null, l = null;
                if (!s[o].disabled) {
                    if (null !== s[o].href && (t = s[o].href.match(/font\-*awesome/i)), angular.isArray(t)) {
                        n.useFontAwesome();
                        break;
                    }
                    l = s[o].cssRules;
                    for (var r = l.length - 1; r >= 0; r--) if (".fa" == l[r].selectorText.toLowerCase()) {
                        n.useFontAwesome();
                        break a;
                    }
                }
            }
        } catch (e) {}
    } ]).run([ "$templateCache", "$interpolate", function(a, n) {
        var e = n.startSymbol(), s = n.endSymbol();
        a.put("/dialogs/error.html", '<div class="modal-header dialog-header-error"><button type="button" class="close" ng-click="close()">&times;</button><h4 class="modal-title text-danger"><span class="' + e + "icon" + s + '"></span> <span ng-bind-html="header"></span></h4></div><div class="modal-body text-danger" ng-bind-html="msg"></div><div class="modal-footer"><button type="button" class="btn btn-default" ng-click="close()">' + e + '"DIALOGS_CLOSE" | translate' + s + "</button></div>"), 
        a.put("/dialogs/wait.html", '<div class="modal-header dialog-header-wait"><h4 class="modal-title"><span class="' + e + "icon" + s + '"></span> ' + e + "header" + s + '</h4></div><div class="modal-body"><p ng-bind-html="msg"></p><div class="progress progress-striped active"><div class="progress-bar progress-bar-info" ng-style="getProgress()"></div><span class="sr-only">' + e + "progress" + s + e + '"DIALOGS_PERCENT_COMPLETE" | translate' + s + "</span></div></div>"), 
        a.put("/dialogs/notify.html", '<div class="modal-header dialog-header-notify"><button type="button" class="close" ng-click="close()" class="pull-right">&times;</button><h4 class="modal-title text-info"><span class="' + e + "icon" + s + '"></span> ' + e + "header" + s + '</h4></div><div class="modal-body text-info" ng-bind-html="msg"></div><div class="modal-footer"><button type="button" class="btn btn-primary" ng-click="close()">' + e + '"DIALOGS_OK" | translate' + s + "</button></div>"), 
        a.put("/dialogs/confirm.html", '<div class="modal-header dialog-header-confirm"><button type="button" class="close" ng-click="no()">&times;</button><h4 class="modal-title"><span class="' + e + "icon" + s + '"></span> ' + e + "header" + s + '</h4></div><div class="modal-body" ng-bind-html="msg"></div><div class="modal-footer"><button type="button" class="btn btn-default" ng-click="yes()">' + e + '"DIALOGS_YES" | translate' + s + '</button><button type="button" class="btn btn-primary" ng-click="no()">' + e + '"DIALOGS_NO" | translate' + s + "</button></div>");
    } ]);
}();

(function() {
    "use strict";
    var translateSubMod = angular.module("translate.sub", []);
    translateSubMod.provider("$translate", [ function() {
        var _translations = [];
        var _current = "en-US";
        this.translations = function(lang, obj) {
            if (angular.isDefined(lang) && angular.isDefined(obj)) {
                _translations[lang] = angular.copy(obj);
                _current = lang;
            }
        };
        this.$get = [ function() {
            return {
                instant: function(what) {
                    if (angular.isDefined(what) && angular.isDefined(_translations[_current][what])) return _translations[_current][what]; else return "";
                }
            };
        } ];
    } ]);
    translateSubMod.filter("translate", [ "$translate", function($translate) {
        return function(what) {
            return $translate.instant(what);
        };
    } ]);
    var ctrlrs;
    try {
        angular.module("pascalprecht.translate");
        ctrlrs = angular.module("dialogs.controllers", [ "ui.bootstrap.modal", "pascalprecht.translate" ]);
    } catch (err) {
        ctrlrs = angular.module("dialogs.controllers", [ "ui.bootstrap.modal", "translate.sub" ]);
    }
    ctrlrs.controller("errorDialogCtrl", [ "$scope", "$uibModalInstance", "$translate", "data", function($scope, $uibModalInstance, $translate, data) {
        $scope.header = angular.isDefined(data.header) ? data.header : $translate.instant("DIALOGS_ERROR");
        $scope.msg = angular.isDefined(data.msg) ? data.msg : $translate.instant("DIALOGS_ERROR_MSG");
        $scope.icon = angular.isDefined(data.fa) && angular.equals(data.fa, true) ? "fa fa-warning" : "glyphicon glyphicon-warning-sign";
        $scope.close = function() {
            $uibModalInstance.close();
            $scope.$destroy();
        };
    } ]);
    ctrlrs.controller("waitDialogCtrl", [ "$scope", "$uibModalInstance", "$translate", "$timeout", "data", function($scope, $uibModalInstance, $translate, $timeout, data) {
        $scope.header = angular.isDefined(data.header) ? data.header : $translate.instant("DIALOGS_PLEASE_WAIT_ELIPS");
        $scope.msg = angular.isDefined(data.msg) ? data.msg : $translate.instant("DIALOGS_PLEASE_WAIT_MSG");
        $scope.progress = angular.isDefined(data.progress) ? data.progress : 100;
        $scope.icon = angular.isDefined(data.fa) && angular.equals(data.fa, true) ? "fa fa-clock-o" : "glyphicon glyphicon-time";
        $scope.$on("dialogs.wait.complete", function() {
            $timeout(function() {
                $uibModalInstance.close();
                $scope.$destroy();
            });
        });
        $scope.$on("dialogs.wait.message", function(evt, args) {
            $scope.msg = angular.isDefined(args.msg) ? args.msg : $scope.msg;
        });
        $scope.$on("dialogs.wait.progress", function(evt, args) {
            $scope.msg = angular.isDefined(args.msg) ? args.msg : $scope.msg;
            $scope.progress = angular.isDefined(args.progress) ? args.progress : $scope.progress;
        });
        $scope.getProgress = function() {
            return {
                width: $scope.progress + "%"
            };
        };
    } ]);
    ctrlrs.controller("notifyDialogCtrl", [ "$scope", "$uibModalInstance", "$translate", "data", function($scope, $uibModalInstance, $translate, data) {
        $scope.header = angular.isDefined(data.header) ? data.header : $translate.instant("DIALOGS_NOTIFICATION");
        $scope.msg = angular.isDefined(data.msg) ? data.msg : $translate.instant("DIALOGS_NOTIFICATION_MSG");
        $scope.icon = angular.isDefined(data.fa) && angular.equals(data.fa, true) ? "fa fa-info" : "glyphicon glyphicon-info-sign";
        $scope.close = function() {
            $uibModalInstance.close();
            $scope.$destroy();
        };
    } ]);
    ctrlrs.controller("confirmDialogCtrl", [ "$scope", "$uibModalInstance", "$translate", "data", function($scope, $uibModalInstance, $translate, data) {
        $scope.header = angular.isDefined(data.header) ? data.header : $translate.instant("DIALOGS_CONFIRMATION");
        $scope.msg = angular.isDefined(data.msg) ? data.msg : $translate.instant("DIALOGS_CONFIRMATION_MSG");
        $scope.icon = angular.isDefined(data.fa) && angular.equals(data.fa, true) ? "fa fa-check" : "glyphicon glyphicon-check";
        $scope.no = function() {
            $uibModalInstance.dismiss("no");
        };
        $scope.yes = function() {
            $uibModalInstance.close("yes");
        };
    } ]);
    angular.module("dialogs.services", [ "ui.bootstrap.modal", "dialogs.controllers" ]).provider("dialogs", [ function() {
        var _b = true;
        var _k = true;
        var _w = "dialogs-default";
        var _bdc = "dialogs-backdrop-default";
        var _copy = true;
        var _wTmpl = null;
        var _wSize = "lg";
        var _animation = false;
        var _fa = false;
        var _setOpts = function(opts) {
            var _opts = {};
            opts = opts || {};
            _opts.kb = angular.isDefined(opts.keyboard) ? !!opts.keyboard : _k;
            _opts.bd = angular.isDefined(opts.backdrop) ? opts.backdrop : _b;
            _opts.bdc = angular.isDefined(opts.backdropClass) ? opts.backdropClass : _bdc;
            _opts.ws = angular.isDefined(opts.size) && (opts.size === "sm" || opts.size === "lg" || opts.size === "md") ? opts.size : _wSize;
            _opts.wc = angular.isDefined(opts.windowClass) ? opts.windowClass : _w;
            _opts.anim = angular.isDefined(opts.animation) ? !!opts.animation : _animation;
            return _opts;
        };
        this.useBackdrop = function(val) {
            if (angular.isDefined(val)) _b = val;
        };
        this.useEscClose = function(val) {
            if (angular.isDefined(val)) _k = !angular.equals(val, 0) && !angular.equals(val, "false") && !angular.equals(val, "no") && !angular.equals(val, null) && !angular.equals(val, false) ? true : false;
        };
        this.useClass = function(val) {
            if (angular.isDefined(val)) _w = val;
        };
        this.useCopy = function(val) {
            if (angular.isDefined(val)) _copy = !angular.equals(val, 0) && !angular.equals(val, "false") && !angular.equals(val, "no") && !angular.equals(val, null) && !angular.equals(val, false) ? true : false;
        };
        this.setWindowTmpl = function(val) {
            if (angular.isDefined(val)) _wTmpl = val;
        };
        this.setSize = function(val) {
            if (angular.isDefined(val)) _wSize = angular.equals(val, "sm") || angular.equals(val, "lg") || angular.equals(val, "md") ? val : _wSize;
        };
        this.useAnimation = function() {
            _animation = true;
        };
        this.useFontAwesome = function() {
            _fa = true;
        };
        this.$get = [ "$uibModal", function($uibModal) {
            return {
                error: function(header, msg, opts) {
                    opts = _setOpts(opts);
                    return $uibModal.open({
                        templateUrl: "/dialogs/error.html",
                        controller: "errorDialogCtrl",
                        backdrop: opts.bd,
                        backdropClass: opts.bdc,
                        keyboard: opts.kb,
                        windowClass: opts.wc,
                        size: opts.ws,
                        animation: opts.anim,
                        resolve: {
                            data: function() {
                                return {
                                    header: angular.copy(header),
                                    msg: angular.copy(msg),
                                    fa: _fa
                                };
                            }
                        }
                    });
                },
                wait: function(header, msg, progress, opts) {
                    opts = _setOpts(opts);
                    return $uibModal.open({
                        templateUrl: "/dialogs/wait.html",
                        controller: "waitDialogCtrl",
                        backdrop: opts.bd,
                        backdropClass: opts.bdc,
                        keyboard: opts.kb,
                        windowClass: opts.wc,
                        size: opts.ws,
                        animation: opts.anim,
                        resolve: {
                            data: function() {
                                return {
                                    header: angular.copy(header),
                                    msg: angular.copy(msg),
                                    progress: angular.copy(progress),
                                    fa: _fa
                                };
                            }
                        }
                    });
                },
                notify: function(header, msg, opts) {
                    opts = _setOpts(opts);
                    return $uibModal.open({
                        templateUrl: "/dialogs/notify.html",
                        controller: "notifyDialogCtrl",
                        backdrop: opts.bd,
                        backdropClass: opts.bdc,
                        keyboard: opts.kb,
                        windowClass: opts.wc,
                        size: opts.ws,
                        animation: opts.anim,
                        resolve: {
                            data: function() {
                                return {
                                    header: angular.copy(header),
                                    msg: angular.copy(msg),
                                    fa: _fa
                                };
                            }
                        }
                    });
                },
                confirm: function(header, msg, opts) {
                    opts = _setOpts(opts);
                    return $uibModal.open({
                        templateUrl: "/dialogs/confirm.html",
                        controller: "confirmDialogCtrl",
                        backdrop: opts.bd,
                        backdropClass: opts.bdc,
                        keyboard: opts.kb,
                        windowClass: opts.wc,
                        size: opts.ws,
                        animation: opts.anim,
                        resolve: {
                            data: function() {
                                return {
                                    header: angular.copy(header),
                                    msg: angular.copy(msg),
                                    fa: _fa
                                };
                            }
                        }
                    });
                },
                create: function(url, ctrlr, data, opts, ctrlAs) {
                    var copy = opts && angular.isDefined(opts.copy) ? opts.copy : _copy;
                    opts = _setOpts(opts);
                    return $uibModal.open({
                        templateUrl: url,
                        controller: ctrlr,
                        controllerAs: ctrlAs,
                        keyboard: opts.kb,
                        backdrop: opts.bd,
                        backdropClass: opts.bdc,
                        windowClass: opts.wc,
                        size: opts.ws,
                        animation: opts.anim,
                        resolve: {
                            data: function() {
                                if (copy) return angular.copy(data); else return data;
                            }
                        }
                    });
                }
            };
        } ];
    } ]);
    angular.module("dialogs.main", [ "dialogs.services", "ngSanitize" ]).config([ "$translateProvider", "dialogsProvider", function($translateProvider, dialogsProvider) {
        try {
            angular.module("pascalprecht.translate");
        } catch (err) {
            $translateProvider.translations("en-US", {
                DIALOGS_ERROR: "Error",
                DIALOGS_ERROR_MSG: "An unknown error has occurred.",
                DIALOGS_CLOSE: "Close",
                DIALOGS_PLEASE_WAIT: "Please Wait",
                DIALOGS_PLEASE_WAIT_ELIPS: "Please Wait...",
                DIALOGS_PLEASE_WAIT_MSG: "Waiting on operation to complete.",
                DIALOGS_PERCENT_COMPLETE: "% Complete",
                DIALOGS_NOTIFICATION: "Notification",
                DIALOGS_NOTIFICATION_MSG: "Unknown application notification.",
                DIALOGS_CONFIRMATION: "Confirmation",
                DIALOGS_CONFIRMATION_MSG: "Confirmation required.",
                DIALOGS_OK: "OK",
                DIALOGS_YES: "Yes",
                DIALOGS_NO: "No"
            });
        }
        try {
            var _sheets = document.styleSheets;
            sheetLoop: for (var i = _sheets.length - 1; i >= 0; i--) {
                var _matches = null;
                var _rules = null;
                if (!_sheets[i].disabled) {
                    if (_sheets[i].href !== null) _matches = _sheets[i].href.match(/font\-*awesome/i);
                    if (angular.isArray(_matches)) {
                        dialogsProvider.useFontAwesome();
                        break;
                    } else {
                        _rules = _sheets[i].cssRules;
                        for (var x = _rules.length - 1; x >= 0; x--) {
                            if (_rules[x].selectorText.toLowerCase() == ".fa") {
                                dialogsProvider.useFontAwesome();
                                break sheetLoop;
                            }
                        }
                    }
                }
            }
        } catch (err) {}
    } ]).run([ "$templateCache", "$interpolate", function($templateCache, $interpolate) {
        var startSym = $interpolate.startSymbol();
        var endSym = $interpolate.endSymbol();
        $templateCache.put("/dialogs/error.html", '<div class="modal-header dialog-header-error"><button type="button" class="close" ng-click="close()">&times;</button><h4 class="modal-title text-danger"><span class="' + startSym + "icon" + endSym + '"></span> <span ng-bind-html="header"></span></h4></div><div class="modal-body text-danger" ng-bind-html="msg"></div><div class="modal-footer"><button type="button" class="btn btn-default" ng-click="close()">' + startSym + '"DIALOGS_CLOSE" | translate' + endSym + "</button></div>");
        $templateCache.put("/dialogs/wait.html", '<div class="modal-header dialog-header-wait"><h4 class="modal-title"><span class="' + startSym + "icon" + endSym + '"></span> ' + startSym + "header" + endSym + '</h4></div><div class="modal-body"><p ng-bind-html="msg"></p><div class="progress progress-striped active"><div class="progress-bar progress-bar-info" ng-style="getProgress()"></div><span class="sr-only">' + startSym + "progress" + endSym + "" + startSym + '"DIALOGS_PERCENT_COMPLETE" | translate' + endSym + "</span></div></div>");
        $templateCache.put("/dialogs/notify.html", '<div class="modal-header dialog-header-notify"><button type="button" class="close" ng-click="close()" class="pull-right">&times;</button><h4 class="modal-title text-info"><span class="' + startSym + "icon" + endSym + '"></span> ' + startSym + "header" + endSym + '</h4></div><div class="modal-body text-info" ng-bind-html="msg"></div><div class="modal-footer"><button type="button" class="btn btn-primary" ng-click="close()">' + startSym + '"DIALOGS_OK" | translate' + endSym + "</button></div>");
        $templateCache.put("/dialogs/confirm.html", '<div class="modal-header dialog-header-confirm"><button type="button" class="close" ng-click="no()">&times;</button><h4 class="modal-title"><span class="' + startSym + "icon" + endSym + '"></span> ' + startSym + "header" + endSym + '</h4></div><div class="modal-body" ng-bind-html="msg"></div><div class="modal-footer"><button type="button" class="btn btn-default" ng-click="yes()">' + startSym + '"DIALOGS_YES" | translate' + endSym + '</button><button type="button" class="btn btn-primary" ng-click="no()">' + startSym + '"DIALOGS_NO" | translate' + endSym + "</button></div>");
    } ]);
})();

angular.module("dialogs.default-translations", [ "pascalprecht.translate" ]).config([ "$translateProvider", function(O) {
    O.translations("en-US", {
        DIALOGS_ERROR: "Error",
        DIALOGS_ERROR_MSG: "An unknown error has occurred.",
        DIALOGS_CLOSE: "Close",
        DIALOGS_PLEASE_WAIT: "Please Wait",
        DIALOGS_PLEASE_WAIT_ELIPS: "Please Wait...",
        DIALOGS_PLEASE_WAIT_MSG: "Waiting on operation to complete.",
        DIALOGS_PERCENT_COMPLETE: "% Complete",
        DIALOGS_NOTIFICATION: "Notification",
        DIALOGS_NOTIFICATION_MSG: "Unknown application notification.",
        DIALOGS_CONFIRMATION: "Confirmation",
        DIALOGS_CONFIRMATION_MSG: "Confirmation required.",
        DIALOGS_OK: "OK",
        DIALOGS_YES: "Yes",
        DIALOGS_NO: "No"
    }), O.translations("zh-CN", {
        DIALOGS_ERROR: "错误",
        DIALOGS_ERROR_MSG: "出现未知错误。",
        DIALOGS_CLOSE: "关闭",
        DIALOGS_PLEASE_WAIT: "请稍候",
        DIALOGS_PLEASE_WAIT_ELIPS: "请稍候...",
        DIALOGS_PLEASE_WAIT_MSG: "请等待操作完成。",
        DIALOGS_PERCENT_COMPLETE: "% 已完成",
        DIALOGS_NOTIFICATION: "通知",
        DIALOGS_NOTIFICATION_MSG: "未知应用程序的通知。",
        DIALOGS_CONFIRMATION: "确认",
        DIALOGS_CONFIRMATION_MSG: "确认要求。",
        DIALOGS_OK: "确定",
        DIALOGS_YES: "确认",
        DIALOGS_NO: "取消"
    }), O.translations("es-ES", {
        DIALOGS_ERROR: "Error",
        DIALOGS_ERROR_MSG: "Se ha producido un error.",
        DIALOGS_CLOSE: "Cerrar",
        DIALOGS_PLEASE_WAIT: "Espere por favor",
        DIALOGS_PLEASE_WAIT_ELIPS: "Espere por favor...",
        DIALOGS_PLEASE_WAIT_MSG: "Completando operación.",
        DIALOGS_PERCENT_COMPLETE: "% Completado",
        DIALOGS_NOTIFICATION: "Notificación",
        DIALOGS_NOTIFICATION_MSG: "Notificación de una aplicación desconocida.",
        DIALOGS_CONFIRMATION: "Confirmación",
        DIALOGS_CONFIRMATION_MSG: "Se requiere confirmacion.",
        DIALOGS_OK: "Aceptar",
        DIALOGS_YES: "Sí",
        DIALOGS_NO: "No"
    }), O.translations("fr-FR", {
        DIALOGS_ERROR: "Erreur",
        DIALOGS_ERROR_MSG: "Une erreur inconnue s'est produite.",
        DIALOGS_CLOSE: "Fermer",
        DIALOGS_PLEASE_WAIT: "Patientez svp",
        DIALOGS_PLEASE_WAIT_ELIPS: "Patienter svp...",
        DIALOGS_PLEASE_WAIT_MSG: "En attente de la fin de l'opération.",
        DIALOGS_PERCENT_COMPLETE: "% Terminer",
        DIALOGS_NOTIFICATION: "Notification",
        DIALOGS_NOTIFICATION_MSG: "Notification de l'application inconnue",
        DIALOGS_CONFIRMATION: "Confirmer",
        DIALOGS_CONFIRMATION_MSG: "Merci de confirmer",
        DIALOGS_OK: "OK",
        DIALOGS_YES: "Oui",
        DIALOGS_NO: "Non"
    }), O.translations("pt-BR", {
        DIALOGS_ERROR: "Erro",
        DIALOGS_ERROR_MSG: "Ocorreu um erro inesperado.",
        DIALOGS_CLOSE: "Fechar",
        DIALOGS_PLEASE_WAIT: "Por favor aguarde",
        DIALOGS_PLEASE_WAIT_ELIPS: "Por favor aguarde...",
        DIALOGS_PLEASE_WAIT_MSG: "Aguardando que a operação termine.",
        DIALOGS_PERCENT_COMPLETE: "% Completados",
        DIALOGS_NOTIFICATION: "Notificação",
        DIALOGS_NOTIFICATION_MSG: "Notificação de aplicação desconhecida.",
        DIALOGS_CONFIRMATION: "Confirmação",
        DIALOGS_CONFIRMATION_MSG: "Confirmação requerida.",
        DIALOGS_OK: "OK",
        DIALOGS_YES: "Sim",
        DIALOGS_NO: "Não"
    }), O.preferredLanguage("en-US");
} ]);

angular.module("dialogs.default-translations", [ "pascalprecht.translate" ]).config([ "$translateProvider", function($translateProvider) {
    $translateProvider.translations("en-US", {
        DIALOGS_ERROR: "Error",
        DIALOGS_ERROR_MSG: "An unknown error has occurred.",
        DIALOGS_CLOSE: "Close",
        DIALOGS_PLEASE_WAIT: "Please Wait",
        DIALOGS_PLEASE_WAIT_ELIPS: "Please Wait...",
        DIALOGS_PLEASE_WAIT_MSG: "Waiting on operation to complete.",
        DIALOGS_PERCENT_COMPLETE: "% Complete",
        DIALOGS_NOTIFICATION: "Notification",
        DIALOGS_NOTIFICATION_MSG: "Unknown application notification.",
        DIALOGS_CONFIRMATION: "Confirmation",
        DIALOGS_CONFIRMATION_MSG: "Confirmation required.",
        DIALOGS_OK: "OK",
        DIALOGS_YES: "Yes",
        DIALOGS_NO: "No"
    });
    $translateProvider.translations("zh-CN", {
        DIALOGS_ERROR: "错误",
        DIALOGS_ERROR_MSG: "出现未知错误。",
        DIALOGS_CLOSE: "关闭",
        DIALOGS_PLEASE_WAIT: "请稍候",
        DIALOGS_PLEASE_WAIT_ELIPS: "请稍候...",
        DIALOGS_PLEASE_WAIT_MSG: "请等待操作完成。",
        DIALOGS_PERCENT_COMPLETE: "% 已完成",
        DIALOGS_NOTIFICATION: "通知",
        DIALOGS_NOTIFICATION_MSG: "未知应用程序的通知。",
        DIALOGS_CONFIRMATION: "确认",
        DIALOGS_CONFIRMATION_MSG: "确认要求。",
        DIALOGS_OK: "确定",
        DIALOGS_YES: "确认",
        DIALOGS_NO: "取消"
    });
    $translateProvider.translations("es-ES", {
        DIALOGS_ERROR: "Error",
        DIALOGS_ERROR_MSG: "Se ha producido un error.",
        DIALOGS_CLOSE: "Cerrar",
        DIALOGS_PLEASE_WAIT: "Espere por favor",
        DIALOGS_PLEASE_WAIT_ELIPS: "Espere por favor...",
        DIALOGS_PLEASE_WAIT_MSG: "Completando operación.",
        DIALOGS_PERCENT_COMPLETE: "% Completado",
        DIALOGS_NOTIFICATION: "Notificación",
        DIALOGS_NOTIFICATION_MSG: "Notificación de una aplicación desconocida.",
        DIALOGS_CONFIRMATION: "Confirmación",
        DIALOGS_CONFIRMATION_MSG: "Se requiere confirmacion.",
        DIALOGS_OK: "Aceptar",
        DIALOGS_YES: "Sí",
        DIALOGS_NO: "No"
    });
    $translateProvider.translations("fr-FR", {
        DIALOGS_ERROR: "Erreur",
        DIALOGS_ERROR_MSG: "Une erreur inconnue s'est produite.",
        DIALOGS_CLOSE: "Fermer",
        DIALOGS_PLEASE_WAIT: "Patientez svp",
        DIALOGS_PLEASE_WAIT_ELIPS: "Patienter svp...",
        DIALOGS_PLEASE_WAIT_MSG: "En attente de la fin de l'opération.",
        DIALOGS_PERCENT_COMPLETE: "% Terminer",
        DIALOGS_NOTIFICATION: "Notification",
        DIALOGS_NOTIFICATION_MSG: "Notification de l'application inconnue",
        DIALOGS_CONFIRMATION: "Confirmer",
        DIALOGS_CONFIRMATION_MSG: "Merci de confirmer",
        DIALOGS_OK: "OK",
        DIALOGS_YES: "Oui",
        DIALOGS_NO: "Non"
    });
    $translateProvider.translations("pt-BR", {
        DIALOGS_ERROR: "Erro",
        DIALOGS_ERROR_MSG: "Ocorreu um erro inesperado.",
        DIALOGS_CLOSE: "Fechar",
        DIALOGS_PLEASE_WAIT: "Por favor aguarde",
        DIALOGS_PLEASE_WAIT_ELIPS: "Por favor aguarde...",
        DIALOGS_PLEASE_WAIT_MSG: "Aguardando que a operação termine.",
        DIALOGS_PERCENT_COMPLETE: "% Completados",
        DIALOGS_NOTIFICATION: "Notificação",
        DIALOGS_NOTIFICATION_MSG: "Notificação de aplicação desconhecida.",
        DIALOGS_CONFIRMATION: "Confirmação",
        DIALOGS_CONFIRMATION_MSG: "Confirmação requerida.",
        DIALOGS_OK: "OK",
        DIALOGS_YES: "Sim",
        DIALOGS_NO: "Não"
    });
    $translateProvider.preferredLanguage("en-US");
} ]);

(function(root, factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "angular" ], factory);
    } else if (root.hasOwnProperty("angular")) {
        factory(root.angular);
    } else if (typeof exports === "object") {
        module.exports = factory(require("angular"));
    }
})(this, function(angular) {
    "use strict";
    angular = angular && angular.module ? angular : window.angular;
    function isStorageSupported($window, storageType) {
        var supported;
        try {
            supported = $window[storageType];
        } catch (err) {
            supported = false;
        }
        if (supported) {
            var key = "__" + Math.round(Math.random() * 1e7);
            try {
                $window[storageType].setItem(key, key);
                $window[storageType].removeItem(key, key);
            } catch (err) {
                supported = false;
            }
        }
        return supported;
    }
    return angular.module("ngStorage", []).provider("$localStorage", _storageProvider("localStorage")).provider("$sessionStorage", _storageProvider("sessionStorage"));
    function _storageProvider(storageType) {
        var providerWebStorage = isStorageSupported(window, storageType);
        return function() {
            var storageKeyPrefix = "ngStorage-";
            this.setKeyPrefix = function(prefix) {
                if (typeof prefix !== "string") {
                    throw new TypeError("[ngStorage] - " + storageType + "Provider.setKeyPrefix() expects a String.");
                }
                storageKeyPrefix = prefix;
            };
            var serializer = angular.toJson;
            var deserializer = angular.fromJson;
            this.setSerializer = function(s) {
                if (typeof s !== "function") {
                    throw new TypeError("[ngStorage] - " + storageType + "Provider.setSerializer expects a function.");
                }
                serializer = s;
            };
            this.setDeserializer = function(d) {
                if (typeof d !== "function") {
                    throw new TypeError("[ngStorage] - " + storageType + "Provider.setDeserializer expects a function.");
                }
                deserializer = d;
            };
            this.supported = function() {
                return !!providerWebStorage;
            };
            this.get = function(key) {
                return providerWebStorage && deserializer(providerWebStorage.getItem(storageKeyPrefix + key));
            };
            this.set = function(key, value) {
                return providerWebStorage && providerWebStorage.setItem(storageKeyPrefix + key, serializer(value));
            };
            this.remove = function(key) {
                providerWebStorage && providerWebStorage.removeItem(storageKeyPrefix + key);
            };
            this.$get = [ "$rootScope", "$window", "$log", "$timeout", "$document", function($rootScope, $window, $log, $timeout, $document) {
                var prefixLength = storageKeyPrefix.length;
                var isSupported = isStorageSupported($window, storageType), webStorage = isSupported || ($log.warn("This browser does not support Web Storage!"), 
                {
                    setItem: angular.noop,
                    getItem: angular.noop,
                    removeItem: angular.noop
                }), $storage = {
                    $default: function(items) {
                        for (var k in items) {
                            angular.isDefined($storage[k]) || ($storage[k] = angular.copy(items[k]));
                        }
                        $storage.$sync();
                        return $storage;
                    },
                    $reset: function(items) {
                        for (var k in $storage) {
                            "$" === k[0] || delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k);
                        }
                        return $storage.$default(items);
                    },
                    $sync: function() {
                        for (var i = 0, l = webStorage.length, k; i < l; i++) {
                            (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));
                        }
                    },
                    $apply: function() {
                        var temp$storage;
                        _debounce = null;
                        if (!angular.equals($storage, _last$storage)) {
                            temp$storage = angular.copy(_last$storage);
                            angular.forEach($storage, function(v, k) {
                                if (angular.isDefined(v) && "$" !== k[0]) {
                                    webStorage.setItem(storageKeyPrefix + k, serializer(v));
                                    delete temp$storage[k];
                                }
                            });
                            for (var k in temp$storage) {
                                webStorage.removeItem(storageKeyPrefix + k);
                            }
                            _last$storage = angular.copy($storage);
                        }
                    },
                    $supported: function() {
                        return !!isSupported;
                    }
                }, _last$storage, _debounce;
                $storage.$sync();
                _last$storage = angular.copy($storage);
                $rootScope.$watch(function() {
                    _debounce || (_debounce = $timeout($storage.$apply, 100, false));
                });
                $window.addEventListener && $window.addEventListener("storage", function(event) {
                    if (!event.key) {
                        return;
                    }
                    var doc = $document[0];
                    if ((!doc.hasFocus || !doc.hasFocus()) && storageKeyPrefix === event.key.slice(0, prefixLength)) {
                        event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)];
                        _last$storage = angular.copy($storage);
                        $rootScope.$apply();
                    }
                });
                $window.addEventListener && $window.addEventListener("beforeunload", function() {
                    $storage.$apply();
                });
                return $storage;
            } ];
        };
    }
});

(function() {
    "use strict";
    var KEY = {
        TAB: 9,
        ENTER: 13,
        ESC: 27,
        SPACE: 32,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        HOME: 36,
        END: 35,
        BACKSPACE: 8,
        DELETE: 46,
        COMMAND: 91,
        MAP: {
            91: "COMMAND",
            8: "BACKSPACE",
            9: "TAB",
            13: "ENTER",
            16: "SHIFT",
            17: "CTRL",
            18: "ALT",
            19: "PAUSEBREAK",
            20: "CAPSLOCK",
            27: "ESC",
            32: "SPACE",
            33: "PAGE_UP",
            34: "PAGE_DOWN",
            35: "END",
            36: "HOME",
            37: "LEFT",
            38: "UP",
            39: "RIGHT",
            40: "DOWN",
            43: "+",
            44: "PRINTSCREEN",
            45: "INSERT",
            46: "DELETE",
            48: "0",
            49: "1",
            50: "2",
            51: "3",
            52: "4",
            53: "5",
            54: "6",
            55: "7",
            56: "8",
            57: "9",
            59: ";",
            61: "=",
            65: "A",
            66: "B",
            67: "C",
            68: "D",
            69: "E",
            70: "F",
            71: "G",
            72: "H",
            73: "I",
            74: "J",
            75: "K",
            76: "L",
            77: "M",
            78: "N",
            79: "O",
            80: "P",
            81: "Q",
            82: "R",
            83: "S",
            84: "T",
            85: "U",
            86: "V",
            87: "W",
            88: "X",
            89: "Y",
            90: "Z",
            96: "0",
            97: "1",
            98: "2",
            99: "3",
            100: "4",
            101: "5",
            102: "6",
            103: "7",
            104: "8",
            105: "9",
            106: "*",
            107: "+",
            109: "-",
            110: ".",
            111: "/",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NUMLOCK",
            145: "SCROLLLOCK",
            186: ";",
            187: "=",
            188: ",",
            189: "-",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: "'"
        },
        isControl: function(e) {
            var k = e.which;
            switch (k) {
              case KEY.COMMAND:
              case KEY.SHIFT:
              case KEY.CTRL:
              case KEY.ALT:
                return true;
            }
            if (e.metaKey) return true;
            return false;
        },
        isFunctionKey: function(k) {
            k = k.which ? k.which : k;
            return k >= 112 && k <= 123;
        },
        isVerticalMovement: function(k) {
            return ~[ KEY.UP, KEY.DOWN ].indexOf(k);
        },
        isHorizontalMovement: function(k) {
            return ~[ KEY.LEFT, KEY.RIGHT, KEY.BACKSPACE, KEY.DELETE ].indexOf(k);
        }
    };
    if (angular.element.prototype.querySelectorAll === undefined) {
        angular.element.prototype.querySelectorAll = function(selector) {
            return angular.element(this[0].querySelectorAll(selector));
        };
    }
    if (angular.element.prototype.closest === undefined) {
        angular.element.prototype.closest = function(selector) {
            var elem = this[0];
            var matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector;
            while (elem) {
                if (matchesSelector.bind(elem)(selector)) {
                    return elem;
                } else {
                    elem = elem.parentElement;
                }
            }
            return false;
        };
    }
    var latestId = 0;
    var uis = angular.module("ui.select", []).constant("uiSelectConfig", {
        theme: "bootstrap",
        searchEnabled: true,
        sortable: false,
        placeholder: "",
        refreshDelay: 1e3,
        closeOnSelect: true,
        generateId: function() {
            return latestId++;
        },
        appendToBody: false
    }).service("uiSelectMinErr", function() {
        var minErr = angular.$$minErr("ui.select");
        return function() {
            var error = minErr.apply(this, arguments);
            var message = error.message.replace(new RegExp("\nhttp://errors.angularjs.org/.*"), "");
            return new Error(message);
        };
    }).directive("uisTranscludeAppend", function() {
        return {
            link: function(scope, element, attrs, ctrl, transclude) {
                transclude(scope, function(clone) {
                    element.append(clone);
                });
            }
        };
    }).filter("highlight", function() {
        function escapeRegexp(queryToEscape) {
            return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
        }
        return function(matchItem, query) {
            return query && matchItem ? matchItem.replace(new RegExp(escapeRegexp(query), "gi"), '<span class="ui-select-highlight">$&</span>') : matchItem;
        };
    }).factory("uisOffset", [ "$document", "$window", function($document, $window) {
        return function(element) {
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
                left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
            };
        };
    } ]);
    uis.directive("uiSelectChoices", [ "uiSelectConfig", "uisRepeatParser", "uiSelectMinErr", "$compile", function(uiSelectConfig, RepeatParser, uiSelectMinErr, $compile) {
        return {
            restrict: "EA",
            require: "^uiSelect",
            replace: true,
            transclude: true,
            templateUrl: function(tElement) {
                var theme = tElement.parent().attr("theme") || uiSelectConfig.theme;
                return theme + "/choices.tpl.html";
            },
            compile: function(tElement, tAttrs) {
                if (!tAttrs.repeat) throw uiSelectMinErr("repeat", "Expected 'repeat' expression.");
                return function link(scope, element, attrs, $select, transcludeFn) {
                    var groupByExp = attrs.groupBy;
                    $select.parseRepeatAttr(attrs.repeat, groupByExp);
                    $select.disableChoiceExpression = attrs.uiDisableChoice;
                    $select.onHighlightCallback = attrs.onHighlight;
                    if (groupByExp) {
                        var groups = element.querySelectorAll(".ui-select-choices-group");
                        if (groups.length !== 1) throw uiSelectMinErr("rows", "Expected 1 .ui-select-choices-group but got '{0}'.", groups.length);
                        groups.attr("ng-repeat", RepeatParser.getGroupNgRepeatExpression());
                    }
                    var choices = element.querySelectorAll(".ui-select-choices-row");
                    if (choices.length !== 1) {
                        throw uiSelectMinErr("rows", "Expected 1 .ui-select-choices-row but got '{0}'.", choices.length);
                    }
                    choices.attr("ng-repeat", RepeatParser.getNgRepeatExpression($select.parserResult.itemName, "$select.items", $select.parserResult.trackByExp, groupByExp)).attr("ng-if", "$select.open").attr("ng-mouseenter", "$select.setActiveItem(" + $select.parserResult.itemName + ")").attr("ng-click", "$select.select(" + $select.parserResult.itemName + ",false,$event)");
                    var rowsInner = element.querySelectorAll(".ui-select-choices-row-inner");
                    if (rowsInner.length !== 1) throw uiSelectMinErr("rows", "Expected 1 .ui-select-choices-row-inner but got '{0}'.", rowsInner.length);
                    rowsInner.attr("uis-transclude-append", "");
                    $compile(element, transcludeFn)(scope);
                    scope.$watch("$select.search", function(newValue) {
                        if (newValue && !$select.open && $select.multiple) $select.activate(false, true);
                        $select.activeIndex = $select.tagging.isActivated ? -1 : 0;
                        $select.refresh(attrs.refresh);
                    });
                    attrs.$observe("refreshDelay", function() {
                        var refreshDelay = scope.$eval(attrs.refreshDelay);
                        $select.refreshDelay = refreshDelay !== undefined ? refreshDelay : uiSelectConfig.refreshDelay;
                    });
                };
            }
        };
    } ]);
    uis.controller("uiSelectCtrl", [ "$scope", "$element", "$timeout", "$filter", "uisRepeatParser", "uiSelectMinErr", "uiSelectConfig", function($scope, $element, $timeout, $filter, RepeatParser, uiSelectMinErr, uiSelectConfig) {
        var ctrl = this;
        var EMPTY_SEARCH = "";
        ctrl.placeholder = uiSelectConfig.placeholder;
        ctrl.searchEnabled = uiSelectConfig.searchEnabled;
        ctrl.sortable = uiSelectConfig.sortable;
        ctrl.refreshDelay = uiSelectConfig.refreshDelay;
        ctrl.removeSelected = false;
        ctrl.closeOnSelect = true;
        ctrl.search = EMPTY_SEARCH;
        ctrl.activeIndex = 0;
        ctrl.items = [];
        ctrl.open = false;
        ctrl.focus = false;
        ctrl.disabled = false;
        ctrl.selected = undefined;
        ctrl.focusser = undefined;
        ctrl.resetSearchInput = true;
        ctrl.multiple = undefined;
        ctrl.disableChoiceExpression = undefined;
        ctrl.tagging = {
            isActivated: false,
            fct: undefined
        };
        ctrl.taggingTokens = {
            isActivated: false,
            tokens: undefined
        };
        ctrl.lockChoiceExpression = undefined;
        ctrl.clickTriggeredSelect = false;
        ctrl.$filter = $filter;
        ctrl.searchInput = $element.querySelectorAll("input.ui-select-search");
        if (ctrl.searchInput.length !== 1) {
            throw uiSelectMinErr("searchInput", "Expected 1 input.ui-select-search but got '{0}'.", ctrl.searchInput.length);
        }
        ctrl.isEmpty = function() {
            return angular.isUndefined(ctrl.selected) || ctrl.selected === null || ctrl.selected === "";
        };
        function _resetSearchInput() {
            if (ctrl.resetSearchInput || ctrl.resetSearchInput === undefined && uiSelectConfig.resetSearchInput) {
                ctrl.search = EMPTY_SEARCH;
                if (ctrl.selected && ctrl.items.length && !ctrl.multiple) {
                    ctrl.activeIndex = ctrl.items.indexOf(ctrl.selected);
                }
            }
        }
        ctrl.activate = function(initSearchValue, avoidReset) {
            if (!ctrl.disabled && !ctrl.open) {
                if (!avoidReset) _resetSearchInput();
                $scope.$broadcast("uis:activate");
                ctrl.open = true;
                ctrl.activeIndex = ctrl.activeIndex >= ctrl.items.length ? 0 : ctrl.activeIndex;
                if (ctrl.activeIndex === -1 && ctrl.taggingLabel !== false) {
                    ctrl.activeIndex = 0;
                }
                $timeout(function() {
                    ctrl.search = initSearchValue || ctrl.search;
                    ctrl.searchInput[0].focus();
                });
            }
        };
        ctrl.findGroupByName = function(name) {
            return ctrl.groups && ctrl.groups.filter(function(group) {
                return group.name === name;
            })[0];
        };
        ctrl.parseRepeatAttr = function(repeatAttr, groupByExp) {
            function updateGroups(items) {
                ctrl.groups = [];
                angular.forEach(items, function(item) {
                    var groupFn = $scope.$eval(groupByExp);
                    var groupName = angular.isFunction(groupFn) ? groupFn(item) : item[groupFn];
                    var group = ctrl.findGroupByName(groupName);
                    if (group) {
                        group.items.push(item);
                    } else {
                        ctrl.groups.push({
                            name: groupName,
                            items: [ item ]
                        });
                    }
                });
                ctrl.items = [];
                ctrl.groups.forEach(function(group) {
                    ctrl.items = ctrl.items.concat(group.items);
                });
            }
            function setPlainItems(items) {
                ctrl.items = items;
            }
            ctrl.setItemsFn = groupByExp ? updateGroups : setPlainItems;
            ctrl.parserResult = RepeatParser.parse(repeatAttr);
            ctrl.isGrouped = !!groupByExp;
            ctrl.itemProperty = ctrl.parserResult.itemName;
            ctrl.refreshItems = function(data) {
                data = data || ctrl.parserResult.source($scope);
                var selectedItems = ctrl.selected;
                if (angular.isArray(selectedItems) && !selectedItems.length || !ctrl.removeSelected) {
                    ctrl.setItemsFn(data);
                } else {
                    if (data !== undefined) {
                        var filteredItems = data.filter(function(i) {
                            return selectedItems.indexOf(i) < 0;
                        });
                        ctrl.setItemsFn(filteredItems);
                    }
                }
            };
            $scope.$watchCollection(ctrl.parserResult.source, function(items) {
                if (items === undefined || items === null) {
                    ctrl.items = [];
                } else {
                    if (!angular.isArray(items)) {
                        throw uiSelectMinErr("items", "Expected an array but got '{0}'.", items);
                    } else {
                        ctrl.refreshItems(items);
                        ctrl.ngModel.$modelValue = null;
                    }
                }
            });
        };
        var _refreshDelayPromise;
        ctrl.refresh = function(refreshAttr) {
            if (refreshAttr !== undefined) {
                if (_refreshDelayPromise) {
                    $timeout.cancel(_refreshDelayPromise);
                }
                _refreshDelayPromise = $timeout(function() {
                    $scope.$eval(refreshAttr);
                }, ctrl.refreshDelay);
            }
        };
        ctrl.setActiveItem = function(item) {
            ctrl.activeIndex = ctrl.items.indexOf(item);
        };
        ctrl.isActive = function(itemScope) {
            if (!ctrl.open) {
                return false;
            }
            var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);
            var isActive = itemIndex === ctrl.activeIndex;
            if (!isActive || itemIndex < 0 && ctrl.taggingLabel !== false || itemIndex < 0 && ctrl.taggingLabel === false) {
                return false;
            }
            if (isActive && !angular.isUndefined(ctrl.onHighlightCallback)) {
                itemScope.$eval(ctrl.onHighlightCallback);
            }
            return isActive;
        };
        ctrl.isDisabled = function(itemScope) {
            if (!ctrl.open) return;
            var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);
            var isDisabled = false;
            var item;
            if (itemIndex >= 0 && !angular.isUndefined(ctrl.disableChoiceExpression)) {
                item = ctrl.items[itemIndex];
                isDisabled = !!itemScope.$eval(ctrl.disableChoiceExpression);
                item._uiSelectChoiceDisabled = isDisabled;
            }
            return isDisabled;
        };
        ctrl.select = function(item, skipFocusser, $event) {
            if (item === undefined || !item._uiSelectChoiceDisabled) {
                if (!ctrl.items && !ctrl.search) return;
                if (!item || !item._uiSelectChoiceDisabled) {
                    if (ctrl.tagging.isActivated) {
                        if (ctrl.taggingLabel === false) {
                            if (ctrl.activeIndex < 0) {
                                item = ctrl.tagging.fct !== undefined ? ctrl.tagging.fct(ctrl.search) : ctrl.search;
                                if (!item || angular.equals(ctrl.items[0], item)) {
                                    return;
                                }
                            } else {
                                item = ctrl.items[ctrl.activeIndex];
                            }
                        } else {
                            if (ctrl.activeIndex === 0) {
                                if (item === undefined) return;
                                if (ctrl.tagging.fct !== undefined && typeof item === "string") {
                                    item = ctrl.tagging.fct(ctrl.search);
                                    if (!item) return;
                                } else if (typeof item === "string") {
                                    item = item.replace(ctrl.taggingLabel, "").trim();
                                }
                            }
                        }
                        if (ctrl.selected && angular.isArray(ctrl.selected) && ctrl.selected.filter(function(selection) {
                            return angular.equals(selection, item);
                        }).length > 0) {
                            ctrl.close(skipFocusser);
                            return;
                        }
                    }
                    $scope.$broadcast("uis:select", item);
                    var locals = {};
                    locals[ctrl.parserResult.itemName] = item;
                    $timeout(function() {
                        ctrl.onSelectCallback($scope, {
                            $item: item,
                            $model: ctrl.parserResult.modelMapper($scope, locals)
                        });
                    });
                    if (ctrl.closeOnSelect) {
                        ctrl.close(skipFocusser);
                    }
                    if ($event && $event.type === "click") {
                        ctrl.clickTriggeredSelect = true;
                    }
                }
            }
        };
        ctrl.close = function(skipFocusser) {
            if (!ctrl.open) return;
            if (ctrl.ngModel && ctrl.ngModel.$setTouched) ctrl.ngModel.$setTouched();
            _resetSearchInput();
            ctrl.open = false;
            $scope.$broadcast("uis:close", skipFocusser);
        };
        ctrl.setFocus = function() {
            if (!ctrl.focus) ctrl.focusInput[0].focus();
        };
        ctrl.clear = function($event) {
            ctrl.select(undefined);
            $event.stopPropagation();
            ctrl.focusser[0].focus();
        };
        ctrl.toggle = function(e) {
            if (ctrl.open) {
                ctrl.close();
                e.preventDefault();
                e.stopPropagation();
            } else {
                ctrl.activate();
            }
        };
        ctrl.isLocked = function(itemScope, itemIndex) {
            var isLocked, item = ctrl.selected[itemIndex];
            if (item && !angular.isUndefined(ctrl.lockChoiceExpression)) {
                isLocked = !!itemScope.$eval(ctrl.lockChoiceExpression);
                item._uiSelectChoiceLocked = isLocked;
            }
            return isLocked;
        };
        var sizeWatch = null;
        ctrl.sizeSearchInput = function() {
            var input = ctrl.searchInput[0], container = ctrl.searchInput.parent().parent()[0], calculateContainerWidth = function() {
                return container.clientWidth * !!input.offsetParent;
            }, updateIfVisible = function(containerWidth) {
                if (containerWidth === 0) {
                    return false;
                }
                var inputWidth = containerWidth - input.offsetLeft - 10;
                if (inputWidth < 50) inputWidth = containerWidth;
                ctrl.searchInput.css("width", inputWidth + "px");
                return true;
            };
            ctrl.searchInput.css("width", "10px");
            $timeout(function() {
                if (sizeWatch === null && !updateIfVisible(calculateContainerWidth())) {
                    sizeWatch = $scope.$watch(calculateContainerWidth, function(containerWidth) {
                        if (updateIfVisible(containerWidth)) {
                            sizeWatch();
                            sizeWatch = null;
                        }
                    });
                }
            });
        };
        function _handleDropDownSelection(key) {
            var processed = true;
            switch (key) {
              case KEY.DOWN:
                if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); else if (ctrl.activeIndex < ctrl.items.length - 1) {
                    ctrl.activeIndex++;
                }
                break;

              case KEY.UP:
                if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); else if (ctrl.activeIndex > 0 || ctrl.search.length === 0 && ctrl.tagging.isActivated && ctrl.activeIndex > -1) {
                    ctrl.activeIndex--;
                }
                break;

              case KEY.TAB:
                if (!ctrl.multiple || ctrl.open) ctrl.select(ctrl.items[ctrl.activeIndex], true);
                break;

              case KEY.ENTER:
                if (ctrl.open && ctrl.activeIndex >= 0) {
                    ctrl.select(ctrl.items[ctrl.activeIndex]);
                } else {
                    ctrl.activate(false, true);
                }
                break;

              case KEY.ESC:
                ctrl.close();
                break;

              default:
                processed = false;
            }
            return processed;
        }
        ctrl.searchInput.on("keydown", function(e) {
            var key = e.which;
            $scope.$apply(function() {
                var tagged = false;
                if (ctrl.items.length > 0 || ctrl.tagging.isActivated) {
                    _handleDropDownSelection(key);
                    if (ctrl.taggingTokens.isActivated) {
                        for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {
                            if (ctrl.taggingTokens.tokens[i] === KEY.MAP[e.keyCode]) {
                                if (ctrl.search.length > 0) {
                                    tagged = true;
                                }
                            }
                        }
                        if (tagged) {
                            $timeout(function() {
                                ctrl.searchInput.triggerHandler("tagged");
                                var newItem = ctrl.search.replace(KEY.MAP[e.keyCode], "").trim();
                                if (ctrl.tagging.fct) {
                                    newItem = ctrl.tagging.fct(newItem);
                                }
                                if (newItem) ctrl.select(newItem, true);
                            });
                        }
                    }
                }
            });
            if (KEY.isVerticalMovement(key) && ctrl.items.length > 0) {
                _ensureHighlightVisible();
            }
        });
        ctrl.searchInput.on("paste", function(e) {
            var data = e.originalEvent.clipboardData.getData("text/plain");
            if (data && data.length > 0 && ctrl.taggingTokens.isActivated && ctrl.tagging.fct) {
                var items = data.split(ctrl.taggingTokens.tokens[0]);
                if (items && items.length > 0) {
                    angular.forEach(items, function(item) {
                        var newItem = ctrl.tagging.fct(item);
                        if (newItem) {
                            ctrl.select(newItem, true);
                        }
                    });
                    e.preventDefault();
                    e.stopPropagation();
                }
            }
        });
        ctrl.searchInput.on("tagged", function() {
            $timeout(function() {
                _resetSearchInput();
            });
        });
        function _ensureHighlightVisible() {
            var container = $element.querySelectorAll(".ui-select-choices-content");
            var choices = container.querySelectorAll(".ui-select-choices-row");
            if (choices.length < 1) {
                throw uiSelectMinErr("choices", "Expected multiple .ui-select-choices-row but got '{0}'.", choices.length);
            }
            if (ctrl.activeIndex < 0) {
                return;
            }
            var highlighted = choices[ctrl.activeIndex];
            var posY = highlighted.offsetTop + highlighted.clientHeight - container[0].scrollTop;
            var height = container[0].offsetHeight;
            if (posY > height) {
                container[0].scrollTop += posY - height;
            } else if (posY < highlighted.clientHeight) {
                if (ctrl.isGrouped && ctrl.activeIndex === 0) container[0].scrollTop = 0; else container[0].scrollTop -= highlighted.clientHeight - posY;
            }
        }
        $scope.$on("$destroy", function() {
            ctrl.searchInput.off("keyup keydown tagged blur paste");
        });
    } ]);
    uis.directive("uiSelect", [ "$document", "uiSelectConfig", "uiSelectMinErr", "uisOffset", "$compile", "$parse", "$timeout", function($document, uiSelectConfig, uiSelectMinErr, uisOffset, $compile, $parse, $timeout) {
        return {
            restrict: "EA",
            templateUrl: function(tElement, tAttrs) {
                var theme = tAttrs.theme || uiSelectConfig.theme;
                return theme + (angular.isDefined(tAttrs.multiple) ? "/select-multiple.tpl.html" : "/select.tpl.html");
            },
            replace: true,
            transclude: true,
            require: [ "uiSelect", "^ngModel" ],
            scope: true,
            controller: "uiSelectCtrl",
            controllerAs: "$select",
            compile: function(tElement, tAttrs) {
                if (angular.isDefined(tAttrs.multiple)) tElement.append("<ui-select-multiple/>").removeAttr("multiple"); else tElement.append("<ui-select-single/>");
                return function(scope, element, attrs, ctrls, transcludeFn) {
                    var $select = ctrls[0];
                    var ngModel = ctrls[1];
                    $select.generatedId = uiSelectConfig.generateId();
                    $select.baseTitle = attrs.title || "Select box";
                    $select.focusserTitle = $select.baseTitle + " focus";
                    $select.focusserId = "focusser-" + $select.generatedId;
                    $select.closeOnSelect = function() {
                        if (angular.isDefined(attrs.closeOnSelect)) {
                            return $parse(attrs.closeOnSelect)();
                        } else {
                            return uiSelectConfig.closeOnSelect;
                        }
                    }();
                    $select.onSelectCallback = $parse(attrs.onSelect);
                    $select.onRemoveCallback = $parse(attrs.onRemove);
                    $select.ngModel = ngModel;
                    $select.choiceGrouped = function(group) {
                        return $select.isGrouped && group && group.name;
                    };
                    if (attrs.tabindex) {
                        attrs.$observe("tabindex", function(value) {
                            $select.focusInput.attr("tabindex", value);
                            element.removeAttr("tabindex");
                        });
                    }
                    scope.$watch("searchEnabled", function() {
                        var searchEnabled = scope.$eval(attrs.searchEnabled);
                        $select.searchEnabled = searchEnabled !== undefined ? searchEnabled : uiSelectConfig.searchEnabled;
                    });
                    scope.$watch("sortable", function() {
                        var sortable = scope.$eval(attrs.sortable);
                        $select.sortable = sortable !== undefined ? sortable : uiSelectConfig.sortable;
                    });
                    attrs.$observe("disabled", function() {
                        $select.disabled = attrs.disabled !== undefined ? attrs.disabled : false;
                    });
                    attrs.$observe("resetSearchInput", function() {
                        var resetSearchInput = scope.$eval(attrs.resetSearchInput);
                        $select.resetSearchInput = resetSearchInput !== undefined ? resetSearchInput : true;
                    });
                    attrs.$observe("tagging", function() {
                        if (attrs.tagging !== undefined) {
                            var taggingEval = scope.$eval(attrs.tagging);
                            $select.tagging = {
                                isActivated: true,
                                fct: taggingEval !== true ? taggingEval : undefined
                            };
                        } else {
                            $select.tagging = {
                                isActivated: false,
                                fct: undefined
                            };
                        }
                    });
                    attrs.$observe("taggingLabel", function() {
                        if (attrs.tagging !== undefined) {
                            if (attrs.taggingLabel === "false") {
                                $select.taggingLabel = false;
                            } else {
                                $select.taggingLabel = attrs.taggingLabel !== undefined ? attrs.taggingLabel : "(new)";
                            }
                        }
                    });
                    attrs.$observe("taggingTokens", function() {
                        if (attrs.tagging !== undefined) {
                            var tokens = attrs.taggingTokens !== undefined ? attrs.taggingTokens.split("|") : [ ",", "ENTER" ];
                            $select.taggingTokens = {
                                isActivated: true,
                                tokens: tokens
                            };
                        }
                    });
                    if (angular.isDefined(attrs.autofocus)) {
                        $timeout(function() {
                            $select.setFocus();
                        });
                    }
                    if (angular.isDefined(attrs.focusOn)) {
                        scope.$on(attrs.focusOn, function() {
                            $timeout(function() {
                                $select.setFocus();
                            });
                        });
                    }
                    function onDocumentClick(e) {
                        if (!$select.open) return;
                        var contains = false;
                        if (window.jQuery) {
                            contains = window.jQuery.contains(element[0], e.target);
                        } else {
                            contains = element[0].contains(e.target);
                        }
                        if (!contains && !$select.clickTriggeredSelect) {
                            var focusableControls = [ "input", "button", "textarea" ];
                            var targetScope = angular.element(e.target).scope();
                            var skipFocusser = targetScope && targetScope.$select && targetScope.$select !== $select;
                            if (!skipFocusser) skipFocusser = ~focusableControls.indexOf(e.target.tagName.toLowerCase());
                            $select.close(skipFocusser);
                            scope.$digest();
                        }
                        $select.clickTriggeredSelect = false;
                    }
                    $document.on("click", onDocumentClick);
                    scope.$on("$destroy", function() {
                        $document.off("click", onDocumentClick);
                    });
                    transcludeFn(scope, function(clone) {
                        var transcluded = angular.element("<div>").append(clone);
                        var transcludedMatch = transcluded.querySelectorAll(".ui-select-match");
                        transcludedMatch.removeAttr("ui-select-match");
                        transcludedMatch.removeAttr("data-ui-select-match");
                        if (transcludedMatch.length !== 1) {
                            throw uiSelectMinErr("transcluded", "Expected 1 .ui-select-match but got '{0}'.", transcludedMatch.length);
                        }
                        element.querySelectorAll(".ui-select-match").replaceWith(transcludedMatch);
                        var transcludedChoices = transcluded.querySelectorAll(".ui-select-choices");
                        transcludedChoices.removeAttr("ui-select-choices");
                        transcludedChoices.removeAttr("data-ui-select-choices");
                        if (transcludedChoices.length !== 1) {
                            throw uiSelectMinErr("transcluded", "Expected 1 .ui-select-choices but got '{0}'.", transcludedChoices.length);
                        }
                        element.querySelectorAll(".ui-select-choices").replaceWith(transcludedChoices);
                    });
                    var appendToBody = scope.$eval(attrs.appendToBody);
                    if (appendToBody !== undefined ? appendToBody : uiSelectConfig.appendToBody) {
                        scope.$watch("$select.open", function(isOpen) {
                            if (isOpen) {
                                positionDropdown();
                            } else {
                                resetDropdown();
                            }
                        });
                        scope.$on("$destroy", function() {
                            resetDropdown();
                        });
                    }
                    var placeholder = null, originalWidth = "";
                    function positionDropdown() {
                        var offset = uisOffset(element);
                        placeholder = angular.element('<div class="ui-select-placeholder"></div>');
                        placeholder[0].style.width = offset.width + "px";
                        placeholder[0].style.height = offset.height + "px";
                        element.after(placeholder);
                        originalWidth = element[0].style.width;
                        $document.find("body").append(element);
                        element[0].style.position = "absolute";
                        element[0].style.left = offset.left + "px";
                        element[0].style.top = offset.top + "px";
                        element[0].style.width = offset.width + "px";
                    }
                    function resetDropdown() {
                        if (placeholder === null) {
                            return;
                        }
                        placeholder.replaceWith(element);
                        placeholder = null;
                        element[0].style.position = "";
                        element[0].style.left = "";
                        element[0].style.top = "";
                        element[0].style.width = originalWidth;
                    }
                };
            }
        };
    } ]);
    uis.directive("uiSelectMatch", [ "uiSelectConfig", function(uiSelectConfig) {
        return {
            restrict: "EA",
            require: "^uiSelect",
            replace: true,
            transclude: true,
            templateUrl: function(tElement) {
                var theme = tElement.parent().attr("theme") || uiSelectConfig.theme;
                var multi = tElement.parent().attr("multiple");
                return theme + (multi ? "/match-multiple.tpl.html" : "/match.tpl.html");
            },
            link: function(scope, element, attrs, $select) {
                $select.lockChoiceExpression = attrs.uiLockChoice;
                attrs.$observe("placeholder", function(placeholder) {
                    $select.placeholder = placeholder !== undefined ? placeholder : uiSelectConfig.placeholder;
                });
                function setAllowClear(allow) {
                    $select.allowClear = angular.isDefined(allow) ? allow === "" ? true : allow.toLowerCase() === "true" : false;
                }
                attrs.$observe("allowClear", setAllowClear);
                setAllowClear(attrs.allowClear);
                if ($select.multiple) {
                    $select.sizeSearchInput();
                }
            }
        };
    } ]);
    uis.directive("uiSelectMultiple", [ "uiSelectMinErr", "$timeout", function(uiSelectMinErr, $timeout) {
        return {
            restrict: "EA",
            require: [ "^uiSelect", "^ngModel" ],
            controller: [ "$scope", "$timeout", function($scope, $timeout) {
                var ctrl = this, $select = $scope.$select, ngModel;
                $scope.$evalAsync(function() {
                    ngModel = $scope.ngModel;
                });
                ctrl.activeMatchIndex = -1;
                ctrl.updateModel = function() {
                    ngModel.$setViewValue(Date.now());
                    ctrl.refreshComponent();
                };
                ctrl.refreshComponent = function() {
                    $select.refreshItems();
                    $select.sizeSearchInput();
                };
                ctrl.removeChoice = function(index) {
                    var removedChoice = $select.selected[index];
                    if (removedChoice._uiSelectChoiceLocked) return;
                    var locals = {};
                    locals[$select.parserResult.itemName] = removedChoice;
                    $select.selected.splice(index, 1);
                    ctrl.activeMatchIndex = -1;
                    $select.sizeSearchInput();
                    $timeout(function() {
                        $select.onRemoveCallback($scope, {
                            $item: removedChoice,
                            $model: $select.parserResult.modelMapper($scope, locals)
                        });
                    });
                    ctrl.updateModel();
                };
                ctrl.getPlaceholder = function() {
                    if ($select.selected.length) return;
                    return $select.placeholder;
                };
            } ],
            controllerAs: "$selectMultiple",
            link: function(scope, element, attrs, ctrls) {
                var $select = ctrls[0];
                var ngModel = scope.ngModel = ctrls[1];
                var $selectMultiple = scope.$selectMultiple;
                $select.multiple = true;
                $select.removeSelected = true;
                $select.focusInput = $select.searchInput;
                ngModel.$parsers.unshift(function() {
                    var locals = {}, result, resultMultiple = [];
                    for (var j = $select.selected.length - 1; j >= 0; j--) {
                        locals = {};
                        locals[$select.parserResult.itemName] = $select.selected[j];
                        result = $select.parserResult.modelMapper(scope, locals);
                        resultMultiple.unshift(result);
                    }
                    return resultMultiple;
                });
                ngModel.$formatters.unshift(function(inputValue) {
                    var data = $select.parserResult.source(scope, {
                        $select: {
                            search: ""
                        }
                    }), locals = {}, result;
                    if (!data) return inputValue;
                    var resultMultiple = [];
                    var checkFnMultiple = function(list, value) {
                        if (!list || !list.length) return;
                        for (var p = list.length - 1; p >= 0; p--) {
                            locals[$select.parserResult.itemName] = list[p];
                            result = $select.parserResult.modelMapper(scope, locals);
                            if ($select.parserResult.trackByExp) {
                                var matches = /\.(.+)/.exec($select.parserResult.trackByExp);
                                if (matches.length > 0 && result[matches[1]] == value[matches[1]]) {
                                    resultMultiple.unshift(list[p]);
                                    return true;
                                }
                            }
                            if (angular.equals(result, value)) {
                                resultMultiple.unshift(list[p]);
                                return true;
                            }
                        }
                        return false;
                    };
                    if (!inputValue) return resultMultiple;
                    for (var k = inputValue.length - 1; k >= 0; k--) {
                        if (!checkFnMultiple($select.selected, inputValue[k])) {
                            if (!checkFnMultiple(data, inputValue[k])) {
                                resultMultiple.unshift(inputValue[k]);
                            }
                        }
                    }
                    return resultMultiple;
                });
                scope.$watchCollection(function() {
                    return ngModel.$modelValue;
                }, function(newValue, oldValue) {
                    if (oldValue != newValue) {
                        ngModel.$modelValue = null;
                        $selectMultiple.refreshComponent();
                    }
                });
                ngModel.$render = function() {
                    if (!angular.isArray(ngModel.$viewValue)) {
                        if (angular.isUndefined(ngModel.$viewValue) || ngModel.$viewValue === null) {
                            $select.selected = [];
                        } else {
                            throw uiSelectMinErr("multiarr", "Expected model value to be array but got '{0}'", ngModel.$viewValue);
                        }
                    }
                    $select.selected = ngModel.$viewValue;
                    scope.$evalAsync();
                };
                scope.$on("uis:select", function(event, item) {
                    $select.selected.push(item);
                    $selectMultiple.updateModel();
                });
                scope.$on("uis:activate", function() {
                    $selectMultiple.activeMatchIndex = -1;
                });
                scope.$watch("$select.disabled", function(newValue, oldValue) {
                    if (oldValue && !newValue) $select.sizeSearchInput();
                });
                $select.searchInput.on("keydown", function(e) {
                    var key = e.which;
                    scope.$apply(function() {
                        var processed = false;
                        if (KEY.isHorizontalMovement(key)) {
                            processed = _handleMatchSelection(key);
                        }
                        if (processed && key != KEY.TAB) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    });
                });
                function _getCaretPosition(el) {
                    if (angular.isNumber(el.selectionStart)) return el.selectionStart; else return el.value.length;
                }
                function _handleMatchSelection(key) {
                    var caretPosition = _getCaretPosition($select.searchInput[0]), length = $select.selected.length, first = 0, last = length - 1, curr = $selectMultiple.activeMatchIndex, next = $selectMultiple.activeMatchIndex + 1, prev = $selectMultiple.activeMatchIndex - 1, newIndex = curr;
                    if (caretPosition > 0 || $select.search.length && key == KEY.RIGHT) return false;
                    $select.close();
                    function getNewActiveMatchIndex() {
                        switch (key) {
                          case KEY.LEFT:
                            if (~$selectMultiple.activeMatchIndex) return prev; else return last;
                            break;

                          case KEY.RIGHT:
                            if (!~$selectMultiple.activeMatchIndex || curr === last) {
                                $select.activate();
                                return false;
                            } else return next;
                            break;

                          case KEY.BACKSPACE:
                            if (~$selectMultiple.activeMatchIndex) {
                                $selectMultiple.removeChoice(curr);
                                return prev;
                            } else return last;
                            break;

                          case KEY.DELETE:
                            if (~$selectMultiple.activeMatchIndex) {
                                $selectMultiple.removeChoice($selectMultiple.activeMatchIndex);
                                return curr;
                            } else return false;
                        }
                    }
                    newIndex = getNewActiveMatchIndex();
                    if (!$select.selected.length || newIndex === false) $selectMultiple.activeMatchIndex = -1; else $selectMultiple.activeMatchIndex = Math.min(last, Math.max(first, newIndex));
                    return true;
                }
                $select.searchInput.on("keyup", function(e) {
                    if (!KEY.isVerticalMovement(e.which)) {
                        scope.$evalAsync(function() {
                            $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
                        });
                    }
                    if ($select.tagging.isActivated && $select.search.length > 0) {
                        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || KEY.isVerticalMovement(e.which)) {
                            return;
                        }
                        $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
                        if ($select.taggingLabel === false) return;
                        var items = angular.copy($select.items);
                        var stashArr = angular.copy($select.items);
                        var newItem;
                        var item;
                        var hasTag = false;
                        var dupeIndex = -1;
                        var tagItems;
                        var tagItem;
                        if ($select.tagging.fct !== undefined) {
                            tagItems = $select.$filter("filter")(items, {
                                isTag: true
                            });
                            if (tagItems.length > 0) {
                                tagItem = tagItems[0];
                            }
                            if (items.length > 0 && tagItem) {
                                hasTag = true;
                                items = items.slice(1, items.length);
                                stashArr = stashArr.slice(1, stashArr.length);
                            }
                            newItem = $select.tagging.fct($select.search);
                            newItem.isTag = true;
                            if (stashArr.filter(function(origItem) {
                                return angular.equals(origItem, $select.tagging.fct($select.search));
                            }).length > 0) {
                                return;
                            }
                            newItem.isTag = true;
                        } else {
                            tagItems = $select.$filter("filter")(items, function(item) {
                                return item.match($select.taggingLabel);
                            });
                            if (tagItems.length > 0) {
                                tagItem = tagItems[0];
                            }
                            item = items[0];
                            if (item !== undefined && items.length > 0 && tagItem) {
                                hasTag = true;
                                items = items.slice(1, items.length);
                                stashArr = stashArr.slice(1, stashArr.length);
                            }
                            newItem = $select.search + " " + $select.taggingLabel;
                            if (_findApproxDupe($select.selected, $select.search) > -1) {
                                return;
                            }
                            if (_findCaseInsensitiveDupe(stashArr.concat($select.selected))) {
                                if (hasTag) {
                                    items = stashArr;
                                    scope.$evalAsync(function() {
                                        $select.activeIndex = 0;
                                        $select.items = items;
                                    });
                                }
                                return;
                            }
                            if (_findCaseInsensitiveDupe(stashArr)) {
                                if (hasTag) {
                                    $select.items = stashArr.slice(1, stashArr.length);
                                }
                                return;
                            }
                        }
                        if (hasTag) dupeIndex = _findApproxDupe($select.selected, newItem);
                        if (dupeIndex > -1) {
                            items = items.slice(dupeIndex + 1, items.length - 1);
                        } else {
                            items = [];
                            items.push(newItem);
                            items = items.concat(stashArr);
                        }
                        scope.$evalAsync(function() {
                            $select.activeIndex = 0;
                            $select.items = items;
                        });
                    }
                });
                function _findCaseInsensitiveDupe(arr) {
                    if (arr === undefined || $select.search === undefined) {
                        return false;
                    }
                    var hasDupe = arr.filter(function(origItem) {
                        if ($select.search.toUpperCase() === undefined || origItem === undefined) {
                            return false;
                        }
                        return origItem.toUpperCase() === $select.search.toUpperCase();
                    }).length > 0;
                    return hasDupe;
                }
                function _findApproxDupe(haystack, needle) {
                    var dupeIndex = -1;
                    if (angular.isArray(haystack)) {
                        var tempArr = angular.copy(haystack);
                        for (var i = 0; i < tempArr.length; i++) {
                            if ($select.tagging.fct === undefined) {
                                if (tempArr[i] + " " + $select.taggingLabel === needle) {
                                    dupeIndex = i;
                                }
                            } else {
                                var mockObj = tempArr[i];
                                mockObj.isTag = true;
                                if (angular.equals(mockObj, needle)) {
                                    dupeIndex = i;
                                }
                            }
                        }
                    }
                    return dupeIndex;
                }
                $select.searchInput.on("blur", function() {
                    $timeout(function() {
                        $selectMultiple.activeMatchIndex = -1;
                    });
                });
            }
        };
    } ]);
    uis.directive("uiSelectSingle", [ "$timeout", "$compile", function($timeout, $compile) {
        return {
            restrict: "EA",
            require: [ "^uiSelect", "^ngModel" ],
            link: function(scope, element, attrs, ctrls) {
                var $select = ctrls[0];
                var ngModel = ctrls[1];
                ngModel.$parsers.unshift(function(inputValue) {
                    var locals = {}, result;
                    locals[$select.parserResult.itemName] = inputValue;
                    result = $select.parserResult.modelMapper(scope, locals);
                    return result;
                });
                ngModel.$formatters.unshift(function(inputValue) {
                    var data = $select.parserResult.source(scope, {
                        $select: {
                            search: ""
                        }
                    }), locals = {}, result;
                    if (data) {
                        var checkFnSingle = function(d) {
                            locals[$select.parserResult.itemName] = d;
                            result = $select.parserResult.modelMapper(scope, locals);
                            return result == inputValue;
                        };
                        if ($select.selected && checkFnSingle($select.selected)) {
                            return $select.selected;
                        }
                        for (var i = data.length - 1; i >= 0; i--) {
                            if (checkFnSingle(data[i])) return data[i];
                        }
                    }
                    return inputValue;
                });
                scope.$watch("$select.selected", function(newValue) {
                    if (ngModel.$viewValue !== newValue) {
                        ngModel.$setViewValue(newValue);
                    }
                });
                ngModel.$render = function() {
                    $select.selected = ngModel.$viewValue;
                };
                scope.$on("uis:select", function(event, item) {
                    $select.selected = item;
                });
                scope.$on("uis:close", function(event, skipFocusser) {
                    $timeout(function() {
                        $select.focusser.prop("disabled", false);
                        if (!skipFocusser) $select.focusser[0].focus();
                    }, 0, false);
                });
                scope.$on("uis:activate", function() {
                    focusser.prop("disabled", true);
                });
                var focusser = angular.element("<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' id='{{ $select.focusserId }}' aria-label='{{ $select.focusserTitle }}' aria-haspopup='true' role='button' />");
                $compile(focusser)(scope);
                $select.focusser = focusser;
                $select.focusInput = focusser;
                element.parent().append(focusser);
                focusser.bind("focus", function() {
                    scope.$evalAsync(function() {
                        $select.focus = true;
                    });
                });
                focusser.bind("blur", function() {
                    scope.$evalAsync(function() {
                        $select.focus = false;
                    });
                });
                focusser.bind("keydown", function(e) {
                    if (e.which === KEY.BACKSPACE) {
                        e.preventDefault();
                        e.stopPropagation();
                        $select.select(undefined);
                        scope.$apply();
                        return;
                    }
                    if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                        return;
                    }
                    if (e.which == KEY.DOWN || e.which == KEY.UP || e.which == KEY.ENTER || e.which == KEY.SPACE) {
                        e.preventDefault();
                        e.stopPropagation();
                        $select.activate();
                    }
                    scope.$digest();
                });
                focusser.bind("keyup input", function(e) {
                    if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || e.which == KEY.ENTER || e.which === KEY.BACKSPACE) {
                        return;
                    }
                    $select.activate(focusser.val());
                    focusser.val("");
                    scope.$digest();
                });
            }
        };
    } ]);
    uis.directive("uiSelectSort", [ "$timeout", "uiSelectConfig", "uiSelectMinErr", function($timeout, uiSelectConfig, uiSelectMinErr) {
        return {
            require: "^uiSelect",
            link: function(scope, element, attrs, $select) {
                if (scope[attrs.uiSelectSort] === null) {
                    throw uiSelectMinErr("sort", "Expected a list to sort");
                }
                var options = angular.extend({
                    axis: "horizontal"
                }, scope.$eval(attrs.uiSelectSortOptions));
                var axis = options.axis, draggingClassName = "dragging", droppingClassName = "dropping", droppingBeforeClassName = "dropping-before", droppingAfterClassName = "dropping-after";
                scope.$watch(function() {
                    return $select.sortable;
                }, function(n) {
                    if (n) {
                        element.attr("draggable", true);
                    } else {
                        element.removeAttr("draggable");
                    }
                });
                element.on("dragstart", function(e) {
                    element.addClass(draggingClassName);
                    (e.dataTransfer || e.originalEvent.dataTransfer).setData("text/plain", scope.$index);
                });
                element.on("dragend", function() {
                    element.removeClass(draggingClassName);
                });
                var move = function(from, to) {
                    this.splice(to, 0, this.splice(from, 1)[0]);
                };
                var dragOverHandler = function(e) {
                    e.preventDefault();
                    var offset = axis === "vertical" ? e.offsetY || e.layerY || (e.originalEvent ? e.originalEvent.offsetY : 0) : e.offsetX || e.layerX || (e.originalEvent ? e.originalEvent.offsetX : 0);
                    if (offset < this[axis === "vertical" ? "offsetHeight" : "offsetWidth"] / 2) {
                        element.removeClass(droppingAfterClassName);
                        element.addClass(droppingBeforeClassName);
                    } else {
                        element.removeClass(droppingBeforeClassName);
                        element.addClass(droppingAfterClassName);
                    }
                };
                var dropTimeout;
                var dropHandler = function(e) {
                    e.preventDefault();
                    var droppedItemIndex = parseInt((e.dataTransfer || e.originalEvent.dataTransfer).getData("text/plain"), 10);
                    $timeout.cancel(dropTimeout);
                    dropTimeout = $timeout(function() {
                        _dropHandler(droppedItemIndex);
                    }, 20);
                };
                var _dropHandler = function(droppedItemIndex) {
                    var theList = scope.$eval(attrs.uiSelectSort), itemToMove = theList[droppedItemIndex], newIndex = null;
                    if (element.hasClass(droppingBeforeClassName)) {
                        if (droppedItemIndex < scope.$index) {
                            newIndex = scope.$index - 1;
                        } else {
                            newIndex = scope.$index;
                        }
                    } else {
                        if (droppedItemIndex < scope.$index) {
                            newIndex = scope.$index;
                        } else {
                            newIndex = scope.$index + 1;
                        }
                    }
                    move.apply(theList, [ droppedItemIndex, newIndex ]);
                    scope.$apply(function() {
                        scope.$emit("uiSelectSort:change", {
                            array: theList,
                            item: itemToMove,
                            from: droppedItemIndex,
                            to: newIndex
                        });
                    });
                    element.removeClass(droppingClassName);
                    element.removeClass(droppingBeforeClassName);
                    element.removeClass(droppingAfterClassName);
                    element.off("drop", dropHandler);
                };
                element.on("dragenter", function() {
                    if (element.hasClass(draggingClassName)) {
                        return;
                    }
                    element.addClass(droppingClassName);
                    element.on("dragover", dragOverHandler);
                    element.on("drop", dropHandler);
                });
                element.on("dragleave", function(e) {
                    if (e.target != element) {
                        return;
                    }
                    element.removeClass(droppingClassName);
                    element.removeClass(droppingBeforeClassName);
                    element.removeClass(droppingAfterClassName);
                    element.off("dragover", dragOverHandler);
                    element.off("drop", dropHandler);
                });
            }
        };
    } ]);
    uis.service("uisRepeatParser", [ "uiSelectMinErr", "$parse", function(uiSelectMinErr, $parse) {
        var self = this;
        self.parse = function(expression) {
            var match = expression.match(/^\s*(?:([\s\S]+?)\s+as\s+)?([\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
                throw uiSelectMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            return {
                itemName: match[2],
                source: $parse(match[3]),
                trackByExp: match[4],
                modelMapper: $parse(match[1] || match[2])
            };
        };
        self.getGroupNgRepeatExpression = function() {
            return "$group in $select.groups";
        };
        self.getNgRepeatExpression = function(itemName, source, trackByExp, grouped) {
            var expression = itemName + " in " + (grouped ? "$group.items" : source);
            if (trackByExp) {
                expression += " track by " + trackByExp;
            }
            return expression;
        };
    } ]);
})();

angular.module("ui.select").run([ "$templateCache", function($templateCache) {
    $templateCache.put("bootstrap/choices.tpl.html", '<ul class="ui-select-choices ui-select-choices-content dropdown-menu" role="listbox" ng-show="$select.items.length > 0"><li class="ui-select-choices-group" id="ui-select-choices-{{ $select.generatedId }}"><div class="divider" ng-show="$select.isGrouped && $index > 0"></div><div ng-show="$select.isGrouped" class="ui-select-choices-group-label dropdown-header" ng-bind="$group.name"></div><div id="ui-select-choices-row-{{ $select.generatedId }}-{{$index}}" class="ui-select-choices-row" ng-class="{active: $select.isActive(this), disabled: $select.isDisabled(this)}" role="option"><a href="javascript:void(0)" class="ui-select-choices-row-inner"></a></div></li></ul>');
    $templateCache.put("bootstrap/match-multiple.tpl.html", '<span class="ui-select-match"><span ng-repeat="$item in $select.selected"><span class="ui-select-match-item btn btn-default btn-xs" tabindex="-1" type="button" ng-disabled="$select.disabled" ng-click="$selectMultiple.activeMatchIndex = $index;" ng-class="{\'btn-primary\':$selectMultiple.activeMatchIndex === $index, \'select-locked\':$select.isLocked(this, $index)}" ui-select-sort="$select.selected"><span class="close ui-select-match-close" ng-hide="$select.disabled" ng-click="$selectMultiple.removeChoice($index)">&nbsp;&times;</span> <span uis-transclude-append=""></span></span></span></span>');
    $templateCache.put("bootstrap/match.tpl.html", '<div class="ui-select-match" ng-hide="$select.open" ng-disabled="$select.disabled" ng-class="{\'btn-default-focus\':$select.focus}"><span tabindex="-1" class="btn btn-default form-control ui-select-toggle" aria-label="{{ $select.baseTitle }} activate" ng-disabled="$select.disabled" ng-click="$select.activate()" style="outline: 0;"><span ng-show="$select.isEmpty()" class="ui-select-placeholder text-muted">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty()" class="ui-select-match-text pull-left" ng-class="{\'ui-select-allow-clear\': $select.allowClear && !$select.isEmpty()}" ng-transclude=""></span> <i class="caret pull-right" ng-click="$select.toggle($event)"></i> <a ng-show="$select.allowClear && !$select.isEmpty()" aria-label="{{ $select.baseTitle }} clear" style="margin-right: 10px" ng-click="$select.clear($event)" class="btn btn-xs btn-link pull-right"><i class="glyphicon glyphicon-remove" aria-hidden="true"></i></a></span></div>');
    $templateCache.put("bootstrap/select-multiple.tpl.html", '<div class="ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control" ng-class="{open: $select.open}"><div><div class="ui-select-match"></div><input type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" class="ui-select-search input-xs" placeholder="{{$selectMultiple.getPlaceholder()}}" ng-disabled="$select.disabled" ng-hide="$select.disabled" ng-click="$select.activate()" ng-model="$select.search" role="combobox" aria-label="{{ $select.baseTitle }}" ondrop="return false;"></div><div class="ui-select-choices"></div></div>');
    $templateCache.put("bootstrap/select.tpl.html", '<div class="ui-select-container ui-select-bootstrap dropdown" ng-class="{open: $select.open}"><div class="ui-select-match"></div><input type="text" autocomplete="off" tabindex="-1" aria-expanded="true" aria-label="{{ $select.baseTitle }}" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-activedescendant="ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}" class="form-control ui-select-search" placeholder="{{$select.placeholder}}" ng-model="$select.search" ng-show="$select.searchEnabled && $select.open"><div class="ui-select-choices"></div></div>');
    $templateCache.put("select2/choices.tpl.html", '<ul class="ui-select-choices ui-select-choices-content select2-results"><li class="ui-select-choices-group" ng-class="{\'select2-result-with-children\': $select.choiceGrouped($group) }"><div ng-show="$select.choiceGrouped($group)" class="ui-select-choices-group-label select2-result-label" ng-bind="$group.name"></div><ul role="listbox" id="ui-select-choices-{{ $select.generatedId }}" ng-class="{\'select2-result-sub\': $select.choiceGrouped($group), \'select2-result-single\': !$select.choiceGrouped($group) }"><li role="option" id="ui-select-choices-row-{{ $select.generatedId }}-{{$index}}" class="ui-select-choices-row" ng-class="{\'select2-highlighted\': $select.isActive(this), \'select2-disabled\': $select.isDisabled(this)}"><div class="select2-result-label ui-select-choices-row-inner"></div></li></ul></li></ul>');
    $templateCache.put("select2/match-multiple.tpl.html", '<span class="ui-select-match"><li class="ui-select-match-item select2-search-choice" ng-repeat="$item in $select.selected" ng-class="{\'select2-search-choice-focus\':$selectMultiple.activeMatchIndex === $index, \'select2-locked\':$select.isLocked(this, $index)}" ui-select-sort="$select.selected"><span uis-transclude-append=""></span> <a href="javascript:;" class="ui-select-match-close select2-search-choice-close" ng-click="$selectMultiple.removeChoice($index)" tabindex="-1"></a></li></span>');
    $templateCache.put("select2/match.tpl.html", '<a class="select2-choice ui-select-match" ng-class="{\'select2-default\': $select.isEmpty()}" ng-click="$select.toggle($event)" aria-label="{{ $select.baseTitle }} select"><span ng-show="$select.isEmpty()" class="select2-chosen">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty()" class="select2-chosen" ng-transclude=""></span> <abbr ng-if="$select.allowClear && !$select.isEmpty()" class="select2-search-choice-close" ng-click="$select.clear($event)"></abbr> <span class="select2-arrow ui-select-toggle"><b></b></span></a>');
    $templateCache.put("select2/select-multiple.tpl.html", '<div class="ui-select-container ui-select-multiple select2 select2-container select2-container-multi" ng-class="{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled}"><ul class="select2-choices"><span class="ui-select-match"></span><li class="select2-search-field"><input type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="combobox" aria-expanded="true" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-label="{{ $select.baseTitle }}" aria-activedescendant="ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}" class="select2-input ui-select-search" placeholder="{{$selectMultiple.getPlaceholder()}}" ng-disabled="$select.disabled" ng-hide="$select.disabled" ng-model="$select.search" ng-click="$select.activate()" style="width: 34px;" ondrop="return false;"></li></ul><div class="select2-drop select2-with-searchbox select2-drop-active" ng-class="{\'select2-display-none\': !$select.open}"><div class="ui-select-choices"></div></div></div>');
    $templateCache.put("select2/select.tpl.html", '<div class="ui-select-container select2 select2-container" ng-class="{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled, \'select2-container-active\': $select.focus, \'select2-allowclear\': $select.allowClear && !$select.isEmpty()}"><div class="ui-select-match"></div><div class="select2-drop select2-with-searchbox select2-drop-active" ng-class="{\'select2-display-none\': !$select.open}"><div class="select2-search" ng-show="$select.searchEnabled"><input type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="combobox" aria-expanded="true" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-label="{{ $select.baseTitle }}" aria-activedescendant="ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}" class="ui-select-search select2-input" ng-model="$select.search"></div><div class="ui-select-choices"></div></div></div>');
    $templateCache.put("selectize/choices.tpl.html", '<div ng-show="$select.open" class="ui-select-choices selectize-dropdown single"><div class="ui-select-choices-content selectize-dropdown-content"><div class="ui-select-choices-group optgroup" role="listbox"><div ng-show="$select.isGrouped" class="ui-select-choices-group-label optgroup-header" ng-bind="$group.name"></div><div role="option" class="ui-select-choices-row" ng-class="{active: $select.isActive(this), disabled: $select.isDisabled(this)}"><div class="option ui-select-choices-row-inner" data-selectable=""></div></div></div></div></div>');
    $templateCache.put("selectize/match.tpl.html", '<div ng-hide="($select.open || $select.isEmpty())" class="ui-select-match" ng-transclude=""></div>');
    $templateCache.put("selectize/select.tpl.html", '<div class="ui-select-container selectize-control single" ng-class="{\'open\': $select.open}"><div class="selectize-input" ng-class="{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}" ng-click="$select.activate()"><div class="ui-select-match"></div><input type="text" autocomplete="off" tabindex="-1" class="ui-select-search ui-select-toggle" ng-click="$select.toggle($event)" placeholder="{{$select.placeholder}}" ng-model="$select.search" ng-hide="!$select.searchEnabled || ($select.selected && !$select.open)" ng-disabled="$select.disabled" aria-label="{{ $select.baseTitle }}"></div><div class="ui-select-choices"></div></div>');
} ]);

"use strict";

function _typeof(obj) {
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}

var windowIsDefined = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object";

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports) {
        var jQuery;
        try {
            jQuery = require("jquery");
        } catch (err) {
            jQuery = null;
        }
        module.exports = factory(jQuery);
    } else if (window) {
        window.Slider = factory(window.jQuery);
    }
})(function($) {
    var NAMESPACE_MAIN = "slider";
    var NAMESPACE_ALTERNATE = "bootstrapSlider";
    if (windowIsDefined && !window.console) {
        window.console = {};
    }
    if (windowIsDefined && !window.console.log) {
        window.console.log = function() {};
    }
    if (windowIsDefined && !window.console.warn) {
        window.console.warn = function() {};
    }
    var Slider;
    (function($) {
        "use strict";
        var slice = Array.prototype.slice;
        function noop() {}
        function defineBridget($) {
            if (!$) {
                return;
            }
            function addOptionMethod(PluginClass) {
                if (PluginClass.prototype.option) {
                    return;
                }
                PluginClass.prototype.option = function(opts) {
                    if (!$.isPlainObject(opts)) {
                        return;
                    }
                    this.options = $.extend(true, this.options, opts);
                };
            }
            var logError = typeof console === "undefined" ? noop : function(message) {
                console.error(message);
            };
            function bridge(namespace, PluginClass) {
                $.fn[namespace] = function(options) {
                    if (typeof options === "string") {
                        var args = slice.call(arguments, 1);
                        for (var i = 0, len = this.length; i < len; i++) {
                            var elem = this[i];
                            var instance = $.data(elem, namespace);
                            if (!instance) {
                                logError("cannot call methods on " + namespace + " prior to initialization; " + "attempted to call '" + options + "'");
                                continue;
                            }
                            if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                                logError("no such method '" + options + "' for " + namespace + " instance");
                                continue;
                            }
                            var returnValue = instance[options].apply(instance, args);
                            if (returnValue !== undefined && returnValue !== instance) {
                                return returnValue;
                            }
                        }
                        return this;
                    } else {
                        var objects = this.map(function() {
                            var instance = $.data(this, namespace);
                            if (instance) {
                                instance.option(options);
                                instance._init();
                            } else {
                                instance = new PluginClass(this, options);
                                $.data(this, namespace, instance);
                            }
                            return $(this);
                        });
                        if (!objects || objects.length > 1) {
                            return objects;
                        } else {
                            return objects[0];
                        }
                    }
                };
            }
            $.bridget = function(namespace, PluginClass) {
                addOptionMethod(PluginClass);
                bridge(namespace, PluginClass);
            };
            return $.bridget;
        }
        defineBridget($);
    })($);
    (function($) {
        var ErrorMsgs = {
            formatInvalidInputErrorMsg: function formatInvalidInputErrorMsg(input) {
                return "Invalid input value '" + input + "' passed in";
            },
            callingContextNotSliderInstance: "Calling context element does not have instance of Slider bound to it. Check your code to make sure the JQuery object returned from the call to the slider() initializer is calling the method"
        };
        var SliderScale = {
            linear: {
                toValue: function toValue(percentage) {
                    var rawValue = percentage / 100 * (this.options.max - this.options.min);
                    var shouldAdjustWithBase = true;
                    if (this.options.ticks_positions.length > 0) {
                        var minv, maxv, minp, maxp = 0;
                        for (var i = 1; i < this.options.ticks_positions.length; i++) {
                            if (percentage <= this.options.ticks_positions[i]) {
                                minv = this.options.ticks[i - 1];
                                minp = this.options.ticks_positions[i - 1];
                                maxv = this.options.ticks[i];
                                maxp = this.options.ticks_positions[i];
                                break;
                            }
                        }
                        var partialPercentage = (percentage - minp) / (maxp - minp);
                        rawValue = minv + partialPercentage * (maxv - minv);
                        shouldAdjustWithBase = false;
                    }
                    var adjustment = shouldAdjustWithBase ? this.options.min : 0;
                    var value = adjustment + Math.round(rawValue / this.options.step) * this.options.step;
                    if (value < this.options.min) {
                        return this.options.min;
                    } else if (value > this.options.max) {
                        return this.options.max;
                    } else {
                        return value;
                    }
                },
                toPercentage: function toPercentage(value) {
                    if (this.options.max === this.options.min) {
                        return 0;
                    }
                    if (this.options.ticks_positions.length > 0) {
                        var minv, maxv, minp, maxp = 0;
                        for (var i = 0; i < this.options.ticks.length; i++) {
                            if (value <= this.options.ticks[i]) {
                                minv = i > 0 ? this.options.ticks[i - 1] : 0;
                                minp = i > 0 ? this.options.ticks_positions[i - 1] : 0;
                                maxv = this.options.ticks[i];
                                maxp = this.options.ticks_positions[i];
                                break;
                            }
                        }
                        if (i > 0) {
                            var partialPercentage = (value - minv) / (maxv - minv);
                            return minp + partialPercentage * (maxp - minp);
                        }
                    }
                    return 100 * (value - this.options.min) / (this.options.max - this.options.min);
                }
            },
            logarithmic: {
                toValue: function toValue(percentage) {
                    var min = this.options.min === 0 ? 0 : Math.log(this.options.min);
                    var max = Math.log(this.options.max);
                    var value = Math.exp(min + (max - min) * percentage / 100);
                    value = this.options.min + Math.round((value - this.options.min) / this.options.step) * this.options.step;
                    if (value < this.options.min) {
                        return this.options.min;
                    } else if (value > this.options.max) {
                        return this.options.max;
                    } else {
                        return value;
                    }
                },
                toPercentage: function toPercentage(value) {
                    if (this.options.max === this.options.min) {
                        return 0;
                    } else {
                        var max = Math.log(this.options.max);
                        var min = this.options.min === 0 ? 0 : Math.log(this.options.min);
                        var v = value === 0 ? 0 : Math.log(value);
                        return 100 * (v - min) / (max - min);
                    }
                }
            }
        };
        Slider = function(element, options) {
            createNewSlider.call(this, element, options);
            return this;
        };
        function createNewSlider(element, options) {
            this._state = {
                value: null,
                enabled: null,
                offset: null,
                size: null,
                percentage: null,
                inDrag: false,
                over: false
            };
            if (typeof element === "string") {
                this.element = document.querySelector(element);
            } else if (element instanceof HTMLElement) {
                this.element = element;
            }
            options = options ? options : {};
            var optionTypes = Object.keys(this.defaultOptions);
            for (var i = 0; i < optionTypes.length; i++) {
                var optName = optionTypes[i];
                var val = options[optName];
                val = typeof val !== "undefined" ? val : getDataAttrib(this.element, optName);
                val = val !== null ? val : this.defaultOptions[optName];
                if (!this.options) {
                    this.options = {};
                }
                this.options[optName] = val;
            }
            if (this.options.orientation === "vertical" && (this.options.tooltip_position === "top" || this.options.tooltip_position === "bottom")) {
                this.options.tooltip_position = "right";
            } else if (this.options.orientation === "horizontal" && (this.options.tooltip_position === "left" || this.options.tooltip_position === "right")) {
                this.options.tooltip_position = "top";
            }
            function getDataAttrib(element, optName) {
                var dataName = "data-slider-" + optName.replace(/_/g, "-");
                var dataValString = element.getAttribute(dataName);
                try {
                    return JSON.parse(dataValString);
                } catch (err) {
                    return dataValString;
                }
            }
            var origWidth = this.element.style.width;
            var updateSlider = false;
            var parent = this.element.parentNode;
            var sliderTrackSelection;
            var sliderTrackLow, sliderTrackHigh;
            var sliderMinHandle;
            var sliderMaxHandle;
            if (this.sliderElem) {
                updateSlider = true;
            } else {
                this.sliderElem = document.createElement("div");
                this.sliderElem.className = "slider";
                var sliderTrack = document.createElement("div");
                sliderTrack.className = "slider-track";
                sliderTrackLow = document.createElement("div");
                sliderTrackLow.className = "slider-track-low";
                sliderTrackSelection = document.createElement("div");
                sliderTrackSelection.className = "slider-selection";
                sliderTrackHigh = document.createElement("div");
                sliderTrackHigh.className = "slider-track-high";
                sliderMinHandle = document.createElement("div");
                sliderMinHandle.className = "slider-handle min-slider-handle";
                sliderMinHandle.setAttribute("role", "slider");
                sliderMinHandle.setAttribute("aria-valuemin", this.options.min);
                sliderMinHandle.setAttribute("aria-valuemax", this.options.max);
                sliderMaxHandle = document.createElement("div");
                sliderMaxHandle.className = "slider-handle max-slider-handle";
                sliderMaxHandle.setAttribute("role", "slider");
                sliderMaxHandle.setAttribute("aria-valuemin", this.options.min);
                sliderMaxHandle.setAttribute("aria-valuemax", this.options.max);
                sliderTrack.appendChild(sliderTrackLow);
                sliderTrack.appendChild(sliderTrackSelection);
                sliderTrack.appendChild(sliderTrackHigh);
                this.rangeHighlightElements = [];
                if (Array.isArray(this.options.rangeHighlights) && this.options.rangeHighlights.length > 0) {
                    for (var j = 0; j < this.options.rangeHighlights.length; j++) {
                        var rangeHighlightElement = document.createElement("div");
                        rangeHighlightElement.className = "slider-rangeHighlight slider-selection";
                        this.rangeHighlightElements.push(rangeHighlightElement);
                        sliderTrack.appendChild(rangeHighlightElement);
                    }
                }
                var isLabelledbyArray = Array.isArray(this.options.labelledby);
                if (isLabelledbyArray && this.options.labelledby[0]) {
                    sliderMinHandle.setAttribute("aria-labelledby", this.options.labelledby[0]);
                }
                if (isLabelledbyArray && this.options.labelledby[1]) {
                    sliderMaxHandle.setAttribute("aria-labelledby", this.options.labelledby[1]);
                }
                if (!isLabelledbyArray && this.options.labelledby) {
                    sliderMinHandle.setAttribute("aria-labelledby", this.options.labelledby);
                    sliderMaxHandle.setAttribute("aria-labelledby", this.options.labelledby);
                }
                this.ticks = [];
                if (Array.isArray(this.options.ticks) && this.options.ticks.length > 0) {
                    this.ticksContainer = document.createElement("div");
                    this.ticksContainer.className = "slider-tick-container";
                    for (i = 0; i < this.options.ticks.length; i++) {
                        var tick = document.createElement("div");
                        tick.className = "slider-tick";
                        this.ticks.push(tick);
                        this.ticksContainer.appendChild(tick);
                    }
                    sliderTrackSelection.className += " tick-slider-selection";
                }
                this.tickLabels = [];
                if (Array.isArray(this.options.ticks_labels) && this.options.ticks_labels.length > 0) {
                    this.tickLabelContainer = document.createElement("div");
                    this.tickLabelContainer.className = "slider-tick-label-container";
                    for (i = 0; i < this.options.ticks_labels.length; i++) {
                        var label = document.createElement("div");
                        var noTickPositionsSpecified = this.options.ticks_positions.length === 0;
                        var tickLabelsIndex = this.options.reversed && noTickPositionsSpecified ? this.options.ticks_labels.length - (i + 1) : i;
                        label.className = "slider-tick-label";
                        label.innerHTML = this.options.ticks_labels[tickLabelsIndex];
                        this.tickLabels.push(label);
                        this.tickLabelContainer.appendChild(label);
                    }
                }
                var createAndAppendTooltipSubElements = function createAndAppendTooltipSubElements(tooltipElem) {
                    var arrow = document.createElement("div");
                    arrow.className = "tooltip-arrow";
                    var inner = document.createElement("div");
                    inner.className = "tooltip-inner";
                    tooltipElem.appendChild(arrow);
                    tooltipElem.appendChild(inner);
                };
                var sliderTooltip = document.createElement("div");
                sliderTooltip.className = "tooltip tooltip-main";
                sliderTooltip.setAttribute("role", "presentation");
                createAndAppendTooltipSubElements(sliderTooltip);
                var sliderTooltipMin = document.createElement("div");
                sliderTooltipMin.className = "tooltip tooltip-min";
                sliderTooltipMin.setAttribute("role", "presentation");
                createAndAppendTooltipSubElements(sliderTooltipMin);
                var sliderTooltipMax = document.createElement("div");
                sliderTooltipMax.className = "tooltip tooltip-max";
                sliderTooltipMax.setAttribute("role", "presentation");
                createAndAppendTooltipSubElements(sliderTooltipMax);
                this.sliderElem.appendChild(sliderTrack);
                this.sliderElem.appendChild(sliderTooltip);
                this.sliderElem.appendChild(sliderTooltipMin);
                this.sliderElem.appendChild(sliderTooltipMax);
                if (this.tickLabelContainer) {
                    this.sliderElem.appendChild(this.tickLabelContainer);
                }
                if (this.ticksContainer) {
                    this.sliderElem.appendChild(this.ticksContainer);
                }
                this.sliderElem.appendChild(sliderMinHandle);
                this.sliderElem.appendChild(sliderMaxHandle);
                parent.insertBefore(this.sliderElem, this.element);
                this.element.style.display = "none";
            }
            if ($) {
                this.$element = $(this.element);
                this.$sliderElem = $(this.sliderElem);
            }
            this.eventToCallbackMap = {};
            this.sliderElem.id = this.options.id;
            this.touchCapable = "ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch;
            this.touchX = 0;
            this.touchY = 0;
            this.tooltip = this.sliderElem.querySelector(".tooltip-main");
            this.tooltipInner = this.tooltip.querySelector(".tooltip-inner");
            this.tooltip_min = this.sliderElem.querySelector(".tooltip-min");
            this.tooltipInner_min = this.tooltip_min.querySelector(".tooltip-inner");
            this.tooltip_max = this.sliderElem.querySelector(".tooltip-max");
            this.tooltipInner_max = this.tooltip_max.querySelector(".tooltip-inner");
            if (SliderScale[this.options.scale]) {
                this.options.scale = SliderScale[this.options.scale];
            }
            if (updateSlider === true) {
                this._removeClass(this.sliderElem, "slider-horizontal");
                this._removeClass(this.sliderElem, "slider-vertical");
                this._removeClass(this.tooltip, "hide");
                this._removeClass(this.tooltip_min, "hide");
                this._removeClass(this.tooltip_max, "hide");
                [ "left", "top", "width", "height" ].forEach(function(prop) {
                    this._removeProperty(this.trackLow, prop);
                    this._removeProperty(this.trackSelection, prop);
                    this._removeProperty(this.trackHigh, prop);
                }, this);
                [ this.handle1, this.handle2 ].forEach(function(handle) {
                    this._removeProperty(handle, "left");
                    this._removeProperty(handle, "top");
                }, this);
                [ this.tooltip, this.tooltip_min, this.tooltip_max ].forEach(function(tooltip) {
                    this._removeProperty(tooltip, "left");
                    this._removeProperty(tooltip, "top");
                    this._removeProperty(tooltip, "margin-left");
                    this._removeProperty(tooltip, "margin-top");
                    this._removeClass(tooltip, "right");
                    this._removeClass(tooltip, "top");
                }, this);
            }
            if (this.options.orientation === "vertical") {
                this._addClass(this.sliderElem, "slider-vertical");
                this.stylePos = "top";
                this.mousePos = "pageY";
                this.sizePos = "offsetHeight";
            } else {
                this._addClass(this.sliderElem, "slider-horizontal");
                this.sliderElem.style.width = origWidth;
                this.options.orientation = "horizontal";
                this.stylePos = "left";
                this.mousePos = "pageX";
                this.sizePos = "offsetWidth";
            }
            this._setTooltipPosition();
            if (Array.isArray(this.options.ticks) && this.options.ticks.length > 0) {
                this.options.max = Math.max.apply(Math, this.options.ticks);
                this.options.min = Math.min.apply(Math, this.options.ticks);
            }
            if (Array.isArray(this.options.value)) {
                this.options.range = true;
                this._state.value = this.options.value;
            } else if (this.options.range) {
                this._state.value = [ this.options.value, this.options.max ];
            } else {
                this._state.value = this.options.value;
            }
            this.trackLow = sliderTrackLow || this.trackLow;
            this.trackSelection = sliderTrackSelection || this.trackSelection;
            this.trackHigh = sliderTrackHigh || this.trackHigh;
            if (this.options.selection === "none") {
                this._addClass(this.trackLow, "hide");
                this._addClass(this.trackSelection, "hide");
                this._addClass(this.trackHigh, "hide");
            }
            this.handle1 = sliderMinHandle || this.handle1;
            this.handle2 = sliderMaxHandle || this.handle2;
            if (updateSlider === true) {
                this._removeClass(this.handle1, "round triangle");
                this._removeClass(this.handle2, "round triangle hide");
                for (i = 0; i < this.ticks.length; i++) {
                    this._removeClass(this.ticks[i], "round triangle hide");
                }
            }
            var availableHandleModifiers = [ "round", "triangle", "custom" ];
            var isValidHandleType = availableHandleModifiers.indexOf(this.options.handle) !== -1;
            if (isValidHandleType) {
                this._addClass(this.handle1, this.options.handle);
                this._addClass(this.handle2, this.options.handle);
                for (i = 0; i < this.ticks.length; i++) {
                    this._addClass(this.ticks[i], this.options.handle);
                }
            }
            this._state.offset = this._offset(this.sliderElem);
            this._state.size = this.sliderElem[this.sizePos];
            this.setValue(this._state.value);
            this.handle1Keydown = this._keydown.bind(this, 0);
            this.handle1.addEventListener("keydown", this.handle1Keydown, false);
            this.handle2Keydown = this._keydown.bind(this, 1);
            this.handle2.addEventListener("keydown", this.handle2Keydown, false);
            this.mousedown = this._mousedown.bind(this);
            this.touchstart = this._touchstart.bind(this);
            this.touchmove = this._touchmove.bind(this);
            if (this.touchCapable) {
                this.sliderElem.addEventListener("touchstart", this.touchstart, false);
                this.sliderElem.addEventListener("touchmove", this.touchmove, false);
            }
            this.sliderElem.addEventListener("mousedown", this.mousedown, false);
            this.resize = this._resize.bind(this);
            window.addEventListener("resize", this.resize, false);
            if (this.options.tooltip === "hide") {
                this._addClass(this.tooltip, "hide");
                this._addClass(this.tooltip_min, "hide");
                this._addClass(this.tooltip_max, "hide");
            } else if (this.options.tooltip === "always") {
                this._showTooltip();
                this._alwaysShowTooltip = true;
            } else {
                this.showTooltip = this._showTooltip.bind(this);
                this.hideTooltip = this._hideTooltip.bind(this);
                this.sliderElem.addEventListener("mouseenter", this.showTooltip, false);
                this.sliderElem.addEventListener("mouseleave", this.hideTooltip, false);
                this.handle1.addEventListener("focus", this.showTooltip, false);
                this.handle1.addEventListener("blur", this.hideTooltip, false);
                this.handle2.addEventListener("focus", this.showTooltip, false);
                this.handle2.addEventListener("blur", this.hideTooltip, false);
            }
            if (this.options.enabled) {
                this.enable();
            } else {
                this.disable();
            }
        }
        Slider.prototype = {
            _init: function _init() {},
            constructor: Slider,
            defaultOptions: {
                id: "",
                min: 0,
                max: 10,
                step: 1,
                precision: 0,
                orientation: "horizontal",
                value: 5,
                range: false,
                selection: "before",
                tooltip: "show",
                tooltip_split: false,
                handle: "round",
                reversed: false,
                enabled: true,
                formatter: function formatter(val) {
                    if (Array.isArray(val)) {
                        return val[0] + " : " + val[1];
                    } else {
                        return val;
                    }
                },
                natural_arrow_keys: false,
                ticks: [],
                ticks_positions: [],
                ticks_labels: [],
                ticks_snap_bounds: 0,
                scale: "linear",
                focus: false,
                tooltip_position: null,
                labelledby: null,
                rangeHighlights: []
            },
            getElement: function getElement() {
                return this.sliderElem;
            },
            getValue: function getValue() {
                if (this.options.range) {
                    return this._state.value;
                } else {
                    return this._state.value[0];
                }
            },
            setValue: function setValue(val, triggerSlideEvent, triggerChangeEvent) {
                if (!val) {
                    val = 0;
                }
                var oldValue = this.getValue();
                this._state.value = this._validateInputValue(val);
                var applyPrecision = this._applyPrecision.bind(this);
                if (this.options.range) {
                    this._state.value[0] = applyPrecision(this._state.value[0]);
                    this._state.value[1] = applyPrecision(this._state.value[1]);
                    this._state.value[0] = Math.max(this.options.min, Math.min(this.options.max, this._state.value[0]));
                    this._state.value[1] = Math.max(this.options.min, Math.min(this.options.max, this._state.value[1]));
                } else {
                    this._state.value = applyPrecision(this._state.value);
                    this._state.value = [ Math.max(this.options.min, Math.min(this.options.max, this._state.value)) ];
                    this._addClass(this.handle2, "hide");
                    if (this.options.selection === "after") {
                        this._state.value[1] = this.options.max;
                    } else {
                        this._state.value[1] = this.options.min;
                    }
                }
                if (this.options.max > this.options.min) {
                    this._state.percentage = [ this._toPercentage(this._state.value[0]), this._toPercentage(this._state.value[1]), this.options.step * 100 / (this.options.max - this.options.min) ];
                } else {
                    this._state.percentage = [ 0, 0, 100 ];
                }
                this._layout();
                var newValue = this.options.range ? this._state.value : this._state.value[0];
                this._setDataVal(newValue);
                if (triggerSlideEvent === true) {
                    this._trigger("slide", newValue);
                }
                if (oldValue !== newValue && triggerChangeEvent === true) {
                    this._trigger("change", {
                        oldValue: oldValue,
                        newValue: newValue
                    });
                }
                return this;
            },
            destroy: function destroy() {
                this._removeSliderEventHandlers();
                this.sliderElem.parentNode.removeChild(this.sliderElem);
                this.element.style.display = "";
                this._cleanUpEventCallbacksMap();
                this.element.removeAttribute("data");
                if ($) {
                    this._unbindJQueryEventHandlers();
                    this.$element.removeData("slider");
                }
            },
            disable: function disable() {
                this._state.enabled = false;
                this.handle1.removeAttribute("tabindex");
                this.handle2.removeAttribute("tabindex");
                this._addClass(this.sliderElem, "slider-disabled");
                this._trigger("slideDisabled");
                return this;
            },
            enable: function enable() {
                this._state.enabled = true;
                this.handle1.setAttribute("tabindex", 0);
                this.handle2.setAttribute("tabindex", 0);
                this._removeClass(this.sliderElem, "slider-disabled");
                this._trigger("slideEnabled");
                return this;
            },
            toggle: function toggle() {
                if (this._state.enabled) {
                    this.disable();
                } else {
                    this.enable();
                }
                return this;
            },
            isEnabled: function isEnabled() {
                return this._state.enabled;
            },
            on: function on(evt, callback) {
                this._bindNonQueryEventHandler(evt, callback);
                return this;
            },
            off: function off(evt, callback) {
                if ($) {
                    this.$element.off(evt, callback);
                    this.$sliderElem.off(evt, callback);
                } else {
                    this._unbindNonQueryEventHandler(evt, callback);
                }
            },
            getAttribute: function getAttribute(attribute) {
                if (attribute) {
                    return this.options[attribute];
                } else {
                    return this.options;
                }
            },
            setAttribute: function setAttribute(attribute, value) {
                this.options[attribute] = value;
                return this;
            },
            refresh: function refresh() {
                this._removeSliderEventHandlers();
                createNewSlider.call(this, this.element, this.options);
                if ($) {
                    $.data(this.element, "slider", this);
                }
                return this;
            },
            relayout: function relayout() {
                this._resize();
                this._layout();
                return this;
            },
            _removeSliderEventHandlers: function _removeSliderEventHandlers() {
                this.handle1.removeEventListener("keydown", this.handle1Keydown, false);
                this.handle2.removeEventListener("keydown", this.handle2Keydown, false);
                if (this.showTooltip) {
                    this.handle1.removeEventListener("focus", this.showTooltip, false);
                    this.handle2.removeEventListener("focus", this.showTooltip, false);
                }
                if (this.hideTooltip) {
                    this.handle1.removeEventListener("blur", this.hideTooltip, false);
                    this.handle2.removeEventListener("blur", this.hideTooltip, false);
                }
                if (this.showTooltip) {
                    this.sliderElem.removeEventListener("mouseenter", this.showTooltip, false);
                }
                if (this.hideTooltip) {
                    this.sliderElem.removeEventListener("mouseleave", this.hideTooltip, false);
                }
                this.sliderElem.removeEventListener("touchstart", this.touchstart, false);
                this.sliderElem.removeEventListener("touchmove", this.touchmove, false);
                this.sliderElem.removeEventListener("mousedown", this.mousedown, false);
                window.removeEventListener("resize", this.resize, false);
            },
            _bindNonQueryEventHandler: function _bindNonQueryEventHandler(evt, callback) {
                if (this.eventToCallbackMap[evt] === undefined) {
                    this.eventToCallbackMap[evt] = [];
                }
                this.eventToCallbackMap[evt].push(callback);
            },
            _unbindNonQueryEventHandler: function _unbindNonQueryEventHandler(evt, callback) {
                var callbacks = this.eventToCallbackMap[evt];
                if (callbacks !== undefined) {
                    for (var i = 0; i < callbacks.length; i++) {
                        if (callbacks[i] === callback) {
                            callbacks.splice(i, 1);
                            break;
                        }
                    }
                }
            },
            _cleanUpEventCallbacksMap: function _cleanUpEventCallbacksMap() {
                var eventNames = Object.keys(this.eventToCallbackMap);
                for (var i = 0; i < eventNames.length; i++) {
                    var eventName = eventNames[i];
                    this.eventToCallbackMap[eventName] = null;
                }
            },
            _showTooltip: function _showTooltip() {
                if (this.options.tooltip_split === false) {
                    this._addClass(this.tooltip, "in");
                    this.tooltip_min.style.display = "none";
                    this.tooltip_max.style.display = "none";
                } else {
                    this._addClass(this.tooltip_min, "in");
                    this._addClass(this.tooltip_max, "in");
                    this.tooltip.style.display = "none";
                }
                this._state.over = true;
            },
            _hideTooltip: function _hideTooltip() {
                if (this._state.inDrag === false && this.alwaysShowTooltip !== true) {
                    this._removeClass(this.tooltip, "in");
                    this._removeClass(this.tooltip_min, "in");
                    this._removeClass(this.tooltip_max, "in");
                }
                this._state.over = false;
            },
            _layout: function _layout() {
                var positionPercentages;
                if (this.options.reversed) {
                    positionPercentages = [ 100 - this._state.percentage[0], this.options.range ? 100 - this._state.percentage[1] : this._state.percentage[1] ];
                } else {
                    positionPercentages = [ this._state.percentage[0], this._state.percentage[1] ];
                }
                this.handle1.style[this.stylePos] = positionPercentages[0] + "%";
                this.handle1.setAttribute("aria-valuenow", this._state.value[0]);
                this.handle2.style[this.stylePos] = positionPercentages[1] + "%";
                this.handle2.setAttribute("aria-valuenow", this._state.value[1]);
                if (this.rangeHighlightElements.length > 0 && Array.isArray(this.options.rangeHighlights) && this.options.rangeHighlights.length > 0) {
                    for (var _i = 0; _i < this.options.rangeHighlights.length; _i++) {
                        var startPercent = this._toPercentage(this.options.rangeHighlights[_i].start);
                        var endPercent = this._toPercentage(this.options.rangeHighlights[_i].end);
                        if (this.options.reversed) {
                            var sp = 100 - endPercent;
                            endPercent = 100 - startPercent;
                            startPercent = sp;
                        }
                        var currentRange = this._createHighlightRange(startPercent, endPercent);
                        if (currentRange) {
                            if (this.options.orientation === "vertical") {
                                this.rangeHighlightElements[_i].style.top = currentRange.start + "%";
                                this.rangeHighlightElements[_i].style.height = currentRange.size + "%";
                            } else {
                                this.rangeHighlightElements[_i].style.left = currentRange.start + "%";
                                this.rangeHighlightElements[_i].style.width = currentRange.size + "%";
                            }
                        } else {
                            this.rangeHighlightElements[_i].style.display = "none";
                        }
                    }
                }
                if (Array.isArray(this.options.ticks) && this.options.ticks.length > 0) {
                    var styleSize = this.options.orientation === "vertical" ? "height" : "width";
                    var styleMargin = this.options.orientation === "vertical" ? "marginTop" : "marginLeft";
                    var labelSize = this._state.size / (this.options.ticks.length - 1);
                    if (this.tickLabelContainer) {
                        var extraMargin = 0;
                        if (this.options.ticks_positions.length === 0) {
                            if (this.options.orientation !== "vertical") {
                                this.tickLabelContainer.style[styleMargin] = -labelSize / 2 + "px";
                            }
                            extraMargin = this.tickLabelContainer.offsetHeight;
                        } else {
                            for (i = 0; i < this.tickLabelContainer.childNodes.length; i++) {
                                if (this.tickLabelContainer.childNodes[i].offsetHeight > extraMargin) {
                                    extraMargin = this.tickLabelContainer.childNodes[i].offsetHeight;
                                }
                            }
                        }
                        if (this.options.orientation === "horizontal") {
                            this.sliderElem.style.marginBottom = extraMargin + "px";
                        }
                    }
                    for (var i = 0; i < this.options.ticks.length; i++) {
                        var percentage = this.options.ticks_positions[i] || this._toPercentage(this.options.ticks[i]);
                        if (this.options.reversed) {
                            percentage = 100 - percentage;
                        }
                        this.ticks[i].style[this.stylePos] = percentage + "%";
                        this._removeClass(this.ticks[i], "in-selection");
                        if (!this.options.range) {
                            if (this.options.selection === "after" && percentage >= positionPercentages[0]) {
                                this._addClass(this.ticks[i], "in-selection");
                            } else if (this.options.selection === "before" && percentage <= positionPercentages[0]) {
                                this._addClass(this.ticks[i], "in-selection");
                            }
                        } else if (percentage >= positionPercentages[0] && percentage <= positionPercentages[1]) {
                            this._addClass(this.ticks[i], "in-selection");
                        }
                        if (this.tickLabels[i]) {
                            this.tickLabels[i].style[styleSize] = labelSize + "px";
                            if (this.options.orientation !== "vertical" && this.options.ticks_positions[i] !== undefined) {
                                this.tickLabels[i].style.position = "absolute";
                                this.tickLabels[i].style[this.stylePos] = percentage + "%";
                                this.tickLabels[i].style[styleMargin] = -labelSize / 2 + "px";
                            } else if (this.options.orientation === "vertical") {
                                this.tickLabels[i].style["marginLeft"] = this.sliderElem.offsetWidth + "px";
                                this.tickLabelContainer.style["marginTop"] = this.sliderElem.offsetWidth / 2 * -1 + "px";
                            }
                        }
                    }
                }
                var formattedTooltipVal;
                if (this.options.range) {
                    formattedTooltipVal = this.options.formatter(this._state.value);
                    this._setText(this.tooltipInner, formattedTooltipVal);
                    this.tooltip.style[this.stylePos] = (positionPercentages[1] + positionPercentages[0]) / 2 + "%";
                    if (this.options.orientation === "vertical") {
                        this._css(this.tooltip, "margin-top", -this.tooltip.offsetHeight / 2 + "px");
                    } else {
                        this._css(this.tooltip, "margin-left", -this.tooltip.offsetWidth / 2 + "px");
                    }
                    if (this.options.orientation === "vertical") {
                        this._css(this.tooltip, "margin-top", -this.tooltip.offsetHeight / 2 + "px");
                    } else {
                        this._css(this.tooltip, "margin-left", -this.tooltip.offsetWidth / 2 + "px");
                    }
                    var innerTooltipMinText = this.options.formatter(this._state.value[0]);
                    this._setText(this.tooltipInner_min, innerTooltipMinText);
                    var innerTooltipMaxText = this.options.formatter(this._state.value[1]);
                    this._setText(this.tooltipInner_max, innerTooltipMaxText);
                    this.tooltip_min.style[this.stylePos] = positionPercentages[0] + "%";
                    if (this.options.orientation === "vertical") {
                        this._css(this.tooltip_min, "margin-top", -this.tooltip_min.offsetHeight / 2 + "px");
                    } else {
                        this._css(this.tooltip_min, "margin-left", -this.tooltip_min.offsetWidth / 2 + "px");
                    }
                    this.tooltip_max.style[this.stylePos] = positionPercentages[1] + "%";
                    if (this.options.orientation === "vertical") {
                        this._css(this.tooltip_max, "margin-top", -this.tooltip_max.offsetHeight / 2 + "px");
                    } else {
                        this._css(this.tooltip_max, "margin-left", -this.tooltip_max.offsetWidth / 2 + "px");
                    }
                } else {
                    formattedTooltipVal = this.options.formatter(this._state.value[0]);
                    this._setText(this.tooltipInner, formattedTooltipVal);
                    this.tooltip.style[this.stylePos] = positionPercentages[0] + "%";
                    if (this.options.orientation === "vertical") {
                        this._css(this.tooltip, "margin-top", -this.tooltip.offsetHeight / 2 + "px");
                    } else {
                        this._css(this.tooltip, "margin-left", -this.tooltip.offsetWidth / 2 + "px");
                    }
                }
                if (this.options.orientation === "vertical") {
                    this.trackLow.style.top = "0";
                    this.trackLow.style.height = Math.min(positionPercentages[0], positionPercentages[1]) + "%";
                    this.trackSelection.style.top = Math.min(positionPercentages[0], positionPercentages[1]) + "%";
                    this.trackSelection.style.height = Math.abs(positionPercentages[0] - positionPercentages[1]) + "%";
                    this.trackHigh.style.bottom = "0";
                    this.trackHigh.style.height = 100 - Math.min(positionPercentages[0], positionPercentages[1]) - Math.abs(positionPercentages[0] - positionPercentages[1]) + "%";
                } else {
                    this.trackLow.style.left = "0";
                    this.trackLow.style.width = Math.min(positionPercentages[0], positionPercentages[1]) + "%";
                    this.trackSelection.style.left = Math.min(positionPercentages[0], positionPercentages[1]) + "%";
                    this.trackSelection.style.width = Math.abs(positionPercentages[0] - positionPercentages[1]) + "%";
                    this.trackHigh.style.right = "0";
                    this.trackHigh.style.width = 100 - Math.min(positionPercentages[0], positionPercentages[1]) - Math.abs(positionPercentages[0] - positionPercentages[1]) + "%";
                    var offset_min = this.tooltip_min.getBoundingClientRect();
                    var offset_max = this.tooltip_max.getBoundingClientRect();
                    if (this.options.tooltip_position === "bottom") {
                        if (offset_min.right > offset_max.left) {
                            this._removeClass(this.tooltip_max, "bottom");
                            this._addClass(this.tooltip_max, "top");
                            this.tooltip_max.style.top = "";
                            this.tooltip_max.style.bottom = 22 + "px";
                        } else {
                            this._removeClass(this.tooltip_max, "top");
                            this._addClass(this.tooltip_max, "bottom");
                            this.tooltip_max.style.top = this.tooltip_min.style.top;
                            this.tooltip_max.style.bottom = "";
                        }
                    } else {
                        if (offset_min.right > offset_max.left) {
                            this._removeClass(this.tooltip_max, "top");
                            this._addClass(this.tooltip_max, "bottom");
                            this.tooltip_max.style.top = 18 + "px";
                        } else {
                            this._removeClass(this.tooltip_max, "bottom");
                            this._addClass(this.tooltip_max, "top");
                            this.tooltip_max.style.top = this.tooltip_min.style.top;
                        }
                    }
                }
            },
            _createHighlightRange: function _createHighlightRange(start, end) {
                if (this._isHighlightRange(start, end)) {
                    if (start > end) {
                        return {
                            start: end,
                            size: start - end
                        };
                    }
                    return {
                        start: start,
                        size: end - start
                    };
                }
                return null;
            },
            _isHighlightRange: function _isHighlightRange(start, end) {
                if (0 <= start && start <= 100 && 0 <= end && end <= 100) {
                    return true;
                } else {
                    return false;
                }
            },
            _resize: function _resize(ev) {
                this._state.offset = this._offset(this.sliderElem);
                this._state.size = this.sliderElem[this.sizePos];
                this._layout();
            },
            _removeProperty: function _removeProperty(element, prop) {
                if (element.style.removeProperty) {
                    element.style.removeProperty(prop);
                } else {
                    element.style.removeAttribute(prop);
                }
            },
            _mousedown: function _mousedown(ev) {
                if (!this._state.enabled) {
                    return false;
                }
                this._state.offset = this._offset(this.sliderElem);
                this._state.size = this.sliderElem[this.sizePos];
                var percentage = this._getPercentage(ev);
                if (this.options.range) {
                    var diff1 = Math.abs(this._state.percentage[0] - percentage);
                    var diff2 = Math.abs(this._state.percentage[1] - percentage);
                    this._state.dragged = diff1 < diff2 ? 0 : 1;
                    this._adjustPercentageForRangeSliders(percentage);
                } else {
                    this._state.dragged = 0;
                }
                this._state.percentage[this._state.dragged] = percentage;
                this._layout();
                if (this.touchCapable) {
                    document.removeEventListener("touchmove", this.mousemove, false);
                    document.removeEventListener("touchend", this.mouseup, false);
                }
                if (this.mousemove) {
                    document.removeEventListener("mousemove", this.mousemove, false);
                }
                if (this.mouseup) {
                    document.removeEventListener("mouseup", this.mouseup, false);
                }
                this.mousemove = this._mousemove.bind(this);
                this.mouseup = this._mouseup.bind(this);
                if (this.touchCapable) {
                    document.addEventListener("touchmove", this.mousemove, false);
                    document.addEventListener("touchend", this.mouseup, false);
                }
                document.addEventListener("mousemove", this.mousemove, false);
                document.addEventListener("mouseup", this.mouseup, false);
                this._state.inDrag = true;
                var newValue = this._calculateValue();
                this._trigger("slideStart", newValue);
                this._setDataVal(newValue);
                this.setValue(newValue, false, true);
                this._pauseEvent(ev);
                if (this.options.focus) {
                    this._triggerFocusOnHandle(this._state.dragged);
                }
                return true;
            },
            _touchstart: function _touchstart(ev) {
                if (ev.changedTouches === undefined) {
                    this._mousedown(ev);
                    return;
                }
                var touch = ev.changedTouches[0];
                this.touchX = touch.pageX;
                this.touchY = touch.pageY;
            },
            _triggerFocusOnHandle: function _triggerFocusOnHandle(handleIdx) {
                if (handleIdx === 0) {
                    this.handle1.focus();
                }
                if (handleIdx === 1) {
                    this.handle2.focus();
                }
            },
            _keydown: function _keydown(handleIdx, ev) {
                if (!this._state.enabled) {
                    return false;
                }
                var dir;
                switch (ev.keyCode) {
                  case 37:
                  case 40:
                    dir = -1;
                    break;

                  case 39:
                  case 38:
                    dir = 1;
                    break;
                }
                if (!dir) {
                    return;
                }
                if (this.options.natural_arrow_keys) {
                    var ifVerticalAndNotReversed = this.options.orientation === "vertical" && !this.options.reversed;
                    var ifHorizontalAndReversed = this.options.orientation === "horizontal" && this.options.reversed;
                    if (ifVerticalAndNotReversed || ifHorizontalAndReversed) {
                        dir = -dir;
                    }
                }
                var val = this._state.value[handleIdx] + dir * this.options.step;
                if (this.options.range) {
                    val = [ !handleIdx ? val : this._state.value[0], handleIdx ? val : this._state.value[1] ];
                }
                this._trigger("slideStart", val);
                this._setDataVal(val);
                this.setValue(val, true, true);
                this._setDataVal(val);
                this._trigger("slideStop", val);
                this._layout();
                this._pauseEvent(ev);
                return false;
            },
            _pauseEvent: function _pauseEvent(ev) {
                if (ev.stopPropagation) {
                    ev.stopPropagation();
                }
                if (ev.preventDefault) {
                    ev.preventDefault();
                }
                ev.cancelBubble = true;
                ev.returnValue = false;
            },
            _mousemove: function _mousemove(ev) {
                if (!this._state.enabled) {
                    return false;
                }
                var percentage = this._getPercentage(ev);
                this._adjustPercentageForRangeSliders(percentage);
                this._state.percentage[this._state.dragged] = percentage;
                this._layout();
                var val = this._calculateValue(true);
                this.setValue(val, true, true);
                return false;
            },
            _touchmove: function _touchmove(ev) {
                if (ev.changedTouches === undefined) {
                    return;
                }
                var touch = ev.changedTouches[0];
                var xDiff = touch.pageX - this.touchX;
                var yDiff = touch.pageY - this.touchY;
                if (!this._state.inDrag) {
                    if (this.options.orientation === "vertical" && xDiff <= 5 && xDiff >= -5 && (yDiff >= 15 || yDiff <= -15)) {
                        this._mousedown(ev);
                    } else if (yDiff <= 5 && yDiff >= -5 && (xDiff >= 15 || xDiff <= -15)) {
                        this._mousedown(ev);
                    }
                }
            },
            _adjustPercentageForRangeSliders: function _adjustPercentageForRangeSliders(percentage) {
                if (this.options.range) {
                    var precision = this._getNumDigitsAfterDecimalPlace(percentage);
                    precision = precision ? precision - 1 : 0;
                    var percentageWithAdjustedPrecision = this._applyToFixedAndParseFloat(percentage, precision);
                    if (this._state.dragged === 0 && this._applyToFixedAndParseFloat(this._state.percentage[1], precision) < percentageWithAdjustedPrecision) {
                        this._state.percentage[0] = this._state.percentage[1];
                        this._state.dragged = 1;
                    } else if (this._state.dragged === 1 && this._applyToFixedAndParseFloat(this._state.percentage[0], precision) > percentageWithAdjustedPrecision) {
                        this._state.percentage[1] = this._state.percentage[0];
                        this._state.dragged = 0;
                    }
                }
            },
            _mouseup: function _mouseup() {
                if (!this._state.enabled) {
                    return false;
                }
                if (this.touchCapable) {
                    document.removeEventListener("touchmove", this.mousemove, false);
                    document.removeEventListener("touchend", this.mouseup, false);
                }
                document.removeEventListener("mousemove", this.mousemove, false);
                document.removeEventListener("mouseup", this.mouseup, false);
                this._state.inDrag = false;
                if (this._state.over === false) {
                    this._hideTooltip();
                }
                var val = this._calculateValue(true);
                this._layout();
                this._setDataVal(val);
                this._trigger("slideStop", val);
                return false;
            },
            _calculateValue: function _calculateValue(snapToClosestTick) {
                var val;
                if (this.options.range) {
                    val = [ this.options.min, this.options.max ];
                    if (this._state.percentage[0] !== 0) {
                        val[0] = this._toValue(this._state.percentage[0]);
                        val[0] = this._applyPrecision(val[0]);
                    }
                    if (this._state.percentage[1] !== 100) {
                        val[1] = this._toValue(this._state.percentage[1]);
                        val[1] = this._applyPrecision(val[1]);
                    }
                } else {
                    val = this._toValue(this._state.percentage[0]);
                    val = parseFloat(val);
                    val = this._applyPrecision(val);
                }
                if (snapToClosestTick) {
                    var min = [ val, Infinity ];
                    for (var i = 0; i < this.options.ticks.length; i++) {
                        var diff = Math.abs(this.options.ticks[i] - val);
                        if (diff <= min[1]) {
                            min = [ this.options.ticks[i], diff ];
                        }
                    }
                    if (min[1] <= this.options.ticks_snap_bounds) {
                        return min[0];
                    }
                }
                return val;
            },
            _applyPrecision: function _applyPrecision(val) {
                var precision = this.options.precision || this._getNumDigitsAfterDecimalPlace(this.options.step);
                return this._applyToFixedAndParseFloat(val, precision);
            },
            _getNumDigitsAfterDecimalPlace: function _getNumDigitsAfterDecimalPlace(num) {
                var match = ("" + num).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
                if (!match) {
                    return 0;
                }
                return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));
            },
            _applyToFixedAndParseFloat: function _applyToFixedAndParseFloat(num, toFixedInput) {
                var truncatedNum = num.toFixed(toFixedInput);
                return parseFloat(truncatedNum);
            },
            _getPercentage: function _getPercentage(ev) {
                if (this.touchCapable && (ev.type === "touchstart" || ev.type === "touchmove")) {
                    ev = ev.touches[0];
                }
                var eventPosition = ev[this.mousePos];
                var sliderOffset = this._state.offset[this.stylePos];
                var distanceToSlide = eventPosition - sliderOffset;
                var percentage = distanceToSlide / this._state.size * 100;
                percentage = Math.round(percentage / this._state.percentage[2]) * this._state.percentage[2];
                if (this.options.reversed) {
                    percentage = 100 - percentage;
                }
                return Math.max(0, Math.min(100, percentage));
            },
            _validateInputValue: function _validateInputValue(val) {
                if (typeof val === "number") {
                    return val;
                } else if (Array.isArray(val)) {
                    this._validateArray(val);
                    return val;
                } else {
                    throw new Error(ErrorMsgs.formatInvalidInputErrorMsg(val));
                }
            },
            _validateArray: function _validateArray(val) {
                for (var i = 0; i < val.length; i++) {
                    var input = val[i];
                    if (typeof input !== "number") {
                        throw new Error(ErrorMsgs.formatInvalidInputErrorMsg(input));
                    }
                }
            },
            _setDataVal: function _setDataVal(val) {
                this.element.setAttribute("data-value", val);
                this.element.setAttribute("value", val);
                this.element.value = val;
            },
            _trigger: function _trigger(evt, val) {
                val = val || val === 0 ? val : undefined;
                var callbackFnArray = this.eventToCallbackMap[evt];
                if (callbackFnArray && callbackFnArray.length) {
                    for (var i = 0; i < callbackFnArray.length; i++) {
                        var callbackFn = callbackFnArray[i];
                        callbackFn(val);
                    }
                }
                if ($) {
                    this._triggerJQueryEvent(evt, val);
                }
            },
            _triggerJQueryEvent: function _triggerJQueryEvent(evt, val) {
                var eventData = {
                    type: evt,
                    value: val
                };
                this.$element.trigger(eventData);
                this.$sliderElem.trigger(eventData);
            },
            _unbindJQueryEventHandlers: function _unbindJQueryEventHandlers() {
                this.$element.off();
                this.$sliderElem.off();
            },
            _setText: function _setText(element, text) {
                if (typeof element.textContent !== "undefined") {
                    element.textContent = text;
                } else if (typeof element.innerText !== "undefined") {
                    element.innerText = text;
                }
            },
            _removeClass: function _removeClass(element, classString) {
                var classes = classString.split(" ");
                var newClasses = element.className;
                for (var i = 0; i < classes.length; i++) {
                    var classTag = classes[i];
                    var regex = new RegExp("(?:\\s|^)" + classTag + "(?:\\s|$)");
                    newClasses = newClasses.replace(regex, " ");
                }
                element.className = newClasses.trim();
            },
            _addClass: function _addClass(element, classString) {
                var classes = classString.split(" ");
                var newClasses = element.className;
                for (var i = 0; i < classes.length; i++) {
                    var classTag = classes[i];
                    var regex = new RegExp("(?:\\s|^)" + classTag + "(?:\\s|$)");
                    var ifClassExists = regex.test(newClasses);
                    if (!ifClassExists) {
                        newClasses += " " + classTag;
                    }
                }
                element.className = newClasses.trim();
            },
            _offsetLeft: function _offsetLeft(obj) {
                return obj.getBoundingClientRect().left;
            },
            _offsetTop: function _offsetTop(obj) {
                var offsetTop = obj.offsetTop;
                while ((obj = obj.offsetParent) && !isNaN(obj.offsetTop)) {
                    offsetTop += obj.offsetTop;
                    if (obj.tagName !== "BODY") {
                        offsetTop -= obj.scrollTop;
                    }
                }
                return offsetTop;
            },
            _offset: function _offset(obj) {
                return {
                    left: this._offsetLeft(obj),
                    top: this._offsetTop(obj)
                };
            },
            _css: function _css(elementRef, styleName, value) {
                if ($) {
                    $.style(elementRef, styleName, value);
                } else {
                    var style = styleName.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(all, letter) {
                        return letter.toUpperCase();
                    });
                    elementRef.style[style] = value;
                }
            },
            _toValue: function _toValue(percentage) {
                return this.options.scale.toValue.apply(this, [ percentage ]);
            },
            _toPercentage: function _toPercentage(value) {
                return this.options.scale.toPercentage.apply(this, [ value ]);
            },
            _setTooltipPosition: function _setTooltipPosition() {
                var tooltips = [ this.tooltip, this.tooltip_min, this.tooltip_max ];
                if (this.options.orientation === "vertical") {
                    var tooltipPos = this.options.tooltip_position || "right";
                    var oppositeSide = tooltipPos === "left" ? "right" : "left";
                    tooltips.forEach(function(tooltip) {
                        this._addClass(tooltip, tooltipPos);
                        tooltip.style[oppositeSide] = "100%";
                    }.bind(this));
                } else if (this.options.tooltip_position === "bottom") {
                    tooltips.forEach(function(tooltip) {
                        this._addClass(tooltip, "bottom");
                        tooltip.style.top = 22 + "px";
                    }.bind(this));
                } else {
                    tooltips.forEach(function(tooltip) {
                        this._addClass(tooltip, "top");
                        tooltip.style.top = -this.tooltip.outerHeight - 14 + "px";
                    }.bind(this));
                }
            }
        };
        if ($) {
            (function() {
                var autoRegisterNamespace = undefined;
                if (!$.fn.slider) {
                    $.bridget(NAMESPACE_MAIN, Slider);
                    autoRegisterNamespace = NAMESPACE_MAIN;
                } else {
                    if (windowIsDefined) {
                        window.console.warn("bootstrap-slider.js - WARNING: $.fn.slider namespace is already bound. Use the $.fn.bootstrapSlider namespace instead.");
                    }
                    autoRegisterNamespace = NAMESPACE_ALTERNATE;
                }
                $.bridget(NAMESPACE_ALTERNATE, Slider);
                $(function() {
                    $("input[data-provide=slider]")[autoRegisterNamespace]();
                });
            })();
        }
    })($);
    return Slider;
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "angular", "bootstrap-slider" ], factory);
    } else if (typeof module === "object" && module.exports) {
        module.exports = factory(require("angular"), require("bootstrap-slider"));
    } else if (window) {
        factory(window.angular, window.Slider);
    }
})(function(angular, Slider) {
    angular.module("ui.bootstrap-slider", []).directive("slider", [ "$parse", "$timeout", "$rootScope", function($parse, $timeout, $rootScope) {
        return {
            restrict: "AE",
            replace: true,
            template: '<div><input class="slider-input" type="text" style="width:100%" /></div>',
            require: "ngModel",
            scope: {
                max: "=",
                min: "=",
                step: "=",
                value: "=",
                ngModel: "=",
                ngDisabled: "=",
                range: "=",
                sliderid: "=",
                ticks: "=",
                ticksLabels: "=",
                ticksSnapBounds: "=",
                ticksPositions: "=",
                scale: "=",
                focus: "=",
                formatter: "&",
                onStartSlide: "&",
                onStopSlide: "&",
                onSlide: "&"
            },
            link: function($scope, element, attrs, ngModelCtrl, $compile) {
                var ngModelDeregisterFn, ngDisabledDeregisterFn;
                var slider = initSlider();
                function initSlider() {
                    var options = {};
                    function setOption(key, value, defaultValue) {
                        options[key] = value || defaultValue;
                    }
                    function setFloatOption(key, value, defaultValue) {
                        options[key] = value || value === 0 ? parseFloat(value) : defaultValue;
                    }
                    function setBooleanOption(key, value, defaultValue) {
                        options[key] = value ? value + "" === "true" : defaultValue;
                    }
                    function getArrayOrValue(value) {
                        return angular.isString(value) && value.indexOf("[") === 0 ? angular.fromJson(value) : value;
                    }
                    setOption("id", $scope.sliderid);
                    setOption("orientation", attrs.orientation, "horizontal");
                    setOption("selection", attrs.selection, "before");
                    setOption("handle", attrs.handle, "round");
                    setOption("tooltip", attrs.sliderTooltip || attrs.tooltip, "show");
                    setOption("tooltip_position", attrs.sliderTooltipPosition, "top");
                    setOption("tooltipseparator", attrs.tooltipseparator, ":");
                    setOption("ticks", $scope.ticks);
                    setOption("ticks_labels", $scope.ticksLabels);
                    setOption("ticks_snap_bounds", $scope.ticksSnapBounds);
                    setOption("ticks_positions", $scope.ticksPositions);
                    setOption("scale", $scope.scale, "linear");
                    setOption("focus", $scope.focus);
                    setFloatOption("min", $scope.min, 0);
                    setFloatOption("max", $scope.max, 10);
                    setFloatOption("step", $scope.step, 1);
                    var strNbr = options.step + "";
                    var dotPos = strNbr.search(/[^.,]*$/);
                    var decimals = strNbr.substring(dotPos);
                    setFloatOption("precision", attrs.precision, decimals.length);
                    setBooleanOption("tooltip_split", attrs.tooltipsplit, false);
                    setBooleanOption("enabled", attrs.enabled, true);
                    setBooleanOption("naturalarrowkeys", attrs.naturalarrowkeys, false);
                    setBooleanOption("reversed", attrs.reversed, false);
                    setBooleanOption("range", $scope.range, false);
                    if (options.range) {
                        if (angular.isArray($scope.value)) {
                            options.value = $scope.value;
                        } else if (angular.isString($scope.value)) {
                            options.value = getArrayOrValue($scope.value);
                            if (!angular.isArray(options.value)) {
                                var value = parseFloat($scope.value);
                                if (isNaN(value)) value = 5;
                                if (value < $scope.min) {
                                    value = $scope.min;
                                    options.value = [ value, options.max ];
                                } else if (value > $scope.max) {
                                    value = $scope.max;
                                    options.value = [ options.min, value ];
                                } else {
                                    options.value = [ options.min, options.max ];
                                }
                            }
                        } else {
                            options.value = [ options.min, options.max ];
                        }
                        $scope.ngModel = options.value;
                    } else {
                        setFloatOption("value", $scope.value, 5);
                    }
                    if (attrs.formatter) {
                        options.formatter = function(value) {
                            return $scope.formatter({
                                value: value
                            });
                        };
                    }
                    if ("$" in window && $.fn.slider) {
                        $.fn.slider.constructor.prototype.disable = function() {
                            this.picker.off();
                        };
                        $.fn.slider.constructor.prototype.enable = function() {
                            this.picker.on();
                        };
                    }
                    if (element[0].__slider) element[0].__slider.destroy();
                    var slider = new Slider(element[0].getElementsByClassName("slider-input")[0], options);
                    element[0].__slider = slider;
                    var updateEvent = getArrayOrValue(attrs.updateevent);
                    if (angular.isString(updateEvent)) {
                        updateEvent = [ updateEvent ];
                    } else {
                        updateEvent = [ "slide" ];
                    }
                    angular.forEach(updateEvent, function(sliderEvent) {
                        slider.on(sliderEvent, function(ev) {
                            ngModelCtrl.$setViewValue(ev);
                        });
                    });
                    slider.on("change", function(ev) {
                        ngModelCtrl.$setViewValue(ev.newValue);
                    });
                    var sliderEvents = {
                        slideStart: "onStartSlide",
                        slide: "onSlide",
                        slideStop: "onStopSlide"
                    };
                    angular.forEach(sliderEvents, function(sliderEventAttr, sliderEvent) {
                        var fn = $parse(attrs[sliderEventAttr]);
                        slider.on(sliderEvent, function(ev) {
                            if ($scope[sliderEventAttr]) {
                                $scope.$apply(function() {
                                    fn($scope.$parent, {
                                        $event: ev,
                                        value: ev
                                    });
                                });
                            }
                        });
                    });
                    if (angular.isFunction(ngDisabledDeregisterFn)) {
                        ngDisabledDeregisterFn();
                        ngDisabledDeregisterFn = null;
                    }
                    ngDisabledDeregisterFn = $scope.$watch("ngDisabled", function(value) {
                        if (value) {
                            slider.disable();
                        } else {
                            slider.enable();
                        }
                    });
                    if (angular.isFunction(ngModelDeregisterFn)) ngModelDeregisterFn();
                    ngModelDeregisterFn = $scope.$watch("ngModel", function(value) {
                        if ($scope.range) {
                            slider.setValue(value);
                        } else {
                            slider.setValue(parseFloat(value));
                        }
                        slider.relayout();
                    }, true);
                    return slider;
                }
                var watchers = [ "min", "max", "step", "range", "scale", "ticksLabels" ];
                angular.forEach(watchers, function(prop) {
                    $scope.$watch(prop, function() {
                        slider = initSlider();
                    });
                });
                var globalEvents = [ "relayout", "refresh", "resize" ];
                angular.forEach(globalEvents, function(event) {
                    if (angular.isFunction(slider[event])) {
                        $scope.$on("slider:" + event, function() {
                            slider[event]();
                        });
                    }
                });
            }
        };
    } ]);
});

var bind = function(fn, me) {
    return function() {
        return fn.apply(me, arguments);
    };
};

angular.module("nemLogging", []).provider("nemSimpleLogger", function() {
    var LEVELS, Logger, _fns, maybeExecLevel;
    _fns = [ "log", "info", "debug", "warn", "error" ];
    LEVELS = {
        log: 1,
        info: 2,
        debug: 3,
        warn: 4,
        error: 5
    };
    maybeExecLevel = function(level, current, fn) {
        if (level >= current) {
            return fn();
        }
    };
    Logger = function() {
        function Logger($log1) {
            var logFns;
            this.$log = $log1;
            this.spawn = bind(this.spawn, this);
            if (!this.$log) {
                throw "internalLogger undefined";
            }
            this.doLog = true;
            logFns = {};
            _fns.forEach(function(_this) {
                return function(level) {
                    return logFns[level] = function(msg) {
                        if (_this.doLog) {
                            return maybeExecLevel(LEVELS[level], _this.currentLevel, function() {
                                return _this.$log[level](msg);
                            });
                        }
                    };
                };
            }(this));
            this.LEVELS = LEVELS;
            this.currentLevel = LEVELS.error;
            _fns.forEach(function(_this) {
                return function(fnName) {
                    return _this[fnName] = logFns[fnName];
                };
            }(this));
        }
        Logger.prototype.spawn = function(newInternalLogger) {
            return new Logger(newInternalLogger || this.$log);
        };
        return Logger;
    }();
    this.decorator = [ "$log", function($delegate) {
        var log;
        log = new Logger($delegate);
        log.currentLevel = LEVELS.log;
        return log;
    } ];
    this.$get = [ "$log", function($log) {
        return new Logger($log);
    } ];
    return this;
});

(function(window, angular, undefined) {
    "use strict";
    (function() {
        angular.module("uiGmapgoogle-maps.providers", [ "nemLogging" ]);
        angular.module("uiGmapgoogle-maps.wrapped", []);
        angular.module("uiGmapgoogle-maps.extensions", [ "uiGmapgoogle-maps.wrapped", "uiGmapgoogle-maps.providers" ]);
        angular.module("uiGmapgoogle-maps.directives.api.utils", [ "uiGmapgoogle-maps.extensions" ]);
        angular.module("uiGmapgoogle-maps.directives.api.managers", []);
        angular.module("uiGmapgoogle-maps.directives.api.options", [ "uiGmapgoogle-maps.directives.api.utils" ]);
        angular.module("uiGmapgoogle-maps.directives.api.options.builders", []);
        angular.module("uiGmapgoogle-maps.directives.api.models.child", [ "uiGmapgoogle-maps.directives.api.utils", "uiGmapgoogle-maps.directives.api.options", "uiGmapgoogle-maps.directives.api.options.builders" ]);
        angular.module("uiGmapgoogle-maps.directives.api.models.parent", [ "uiGmapgoogle-maps.directives.api.managers", "uiGmapgoogle-maps.directives.api.models.child", "uiGmapgoogle-maps.providers" ]);
        angular.module("uiGmapgoogle-maps.directives.api", [ "uiGmapgoogle-maps.directives.api.models.parent" ]);
        angular.module("uiGmapgoogle-maps", [ "uiGmapgoogle-maps.directives.api", "uiGmapgoogle-maps.providers" ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.providers").factory("uiGmapMapScriptLoader", [ "$q", "uiGmapuuid", function($q, uuid) {
            var getScriptUrl, includeScript, isGoogleMapsLoaded, scriptId;
            scriptId = void 0;
            getScriptUrl = function(options) {
                if (options.china) {
                    return "http://maps.google.cn/maps/api/js?";
                } else {
                    if (options.transport === "auto") {
                        return "//maps.googleapis.com/maps/api/js?";
                    } else {
                        return options.transport + "://maps.googleapis.com/maps/api/js?";
                    }
                }
            };
            includeScript = function(options) {
                var omitOptions, query, script;
                omitOptions = [ "transport", "isGoogleMapsForWork", "china" ];
                if (options.isGoogleMapsForWork) {
                    omitOptions.push("key");
                }
                query = _.map(_.omit(options, omitOptions), function(v, k) {
                    return k + "=" + v;
                });
                if (scriptId) {
                    document.getElementById(scriptId).remove();
                }
                query = query.join("&");
                script = document.createElement("script");
                script.id = scriptId = "ui_gmap_map_load_" + uuid.generate();
                script.type = "text/javascript";
                script.src = getScriptUrl(options) + query;
                return document.body.appendChild(script);
            };
            isGoogleMapsLoaded = function() {
                return angular.isDefined(window.google) && angular.isDefined(window.google.maps);
            };
            return {
                load: function(options) {
                    var deferred, randomizedFunctionName;
                    deferred = $q.defer();
                    if (isGoogleMapsLoaded()) {
                        deferred.resolve(window.google.maps);
                        return deferred.promise;
                    }
                    randomizedFunctionName = options.callback = "onGoogleMapsReady" + Math.round(Math.random() * 1e3);
                    window[randomizedFunctionName] = function() {
                        window[randomizedFunctionName] = null;
                        deferred.resolve(window.google.maps);
                    };
                    if (window.navigator.connection && window.Connection && window.navigator.connection.type === window.Connection.NONE) {
                        document.addEventListener("online", function() {
                            if (!isGoogleMapsLoaded()) {
                                return includeScript(options);
                            }
                        });
                    } else {
                        includeScript(options);
                    }
                    return deferred.promise;
                }
            };
        } ]).provider("uiGmapGoogleMapApi", function() {
            this.options = {
                transport: "https",
                isGoogleMapsForWork: false,
                china: false,
                v: "3",
                libraries: "",
                language: "en",
                sensor: "false"
            };
            this.configure = function(options) {
                angular.extend(this.options, options);
            };
            this.$get = [ "uiGmapMapScriptLoader", function(_this) {
                return function(loader) {
                    return loader.load(_this.options);
                };
            }(this) ];
            return this;
        });
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.extensions").service("uiGmapExtendGWin", function() {
            return {
                init: _.once(function() {
                    var uiGmapInfoBox;
                    if (!(google || (typeof google !== "undefined" && google !== null ? google.maps : void 0) || google.maps.InfoWindow != null)) {
                        return;
                    }
                    google.maps.InfoWindow.prototype._open = google.maps.InfoWindow.prototype.open;
                    google.maps.InfoWindow.prototype._close = google.maps.InfoWindow.prototype.close;
                    google.maps.InfoWindow.prototype._isOpen = false;
                    google.maps.InfoWindow.prototype.open = function(map, anchor, recurse) {
                        if (recurse != null) {
                            return;
                        }
                        this._isOpen = true;
                        this._open(map, anchor, true);
                    };
                    google.maps.InfoWindow.prototype.close = function(recurse) {
                        if (recurse != null) {
                            return;
                        }
                        this._isOpen = false;
                        this._close(true);
                    };
                    google.maps.InfoWindow.prototype.isOpen = function(val) {
                        if (val == null) {
                            val = void 0;
                        }
                        if (val == null) {
                            return this._isOpen;
                        } else {
                            return this._isOpen = val;
                        }
                    };
                    if (window.InfoBox) {
                        window.InfoBox.prototype._open = window.InfoBox.prototype.open;
                        window.InfoBox.prototype._close = window.InfoBox.prototype.close;
                        window.InfoBox.prototype._isOpen = false;
                        window.InfoBox.prototype.open = function(map, anchor) {
                            this._isOpen = true;
                            this._open(map, anchor);
                        };
                        window.InfoBox.prototype.close = function() {
                            this._isOpen = false;
                            this._close();
                        };
                        window.InfoBox.prototype.isOpen = function(val) {
                            if (val == null) {
                                val = void 0;
                            }
                            if (val == null) {
                                return this._isOpen;
                            } else {
                                return this._isOpen = val;
                            }
                        };
                        uiGmapInfoBox = function(superClass) {
                            extend(uiGmapInfoBox, superClass);
                            function uiGmapInfoBox(opts) {
                                this.getOrigCloseBoxImg_ = bind(this.getOrigCloseBoxImg_, this);
                                this.getCloseBoxDiv_ = bind(this.getCloseBoxDiv_, this);
                                var box;
                                box = new window.InfoBox(opts);
                                _.extend(this, box);
                                if (opts.closeBoxDiv != null) {
                                    this.closeBoxDiv_ = opts.closeBoxDiv;
                                }
                            }
                            uiGmapInfoBox.prototype.getCloseBoxDiv_ = function() {
                                return this.closeBoxDiv_;
                            };
                            uiGmapInfoBox.prototype.getCloseBoxImg_ = function() {
                                var div, img;
                                div = this.getCloseBoxDiv_();
                                img = this.getOrigCloseBoxImg_();
                                return div || img;
                            };
                            uiGmapInfoBox.prototype.getOrigCloseBoxImg_ = function() {
                                var img;
                                img = "";
                                if (this.closeBoxURL_ !== "") {
                                    img = "<img";
                                    img += " src='" + this.closeBoxURL_ + "'";
                                    img += " align=right";
                                    img += " style='";
                                    img += " position: relative;";
                                    img += " cursor: pointer;";
                                    img += " margin: " + this.closeBoxMargin_ + ";";
                                    img += "'>";
                                }
                                return img;
                            };
                            return uiGmapInfoBox;
                        }(window.InfoBox);
                        window.uiGmapInfoBox = uiGmapInfoBox;
                    }
                    if (window.MarkerLabel_) {
                        return window.MarkerLabel_.prototype.setContent = function() {
                            var content;
                            content = this.marker_.get("labelContent");
                            if (!content || _.isEqual(this.oldContent, content)) {
                                return;
                            }
                            if (typeof (content != null ? content.nodeType : void 0) === "undefined") {
                                this.labelDiv_.innerHTML = content;
                                this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;
                                this.oldContent = content;
                            } else {
                                this.labelDiv_.innerHTML = "";
                                this.labelDiv_.appendChild(content);
                                content = content.cloneNode(true);
                                this.labelDiv_.innerHTML = "";
                                this.eventDiv_.appendChild(content);
                                this.oldContent = content;
                            }
                        };
                    }
                })
            };
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.extensions").service("uiGmapLodash", function() {
            var baseGet, baseToString, get, reIsDeepProp, reIsPlainProp, rePropName, toObject, toPath;
            if (_.get == null) {
                reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/;
                reIsPlainProp = /^\w*$/;
                rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
                toObject = function(value) {
                    if (_.isObject(value)) {
                        return value;
                    } else {
                        return Object(value);
                    }
                };
                baseToString = function(value) {
                    if (value === null) {
                        return "";
                    } else {
                        return value + "";
                    }
                };
                toPath = function(value) {
                    var result;
                    if (_.isArray(value)) {
                        return value;
                    }
                    result = [];
                    baseToString(value).replace(rePropName, function(match, number, quote, string) {
                        result.push(quote ? string.replace(reEscapeChar, "$1") : number || match);
                    });
                    return result;
                };
                baseGet = function(object, path, pathKey) {
                    var index, length;
                    if (object === null) {
                        return;
                    }
                    if (pathKey !== void 0 && pathKey in toObject(object)) {
                        path = [ pathKey ];
                    }
                    index = 0;
                    length = path.length;
                    while (!_.isUndefined(object) && index < length) {
                        object = object[path[index++]];
                    }
                    if (index && index === length) {
                        return object;
                    } else {
                        return void 0;
                    }
                };
                get = function(object, path, defaultValue) {
                    var result;
                    result = object === null ? void 0 : baseGet(object, toPath(path), path + "");
                    if (result === void 0) {
                        return defaultValue;
                    } else {
                        return result;
                    }
                };
                _.get = get;
            }
            this.intersectionObjects = function(array1, array2, comparison) {
                var res;
                if (comparison == null) {
                    comparison = void 0;
                }
                res = _.map(array1, function(_this) {
                    return function(obj1) {
                        return _.find(array2, function(obj2) {
                            if (comparison != null) {
                                return comparison(obj1, obj2);
                            } else {
                                return _.isEqual(obj1, obj2);
                            }
                        });
                    };
                }(this));
                return _.filter(res, function(o) {
                    return o != null;
                });
            };
            this.containsObject = _.includeObject = function(obj, target, comparison) {
                if (comparison == null) {
                    comparison = void 0;
                }
                if (obj === null) {
                    return false;
                }
                return _.any(obj, function(_this) {
                    return function(value) {
                        if (comparison != null) {
                            return comparison(value, target);
                        } else {
                            return _.isEqual(value, target);
                        }
                    };
                }(this));
            };
            this.differenceObjects = function(array1, array2, comparison) {
                if (comparison == null) {
                    comparison = void 0;
                }
                return _.filter(array1, function(_this) {
                    return function(value) {
                        return !_this.containsObject(array2, value, comparison);
                    };
                }(this));
            };
            this.withoutObjects = this.differenceObjects;
            this.indexOfObject = function(array, item, comparison, isSorted) {
                var i, length;
                if (array == null) {
                    return -1;
                }
                i = 0;
                length = array.length;
                if (isSorted) {
                    if (typeof isSorted === "number") {
                        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
                    } else {
                        i = _.sortedIndex(array, item);
                        return array[i] === item ? i : -1;
                    }
                }
                while (i < length) {
                    if (comparison != null) {
                        if (comparison(array[i], item)) {
                            return i;
                        }
                    } else {
                        if (_.isEqual(array[i], item)) {
                            return i;
                        }
                    }
                    i++;
                }
                return -1;
            };
            this.isNullOrUndefined = function(thing) {
                return _.isNull(thing || _.isUndefined(thing));
            };
            return this;
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.extensions").factory("uiGmapString", function() {
            return function(str) {
                this.contains = function(value, fromIndex) {
                    return str.indexOf(value, fromIndex) !== -1;
                };
                return this;
            };
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmap_sync", [ function() {
            return {
                fakePromise: function() {
                    var _cb;
                    _cb = void 0;
                    return {
                        then: function(cb) {
                            return _cb = cb;
                        },
                        resolve: function() {
                            return _cb.apply(void 0, arguments);
                        }
                    };
                }
            };
        } ]).service("uiGmap_async", [ "$timeout", "uiGmapPromise", "uiGmapLogger", "$q", "uiGmapDataStructures", "uiGmapGmapUtil", function($timeout, uiGmapPromise, $log, $q, uiGmapDataStructures, uiGmapGmapUtil) {
            var ExposedPromise, PromiseQueueManager, SniffedPromise, _getArrayAndKeys, _getIterateeValue, defaultChunkSize, doChunk, doSkippPromise, each, errorObject, isInProgress, kickPromise, logTryCatch, managePromiseQueue, map, maybeCancelPromises, promiseStatus, promiseTypes, tryCatch;
            promiseTypes = uiGmapPromise.promiseTypes;
            isInProgress = uiGmapPromise.isInProgress;
            promiseStatus = uiGmapPromise.promiseStatus;
            ExposedPromise = uiGmapPromise.ExposedPromise;
            SniffedPromise = uiGmapPromise.SniffedPromise;
            kickPromise = function(sniffedPromise, cancelCb) {
                var promise;
                promise = sniffedPromise.promise();
                promise.promiseType = sniffedPromise.promiseType;
                if (promise.$$state) {
                    $log.debug("promiseType: " + promise.promiseType + ", state: " + promiseStatus(promise.$$state.status));
                }
                promise.cancelCb = cancelCb;
                return promise;
            };
            doSkippPromise = function(sniffedPromise, lastPromise) {
                if (sniffedPromise.promiseType === promiseTypes.create && lastPromise.promiseType !== promiseTypes["delete"] && lastPromise.promiseType !== promiseTypes.init) {
                    $log.debug("lastPromise.promiseType " + lastPromise.promiseType + ", newPromiseType: " + sniffedPromise.promiseType + ", SKIPPED MUST COME AFTER DELETE ONLY");
                    return true;
                }
                return false;
            };
            maybeCancelPromises = function(queue, sniffedPromise, lastPromise) {
                var first;
                if (sniffedPromise.promiseType === promiseTypes["delete"] && lastPromise.promiseType !== promiseTypes["delete"]) {
                    if (lastPromise.cancelCb != null && _.isFunction(lastPromise.cancelCb) && isInProgress(lastPromise)) {
                        $log.debug("promiseType: " + sniffedPromise.promiseType + ", CANCELING LAST PROMISE type: " + lastPromise.promiseType);
                        lastPromise.cancelCb("cancel safe");
                        first = queue.peek();
                        if (first != null && isInProgress(first)) {
                            if (first.hasOwnProperty("cancelCb") && _.isFunction(first.cancelCb)) {
                                $log.debug("promiseType: " + first.promiseType + ", CANCELING FIRST PROMISE type: " + first.promiseType);
                                return first.cancelCb("cancel safe");
                            } else {
                                return $log.warn("first promise was not cancelable");
                            }
                        }
                    }
                }
            };
            PromiseQueueManager = function(existingPiecesObj, sniffedPromise, cancelCb) {
                var lastPromise, newPromise;
                if (!existingPiecesObj.existingPieces) {
                    existingPiecesObj.existingPieces = new uiGmapDataStructures.Queue();
                    return existingPiecesObj.existingPieces.enqueue(kickPromise(sniffedPromise, cancelCb));
                } else {
                    lastPromise = _.last(existingPiecesObj.existingPieces._content);
                    if (doSkippPromise(sniffedPromise, lastPromise)) {
                        return;
                    }
                    maybeCancelPromises(existingPiecesObj.existingPieces, sniffedPromise, lastPromise);
                    newPromise = ExposedPromise(lastPromise["finally"](function() {
                        return kickPromise(sniffedPromise, cancelCb);
                    }));
                    newPromise.cancelCb = cancelCb;
                    newPromise.promiseType = sniffedPromise.promiseType;
                    existingPiecesObj.existingPieces.enqueue(newPromise);
                    return lastPromise["finally"](function() {
                        return existingPiecesObj.existingPieces.dequeue();
                    });
                }
            };
            managePromiseQueue = function(objectToLock, promiseType, msg, cancelCb, fnPromise) {
                var cancelLogger;
                if (msg == null) {
                    msg = "";
                }
                cancelLogger = function(msg) {
                    $log.debug(msg + ": " + msg);
                    if (cancelCb != null && _.isFunction(cancelCb)) {
                        return cancelCb(msg);
                    }
                };
                return PromiseQueueManager(objectToLock, SniffedPromise(fnPromise, promiseType), cancelLogger);
            };
            defaultChunkSize = 80;
            errorObject = {
                value: null
            };
            tryCatch = function(fn, ctx, args) {
                var e;
                try {
                    return fn.apply(ctx, args);
                } catch (_error) {
                    e = _error;
                    errorObject.value = e;
                    return errorObject;
                }
            };
            logTryCatch = function(fn, ctx, deferred, args) {
                var msg, result;
                result = tryCatch(fn, ctx, args);
                if (result === errorObject) {
                    msg = "error within chunking iterator: " + errorObject.value;
                    $log.error(msg);
                    deferred.reject(msg);
                }
                if (result === "cancel safe") {
                    return false;
                }
                return true;
            };
            _getIterateeValue = function(collection, array, index) {
                var _isArray, valOrKey;
                _isArray = collection === array;
                valOrKey = array[index];
                if (_isArray) {
                    return valOrKey;
                }
                return collection[valOrKey];
            };
            _getArrayAndKeys = function(collection, keys, bailOutCb, cb) {
                var array;
                if (angular.isArray(collection)) {
                    array = collection;
                } else {
                    array = keys ? keys : Object.keys(_.omit(collection, [ "length", "forEach", "map" ]));
                    keys = array;
                }
                if (cb == null) {
                    cb = bailOutCb;
                }
                if (angular.isArray(array) && (array === void 0 || (array != null ? array.length : void 0) <= 0)) {
                    if (cb !== bailOutCb) {
                        return bailOutCb();
                    }
                }
                return cb(array, keys);
            };
            doChunk = function(collection, chunkSizeOrDontChunk, pauseMilli, chunkCb, pauseCb, overallD, index, _keys) {
                return _getArrayAndKeys(collection, _keys, function(array, keys) {
                    var cnt, i, keepGoing, val;
                    if (chunkSizeOrDontChunk && chunkSizeOrDontChunk < array.length) {
                        cnt = chunkSizeOrDontChunk;
                    } else {
                        cnt = array.length;
                    }
                    i = index;
                    keepGoing = true;
                    while (keepGoing && cnt-- && i < (array ? array.length : i + 1)) {
                        val = _getIterateeValue(collection, array, i);
                        keepGoing = angular.isFunction(val) ? true : logTryCatch(chunkCb, void 0, overallD, [ val, i ]);
                        ++i;
                    }
                    if (array) {
                        if (keepGoing && i < array.length) {
                            index = i;
                            if (chunkSizeOrDontChunk) {
                                if (pauseCb != null && _.isFunction(pauseCb)) {
                                    logTryCatch(pauseCb, void 0, overallD, []);
                                }
                                return $timeout(function() {
                                    return doChunk(collection, chunkSizeOrDontChunk, pauseMilli, chunkCb, pauseCb, overallD, index, keys);
                                }, pauseMilli, false);
                            }
                        } else {
                            return overallD.resolve();
                        }
                    }
                });
            };
            each = function(collection, chunk, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, _keys) {
                var error, overallD, ret;
                if (chunkSizeOrDontChunk == null) {
                    chunkSizeOrDontChunk = defaultChunkSize;
                }
                if (index == null) {
                    index = 0;
                }
                if (pauseMilli == null) {
                    pauseMilli = 1;
                }
                ret = void 0;
                overallD = uiGmapPromise.defer();
                ret = overallD.promise;
                if (!pauseMilli) {
                    error = "pause (delay) must be set from _async!";
                    $log.error(error);
                    overallD.reject(error);
                    return ret;
                }
                return _getArrayAndKeys(collection, _keys, function() {
                    overallD.resolve();
                    return ret;
                }, function(array, keys) {
                    doChunk(collection, chunkSizeOrDontChunk, pauseMilli, chunk, pauseCb, overallD, index, keys);
                    return ret;
                });
            };
            map = function(collection, iterator, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, _keys) {
                var results;
                results = [];
                return _getArrayAndKeys(collection, _keys, function() {
                    return uiGmapPromise.resolve(results);
                }, function(array, keys) {
                    return each(collection, function(o) {
                        return results.push(iterator(o));
                    }, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, keys).then(function() {
                        return results;
                    });
                });
            };
            return {
                each: each,
                map: map,
                managePromiseQueue: managePromiseQueue,
                promiseLock: managePromiseQueue,
                defaultChunkSize: defaultChunkSize,
                chunkSizeFrom: function(fromSize, ret) {
                    if (ret == null) {
                        ret = void 0;
                    }
                    if (_.isNumber(fromSize)) {
                        ret = fromSize;
                    }
                    if (uiGmapGmapUtil.isFalse(fromSize) || fromSize === false) {
                        ret = false;
                    }
                    return ret;
                }
            };
        } ]);
    }).call(this);
    (function() {
        var indexOf = [].indexOf || function(item) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item) return i;
            }
            return -1;
        };
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapBaseObject", function() {
            var BaseObject, baseObjectKeywords;
            baseObjectKeywords = [ "extended", "included" ];
            BaseObject = function() {
                function BaseObject() {}
                BaseObject.extend = function(obj) {
                    var key, ref, value;
                    for (key in obj) {
                        value = obj[key];
                        if (indexOf.call(baseObjectKeywords, key) < 0) {
                            this[key] = value;
                        }
                    }
                    if ((ref = obj.extended) != null) {
                        ref.apply(this);
                    }
                    return this;
                };
                BaseObject.include = function(obj) {
                    var key, ref, value;
                    for (key in obj) {
                        value = obj[key];
                        if (indexOf.call(baseObjectKeywords, key) < 0) {
                            this.prototype[key] = value;
                        }
                    }
                    if ((ref = obj.included) != null) {
                        ref.apply(this);
                    }
                    return this;
                };
                return BaseObject;
            }();
            return BaseObject;
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapChildEvents", function() {
            return {
                onChildCreation: function(child) {}
            };
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapCtrlHandle", [ "$q", function($q) {
            var CtrlHandle;
            return CtrlHandle = {
                handle: function($scope, $element) {
                    $scope.$on("$destroy", function() {
                        return CtrlHandle.handle($scope);
                    });
                    $scope.deferred = $q.defer();
                    return {
                        getScope: function() {
                            return $scope;
                        }
                    };
                },
                mapPromise: function(scope, ctrl) {
                    var mapScope;
                    mapScope = ctrl.getScope();
                    mapScope.deferred.promise.then(function(map) {
                        return scope.map = map;
                    });
                    return mapScope.deferred.promise;
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapEventsHelper", [ "uiGmapLogger", function($log) {
            var _getEventsObj, _hasEvents;
            _hasEvents = function(obj) {
                return angular.isDefined(obj.events) && obj.events != null && angular.isObject(obj.events);
            };
            _getEventsObj = function(scope, model) {
                if (_hasEvents(scope)) {
                    return scope;
                }
                if (_hasEvents(model)) {
                    return model;
                }
            };
            return {
                setEvents: function(gObject, scope, model, ignores) {
                    var eventObj;
                    eventObj = _getEventsObj(scope, model);
                    if (eventObj != null) {
                        return _.compact(_.map(eventObj.events, function(eventHandler, eventName) {
                            var doIgnore;
                            if (ignores) {
                                doIgnore = _(ignores).contains(eventName);
                            }
                            if (eventObj.events.hasOwnProperty(eventName) && angular.isFunction(eventObj.events[eventName]) && !doIgnore) {
                                return google.maps.event.addListener(gObject, eventName, function() {
                                    if (!scope.$evalAsync) {
                                        scope.$evalAsync = function() {};
                                    }
                                    return scope.$evalAsync(eventHandler.apply(scope, [ gObject, eventName, model, arguments ]));
                                });
                            }
                        }));
                    }
                },
                removeEvents: function(listeners) {
                    var key, l;
                    if (!listeners) {
                        return;
                    }
                    for (key in listeners) {
                        l = listeners[key];
                        if (l) {
                            google.maps.event.removeListener(l);
                        }
                    }
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapFitHelper", [ "uiGmapLogger", function($log) {
            return {
                fit: function(markersOrPoints, gMap) {
                    var bounds, everSet, key, markerOrPoint, point;
                    if (gMap && (markersOrPoints != null ? markersOrPoints.length : void 0)) {
                        bounds = new google.maps.LatLngBounds();
                        everSet = false;
                        for (key in markersOrPoints) {
                            markerOrPoint = markersOrPoints[key];
                            if (markerOrPoint) {
                                if (!everSet) {
                                    everSet = true;
                                }
                                point = _.isFunction(markerOrPoint.getPosition) ? markerOrPoint.getPosition() : markerOrPoint;
                            }
                            bounds.extend(point);
                        }
                        if (everSet) {
                            return gMap.fitBounds(bounds);
                        }
                    }
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapGmapUtil", [ "uiGmapLogger", "$compile", function(Logger, $compile) {
            var _isFalse, _isTruthy, getCoords, getLatitude, getLongitude, validateCoords;
            _isTruthy = function(value, bool, optionsArray) {
                return value === bool || optionsArray.indexOf(value) !== -1;
            };
            _isFalse = function(value) {
                return _isTruthy(value, false, [ "false", "FALSE", 0, "n", "N", "no", "NO" ]);
            };
            getLatitude = function(value) {
                if (Array.isArray(value) && value.length === 2) {
                    return value[1];
                } else if (angular.isDefined(value.type) && value.type === "Point") {
                    return value.coordinates[1];
                } else {
                    return value.latitude;
                }
            };
            getLongitude = function(value) {
                if (Array.isArray(value) && value.length === 2) {
                    return value[0];
                } else if (angular.isDefined(value.type) && value.type === "Point") {
                    return value.coordinates[0];
                } else {
                    return value.longitude;
                }
            };
            getCoords = function(value) {
                if (!value) {
                    return;
                }
                if (Array.isArray(value) && value.length === 2) {
                    return new google.maps.LatLng(value[1], value[0]);
                } else if (angular.isDefined(value.type) && value.type === "Point") {
                    return new google.maps.LatLng(value.coordinates[1], value.coordinates[0]);
                } else {
                    return new google.maps.LatLng(value.latitude, value.longitude);
                }
            };
            validateCoords = function(coords) {
                if (angular.isUndefined(coords)) {
                    return false;
                }
                if (_.isArray(coords)) {
                    if (coords.length === 2) {
                        return true;
                    }
                } else if (coords != null && (coords != null ? coords.type : void 0)) {
                    if (coords.type === "Point" && _.isArray(coords.coordinates) && coords.coordinates.length === 2) {
                        return true;
                    }
                }
                if (coords && angular.isDefined((coords != null ? coords.latitude : void 0) && angular.isDefined(coords != null ? coords.longitude : void 0))) {
                    return true;
                }
                return false;
            };
            return {
                setCoordsFromEvent: function(prevValue, newLatLon) {
                    if (!prevValue) {
                        return;
                    }
                    if (Array.isArray(prevValue) && prevValue.length === 2) {
                        prevValue[1] = newLatLon.lat();
                        prevValue[0] = newLatLon.lng();
                    } else if (angular.isDefined(prevValue.type) && prevValue.type === "Point") {
                        prevValue.coordinates[1] = newLatLon.lat();
                        prevValue.coordinates[0] = newLatLon.lng();
                    } else {
                        prevValue.latitude = newLatLon.lat();
                        prevValue.longitude = newLatLon.lng();
                    }
                    return prevValue;
                },
                getLabelPositionPoint: function(anchor) {
                    var xPos, yPos;
                    if (anchor === void 0) {
                        return void 0;
                    }
                    anchor = /^([-\d\.]+)\s([-\d\.]+)$/.exec(anchor);
                    xPos = parseFloat(anchor[1]);
                    yPos = parseFloat(anchor[2]);
                    if (xPos != null && yPos != null) {
                        return new google.maps.Point(xPos, yPos);
                    }
                },
                createWindowOptions: function(gMarker, scope, content, defaults) {
                    var options;
                    if (content != null && defaults != null && $compile != null) {
                        options = angular.extend({}, defaults, {
                            content: this.buildContent(scope, defaults, content),
                            position: defaults.position != null ? defaults.position : angular.isObject(gMarker) ? gMarker.getPosition() : getCoords(scope.coords)
                        });
                        if (gMarker != null && (options != null ? options.pixelOffset : void 0) == null) {
                            if (options.boxClass == null) {} else {
                                options.pixelOffset = {
                                    height: 0,
                                    width: -2
                                };
                            }
                        }
                        return options;
                    } else {
                        if (!defaults) {
                            Logger.error("infoWindow defaults not defined");
                            if (!content) {
                                return Logger.error("infoWindow content not defined");
                            }
                        } else {
                            return defaults;
                        }
                    }
                },
                buildContent: function(scope, defaults, content) {
                    var parsed, ret;
                    if (defaults.content != null) {
                        ret = defaults.content;
                    } else {
                        if ($compile != null) {
                            content = content.replace(/^\s+|\s+$/g, "");
                            parsed = content === "" ? "" : $compile(content)(scope);
                            if (parsed.length > 0) {
                                ret = parsed[0];
                            }
                        } else {
                            ret = content;
                        }
                    }
                    return ret;
                },
                defaultDelay: 50,
                isTrue: function(value) {
                    return _isTruthy(value, true, [ "true", "TRUE", 1, "y", "Y", "yes", "YES" ]);
                },
                isFalse: _isFalse,
                isFalsy: function(value) {
                    return _isTruthy(value, false, [ void 0, null ]) || _isFalse(value);
                },
                getCoords: getCoords,
                validateCoords: validateCoords,
                equalCoords: function(coord1, coord2) {
                    return getLatitude(coord1) === getLatitude(coord2) && getLongitude(coord1) === getLongitude(coord2);
                },
                validatePath: function(path) {
                    var array, i, polygon, trackMaxVertices;
                    i = 0;
                    if (angular.isUndefined(path.type)) {
                        if (!Array.isArray(path) || path.length < 2) {
                            return false;
                        }
                        while (i < path.length) {
                            if (!(angular.isDefined(path[i].latitude) && angular.isDefined(path[i].longitude) || typeof path[i].lat === "function" && typeof path[i].lng === "function")) {
                                return false;
                            }
                            i++;
                        }
                        return true;
                    } else {
                        if (angular.isUndefined(path.coordinates)) {
                            return false;
                        }
                        if (path.type === "Polygon") {
                            if (path.coordinates[0].length < 4) {
                                return false;
                            }
                            array = path.coordinates[0];
                        } else if (path.type === "MultiPolygon") {
                            trackMaxVertices = {
                                max: 0,
                                index: 0
                            };
                            _.forEach(path.coordinates, function(polygon, index) {
                                if (polygon[0].length > this.max) {
                                    this.max = polygon[0].length;
                                    return this.index = index;
                                }
                            }, trackMaxVertices);
                            polygon = path.coordinates[trackMaxVertices.index];
                            array = polygon[0];
                            if (array.length < 4) {
                                return false;
                            }
                        } else if (path.type === "LineString") {
                            if (path.coordinates.length < 2) {
                                return false;
                            }
                            array = path.coordinates;
                        } else {
                            return false;
                        }
                        while (i < array.length) {
                            if (array[i].length !== 2) {
                                return false;
                            }
                            i++;
                        }
                        return true;
                    }
                },
                convertPathPoints: function(path) {
                    var array, i, latlng, result, trackMaxVertices;
                    i = 0;
                    result = new google.maps.MVCArray();
                    if (angular.isUndefined(path.type)) {
                        while (i < path.length) {
                            latlng;
                            if (angular.isDefined(path[i].latitude) && angular.isDefined(path[i].longitude)) {
                                latlng = new google.maps.LatLng(path[i].latitude, path[i].longitude);
                            } else if (typeof path[i].lat === "function" && typeof path[i].lng === "function") {
                                latlng = path[i];
                            }
                            result.push(latlng);
                            i++;
                        }
                    } else {
                        array;
                        if (path.type === "Polygon") {
                            array = path.coordinates[0];
                        } else if (path.type === "MultiPolygon") {
                            trackMaxVertices = {
                                max: 0,
                                index: 0
                            };
                            _.forEach(path.coordinates, function(polygon, index) {
                                if (polygon[0].length > this.max) {
                                    this.max = polygon[0].length;
                                    return this.index = index;
                                }
                            }, trackMaxVertices);
                            array = path.coordinates[trackMaxVertices.index][0];
                        } else if (path.type === "LineString") {
                            array = path.coordinates;
                        }
                        while (i < array.length) {
                            result.push(new google.maps.LatLng(array[i][1], array[i][0]));
                            i++;
                        }
                    }
                    return result;
                },
                getPath: function(object, key) {
                    var obj;
                    if (key == null || !_.isString(key)) {
                        return key;
                    }
                    obj = object;
                    _.each(key.split("."), function(value) {
                        if (obj) {
                            return obj = obj[value];
                        }
                    });
                    return obj;
                },
                validateBoundPoints: function(bounds) {
                    if (angular.isUndefined(bounds.sw.latitude) || angular.isUndefined(bounds.sw.longitude) || angular.isUndefined(bounds.ne.latitude) || angular.isUndefined(bounds.ne.longitude)) {
                        return false;
                    }
                    return true;
                },
                convertBoundPoints: function(bounds) {
                    var result;
                    result = new google.maps.LatLngBounds(new google.maps.LatLng(bounds.sw.latitude, bounds.sw.longitude), new google.maps.LatLng(bounds.ne.latitude, bounds.ne.longitude));
                    return result;
                },
                fitMapBounds: function(map, bounds) {
                    return map.fitBounds(bounds);
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapIsReady", [ "$q", "$timeout", function($q, $timeout) {
            var _checkIfReady, _ctr, _promises, _proms;
            _ctr = 0;
            _proms = [];
            _promises = function() {
                return $q.all(_proms);
            };
            _checkIfReady = function(deferred, expectedInstances, retriesLeft) {
                return $timeout(function() {
                    if (retriesLeft <= 0) {
                        deferred.reject("Your maps are not found we have checked the maximum amount of times. :)");
                        return;
                    }
                    if (_ctr !== expectedInstances) {
                        _checkIfReady(deferred, expectedInstances, retriesLeft - 1);
                    } else {
                        deferred.resolve(_promises());
                    }
                }, 100);
            };
            return {
                spawn: function() {
                    var d;
                    d = $q.defer();
                    _proms.push(d.promise);
                    _ctr += 1;
                    return {
                        instance: _ctr,
                        deferred: d
                    };
                },
                promises: _promises,
                instances: function() {
                    return _ctr;
                },
                promise: function(expectedInstances, numRetries) {
                    var d;
                    if (expectedInstances == null) {
                        expectedInstances = 1;
                    }
                    if (numRetries == null) {
                        numRetries = 50;
                    }
                    d = $q.defer();
                    _checkIfReady(d, expectedInstances, numRetries);
                    return d.promise;
                },
                reset: function() {
                    _ctr = 0;
                    _proms.length = 0;
                },
                decrement: function() {
                    if (_ctr > 0) {
                        _ctr -= 1;
                    }
                    if (_proms.length) {
                        _proms.length -= 1;
                    }
                }
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapLinked", [ "uiGmapBaseObject", function(BaseObject) {
            var Linked;
            Linked = function(superClass) {
                extend(Linked, superClass);
                function Linked(scope, element, attrs, ctrls) {
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.ctrls = ctrls;
                }
                return Linked;
            }(BaseObject);
            return Linked;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapLogger", [ "nemSimpleLogger", function(nemSimpleLogger) {
            return nemSimpleLogger.spawn();
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapModelKey", [ "uiGmapBaseObject", "uiGmapGmapUtil", "uiGmapPromise", "$q", "$timeout", function(BaseObject, GmapUtil, uiGmapPromise, $q, $timeout) {
            var ModelKey;
            return ModelKey = function(superClass) {
                extend(ModelKey, superClass);
                function ModelKey(scope1) {
                    this.scope = scope1;
                    this.modelsLength = bind(this.modelsLength, this);
                    this.updateChild = bind(this.updateChild, this);
                    this.destroy = bind(this.destroy, this);
                    this.onDestroy = bind(this.onDestroy, this);
                    this.setChildScope = bind(this.setChildScope, this);
                    this.getChanges = bind(this.getChanges, this);
                    this.getProp = bind(this.getProp, this);
                    this.setIdKey = bind(this.setIdKey, this);
                    this.modelKeyComparison = bind(this.modelKeyComparison, this);
                    ModelKey.__super__.constructor.call(this);
                    this["interface"] = {};
                    this["interface"].scopeKeys = [];
                    this.defaultIdKey = "id";
                    this.idKey = void 0;
                }
                ModelKey.prototype.evalModelHandle = function(model, modelKey) {
                    if (model == null || modelKey == null) {
                        return;
                    }
                    if (modelKey === "self") {
                        return model;
                    } else {
                        if (_.isFunction(modelKey)) {
                            modelKey = modelKey();
                        }
                        return GmapUtil.getPath(model, modelKey);
                    }
                };
                ModelKey.prototype.modelKeyComparison = function(model1, model2) {
                    var hasCoords, isEqual, scope;
                    hasCoords = _.contains(this["interface"].scopeKeys, "coords");
                    if (hasCoords && this.scope.coords != null || !hasCoords) {
                        scope = this.scope;
                    }
                    if (scope == null) {
                        throw "No scope set!";
                    }
                    if (hasCoords) {
                        isEqual = GmapUtil.equalCoords(this.scopeOrModelVal("coords", scope, model1), this.scopeOrModelVal("coords", scope, model2));
                        if (!isEqual) {
                            return isEqual;
                        }
                    }
                    isEqual = _.every(_.without(this["interface"].scopeKeys, "coords"), function(_this) {
                        return function(k) {
                            return _this.scopeOrModelVal(scope[k], scope, model1) === _this.scopeOrModelVal(scope[k], scope, model2);
                        };
                    }(this));
                    return isEqual;
                };
                ModelKey.prototype.setIdKey = function(scope) {
                    return this.idKey = scope.idKey != null ? scope.idKey : this.defaultIdKey;
                };
                ModelKey.prototype.setVal = function(model, key, newValue) {
                    var thingToSet;
                    thingToSet = this.modelOrKey(model, key);
                    thingToSet = newValue;
                    return model;
                };
                ModelKey.prototype.modelOrKey = function(model, key) {
                    if (key == null) {
                        return;
                    }
                    if (key !== "self") {
                        return GmapUtil.getPath(model, key);
                    }
                    return model;
                };
                ModelKey.prototype.getProp = function(propName, scope, model) {
                    return this.scopeOrModelVal(propName, scope, model);
                };
                ModelKey.prototype.getChanges = function(now, prev, whitelistedProps) {
                    var c, changes, prop;
                    if (whitelistedProps) {
                        prev = _.pick(prev, whitelistedProps);
                        now = _.pick(now, whitelistedProps);
                    }
                    changes = {};
                    prop = {};
                    c = {};
                    for (prop in now) {
                        if (!prev || prev[prop] !== now[prop]) {
                            if (_.isArray(now[prop])) {
                                changes[prop] = now[prop];
                            } else if (_.isObject(now[prop])) {
                                c = this.getChanges(now[prop], prev ? prev[prop] : null);
                                if (!_.isEmpty(c)) {
                                    changes[prop] = c;
                                }
                            } else {
                                changes[prop] = now[prop];
                            }
                        }
                    }
                    return changes;
                };
                ModelKey.prototype.scopeOrModelVal = function(key, scope, model, doWrap) {
                    var maybeWrap, modelKey, modelProp, scopeProp;
                    if (doWrap == null) {
                        doWrap = false;
                    }
                    maybeWrap = function(isScope, ret, doWrap) {
                        if (doWrap == null) {
                            doWrap = false;
                        }
                        if (doWrap) {
                            return {
                                isScope: isScope,
                                value: ret
                            };
                        }
                        return ret;
                    };
                    scopeProp = _.get(scope, key);
                    if (_.isFunction(scopeProp)) {
                        return maybeWrap(true, scopeProp(model), doWrap);
                    }
                    if (_.isObject(scopeProp)) {
                        return maybeWrap(true, scopeProp, doWrap);
                    }
                    if (!_.isString(scopeProp)) {
                        return maybeWrap(true, scopeProp, doWrap);
                    }
                    modelKey = scopeProp;
                    if (!modelKey) {
                        modelProp = _.get(model, key);
                    } else {
                        modelProp = modelKey === "self" ? model : _.get(model, modelKey);
                    }
                    if (_.isFunction(modelProp)) {
                        return maybeWrap(false, modelProp(), doWrap);
                    }
                    return maybeWrap(false, modelProp, doWrap);
                };
                ModelKey.prototype.setChildScope = function(keys, childScope, model) {
                    var isScopeObj, key, name, newValue;
                    for (key in keys) {
                        name = keys[key];
                        isScopeObj = this.scopeOrModelVal(name, childScope, model, true);
                        if ((isScopeObj != null ? isScopeObj.value : void 0) != null) {
                            newValue = isScopeObj.value;
                            if (newValue !== childScope[name]) {
                                childScope[name] = newValue;
                            }
                        }
                    }
                    return childScope.model = model;
                };
                ModelKey.prototype.onDestroy = function(scope) {};
                ModelKey.prototype.destroy = function(manualOverride) {
                    var ref;
                    if (manualOverride == null) {
                        manualOverride = false;
                    }
                    if (this.scope != null && !((ref = this.scope) != null ? ref.$$destroyed : void 0) && (this.needToManualDestroy || manualOverride)) {
                        return this.scope.$destroy();
                    } else {
                        return this.clean();
                    }
                };
                ModelKey.prototype.updateChild = function(child, model) {
                    if (model[this.idKey] == null) {
                        this.$log.error("Model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
                        return;
                    }
                    return child.updateModel(model);
                };
                ModelKey.prototype.modelsLength = function(arrayOrObjModels) {
                    var len, toCheck;
                    if (arrayOrObjModels == null) {
                        arrayOrObjModels = void 0;
                    }
                    len = 0;
                    toCheck = arrayOrObjModels ? arrayOrObjModels : this.scope.models;
                    if (toCheck == null) {
                        return len;
                    }
                    if (angular.isArray(toCheck) || toCheck.length != null) {
                        len = toCheck.length;
                    } else {
                        len = Object.keys(toCheck).length;
                    }
                    return len;
                };
                return ModelKey;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapModelsWatcher", [ "uiGmapLogger", "uiGmap_async", "$q", "uiGmapPromise", function(Logger, _async, $q, uiGmapPromise) {
            return {
                didQueueInitPromise: function(existingPiecesObj, scope) {
                    if (scope.models.length === 0) {
                        _async.promiseLock(existingPiecesObj, uiGmapPromise.promiseTypes.init, null, null, function(_this) {
                            return function() {
                                return uiGmapPromise.resolve();
                            };
                        }(this));
                        return true;
                    }
                    return false;
                },
                figureOutState: function(idKey, scope, childObjects, comparison, callBack) {
                    var adds, children, mappedScopeModelIds, removals, updates;
                    adds = [];
                    mappedScopeModelIds = {};
                    removals = [];
                    updates = [];
                    scope.models.forEach(function(m) {
                        var child;
                        if (m[idKey] != null) {
                            mappedScopeModelIds[m[idKey]] = {};
                            if (childObjects.get(m[idKey]) == null) {
                                return adds.push(m);
                            } else {
                                child = childObjects.get(m[idKey]);
                                if (!comparison(m, child.clonedModel, scope)) {
                                    return updates.push({
                                        model: m,
                                        child: child
                                    });
                                }
                            }
                        } else {
                            return Logger.error(" id missing for model #{m.toString()},\ncan not use do comparison/insertion");
                        }
                    });
                    children = childObjects.values();
                    children.forEach(function(c) {
                        var id;
                        if (c == null) {
                            Logger.error("child undefined in ModelsWatcher.");
                            return;
                        }
                        if (c.model == null) {
                            Logger.error("child.model undefined in ModelsWatcher.");
                            return;
                        }
                        id = c.model[idKey];
                        if (mappedScopeModelIds[id] == null) {
                            return removals.push(c);
                        }
                    });
                    return {
                        adds: adds,
                        removals: removals,
                        updates: updates
                    };
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapPromise", [ "$q", "$timeout", "uiGmapLogger", function($q, $timeout, $log) {
            var ExposedPromise, SniffedPromise, defer, isInProgress, isResolved, promise, promiseStatus, promiseStatuses, promiseTypes, resolve, strPromiseStatuses;
            promiseTypes = {
                create: "create",
                update: "update",
                delete: "delete",
                init: "init"
            };
            promiseStatuses = {
                IN_PROGRESS: 0,
                RESOLVED: 1,
                REJECTED: 2
            };
            strPromiseStatuses = function() {
                var obj;
                obj = {};
                obj["" + promiseStatuses.IN_PROGRESS] = "in-progress";
                obj["" + promiseStatuses.RESOLVED] = "resolved";
                obj["" + promiseStatuses.REJECTED] = "rejected";
                return obj;
            }();
            isInProgress = function(promise) {
                if (promise.$$state) {
                    return promise.$$state.status === promiseStatuses.IN_PROGRESS;
                }
                if (!promise.hasOwnProperty("$$v")) {
                    return true;
                }
            };
            isResolved = function(promise) {
                if (promise.$$state) {
                    return promise.$$state.status === promiseStatuses.RESOLVED;
                }
                if (promise.hasOwnProperty("$$v")) {
                    return true;
                }
            };
            promiseStatus = function(status) {
                return strPromiseStatuses[status] || "done w error";
            };
            ExposedPromise = function(promise) {
                var cancelDeferred, combined, wrapped;
                cancelDeferred = $q.defer();
                combined = $q.all([ promise, cancelDeferred.promise ]);
                wrapped = $q.defer();
                promise.then(cancelDeferred.resolve, function() {}, function(notify) {
                    cancelDeferred.notify(notify);
                    return wrapped.notify(notify);
                });
                combined.then(function(successes) {
                    return wrapped.resolve(successes[0] || successes[1]);
                }, function(error) {
                    return wrapped.reject(error);
                });
                wrapped.promise.cancel = function(reason) {
                    if (reason == null) {
                        reason = "canceled";
                    }
                    return cancelDeferred.reject(reason);
                };
                wrapped.promise.notify = function(msg) {
                    if (msg == null) {
                        msg = "cancel safe";
                    }
                    wrapped.notify(msg);
                    if (promise.hasOwnProperty("notify")) {
                        return promise.notify(msg);
                    }
                };
                if (promise.promiseType != null) {
                    wrapped.promise.promiseType = promise.promiseType;
                }
                return wrapped.promise;
            };
            SniffedPromise = function(fnPromise, promiseType) {
                return {
                    promise: fnPromise,
                    promiseType: promiseType
                };
            };
            defer = function() {
                return $q.defer();
            };
            resolve = function() {
                var d;
                d = $q.defer();
                d.resolve.apply(void 0, arguments);
                return d.promise;
            };
            promise = function(fnToWrap) {
                var d;
                if (!_.isFunction(fnToWrap)) {
                    $log.error("uiGmapPromise.promise() only accepts functions");
                    return;
                }
                d = $q.defer();
                $timeout(function() {
                    var result;
                    result = fnToWrap();
                    return d.resolve(result);
                });
                return d.promise;
            };
            return {
                defer: defer,
                promise: promise,
                resolve: resolve,
                promiseTypes: promiseTypes,
                isInProgress: isInProgress,
                isResolved: isResolved,
                promiseStatus: promiseStatus,
                ExposedPromise: ExposedPromise,
                SniffedPromise: SniffedPromise
            };
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapPropMap", function() {
            var PropMap;
            return PropMap = function() {
                function PropMap() {
                    this.removeAll = bind(this.removeAll, this);
                    this.slice = bind(this.slice, this);
                    this.push = bind(this.push, this);
                    this.keys = bind(this.keys, this);
                    this.values = bind(this.values, this);
                    this.remove = bind(this.remove, this);
                    this.put = bind(this.put, this);
                    this.stateChanged = bind(this.stateChanged, this);
                    this.get = bind(this.get, this);
                    this.length = 0;
                    this.dict = {};
                    this.didValsStateChange = false;
                    this.didKeysStateChange = false;
                    this.allVals = [];
                    this.allKeys = [];
                }
                PropMap.prototype.get = function(key) {
                    return this.dict[key];
                };
                PropMap.prototype.stateChanged = function() {
                    this.didValsStateChange = true;
                    return this.didKeysStateChange = true;
                };
                PropMap.prototype.put = function(key, value) {
                    if (this.get(key) == null) {
                        this.length++;
                    }
                    this.stateChanged();
                    return this.dict[key] = value;
                };
                PropMap.prototype.remove = function(key, isSafe) {
                    var value;
                    if (isSafe == null) {
                        isSafe = false;
                    }
                    if (isSafe && !this.get(key)) {
                        return void 0;
                    }
                    value = this.dict[key];
                    delete this.dict[key];
                    this.length--;
                    this.stateChanged();
                    return value;
                };
                PropMap.prototype.valuesOrKeys = function(str) {
                    var keys, vals;
                    if (str == null) {
                        str = "Keys";
                    }
                    if (!this["did" + str + "StateChange"]) {
                        return this["all" + str];
                    }
                    vals = [];
                    keys = [];
                    _.each(this.dict, function(v, k) {
                        vals.push(v);
                        return keys.push(k);
                    });
                    this.didKeysStateChange = false;
                    this.didValsStateChange = false;
                    this.allVals = vals;
                    this.allKeys = keys;
                    return this["all" + str];
                };
                PropMap.prototype.values = function() {
                    return this.valuesOrKeys("Vals");
                };
                PropMap.prototype.keys = function() {
                    return this.valuesOrKeys();
                };
                PropMap.prototype.push = function(obj, key) {
                    if (key == null) {
                        key = "key";
                    }
                    return this.put(obj[key], obj);
                };
                PropMap.prototype.slice = function() {
                    return this.keys().map(function(_this) {
                        return function(k) {
                            return _this.remove(k);
                        };
                    }(this));
                };
                PropMap.prototype.removeAll = function() {
                    return this.slice();
                };
                PropMap.prototype.each = function(cb) {
                    return _.each(this.dict, function(v, k) {
                        return cb(v);
                    });
                };
                PropMap.prototype.map = function(cb) {
                    return _.map(this.dict, function(v, k) {
                        return cb(v);
                    });
                };
                return PropMap;
            }();
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapPropertyAction", [ "uiGmapLogger", function(Logger) {
            var PropertyAction;
            PropertyAction = function(setterFn) {
                this.setIfChange = function(newVal, oldVal) {
                    var callingKey;
                    callingKey = this.exp;
                    if (!_.isEqual(oldVal, newVal)) {
                        return setterFn(callingKey, newVal);
                    }
                };
                this.sic = this.setIfChange;
                return this;
            };
            return PropertyAction;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.managers").factory("uiGmapClustererMarkerManager", [ "uiGmapLogger", "uiGmapFitHelper", "uiGmapPropMap", "uiGmapEventsHelper", function($log, FitHelper, PropMap, EventsHelper) {
            var ClustererMarkerManager;
            ClustererMarkerManager = function() {
                ClustererMarkerManager.type = "ClustererMarkerManager";
                function ClustererMarkerManager(gMap, opt_markers, opt_options, opt_events) {
                    if (opt_markers == null) {
                        opt_markers = {};
                    }
                    this.opt_options = opt_options != null ? opt_options : {};
                    this.opt_events = opt_events;
                    this.checkSync = bind(this.checkSync, this);
                    this.getGMarkers = bind(this.getGMarkers, this);
                    this.fit = bind(this.fit, this);
                    this.destroy = bind(this.destroy, this);
                    this.attachEvents = bind(this.attachEvents, this);
                    this.clear = bind(this.clear, this);
                    this.draw = bind(this.draw, this);
                    this.removeMany = bind(this.removeMany, this);
                    this.remove = bind(this.remove, this);
                    this.addMany = bind(this.addMany, this);
                    this.update = bind(this.update, this);
                    this.add = bind(this.add, this);
                    this.type = ClustererMarkerManager.type;
                    this.clusterer = new NgMapMarkerClusterer(gMap, opt_markers, this.opt_options);
                    this.propMapGMarkers = new PropMap();
                    this.attachEvents(this.opt_events, "opt_events");
                    this.clusterer.setIgnoreHidden(true);
                    this.noDrawOnSingleAddRemoves = true;
                    $log.info(this);
                }
                ClustererMarkerManager.prototype.checkKey = function(gMarker) {
                    var msg;
                    if (gMarker.key == null) {
                        msg = "gMarker.key undefined and it is REQUIRED!!";
                        return $log.error(msg);
                    }
                };
                ClustererMarkerManager.prototype.add = function(gMarker) {
                    this.checkKey(gMarker);
                    this.clusterer.addMarker(gMarker, this.noDrawOnSingleAddRemoves);
                    this.propMapGMarkers.put(gMarker.key, gMarker);
                    return this.checkSync();
                };
                ClustererMarkerManager.prototype.update = function(gMarker) {
                    this.remove(gMarker);
                    return this.add(gMarker);
                };
                ClustererMarkerManager.prototype.addMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.add(gMarker);
                        };
                    }(this));
                };
                ClustererMarkerManager.prototype.remove = function(gMarker) {
                    var exists;
                    this.checkKey(gMarker);
                    exists = this.propMapGMarkers.get(gMarker.key);
                    if (exists) {
                        this.clusterer.removeMarker(gMarker, this.noDrawOnSingleAddRemoves);
                        this.propMapGMarkers.remove(gMarker.key);
                    }
                    return this.checkSync();
                };
                ClustererMarkerManager.prototype.removeMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.remove(gMarker);
                        };
                    }(this));
                };
                ClustererMarkerManager.prototype.draw = function() {
                    return this.clusterer.repaint();
                };
                ClustererMarkerManager.prototype.clear = function() {
                    this.removeMany(this.getGMarkers());
                    return this.clusterer.repaint();
                };
                ClustererMarkerManager.prototype.attachEvents = function(options, optionsName) {
                    var eventHandler, eventName, results;
                    this.listeners = [];
                    if (angular.isDefined(options) && options != null && angular.isObject(options)) {
                        results = [];
                        for (eventName in options) {
                            eventHandler = options[eventName];
                            if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                                $log.info(optionsName + ": Attaching event: " + eventName + " to clusterer");
                                results.push(this.listeners.push(google.maps.event.addListener(this.clusterer, eventName, options[eventName])));
                            } else {
                                results.push(void 0);
                            }
                        }
                        return results;
                    }
                };
                ClustererMarkerManager.prototype.clearEvents = function() {
                    EventsHelper.removeEvents(this.listeners);
                    return this.listeners = [];
                };
                ClustererMarkerManager.prototype.destroy = function() {
                    this.clearEvents();
                    return this.clear();
                };
                ClustererMarkerManager.prototype.fit = function() {
                    return FitHelper.fit(this.getGMarkers(), this.clusterer.getMap());
                };
                ClustererMarkerManager.prototype.getGMarkers = function() {
                    return this.clusterer.getMarkers().values();
                };
                ClustererMarkerManager.prototype.checkSync = function() {};
                return ClustererMarkerManager;
            }();
            return ClustererMarkerManager;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.managers").factory("uiGmapMarkerManager", [ "uiGmapLogger", "uiGmapFitHelper", "uiGmapPropMap", function(Logger, FitHelper, PropMap) {
            var MarkerManager;
            MarkerManager = function() {
                MarkerManager.type = "MarkerManager";
                function MarkerManager(gMap, opt_markers, opt_options) {
                    this.getGMarkers = bind(this.getGMarkers, this);
                    this.fit = bind(this.fit, this);
                    this.handleOptDraw = bind(this.handleOptDraw, this);
                    this.clear = bind(this.clear, this);
                    this.destroy = bind(this.destroy, this);
                    this.draw = bind(this.draw, this);
                    this.removeMany = bind(this.removeMany, this);
                    this.remove = bind(this.remove, this);
                    this.addMany = bind(this.addMany, this);
                    this.update = bind(this.update, this);
                    this.add = bind(this.add, this);
                    this.type = MarkerManager.type;
                    this.gMap = gMap;
                    this.gMarkers = new PropMap();
                    this.$log = Logger;
                    this.$log.info(this);
                }
                MarkerManager.prototype.add = function(gMarker, optDraw) {
                    var exists, msg;
                    if (optDraw == null) {
                        optDraw = true;
                    }
                    if (gMarker.key == null) {
                        msg = "gMarker.key undefined and it is REQUIRED!!";
                        Logger.error(msg);
                        throw msg;
                    }
                    exists = this.gMarkers.get(gMarker.key);
                    if (!exists) {
                        this.handleOptDraw(gMarker, optDraw, true);
                        return this.gMarkers.put(gMarker.key, gMarker);
                    }
                };
                MarkerManager.prototype.update = function(gMarker, optDraw) {
                    if (optDraw == null) {
                        optDraw = true;
                    }
                    this.remove(gMarker, optDraw);
                    return this.add(gMarker, optDraw);
                };
                MarkerManager.prototype.addMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.add(gMarker);
                        };
                    }(this));
                };
                MarkerManager.prototype.remove = function(gMarker, optDraw) {
                    if (optDraw == null) {
                        optDraw = true;
                    }
                    this.handleOptDraw(gMarker, optDraw, false);
                    if (this.gMarkers.get(gMarker.key)) {
                        return this.gMarkers.remove(gMarker.key);
                    }
                };
                MarkerManager.prototype.removeMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(marker) {
                            return _this.remove(marker);
                        };
                    }(this));
                };
                MarkerManager.prototype.draw = function() {
                    var deletes;
                    deletes = [];
                    this.gMarkers.each(function(_this) {
                        return function(gMarker) {
                            if (!gMarker.isDrawn) {
                                if (gMarker.doAdd) {
                                    gMarker.setMap(_this.gMap);
                                    return gMarker.isDrawn = true;
                                } else {
                                    return deletes.push(gMarker);
                                }
                            }
                        };
                    }(this));
                    return deletes.forEach(function(_this) {
                        return function(gMarker) {
                            gMarker.isDrawn = false;
                            return _this.remove(gMarker, true);
                        };
                    }(this));
                };
                MarkerManager.prototype.destroy = function() {
                    return this.clear();
                };
                MarkerManager.prototype.clear = function() {
                    this.gMarkers.each(function(gMarker) {
                        return gMarker.setMap(null);
                    });
                    delete this.gMarkers;
                    return this.gMarkers = new PropMap();
                };
                MarkerManager.prototype.handleOptDraw = function(gMarker, optDraw, doAdd) {
                    if (optDraw === true) {
                        if (doAdd) {
                            gMarker.setMap(this.gMap);
                        } else {
                            gMarker.setMap(null);
                        }
                        return gMarker.isDrawn = true;
                    } else {
                        gMarker.isDrawn = false;
                        return gMarker.doAdd = doAdd;
                    }
                };
                MarkerManager.prototype.fit = function() {
                    return FitHelper.fit(this.getGMarkers(), this.gMap);
                };
                MarkerManager.prototype.getGMarkers = function() {
                    return this.gMarkers.values();
                };
                return MarkerManager;
            }();
            return MarkerManager;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.managers").factory("uiGmapSpiderfierMarkerManager", [ "uiGmapLogger", "uiGmapFitHelper", "uiGmapPropMap", "uiGmapMarkerSpiderfier", function($log, FitHelper, PropMap, MarkerSpiderfier) {
            var SpiderfierMarkerManager;
            return SpiderfierMarkerManager = function() {
                SpiderfierMarkerManager.type = "SpiderfierMarkerManager";
                function SpiderfierMarkerManager(gMap, opt_markers, opt_options, opt_events, scope) {
                    if (opt_markers == null) {
                        opt_markers = {};
                    }
                    this.opt_options = opt_options != null ? opt_options : {};
                    this.opt_events = opt_events;
                    this.scope = scope;
                    this.checkSync = bind(this.checkSync, this);
                    this.isSpiderfied = bind(this.isSpiderfied, this);
                    this.getGMarkers = bind(this.getGMarkers, this);
                    this.fit = bind(this.fit, this);
                    this.destroy = bind(this.destroy, this);
                    this.attachEvents = bind(this.attachEvents, this);
                    this.clear = bind(this.clear, this);
                    this.draw = bind(this.draw, this);
                    this.removeMany = bind(this.removeMany, this);
                    this.remove = bind(this.remove, this);
                    this.addMany = bind(this.addMany, this);
                    this.update = bind(this.update, this);
                    this.add = bind(this.add, this);
                    this.type = SpiderfierMarkerManager.type;
                    this.markerSpiderfier = new MarkerSpiderfier(gMap, this.opt_options);
                    this.propMapGMarkers = new PropMap();
                    this.attachEvents(this.opt_events, "opt_events");
                    this.noDrawOnSingleAddRemoves = true;
                    $log.info(this);
                }
                SpiderfierMarkerManager.prototype.checkKey = function(gMarker) {
                    var msg;
                    if (gMarker.key == null) {
                        msg = "gMarker.key undefined and it is REQUIRED!!";
                        return $log.error(msg);
                    }
                };
                SpiderfierMarkerManager.prototype.add = function(gMarker) {
                    gMarker.setMap(this.markerSpiderfier.map);
                    this.checkKey(gMarker);
                    this.markerSpiderfier.addMarker(gMarker, this.noDrawOnSingleAddRemoves);
                    this.propMapGMarkers.put(gMarker.key, gMarker);
                    return this.checkSync();
                };
                SpiderfierMarkerManager.prototype.update = function(gMarker) {
                    this.remove(gMarker);
                    return this.add(gMarker);
                };
                SpiderfierMarkerManager.prototype.addMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.add(gMarker);
                        };
                    }(this));
                };
                SpiderfierMarkerManager.prototype.remove = function(gMarker) {
                    var exists;
                    this.checkKey(gMarker);
                    exists = this.propMapGMarkers.get(gMarker.key);
                    if (exists) {
                        gMarker.setMap(null);
                        this.markerSpiderfier.removeMarker(gMarker, this.noDrawOnSingleAddRemoves);
                        this.propMapGMarkers.remove(gMarker.key);
                    }
                    return this.checkSync();
                };
                SpiderfierMarkerManager.prototype.removeMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.remove(gMarker);
                        };
                    }(this));
                };
                SpiderfierMarkerManager.prototype.draw = function() {};
                SpiderfierMarkerManager.prototype.clear = function() {
                    return this.removeMany(this.getGMarkers());
                };
                SpiderfierMarkerManager.prototype.attachEvents = function(options, optionsName) {
                    if (angular.isDefined(options) && options != null && angular.isObject(options)) {
                        return _.each(options, function(_this) {
                            return function(eventHandler, eventName) {
                                if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                                    $log.info(optionsName + ": Attaching event: " + eventName + " to markerSpiderfier");
                                    return _this.markerSpiderfier.addListener(eventName, function() {
                                        if (eventName === "spiderfy" || eventName === "unspiderfy") {
                                            return _this.scope.$evalAsync(options[eventName].apply(options, arguments));
                                        } else {
                                            return _this.scope.$evalAsync(options[eventName].apply(options, [ arguments[0], eventName, arguments[0].model, arguments ]));
                                        }
                                    });
                                }
                            };
                        }(this));
                    }
                };
                SpiderfierMarkerManager.prototype.clearEvents = function(options, optionsName) {
                    var eventHandler, eventName;
                    if (angular.isDefined(options) && options != null && angular.isObject(options)) {
                        for (eventName in options) {
                            eventHandler = options[eventName];
                            if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                                $log.info(optionsName + ": Clearing event: " + eventName + " to markerSpiderfier");
                                this.markerSpiderfier.clearListeners(eventName);
                            }
                        }
                    }
                };
                SpiderfierMarkerManager.prototype.destroy = function() {
                    this.clearEvents(this.opt_events, "opt_events");
                    return this.clear();
                };
                SpiderfierMarkerManager.prototype.fit = function() {
                    return FitHelper.fit(this.getGMarkers(), this.markerSpiderfier.map);
                };
                SpiderfierMarkerManager.prototype.getGMarkers = function() {
                    return this.markerSpiderfier.getMarkers();
                };
                SpiderfierMarkerManager.prototype.isSpiderfied = function() {
                    return _.find(this.getGMarkers(), function(gMarker) {
                        return (gMarker != null ? gMarker._omsData : void 0) != null;
                    });
                };
                SpiderfierMarkerManager.prototype.checkSync = function() {};
                return SpiderfierMarkerManager;
            }();
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").factory("uiGmapadd-events", [ "$timeout", function($timeout) {
            var addEvent, addEvents;
            addEvent = function(target, eventName, handler) {
                return google.maps.event.addListener(target, eventName, function() {
                    handler.apply(this, arguments);
                    return $timeout(function() {}, true);
                });
            };
            addEvents = function(target, eventName, handler) {
                var remove;
                if (handler) {
                    return addEvent(target, eventName, handler);
                }
                remove = [];
                angular.forEach(eventName, function(_handler, key) {
                    return remove.push(addEvent(target, key, _handler));
                });
                return function() {
                    angular.forEach(remove, function(listener) {
                        return google.maps.event.removeListener(listener);
                    });
                    return remove = null;
                };
            };
            return addEvents;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").factory("uiGmaparray-sync", [ "uiGmapadd-events", function(mapEvents) {
            return function(mapArray, scope, pathEval, pathChangedFn) {
                var geojsonArray, geojsonHandlers, geojsonWatcher, isSetFromScope, legacyHandlers, legacyWatcher, mapArrayListener, scopePath, watchListener;
                isSetFromScope = false;
                scopePath = scope.$eval(pathEval);
                if (!scope["static"]) {
                    legacyHandlers = {
                        set_at: function(index) {
                            var value;
                            if (isSetFromScope) {
                                return;
                            }
                            value = mapArray.getAt(index);
                            if (!value) {
                                return;
                            }
                            if (!value.lng || !value.lat) {
                                return scopePath[index] = value;
                            } else {
                                scopePath[index].latitude = value.lat();
                                return scopePath[index].longitude = value.lng();
                            }
                        },
                        insert_at: function(index) {
                            var value;
                            if (isSetFromScope) {
                                return;
                            }
                            value = mapArray.getAt(index);
                            if (!value) {
                                return;
                            }
                            if (!value.lng || !value.lat) {
                                return scopePath.splice(index, 0, value);
                            } else {
                                return scopePath.splice(index, 0, {
                                    latitude: value.lat(),
                                    longitude: value.lng()
                                });
                            }
                        },
                        remove_at: function(index) {
                            if (isSetFromScope) {
                                return;
                            }
                            return scopePath.splice(index, 1);
                        }
                    };
                    geojsonArray;
                    if (scopePath.type === "Polygon") {
                        geojsonArray = scopePath.coordinates[0];
                    } else if (scopePath.type === "LineString") {
                        geojsonArray = scopePath.coordinates;
                    }
                    geojsonHandlers = {
                        set_at: function(index) {
                            var value;
                            if (isSetFromScope) {
                                return;
                            }
                            value = mapArray.getAt(index);
                            if (!value) {
                                return;
                            }
                            if (!value.lng || !value.lat) {
                                return;
                            }
                            geojsonArray[index][1] = value.lat();
                            return geojsonArray[index][0] = value.lng();
                        },
                        insert_at: function(index) {
                            var value;
                            if (isSetFromScope) {
                                return;
                            }
                            value = mapArray.getAt(index);
                            if (!value) {
                                return;
                            }
                            if (!value.lng || !value.lat) {
                                return;
                            }
                            return geojsonArray.splice(index, 0, [ value.lng(), value.lat() ]);
                        },
                        remove_at: function(index) {
                            if (isSetFromScope) {
                                return;
                            }
                            return geojsonArray.splice(index, 1);
                        }
                    };
                    mapArrayListener = mapEvents(mapArray, angular.isUndefined(scopePath.type) ? legacyHandlers : geojsonHandlers);
                }
                legacyWatcher = function(newPath) {
                    var changed, i, l, newLength, newValue, oldArray, oldLength, oldValue;
                    isSetFromScope = true;
                    oldArray = mapArray;
                    changed = false;
                    if (newPath) {
                        i = 0;
                        oldLength = oldArray.getLength();
                        newLength = newPath.length;
                        l = Math.min(oldLength, newLength);
                        newValue = void 0;
                        while (i < l) {
                            oldValue = oldArray.getAt(i);
                            newValue = newPath[i];
                            if (typeof newValue.equals === "function") {
                                if (!newValue.equals(oldValue)) {
                                    oldArray.setAt(i, newValue);
                                    changed = true;
                                }
                            } else {
                                if (oldValue.lat() !== newValue.latitude || oldValue.lng() !== newValue.longitude) {
                                    oldArray.setAt(i, new google.maps.LatLng(newValue.latitude, newValue.longitude));
                                    changed = true;
                                }
                            }
                            i++;
                        }
                        while (i < newLength) {
                            newValue = newPath[i];
                            if (typeof newValue.lat === "function" && typeof newValue.lng === "function") {
                                oldArray.push(newValue);
                            } else {
                                oldArray.push(new google.maps.LatLng(newValue.latitude, newValue.longitude));
                            }
                            changed = true;
                            i++;
                        }
                        while (i < oldLength) {
                            oldArray.pop();
                            changed = true;
                            i++;
                        }
                    }
                    isSetFromScope = false;
                    if (changed) {
                        return pathChangedFn(oldArray);
                    }
                };
                geojsonWatcher = function(newPath) {
                    var array, changed, i, l, newLength, newValue, oldArray, oldLength, oldValue;
                    isSetFromScope = true;
                    oldArray = mapArray;
                    changed = false;
                    if (newPath) {
                        array;
                        if (scopePath.type === "Polygon") {
                            array = newPath.coordinates[0];
                        } else if (scopePath.type === "LineString") {
                            array = newPath.coordinates;
                        }
                        i = 0;
                        oldLength = oldArray.getLength();
                        newLength = array.length;
                        l = Math.min(oldLength, newLength);
                        newValue = void 0;
                        while (i < l) {
                            oldValue = oldArray.getAt(i);
                            newValue = array[i];
                            if (oldValue.lat() !== newValue[1] || oldValue.lng() !== newValue[0]) {
                                oldArray.setAt(i, new google.maps.LatLng(newValue[1], newValue[0]));
                                changed = true;
                            }
                            i++;
                        }
                        while (i < newLength) {
                            newValue = array[i];
                            oldArray.push(new google.maps.LatLng(newValue[1], newValue[0]));
                            changed = true;
                            i++;
                        }
                        while (i < oldLength) {
                            oldArray.pop();
                            changed = true;
                            i++;
                        }
                    }
                    isSetFromScope = false;
                    if (changed) {
                        return pathChangedFn(oldArray);
                    }
                };
                watchListener;
                if (!scope["static"]) {
                    if (angular.isUndefined(scopePath.type)) {
                        watchListener = scope.$watchCollection(pathEval, legacyWatcher);
                    } else {
                        watchListener = scope.$watch(pathEval, geojsonWatcher, true);
                    }
                }
                return function() {
                    if (mapArrayListener) {
                        mapArrayListener();
                        mapArrayListener = null;
                    }
                    if (watchListener) {
                        watchListener();
                        return watchListener = null;
                    }
                };
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapChromeFixes", [ "$timeout", function($timeout) {
            return {
                maybeRepaint: function(el) {
                    if (el) {
                        el.style.opacity = .9;
                        return $timeout(function() {
                            return el.style.opacity = 1;
                        });
                    }
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").service("uiGmapObjectIterators", function() {
            var _ignores, _iterators, _slapForEach, _slapMap;
            _ignores = [ "length", "forEach", "map" ];
            _iterators = [];
            _slapForEach = function(object) {
                object.forEach = function(cb) {
                    return _.each(_.omit(object, _ignores), function(val) {
                        if (!_.isFunction(val)) {
                            return cb(val);
                        }
                    });
                };
                return object;
            };
            _iterators.push(_slapForEach);
            _slapMap = function(object) {
                object.map = function(cb) {
                    return _.map(_.omit(object, _ignores), function(val) {
                        if (!_.isFunction(val)) {
                            return cb(val);
                        }
                    });
                };
                return object;
            };
            _iterators.push(_slapMap);
            return {
                slapMap: _slapMap,
                slapForEach: _slapForEach,
                slapAll: function(object) {
                    _iterators.forEach(function(it) {
                        return it(object);
                    });
                    return object;
                }
            };
        });
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.options.builders").service("uiGmapCommonOptionsBuilder", [ "uiGmapBaseObject", "uiGmapLogger", "uiGmapModelKey", function(BaseObject, $log, ModelKey) {
            var CommonOptionsBuilder;
            return CommonOptionsBuilder = function(superClass) {
                extend(CommonOptionsBuilder, superClass);
                function CommonOptionsBuilder() {
                    this.watchProps = bind(this.watchProps, this);
                    this.buildOpts = bind(this.buildOpts, this);
                    return CommonOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                CommonOptionsBuilder.prototype.props = [ "clickable", "draggable", "editable", "visible", {
                    prop: "stroke",
                    isColl: true
                } ];
                CommonOptionsBuilder.prototype.getCorrectModel = function(scope) {
                    if (angular.isDefined(scope != null ? scope.model : void 0)) {
                        return scope.model;
                    } else {
                        return scope;
                    }
                };
                CommonOptionsBuilder.prototype.buildOpts = function(customOpts, cachedEval, forEachOpts) {
                    var model, opts, stroke;
                    if (customOpts == null) {
                        customOpts = {};
                    }
                    if (forEachOpts == null) {
                        forEachOpts = {};
                    }
                    if (!this.scope) {
                        $log.error("this.scope not defined in CommonOptionsBuilder can not buildOpts");
                        return;
                    }
                    if (!this.map) {
                        $log.error("this.map not defined in CommonOptionsBuilder can not buildOpts");
                        return;
                    }
                    model = this.getCorrectModel(this.scope);
                    stroke = this.scopeOrModelVal("stroke", this.scope, model);
                    opts = angular.extend(customOpts, this.DEFAULTS, {
                        map: this.map,
                        strokeColor: stroke != null ? stroke.color : void 0,
                        strokeOpacity: stroke != null ? stroke.opacity : void 0,
                        strokeWeight: stroke != null ? stroke.weight : void 0
                    });
                    angular.forEach(angular.extend(forEachOpts, {
                        clickable: true,
                        draggable: false,
                        editable: false,
                        static: false,
                        fit: false,
                        visible: true,
                        zIndex: 0,
                        icons: []
                    }), function(_this) {
                        return function(defaultValue, key) {
                            var val;
                            val = cachedEval ? cachedEval[key] : _this.scopeOrModelVal(key, _this.scope, model);
                            if (angular.isUndefined(val)) {
                                return opts[key] = defaultValue;
                            } else {
                                return opts[key] = model[key];
                            }
                        };
                    }(this));
                    if (opts["static"]) {
                        opts.editable = false;
                    }
                    return opts;
                };
                CommonOptionsBuilder.prototype.watchProps = function(props) {
                    if (props == null) {
                        props = this.props;
                    }
                    return props.forEach(function(_this) {
                        return function(prop) {
                            if (_this.attrs[prop] != null || _this.attrs[prop != null ? prop.prop : void 0] != null) {
                                if (prop != null ? prop.isColl : void 0) {
                                    return _this.scope.$watchCollection(prop.prop, _this.setMyOptions);
                                } else {
                                    return _this.scope.$watch(prop, _this.setMyOptions);
                                }
                            }
                        };
                    }(this));
                };
                return CommonOptionsBuilder;
            }(ModelKey);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.options.builders").factory("uiGmapPolylineOptionsBuilder", [ "uiGmapCommonOptionsBuilder", function(CommonOptionsBuilder) {
            var PolylineOptionsBuilder;
            return PolylineOptionsBuilder = function(superClass) {
                extend(PolylineOptionsBuilder, superClass);
                function PolylineOptionsBuilder() {
                    return PolylineOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                PolylineOptionsBuilder.prototype.buildOpts = function(pathPoints, cachedEval) {
                    return PolylineOptionsBuilder.__super__.buildOpts.call(this, {
                        path: pathPoints
                    }, cachedEval, {
                        geodesic: false
                    });
                };
                return PolylineOptionsBuilder;
            }(CommonOptionsBuilder);
        } ]).factory("uiGmapShapeOptionsBuilder", [ "uiGmapCommonOptionsBuilder", function(CommonOptionsBuilder) {
            var ShapeOptionsBuilder;
            return ShapeOptionsBuilder = function(superClass) {
                extend(ShapeOptionsBuilder, superClass);
                function ShapeOptionsBuilder() {
                    return ShapeOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                ShapeOptionsBuilder.prototype.buildOpts = function(customOpts, cachedEval, forEachOpts) {
                    var fill, model;
                    model = this.getCorrectModel(this.scope);
                    fill = cachedEval ? cachedEval["fill"] : this.scopeOrModelVal("fill", this.scope, model);
                    customOpts = angular.extend(customOpts, {
                        fillColor: fill != null ? fill.color : void 0,
                        fillOpacity: fill != null ? fill.opacity : void 0
                    });
                    return ShapeOptionsBuilder.__super__.buildOpts.call(this, customOpts, cachedEval, forEachOpts);
                };
                return ShapeOptionsBuilder;
            }(CommonOptionsBuilder);
        } ]).factory("uiGmapPolygonOptionsBuilder", [ "uiGmapShapeOptionsBuilder", function(ShapeOptionsBuilder) {
            var PolygonOptionsBuilder;
            return PolygonOptionsBuilder = function(superClass) {
                extend(PolygonOptionsBuilder, superClass);
                function PolygonOptionsBuilder() {
                    return PolygonOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                PolygonOptionsBuilder.prototype.buildOpts = function(pathPoints, cachedEval) {
                    return PolygonOptionsBuilder.__super__.buildOpts.call(this, {
                        path: pathPoints
                    }, cachedEval, {
                        geodesic: false
                    });
                };
                return PolygonOptionsBuilder;
            }(ShapeOptionsBuilder);
        } ]).factory("uiGmapRectangleOptionsBuilder", [ "uiGmapShapeOptionsBuilder", function(ShapeOptionsBuilder) {
            var RectangleOptionsBuilder;
            return RectangleOptionsBuilder = function(superClass) {
                extend(RectangleOptionsBuilder, superClass);
                function RectangleOptionsBuilder() {
                    return RectangleOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                RectangleOptionsBuilder.prototype.buildOpts = function(bounds, cachedEval) {
                    return RectangleOptionsBuilder.__super__.buildOpts.call(this, {
                        bounds: bounds
                    }, cachedEval);
                };
                return RectangleOptionsBuilder;
            }(ShapeOptionsBuilder);
        } ]).factory("uiGmapCircleOptionsBuilder", [ "uiGmapShapeOptionsBuilder", function(ShapeOptionsBuilder) {
            var CircleOptionsBuilder;
            return CircleOptionsBuilder = function(superClass) {
                extend(CircleOptionsBuilder, superClass);
                function CircleOptionsBuilder() {
                    return CircleOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                CircleOptionsBuilder.prototype.buildOpts = function(center, radius, cachedEval) {
                    return CircleOptionsBuilder.__super__.buildOpts.call(this, {
                        center: center,
                        radius: radius
                    }, cachedEval);
                };
                return CircleOptionsBuilder;
            }(ShapeOptionsBuilder);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.options").service("uiGmapMarkerOptions", [ "uiGmapLogger", "uiGmapGmapUtil", function($log, GmapUtil) {
            return _.extend(GmapUtil, {
                createOptions: function(coords, icon, defaults, map) {
                    var opts;
                    if (defaults == null) {
                        defaults = {};
                    }
                    opts = angular.extend({}, defaults, {
                        position: defaults.position != null ? defaults.position : GmapUtil.getCoords(coords),
                        visible: defaults.visible != null ? defaults.visible : GmapUtil.validateCoords(coords)
                    });
                    if (defaults.icon != null || icon != null) {
                        opts = angular.extend(opts, {
                            icon: defaults.icon != null ? defaults.icon : icon
                        });
                    }
                    if (map != null) {
                        opts.map = map;
                    }
                    return opts;
                },
                isLabel: function(options) {
                    if (options == null) {
                        return false;
                    }
                    return options.labelContent != null || options.labelAnchor != null || options.labelClass != null || options.labelStyle != null || options.labelVisible != null;
                }
            });
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapBasePolyChildModel", [ "uiGmapLogger", "$timeout", "uiGmaparray-sync", "uiGmapGmapUtil", "uiGmapEventsHelper", function($log, $timeout, arraySync, GmapUtil, EventsHelper) {
            return function(Builder, gFactory) {
                var BasePolyChildModel;
                return BasePolyChildModel = function(superClass) {
                    extend(BasePolyChildModel, superClass);
                    BasePolyChildModel.include(GmapUtil);
                    function BasePolyChildModel(scope, attrs, map, defaults, model, gObjectChangeCb) {
                        var create;
                        this.scope = scope;
                        this.attrs = attrs;
                        this.map = map;
                        this.defaults = defaults;
                        this.model = model;
                        this.clean = bind(this.clean, this);
                        this.clonedModel = _.clone(this.model, true);
                        this.isDragging = false;
                        this.internalEvents = {
                            dragend: function(_this) {
                                return function() {
                                    return _.defer(function() {
                                        return _this.isDragging = false;
                                    });
                                };
                            }(this),
                            dragstart: function(_this) {
                                return function() {
                                    return _this.isDragging = true;
                                };
                            }(this)
                        };
                        create = function(_this) {
                            return function() {
                                var maybeCachedEval;
                                if (_this.isDragging) {
                                    return;
                                }
                                _this.pathPoints = _this.convertPathPoints(_this.scope.path);
                                if (_this.gObject != null) {
                                    _this.clean();
                                }
                                if (_this.scope.model != null) {
                                    maybeCachedEval = _this.scope;
                                }
                                if (_this.pathPoints.length > 0) {
                                    _this.gObject = gFactory(_this.buildOpts(_this.pathPoints, maybeCachedEval));
                                }
                                if (_this.gObject) {
                                    arraySync(_this.gObject.getPath(), _this.scope, "path", function(pathPoints) {
                                        _this.pathPoints = pathPoints;
                                        if (gObjectChangeCb != null) {
                                            return gObjectChangeCb();
                                        }
                                    });
                                    if (angular.isDefined(_this.scope.events) && angular.isObject(_this.scope.events)) {
                                        _this.listeners = _this.model ? EventsHelper.setEvents(_this.gObject, _this.scope, _this.model) : EventsHelper.setEvents(_this.gObject, _this.scope, _this.scope);
                                    }
                                    return _this.internalListeners = _this.model ? EventsHelper.setEvents(_this.gObject, {
                                        events: _this.internalEvents
                                    }, _this.model) : EventsHelper.setEvents(_this.gObject, {
                                        events: _this.internalEvents
                                    }, _this.scope);
                                }
                            };
                        }(this);
                        create();
                        this.scope.$watch("path", function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue) || !_this.gObject) {
                                    return create();
                                }
                            };
                        }(this), true);
                        if (!this.scope["static"] && angular.isDefined(this.scope.editable)) {
                            this.scope.$watch("editable", function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        newValue = !_this.isFalse(newValue);
                                        return (ref = _this.gObject) != null ? ref.setEditable(newValue) : void 0;
                                    }
                                };
                            }(this), true);
                        }
                        if (angular.isDefined(this.scope.draggable)) {
                            this.scope.$watch("draggable", function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        newValue = !_this.isFalse(newValue);
                                        return (ref = _this.gObject) != null ? ref.setDraggable(newValue) : void 0;
                                    }
                                };
                            }(this), true);
                        }
                        if (angular.isDefined(this.scope.visible)) {
                            this.scope.$watch("visible", function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        newValue = !_this.isFalse(newValue);
                                    }
                                    return (ref = _this.gObject) != null ? ref.setVisible(newValue) : void 0;
                                };
                            }(this), true);
                        }
                        if (angular.isDefined(this.scope.geodesic)) {
                            this.scope.$watch("geodesic", function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        newValue = !_this.isFalse(newValue);
                                        return (ref = _this.gObject) != null ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                                    }
                                };
                            }(this), true);
                        }
                        if (angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.weight)) {
                            this.scope.$watch("stroke.weight", function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        return (ref = _this.gObject) != null ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                                    }
                                };
                            }(this), true);
                        }
                        if (angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.color)) {
                            this.scope.$watch("stroke.color", function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        return (ref = _this.gObject) != null ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                                    }
                                };
                            }(this), true);
                        }
                        if (angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.opacity)) {
                            this.scope.$watch("stroke.opacity", function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        return (ref = _this.gObject) != null ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                                    }
                                };
                            }(this), true);
                        }
                        if (angular.isDefined(this.scope.icons)) {
                            this.scope.$watch("icons", function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        return (ref = _this.gObject) != null ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                                    }
                                };
                            }(this), true);
                        }
                        this.scope.$on("$destroy", function(_this) {
                            return function() {
                                _this.clean();
                                return _this.scope = null;
                            };
                        }(this));
                        if (angular.isDefined(this.scope.fill) && angular.isDefined(this.scope.fill.color)) {
                            this.scope.$watch("fill.color", function(_this) {
                                return function(newValue, oldValue) {
                                    if (newValue !== oldValue) {
                                        return _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath()));
                                    }
                                };
                            }(this));
                        }
                        if (angular.isDefined(this.scope.fill) && angular.isDefined(this.scope.fill.opacity)) {
                            this.scope.$watch("fill.opacity", function(_this) {
                                return function(newValue, oldValue) {
                                    if (newValue !== oldValue) {
                                        return _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath()));
                                    }
                                };
                            }(this));
                        }
                        if (angular.isDefined(this.scope.zIndex)) {
                            this.scope.$watch("zIndex", function(_this) {
                                return function(newValue, oldValue) {
                                    if (newValue !== oldValue) {
                                        return _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath()));
                                    }
                                };
                            }(this));
                        }
                    }
                    BasePolyChildModel.prototype.clean = function() {
                        var ref;
                        EventsHelper.removeEvents(this.listeners);
                        EventsHelper.removeEvents(this.internalListeners);
                        if ((ref = this.gObject) != null) {
                            ref.setMap(null);
                        }
                        return this.gObject = null;
                    };
                    return BasePolyChildModel;
                }(Builder);
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.models.child").factory("uiGmapDrawFreeHandChildModel", [ "uiGmapLogger", "$q", function($log, $q) {
            var drawFreeHand, freeHandMgr;
            drawFreeHand = function(map, polys, done) {
                var move, poly;
                poly = new google.maps.Polyline({
                    map: map,
                    clickable: false
                });
                move = google.maps.event.addListener(map, "mousemove", function(e) {
                    return poly.getPath().push(e.latLng);
                });
                google.maps.event.addListenerOnce(map, "mouseup", function(e) {
                    var path;
                    google.maps.event.removeListener(move);
                    path = poly.getPath();
                    poly.setMap(null);
                    polys.push(new google.maps.Polygon({
                        map: map,
                        path: path
                    }));
                    poly = null;
                    google.maps.event.clearListeners(map.getDiv(), "mousedown");
                    return done();
                });
                return void 0;
            };
            freeHandMgr = function(map1, scope) {
                var disableMap, enableMap;
                this.map = map1;
                disableMap = function(_this) {
                    return function() {
                        var mapOptions;
                        mapOptions = {
                            draggable: false,
                            disableDefaultUI: true,
                            scrollwheel: false,
                            disableDoubleClickZoom: false
                        };
                        $log.info("disabling map move");
                        return _this.map.setOptions(mapOptions);
                    };
                }(this);
                enableMap = function(_this) {
                    return function() {
                        var mapOptions, ref;
                        mapOptions = {
                            draggable: true,
                            disableDefaultUI: false,
                            scrollwheel: true,
                            disableDoubleClickZoom: true
                        };
                        if ((ref = _this.deferred) != null) {
                            ref.resolve();
                        }
                        return _.defer(function() {
                            return _this.map.setOptions(_.extend(mapOptions, scope.options));
                        });
                    };
                }(this);
                this.engage = function(_this) {
                    return function(polys1) {
                        _this.polys = polys1;
                        _this.deferred = $q.defer();
                        disableMap();
                        $log.info("DrawFreeHandChildModel is engaged (drawing).");
                        google.maps.event.addDomListener(_this.map.getDiv(), "mousedown", function(e) {
                            return drawFreeHand(_this.map, _this.polys, enableMap);
                        });
                        return _this.deferred.promise;
                    };
                }(this);
                return this;
            };
            return freeHandMgr;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.child").factory("uiGmapMarkerChildModel", [ "uiGmapModelKey", "uiGmapGmapUtil", "uiGmapLogger", "uiGmapEventsHelper", "uiGmapPropertyAction", "uiGmapMarkerOptions", "uiGmapIMarker", "uiGmapMarkerManager", "uiGmapPromise", function(ModelKey, GmapUtil, $log, EventsHelper, PropertyAction, MarkerOptions, IMarker, MarkerManager, uiGmapPromise) {
            var MarkerChildModel;
            MarkerChildModel = function(superClass) {
                var destroy;
                extend(MarkerChildModel, superClass);
                MarkerChildModel.include(GmapUtil);
                MarkerChildModel.include(EventsHelper);
                MarkerChildModel.include(MarkerOptions);
                destroy = function(child) {
                    if ((child != null ? child.gObject : void 0) != null) {
                        child.removeEvents(child.externalListeners);
                        child.removeEvents(child.internalListeners);
                        if (child != null ? child.gObject : void 0) {
                            if (child.removeFromManager) {
                                child.gManager.remove(child.gObject);
                            }
                            child.gObject.setMap(null);
                            return child.gObject = null;
                        }
                    }
                };
                function MarkerChildModel(scope, model1, keys, gMap, defaults, doClick, gManager, doDrawSelf, trackModel, needRedraw) {
                    var action;
                    this.model = model1;
                    this.keys = keys;
                    this.gMap = gMap;
                    this.defaults = defaults;
                    this.doClick = doClick;
                    this.gManager = gManager;
                    this.doDrawSelf = doDrawSelf != null ? doDrawSelf : true;
                    this.trackModel = trackModel != null ? trackModel : true;
                    this.needRedraw = needRedraw != null ? needRedraw : false;
                    this.internalEvents = bind(this.internalEvents, this);
                    this.setLabelOptions = bind(this.setLabelOptions, this);
                    this.setOptions = bind(this.setOptions, this);
                    this.setIcon = bind(this.setIcon, this);
                    this.setCoords = bind(this.setCoords, this);
                    this.isNotValid = bind(this.isNotValid, this);
                    this.maybeSetScopeValue = bind(this.maybeSetScopeValue, this);
                    this.createMarker = bind(this.createMarker, this);
                    this.setMyScope = bind(this.setMyScope, this);
                    this.updateModel = bind(this.updateModel, this);
                    this.handleModelChanges = bind(this.handleModelChanges, this);
                    this.destroy = bind(this.destroy, this);
                    this.clonedModel = _.clone(this.model, true);
                    this.deferred = uiGmapPromise.defer();
                    _.each(this.keys, function(_this) {
                        return function(v, k) {
                            var keyValue;
                            keyValue = _this.keys[k];
                            if (keyValue != null && !_.isFunction(keyValue) && _.isString(keyValue)) {
                                return _this[k + "Key"] = keyValue;
                            }
                        };
                    }(this));
                    this.idKey = this.idKeyKey || "id";
                    if (this.model[this.idKey] != null) {
                        this.id = this.model[this.idKey];
                    }
                    MarkerChildModel.__super__.constructor.call(this, scope);
                    this.scope.getGMarker = function(_this) {
                        return function() {
                            return _this.gObject;
                        };
                    }(this);
                    this.firstTime = true;
                    if (this.trackModel) {
                        this.scope.model = this.model;
                        this.scope.$watch("model", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) {
                                    return _this.handleModelChanges(newValue, oldValue);
                                }
                            };
                        }(this), true);
                    } else {
                        action = new PropertyAction(function(_this) {
                            return function(calledKey, newVal) {
                                if (!_this.firstTime) {
                                    return _this.setMyScope(calledKey, scope);
                                }
                            };
                        }(this), false);
                        _.each(this.keys, function(v, k) {
                            return scope.$watch(k, action.sic, true);
                        });
                    }
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return destroy(_this);
                        };
                    }(this));
                    this.createMarker(this.model);
                    $log.info(this);
                }
                MarkerChildModel.prototype.destroy = function(removeFromManager) {
                    if (removeFromManager == null) {
                        removeFromManager = true;
                    }
                    this.removeFromManager = removeFromManager;
                    return this.scope.$destroy();
                };
                MarkerChildModel.prototype.handleModelChanges = function(newValue, oldValue) {
                    var changes, ctr, len;
                    changes = this.getChanges(newValue, oldValue, IMarker.keys);
                    if (!this.firstTime) {
                        ctr = 0;
                        len = _.keys(changes).length;
                        return _.each(changes, function(_this) {
                            return function(v, k) {
                                var doDraw;
                                ctr += 1;
                                doDraw = len === ctr;
                                _this.setMyScope(k, newValue, oldValue, false, true, doDraw);
                                return _this.needRedraw = true;
                            };
                        }(this));
                    }
                };
                MarkerChildModel.prototype.updateModel = function(model) {
                    this.clonedModel = _.clone(model, true);
                    return this.setMyScope("all", model, this.model);
                };
                MarkerChildModel.prototype.renderGMarker = function(doDraw, validCb) {
                    var coords, isSpiderfied, ref;
                    if (doDraw == null) {
                        doDraw = true;
                    }
                    coords = this.getProp("coords", this.scope, this.model);
                    if (((ref = this.gManager) != null ? ref.isSpiderfied : void 0) != null) {
                        isSpiderfied = this.gManager.isSpiderfied();
                    }
                    if (coords != null) {
                        if (!this.validateCoords(coords)) {
                            $log.debug("MarkerChild does not have coords yet. They may be defined later.");
                            return;
                        }
                        if (validCb != null) {
                            validCb();
                        }
                        if (doDraw && this.gObject) {
                            this.gManager.add(this.gObject);
                        }
                        if (isSpiderfied) {
                            return this.gManager.markerSpiderfier.spiderListener(this.gObject, window.event);
                        }
                    } else {
                        if (doDraw && this.gObject) {
                            return this.gManager.remove(this.gObject);
                        }
                    }
                };
                MarkerChildModel.prototype.setMyScope = function(thingThatChanged, model, oldModel, isInit, doDraw) {
                    var justCreated;
                    if (oldModel == null) {
                        oldModel = void 0;
                    }
                    if (isInit == null) {
                        isInit = false;
                    }
                    if (doDraw == null) {
                        doDraw = true;
                    }
                    if (model == null) {
                        model = this.model;
                    } else {
                        this.model = model;
                    }
                    if (!this.gObject) {
                        this.setOptions(this.scope, doDraw);
                        justCreated = true;
                    }
                    switch (thingThatChanged) {
                      case "all":
                        return _.each(this.keys, function(_this) {
                            return function(v, k) {
                                return _this.setMyScope(k, model, oldModel, isInit, doDraw);
                            };
                        }(this));

                      case "icon":
                        return this.maybeSetScopeValue("icon", model, oldModel, this.iconKey, this.evalModelHandle, isInit, this.setIcon, doDraw);

                      case "coords":
                        return this.maybeSetScopeValue("coords", model, oldModel, this.coordsKey, this.evalModelHandle, isInit, this.setCoords, doDraw);

                      case "options":
                        if (!justCreated) {
                            return this.createMarker(model, oldModel, isInit, doDraw);
                        }
                    }
                };
                MarkerChildModel.prototype.createMarker = function(model, oldModel, isInit, doDraw) {
                    if (oldModel == null) {
                        oldModel = void 0;
                    }
                    if (isInit == null) {
                        isInit = false;
                    }
                    if (doDraw == null) {
                        doDraw = true;
                    }
                    this.maybeSetScopeValue("options", model, oldModel, this.optionsKey, this.evalModelHandle, isInit, this.setOptions, doDraw);
                    return this.firstTime = false;
                };
                MarkerChildModel.prototype.maybeSetScopeValue = function(scopePropName, model, oldModel, modelKey, evaluate, isInit, gSetter, doDraw) {
                    if (gSetter == null) {
                        gSetter = void 0;
                    }
                    if (doDraw == null) {
                        doDraw = true;
                    }
                    if (gSetter != null) {
                        return gSetter(this.scope, doDraw);
                    }
                };
                if (MarkerChildModel.doDrawSelf && doDraw) {
                    MarkerChildModel.gManager.draw();
                }
                MarkerChildModel.prototype.isNotValid = function(scope, doCheckGmarker) {
                    var hasIdenticalScopes, hasNoGmarker;
                    if (doCheckGmarker == null) {
                        doCheckGmarker = true;
                    }
                    hasNoGmarker = !doCheckGmarker ? false : this.gObject === void 0;
                    hasIdenticalScopes = !this.trackModel ? scope.$id !== this.scope.$id : false;
                    return hasIdenticalScopes || hasNoGmarker;
                };
                MarkerChildModel.prototype.setCoords = function(scope, doDraw) {
                    if (doDraw == null) {
                        doDraw = true;
                    }
                    if (this.isNotValid(scope) || this.gObject == null) {
                        return;
                    }
                    return this.renderGMarker(doDraw, function(_this) {
                        return function() {
                            var newGValue, newModelVal, oldGValue;
                            newModelVal = _this.getProp("coords", scope, _this.model);
                            newGValue = _this.getCoords(newModelVal);
                            oldGValue = _this.gObject.getPosition();
                            if (oldGValue != null && newGValue != null) {
                                if (newGValue.lng() === oldGValue.lng() && newGValue.lat() === oldGValue.lat()) {
                                    return;
                                }
                            }
                            _this.gObject.setPosition(newGValue);
                            return _this.gObject.setVisible(_this.validateCoords(newModelVal));
                        };
                    }(this));
                };
                MarkerChildModel.prototype.setIcon = function(scope, doDraw) {
                    if (doDraw == null) {
                        doDraw = true;
                    }
                    if (this.isNotValid(scope) || this.gObject == null) {
                        return;
                    }
                    return this.renderGMarker(doDraw, function(_this) {
                        return function() {
                            var coords, newValue, oldValue;
                            oldValue = _this.gObject.getIcon();
                            newValue = _this.getProp("icon", scope, _this.model);
                            if (oldValue === newValue) {
                                return;
                            }
                            _this.gObject.setIcon(newValue);
                            coords = _this.getProp("coords", scope, _this.model);
                            _this.gObject.setPosition(_this.getCoords(coords));
                            return _this.gObject.setVisible(_this.validateCoords(coords));
                        };
                    }(this));
                };
                MarkerChildModel.prototype.setOptions = function(scope, doDraw) {
                    var ref;
                    if (doDraw == null) {
                        doDraw = true;
                    }
                    if (this.isNotValid(scope, false)) {
                        return;
                    }
                    this.renderGMarker(doDraw, function(_this) {
                        return function() {
                            var _options, coords, icon;
                            coords = _this.getProp("coords", scope, _this.model);
                            icon = _this.getProp("icon", scope, _this.model);
                            _options = _this.getProp("options", scope, _this.model);
                            _this.opts = _this.createOptions(coords, icon, _options);
                            if (_this.isLabel(_this.gObject) !== _this.isLabel(_this.opts) && _this.gObject != null) {
                                _this.gManager.remove(_this.gObject);
                                _this.gObject = void 0;
                            }
                            if (_this.gObject != null) {
                                _this.gObject.setOptions(_this.setLabelOptions(_this.opts));
                            }
                            if (!_this.gObject) {
                                if (_this.isLabel(_this.opts)) {
                                    _this.gObject = new MarkerWithLabel(_this.setLabelOptions(_this.opts));
                                } else if (_this.opts.content) {
                                    _this.gObject = new RichMarker(_this.opts);
                                    _this.gObject.getIcon = _this.gObject.getContent;
                                    _this.gObject.setIcon = _this.gObject.setContent;
                                } else {
                                    _this.gObject = new google.maps.Marker(_this.opts);
                                }
                                _.extend(_this.gObject, {
                                    model: _this.model
                                });
                            }
                            if (_this.externalListeners) {
                                _this.removeEvents(_this.externalListeners);
                            }
                            if (_this.internalListeners) {
                                _this.removeEvents(_this.internalListeners);
                            }
                            _this.externalListeners = _this.setEvents(_this.gObject, _this.scope, _this.model, [ "dragend" ]);
                            _this.internalListeners = _this.setEvents(_this.gObject, {
                                events: _this.internalEvents(),
                                $evalAsync: function() {}
                            }, _this.model);
                            if (_this.id != null) {
                                return _this.gObject.key = _this.id;
                            }
                        };
                    }(this));
                    if (this.gObject && (this.gObject.getMap() || this.gManager.type !== MarkerManager.type)) {
                        this.deferred.resolve(this.gObject);
                    } else {
                        if (!this.gObject) {
                            return this.deferred.reject("gObject is null");
                        }
                        if (!(((ref = this.gObject) != null ? ref.getMap() : void 0) && this.gManager.type === MarkerManager.type)) {
                            $log.debug("gObject has no map yet");
                            this.deferred.resolve(this.gObject);
                        }
                    }
                    if (this.model[this.fitKey]) {
                        return this.gManager.fit();
                    }
                };
                MarkerChildModel.prototype.setLabelOptions = function(opts) {
                    if (opts.labelAnchor) {
                        opts.labelAnchor = this.getLabelPositionPoint(opts.labelAnchor);
                    }
                    return opts;
                };
                MarkerChildModel.prototype.internalEvents = function() {
                    return {
                        dragend: function(_this) {
                            return function(marker, eventName, model, mousearg) {
                                var events, modelToSet, newCoords;
                                modelToSet = _this.trackModel ? _this.scope.model : _this.model;
                                newCoords = _this.setCoordsFromEvent(_this.modelOrKey(modelToSet, _this.coordsKey), _this.gObject.getPosition());
                                modelToSet = _this.setVal(model, _this.coordsKey, newCoords);
                                events = _this.scope.events;
                                if ((events != null ? events.dragend : void 0) != null) {
                                    events.dragend(marker, eventName, modelToSet, mousearg);
                                }
                                return _this.scope.$apply();
                            };
                        }(this),
                        click: function(_this) {
                            return function(marker, eventName, model, mousearg) {
                                var click;
                                click = _this.getProp("click", _this.scope, _this.model);
                                if (_this.doClick && click != null) {
                                    return _this.scope.$evalAsync(click(marker, eventName, _this.model, mousearg));
                                }
                            };
                        }(this)
                    };
                };
                return MarkerChildModel;
            }(ModelKey);
            return MarkerChildModel;
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolygonChildModel", [ "uiGmapBasePolyChildModel", "uiGmapPolygonOptionsBuilder", function(BaseGen, Builder) {
            var PolygonChildModel, base, gFactory;
            gFactory = function(opts) {
                return new google.maps.Polygon(opts);
            };
            base = new BaseGen(Builder, gFactory);
            return PolygonChildModel = function(superClass) {
                extend(PolygonChildModel, superClass);
                function PolygonChildModel() {
                    return PolygonChildModel.__super__.constructor.apply(this, arguments);
                }
                return PolygonChildModel;
            }(base);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolylineChildModel", [ "uiGmapBasePolyChildModel", "uiGmapPolylineOptionsBuilder", function(BaseGen, Builder) {
            var PolylineChildModel, base, gFactory;
            gFactory = function(opts) {
                return new google.maps.Polyline(opts);
            };
            base = BaseGen(Builder, gFactory);
            return PolylineChildModel = function(superClass) {
                extend(PolylineChildModel, superClass);
                function PolylineChildModel() {
                    return PolylineChildModel.__super__.constructor.apply(this, arguments);
                }
                return PolylineChildModel;
            }(base);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.child").factory("uiGmapWindowChildModel", [ "uiGmapBaseObject", "uiGmapGmapUtil", "uiGmapLogger", "$compile", "$http", "$templateCache", "uiGmapChromeFixes", "uiGmapEventsHelper", function(BaseObject, GmapUtil, $log, $compile, $http, $templateCache, ChromeFixes, EventsHelper) {
            var WindowChildModel;
            WindowChildModel = function(superClass) {
                extend(WindowChildModel, superClass);
                WindowChildModel.include(GmapUtil);
                WindowChildModel.include(EventsHelper);
                function WindowChildModel(model1, scope1, opts, isIconVisibleOnClick, mapCtrl, markerScope, element, needToManualDestroy, markerIsVisibleAfterWindowClose) {
                    var maybeMarker;
                    this.model = model1;
                    this.scope = scope1;
                    this.opts = opts;
                    this.isIconVisibleOnClick = isIconVisibleOnClick;
                    this.mapCtrl = mapCtrl;
                    this.markerScope = markerScope;
                    this.element = element;
                    this.needToManualDestroy = needToManualDestroy != null ? needToManualDestroy : false;
                    this.markerIsVisibleAfterWindowClose = markerIsVisibleAfterWindowClose != null ? markerIsVisibleAfterWindowClose : true;
                    this.updateModel = bind(this.updateModel, this);
                    this.destroy = bind(this.destroy, this);
                    this.remove = bind(this.remove, this);
                    this.getLatestPosition = bind(this.getLatestPosition, this);
                    this.hideWindow = bind(this.hideWindow, this);
                    this.showWindow = bind(this.showWindow, this);
                    this.handleClick = bind(this.handleClick, this);
                    this.watchOptions = bind(this.watchOptions, this);
                    this.watchCoords = bind(this.watchCoords, this);
                    this.createGWin = bind(this.createGWin, this);
                    this.watchElement = bind(this.watchElement, this);
                    this.watchAndDoShow = bind(this.watchAndDoShow, this);
                    this.doShow = bind(this.doShow, this);
                    this.clonedModel = _.clone(this.model, true);
                    this.getGmarker = function() {
                        var ref, ref1;
                        if (((ref = this.markerScope) != null ? ref["getGMarker"] : void 0) != null) {
                            return (ref1 = this.markerScope) != null ? ref1.getGMarker() : void 0;
                        }
                    };
                    this.listeners = [];
                    this.createGWin();
                    maybeMarker = this.getGmarker();
                    if (maybeMarker != null) {
                        maybeMarker.setClickable(true);
                    }
                    this.watchElement();
                    this.watchOptions();
                    this.watchCoords();
                    this.watchAndDoShow();
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return _this.destroy();
                        };
                    }(this));
                    $log.info(this);
                }
                WindowChildModel.prototype.doShow = function(wasOpen) {
                    if (this.scope.show === true || wasOpen) {
                        return this.showWindow();
                    } else {
                        return this.hideWindow();
                    }
                };
                WindowChildModel.prototype.watchAndDoShow = function() {
                    if (this.model.show != null) {
                        this.scope.show = this.model.show;
                    }
                    this.scope.$watch("show", this.doShow, true);
                    return this.doShow();
                };
                WindowChildModel.prototype.watchElement = function() {
                    return this.scope.$watch(function(_this) {
                        return function() {
                            var ref, wasOpen;
                            if (!(_this.element || _this.html)) {
                                return;
                            }
                            if (_this.html !== _this.element.html() && _this.gObject) {
                                if ((ref = _this.opts) != null) {
                                    ref.content = void 0;
                                }
                                wasOpen = _this.gObject.isOpen();
                                _this.remove();
                                return _this.createGWin(wasOpen);
                            }
                        };
                    }(this));
                };
                WindowChildModel.prototype.createGWin = function(isOpen) {
                    var _opts, defaults, maybeMarker, ref, ref1;
                    if (isOpen == null) {
                        isOpen = false;
                    }
                    maybeMarker = this.getGmarker();
                    defaults = {};
                    if (this.opts != null) {
                        if (this.scope.coords) {
                            this.opts.position = this.getCoords(this.scope.coords);
                        }
                        defaults = this.opts;
                    }
                    if (this.element) {
                        this.html = _.isObject(this.element) ? this.element.html() : this.element;
                    }
                    _opts = this.scope.options ? this.scope.options : defaults;
                    this.opts = this.createWindowOptions(maybeMarker, this.markerScope || this.scope, this.html, _opts);
                    if (this.opts != null) {
                        if (!this.gObject) {
                            if (this.opts.boxClass && (window.InfoBox && typeof window.InfoBox === "function")) {
                                this.gObject = new window.InfoBox(this.opts);
                            } else {
                                this.gObject = new google.maps.InfoWindow(this.opts);
                            }
                            this.listeners.push(google.maps.event.addListener(this.gObject, "domready", function() {
                                return ChromeFixes.maybeRepaint(this.content);
                            }));
                            this.listeners.push(google.maps.event.addListener(this.gObject, "closeclick", function(_this) {
                                return function() {
                                    if (maybeMarker) {
                                        maybeMarker.setAnimation(_this.oldMarkerAnimation);
                                        if (_this.markerIsVisibleAfterWindowClose) {
                                            _.delay(function() {
                                                maybeMarker.setVisible(false);
                                                return maybeMarker.setVisible(_this.markerIsVisibleAfterWindowClose);
                                            }, 250);
                                        }
                                    }
                                    _this.gObject.close();
                                    _this.model.show = false;
                                    if (_this.scope.closeClick != null) {
                                        return _this.scope.$evalAsync(_this.scope.closeClick());
                                    } else {
                                        return _this.scope.$evalAsync();
                                    }
                                };
                            }(this)));
                        }
                        this.gObject.setContent(this.opts.content);
                        this.handleClick(((ref = this.scope) != null ? (ref1 = ref.options) != null ? ref1.forceClick : void 0 : void 0) || isOpen);
                        return this.doShow(this.gObject.isOpen());
                    }
                };
                WindowChildModel.prototype.watchCoords = function() {
                    var scope;
                    scope = this.markerScope != null ? this.markerScope : this.scope;
                    return scope.$watch("coords", function(_this) {
                        return function(newValue, oldValue) {
                            var pos;
                            if (newValue !== oldValue) {
                                if (newValue == null) {
                                    _this.hideWindow();
                                } else if (!_this.validateCoords(newValue)) {
                                    $log.error("WindowChildMarker cannot render marker as scope.coords as no position on marker: " + JSON.stringify(_this.model));
                                    return;
                                }
                                pos = _this.getCoords(newValue);
                                _this.doShow();
                                _this.gObject.setPosition(pos);
                                if (_this.opts) {
                                    return _this.opts.position = pos;
                                }
                            }
                        };
                    }(this), true);
                };
                WindowChildModel.prototype.watchOptions = function() {
                    return this.scope.$watch("options", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                _this.opts = newValue;
                                if (_this.gObject != null) {
                                    _this.gObject.setOptions(_this.opts);
                                    if (_this.opts.visible != null && _this.opts.visible) {
                                        return _this.showWindow();
                                    } else if (_this.opts.visible != null) {
                                        return _this.hideWindow();
                                    }
                                }
                            }
                        };
                    }(this), true);
                };
                WindowChildModel.prototype.handleClick = function(forceClick) {
                    var click, maybeMarker;
                    if (this.gObject == null) {
                        return;
                    }
                    maybeMarker = this.getGmarker();
                    click = function(_this) {
                        return function() {
                            if (_this.gObject == null) {
                                _this.createGWin();
                            }
                            _this.showWindow();
                            if (maybeMarker != null) {
                                _this.initialMarkerVisibility = maybeMarker.getVisible();
                                _this.oldMarkerAnimation = maybeMarker.getAnimation();
                                return maybeMarker.setVisible(_this.isIconVisibleOnClick);
                            }
                        };
                    }(this);
                    if (forceClick) {
                        click();
                    }
                    if (maybeMarker) {
                        return this.listeners = this.listeners.concat(this.setEvents(maybeMarker, {
                            events: {
                                click: click
                            }
                        }, this.model));
                    }
                };
                WindowChildModel.prototype.showWindow = function() {
                    var compiled, show, templateScope;
                    if (this.gObject != null) {
                        show = function(_this) {
                            return function() {
                                var isOpen, maybeMarker, pos;
                                if (!_this.gObject.isOpen()) {
                                    maybeMarker = _this.getGmarker();
                                    if (_this.gObject != null && _this.gObject.getPosition != null) {
                                        pos = _this.gObject.getPosition();
                                    }
                                    if (maybeMarker) {
                                        pos = maybeMarker.getPosition();
                                    }
                                    if (!pos) {
                                        return;
                                    }
                                    _this.gObject.open(_this.mapCtrl, maybeMarker);
                                    isOpen = _this.gObject.isOpen();
                                    if (_this.model.show !== isOpen) {
                                        return _this.model.show = isOpen;
                                    }
                                }
                            };
                        }(this);
                        if (this.scope.templateUrl) {
                            return $http.get(this.scope.templateUrl, {
                                cache: $templateCache
                            }).then(function(_this) {
                                return function(content) {
                                    var compiled, templateScope;
                                    templateScope = _this.scope.$new();
                                    if (angular.isDefined(_this.scope.templateParameter)) {
                                        templateScope.parameter = _this.scope.templateParameter;
                                    }
                                    compiled = $compile(content.data)(templateScope);
                                    _this.gObject.setContent(compiled[0]);
                                    return show();
                                };
                            }(this));
                        } else if (this.scope.template) {
                            templateScope = this.scope.$new();
                            if (angular.isDefined(this.scope.templateParameter)) {
                                templateScope.parameter = this.scope.templateParameter;
                            }
                            compiled = $compile(this.scope.template)(templateScope);
                            this.gObject.setContent(compiled[0]);
                            return show();
                        } else {
                            return show();
                        }
                    }
                };
                WindowChildModel.prototype.hideWindow = function() {
                    if (this.gObject != null && this.gObject.isOpen()) {
                        return this.gObject.close();
                    }
                };
                WindowChildModel.prototype.getLatestPosition = function(overridePos) {
                    var maybeMarker;
                    maybeMarker = this.getGmarker();
                    if (this.gObject != null && maybeMarker != null && !overridePos) {
                        return this.gObject.setPosition(maybeMarker.getPosition());
                    } else {
                        if (overridePos) {
                            return this.gObject.setPosition(overridePos);
                        }
                    }
                };
                WindowChildModel.prototype.remove = function() {
                    this.hideWindow();
                    this.removeEvents(this.listeners);
                    this.listeners.length = 0;
                    delete this.gObject;
                    return delete this.opts;
                };
                WindowChildModel.prototype.destroy = function(manualOverride) {
                    var ref;
                    if (manualOverride == null) {
                        manualOverride = false;
                    }
                    this.remove();
                    if (this.scope != null && !((ref = this.scope) != null ? ref.$$destroyed : void 0) && (this.needToManualDestroy || manualOverride)) {
                        return this.scope.$destroy();
                    }
                };
                WindowChildModel.prototype.updateModel = function(model) {
                    this.clonedModel = _.clone(model, true);
                    return _.extend(this.model, this.clonedModel);
                };
                return WindowChildModel;
            }(BaseObject);
            return WindowChildModel;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapBasePolysParentModel", [ "$timeout", "uiGmapLogger", "uiGmapModelKey", "uiGmapModelsWatcher", "uiGmapPropMap", "uiGmap_async", "uiGmapPromise", "uiGmapFitHelper", function($timeout, $log, ModelKey, ModelsWatcher, PropMap, _async, uiGmapPromise, FitHelper) {
            return function(IPoly, PolyChildModel, gObjectName) {
                var BasePolysParentModel;
                return BasePolysParentModel = function(superClass) {
                    extend(BasePolysParentModel, superClass);
                    BasePolysParentModel.include(ModelsWatcher);
                    function BasePolysParentModel(scope, element, attrs, gMap1, defaults) {
                        this.element = element;
                        this.attrs = attrs;
                        this.gMap = gMap1;
                        this.defaults = defaults;
                        this.maybeFit = bind(this.maybeFit, this);
                        this.createChild = bind(this.createChild, this);
                        this.pieceMeal = bind(this.pieceMeal, this);
                        this.createAllNew = bind(this.createAllNew, this);
                        this.watchIdKey = bind(this.watchIdKey, this);
                        this.createChildScopes = bind(this.createChildScopes, this);
                        this.watchDestroy = bind(this.watchDestroy, this);
                        this.onDestroy = bind(this.onDestroy, this);
                        this.rebuildAll = bind(this.rebuildAll, this);
                        this.doINeedToWipe = bind(this.doINeedToWipe, this);
                        this.watchModels = bind(this.watchModels, this);
                        BasePolysParentModel.__super__.constructor.call(this, scope);
                        this["interface"] = IPoly;
                        this.$log = $log;
                        this.plurals = new PropMap();
                        _.each(IPoly.scopeKeys, function(_this) {
                            return function(name) {
                                return _this[name + "Key"] = void 0;
                            };
                        }(this));
                        this.models = void 0;
                        this.firstTime = true;
                        this.$log.info(this);
                        this.createChildScopes();
                    }
                    BasePolysParentModel.prototype.watchModels = function(scope) {
                        return scope.$watch("models", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) {
                                    if (_this.doINeedToWipe(newValue) || scope.doRebuildAll) {
                                        return _this.rebuildAll(scope, true, true);
                                    } else {
                                        return _this.createChildScopes(false);
                                    }
                                }
                            };
                        }(this), true);
                    };
                    BasePolysParentModel.prototype.doINeedToWipe = function(newValue) {
                        var newValueIsEmpty;
                        newValueIsEmpty = newValue != null ? newValue.length === 0 : true;
                        return this.plurals.length > 0 && newValueIsEmpty;
                    };
                    BasePolysParentModel.prototype.rebuildAll = function(scope, doCreate, doDelete) {
                        return this.onDestroy(doDelete).then(function(_this) {
                            return function() {
                                if (doCreate) {
                                    return _this.createChildScopes();
                                }
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.onDestroy = function(scope) {
                        BasePolysParentModel.__super__.onDestroy.call(this, this.scope);
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, function(_this) {
                            return function() {
                                return _async.each(_this.plurals.values(), function(child) {
                                    return child.destroy(true);
                                }, _async.chunkSizeFrom(_this.scope.cleanchunk, false)).then(function() {
                                    var ref;
                                    return (ref = _this.plurals) != null ? ref.removeAll() : void 0;
                                });
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.watchDestroy = function(scope) {
                        return scope.$on("$destroy", function(_this) {
                            return function() {
                                return _this.rebuildAll(scope, false, true);
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
                        if (isCreatingFromScratch == null) {
                            isCreatingFromScratch = true;
                        }
                        if (angular.isUndefined(this.scope.models)) {
                            this.$log.error("No models to create " + gObjectName + "s from! I Need direct models!");
                            return;
                        }
                        if (this.gMap == null || this.scope.models == null) {
                            return;
                        }
                        this.watchIdKey(this.scope);
                        if (isCreatingFromScratch) {
                            return this.createAllNew(this.scope, false);
                        } else {
                            return this.pieceMeal(this.scope, false);
                        }
                    };
                    BasePolysParentModel.prototype.watchIdKey = function(scope) {
                        this.setIdKey(scope);
                        return scope.$watch("idKey", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue && newValue == null) {
                                    _this.idKey = newValue;
                                    return _this.rebuildAll(scope, true, true);
                                }
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.createAllNew = function(scope, isArray) {
                        var maybeCanceled;
                        if (isArray == null) {
                            isArray = false;
                        }
                        this.models = scope.models;
                        if (this.firstTime) {
                            this.watchModels(scope);
                            this.watchDestroy(scope);
                        }
                        if (this.didQueueInitPromise(this, scope)) {
                            return;
                        }
                        maybeCanceled = null;
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, "createAllNew", function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }, function(_this) {
                            return function() {
                                return _async.map(scope.models, function(model) {
                                    var child;
                                    child = _this.createChild(model, _this.gMap);
                                    if (maybeCanceled) {
                                        $log.debug("createNew should fall through safely");
                                        child.isEnabled = false;
                                    }
                                    maybeCanceled;
                                    return child.pathPoints.getArray();
                                }, _async.chunkSizeFrom(scope.chunk)).then(function(pathPoints) {
                                    _this.maybeFit(pathPoints);
                                    return _this.firstTime = false;
                                });
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.pieceMeal = function(scope, isArray) {
                        var maybeCanceled, payload;
                        if (isArray == null) {
                            isArray = true;
                        }
                        if (scope.$$destroyed) {
                            return;
                        }
                        maybeCanceled = null;
                        payload = null;
                        this.models = scope.models;
                        if (scope != null && this.modelsLength() && this.plurals.length) {
                            return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, "pieceMeal", function(canceledMsg) {
                                return maybeCanceled = canceledMsg;
                            }, function(_this) {
                                return function() {
                                    return uiGmapPromise.promise(function() {
                                        return _this.figureOutState(_this.idKey, scope, _this.plurals, _this.modelKeyComparison);
                                    }).then(function(state) {
                                        payload = state;
                                        if (payload.updates.length) {
                                            _async.each(payload.updates, function(obj) {
                                                _.extend(obj.child.scope, obj.model);
                                                return obj.child.model = obj.model;
                                            });
                                        }
                                        return _async.each(payload.removals, function(child) {
                                            if (child != null) {
                                                child.destroy();
                                                _this.plurals.remove(child.model[_this.idKey]);
                                                return maybeCanceled;
                                            }
                                        }, _async.chunkSizeFrom(scope.chunk));
                                    }).then(function() {
                                        return _async.each(payload.adds, function(modelToAdd) {
                                            if (maybeCanceled) {
                                                $log.debug("pieceMeal should fall through safely");
                                            }
                                            _this.createChild(modelToAdd, _this.gMap);
                                            return maybeCanceled;
                                        }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                                            return _this.maybeFit();
                                        });
                                    });
                                };
                            }(this));
                        } else {
                            this.inProgress = false;
                            return this.rebuildAll(this.scope, true, true);
                        }
                    };
                    BasePolysParentModel.prototype.createChild = function(model, gMap) {
                        var child, childScope;
                        childScope = this.scope.$new(false);
                        this.setChildScope(IPoly.scopeKeys, childScope, model);
                        childScope.$watch("model", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) {
                                    return _this.setChildScope(childScope, newValue);
                                }
                            };
                        }(this), true);
                        childScope["static"] = this.scope["static"];
                        child = new PolyChildModel(childScope, this.attrs, gMap, this.defaults, model, function(_this) {
                            return function() {
                                return _this.maybeFit();
                            };
                        }(this));
                        if (model[this.idKey] == null) {
                            this.$log.error(gObjectName + " model has no id to assign a child to.\nThis is required for performance. Please assign id,\nor redirect id to a different key.");
                            return;
                        }
                        this.plurals.put(model[this.idKey], child);
                        return child;
                    };
                    BasePolysParentModel.prototype.maybeFit = function(pathPoints) {
                        if (pathPoints == null) {
                            pathPoints = this.plurals.map(function(p) {
                                return p.pathPoints;
                            });
                        }
                        if (this.scope.fit) {
                            pathPoints = _.flatten(pathPoints);
                            return FitHelper.fit(pathPoints, this.gMap);
                        }
                    };
                    return BasePolysParentModel;
                }(ModelKey);
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapCircleParentModel", [ "uiGmapLogger", "$timeout", "uiGmapGmapUtil", "uiGmapEventsHelper", "uiGmapCircleOptionsBuilder", function($log, $timeout, GmapUtil, EventsHelper, Builder) {
            var CircleParentModel, _settingFromDirective;
            _settingFromDirective = function(scope, fn) {
                scope.settingFromDirective = true;
                fn();
                return $timeout(function() {
                    return scope.settingFromDirective = false;
                });
            };
            return CircleParentModel = function(superClass) {
                extend(CircleParentModel, superClass);
                CircleParentModel.include(GmapUtil);
                CircleParentModel.include(EventsHelper);
                function CircleParentModel(scope, element, attrs, map, DEFAULTS) {
                    var clean, gObject, lastRadius;
                    this.attrs = attrs;
                    this.map = map;
                    this.DEFAULTS = DEFAULTS;
                    this.scope = scope;
                    lastRadius = null;
                    clean = function(_this) {
                        return function() {
                            lastRadius = null;
                            if (_this.listeners != null) {
                                _this.removeEvents(_this.listeners);
                                return _this.listeners = void 0;
                            }
                        };
                    }(this);
                    gObject = new google.maps.Circle(this.buildOpts(GmapUtil.getCoords(scope.center), scope.radius));
                    this.setMyOptions = function(_this) {
                        return function(newVals, oldVals) {
                            if (scope.settingFromDirective) {
                                return;
                            }
                            if (!_.isEqual(newVals, oldVals)) {
                                return gObject.setOptions(_this.buildOpts(GmapUtil.getCoords(scope.center), scope.radius));
                            }
                        };
                    }(this);
                    this.props = this.props.concat([ {
                        prop: "center",
                        isColl: true
                    }, {
                        prop: "fill",
                        isColl: true
                    }, "radius", "zIndex" ]);
                    this.watchProps();
                    if (this.scope.control != null) {
                        this.scope.control.getCircle = function() {
                            return gObject;
                        };
                    }
                    clean();
                    this.listeners = this.setEvents(gObject, scope, scope, [ "radius_changed" ]) || [];
                    this.listeners.push(google.maps.event.addListener(gObject, "radius_changed", function() {
                        var newRadius, work;
                        newRadius = gObject.getRadius();
                        if (newRadius === lastRadius) {
                            return;
                        }
                        lastRadius = newRadius;
                        work = function() {
                            return _settingFromDirective(scope, function() {
                                var ref, ref1;
                                if (newRadius !== scope.radius) {
                                    scope.radius = newRadius;
                                }
                                if (((ref = scope.events) != null ? ref.radius_changed : void 0) && _.isFunction((ref1 = scope.events) != null ? ref1.radius_changed : void 0)) {
                                    return scope.events.radius_changed(gObject, "radius_changed", scope, arguments);
                                }
                            });
                        };
                        if (!angular.mock) {
                            return scope.$evalAsync(function() {
                                return work();
                            });
                        } else {
                            return work();
                        }
                    }));
                    this.listeners.push(google.maps.event.addListener(gObject, "center_changed", function() {
                        return scope.$evalAsync(function() {
                            return _settingFromDirective(scope, function() {
                                if (angular.isDefined(scope.center.type)) {
                                    scope.center.coordinates[1] = gObject.getCenter().lat();
                                    return scope.center.coordinates[0] = gObject.getCenter().lng();
                                } else {
                                    scope.center.latitude = gObject.getCenter().lat();
                                    return scope.center.longitude = gObject.getCenter().lng();
                                }
                            });
                        });
                    }));
                    scope.$on("$destroy", function(_this) {
                        return function() {
                            clean();
                            return gObject.setMap(null);
                        };
                    }(this));
                    $log.info(this);
                }
                return CircleParentModel;
            }(Builder);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapDrawingManagerParentModel", [ "uiGmapLogger", "$timeout", "uiGmapBaseObject", "uiGmapEventsHelper", function($log, $timeout, BaseObject, EventsHelper) {
            var DrawingManagerParentModel;
            return DrawingManagerParentModel = function(superClass) {
                extend(DrawingManagerParentModel, superClass);
                DrawingManagerParentModel.include(EventsHelper);
                function DrawingManagerParentModel(scope, element, attrs, map) {
                    var gObject, listeners;
                    this.scope = scope;
                    this.attrs = attrs;
                    this.map = map;
                    gObject = new google.maps.drawing.DrawingManager(this.scope.options);
                    gObject.setMap(this.map);
                    listeners = void 0;
                    if (this.scope.control != null) {
                        this.scope.control.getDrawingManager = function() {
                            return gObject;
                        };
                    }
                    if (!this.scope["static"] && this.scope.options) {
                        this.scope.$watch("options", function(newValue) {
                            return gObject != null ? gObject.setOptions(newValue) : void 0;
                        }, true);
                    }
                    if (this.scope.events != null) {
                        listeners = this.setEvents(gObject, this.scope, this.scope);
                        this.scope.$watch("events", function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue)) {
                                    if (listeners != null) {
                                        _this.removeEvents(listeners);
                                    }
                                    return listeners = _this.setEvents(gObject, _this.scope, _this.scope);
                                }
                            };
                        }(this));
                    }
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            if (listeners != null) {
                                _this.removeEvents(listeners);
                            }
                            gObject.setMap(null);
                            return gObject = null;
                        };
                    }(this));
                }
                return DrawingManagerParentModel;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapIMarkerParentModel", [ "uiGmapModelKey", "uiGmapLogger", function(ModelKey, Logger) {
            var IMarkerParentModel;
            IMarkerParentModel = function(superClass) {
                extend(IMarkerParentModel, superClass);
                IMarkerParentModel.prototype.DEFAULTS = {};
                function IMarkerParentModel(scope1, element, attrs, map) {
                    this.scope = scope1;
                    this.element = element;
                    this.attrs = attrs;
                    this.map = map;
                    this.onWatch = bind(this.onWatch, this);
                    this.watch = bind(this.watch, this);
                    this.validateScope = bind(this.validateScope, this);
                    IMarkerParentModel.__super__.constructor.call(this, this.scope);
                    this.$log = Logger;
                    if (!this.validateScope(this.scope)) {
                        throw new String("Unable to construct IMarkerParentModel due to invalid scope");
                    }
                    this.doClick = angular.isDefined(this.attrs.click);
                    if (this.scope.options != null) {
                        this.DEFAULTS = this.scope.options;
                    }
                    this.watch("coords", this.scope);
                    this.watch("icon", this.scope);
                    this.watch("options", this.scope);
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return _this.onDestroy(_this.scope);
                        };
                    }(this));
                }
                IMarkerParentModel.prototype.validateScope = function(scope) {
                    var ret;
                    if (scope == null) {
                        this.$log.error(this.constructor.name + ": invalid scope used");
                        return false;
                    }
                    ret = scope.coords != null;
                    if (!ret) {
                        this.$log.error(this.constructor.name + ": no valid coords attribute found");
                        return false;
                    }
                    return ret;
                };
                IMarkerParentModel.prototype.watch = function(propNameToWatch, scope, equalityCheck) {
                    if (equalityCheck == null) {
                        equalityCheck = true;
                    }
                    return scope.$watch(propNameToWatch, function(_this) {
                        return function(newValue, oldValue) {
                            if (!_.isEqual(newValue, oldValue)) {
                                return _this.onWatch(propNameToWatch, scope, newValue, oldValue);
                            }
                        };
                    }(this), equalityCheck);
                };
                IMarkerParentModel.prototype.onWatch = function(propNameToWatch, scope, newValue, oldValue) {};
                return IMarkerParentModel;
            }(ModelKey);
            return IMarkerParentModel;
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapIWindowParentModel", [ "uiGmapModelKey", "uiGmapGmapUtil", "uiGmapLogger", function(ModelKey, GmapUtil, Logger) {
            var IWindowParentModel;
            return IWindowParentModel = function(superClass) {
                extend(IWindowParentModel, superClass);
                IWindowParentModel.include(GmapUtil);
                function IWindowParentModel(scope, element, attrs, ctrls, $timeout, $compile, $http, $templateCache) {
                    IWindowParentModel.__super__.constructor.call(this, scope);
                    this.$log = Logger;
                    this.$timeout = $timeout;
                    this.$compile = $compile;
                    this.$http = $http;
                    this.$templateCache = $templateCache;
                    this.DEFAULTS = {};
                    if (scope.options != null) {
                        this.DEFAULTS = scope.options;
                    }
                }
                IWindowParentModel.prototype.getItem = function(scope, modelsPropToIterate, index) {
                    if (modelsPropToIterate === "models") {
                        return scope[modelsPropToIterate][index];
                    }
                    return scope[modelsPropToIterate].get(index);
                };
                return IWindowParentModel;
            }(ModelKey);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapLayerParentModel", [ "uiGmapBaseObject", "uiGmapLogger", "$timeout", function(BaseObject, Logger, $timeout) {
            var LayerParentModel;
            LayerParentModel = function(superClass) {
                extend(LayerParentModel, superClass);
                function LayerParentModel(scope, element, attrs, gMap, onLayerCreated, $log) {
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.onLayerCreated = onLayerCreated != null ? onLayerCreated : void 0;
                    this.$log = $log != null ? $log : Logger;
                    this.createGoogleLayer = bind(this.createGoogleLayer, this);
                    if (this.attrs.type == null) {
                        this.$log.info("type attribute for the layer directive is mandatory. Layer creation aborted!!");
                        return;
                    }
                    this.createGoogleLayer();
                    this.doShow = true;
                    if (angular.isDefined(this.attrs.show)) {
                        this.doShow = this.scope.show;
                    }
                    if (this.doShow && this.gMap != null) {
                        this.gObject.setMap(this.gMap);
                    }
                    this.scope.$watch("show", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                _this.doShow = newValue;
                                if (newValue) {
                                    return _this.gObject.setMap(_this.gMap);
                                } else {
                                    return _this.gObject.setMap(null);
                                }
                            }
                        };
                    }(this), true);
                    this.scope.$watch("options", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue && _this.doShow) {
                                return _this.gObject.setOptions(newValue);
                            }
                        };
                    }(this), true);
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return _this.gObject.setMap(null);
                        };
                    }(this));
                }
                LayerParentModel.prototype.createGoogleLayer = function() {
                    var base;
                    if (this.attrs.options == null) {
                        this.gObject = this.attrs.namespace === void 0 ? new google.maps[this.attrs.type]() : new google.maps[this.attrs.namespace][this.attrs.type]();
                    } else {
                        this.gObject = this.attrs.namespace === void 0 ? new google.maps[this.attrs.type](this.scope.options) : new google.maps[this.attrs.namespace][this.attrs.type](this.scope.options);
                    }
                    if (this.gObject != null && this.doShow) {
                        this.gObject.setMap(this.gMap);
                    }
                    if (this.gObject != null && this.onLayerCreated != null) {
                        return typeof (base = this.onLayerCreated(this.scope, this.gObject)) === "function" ? base(this.gObject) : void 0;
                    }
                };
                return LayerParentModel;
            }(BaseObject);
            return LayerParentModel;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapMapTypeParentModel", [ "uiGmapBaseObject", "uiGmapLogger", function(BaseObject, Logger) {
            var MapTypeParentModel;
            MapTypeParentModel = function(superClass) {
                extend(MapTypeParentModel, superClass);
                function MapTypeParentModel(scope, element, attrs, gMap, $log) {
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.$log = $log != null ? $log : Logger;
                    this.hideOverlay = bind(this.hideOverlay, this);
                    this.showOverlay = bind(this.showOverlay, this);
                    this.refreshMapType = bind(this.refreshMapType, this);
                    this.createMapType = bind(this.createMapType, this);
                    if (this.attrs.options == null) {
                        this.$log.info("options attribute for the map-type directive is mandatory. Map type creation aborted!!");
                        return;
                    }
                    this.id = this.gMap.overlayMapTypesCount = this.gMap.overlayMapTypesCount + 1 || 0;
                    this.doShow = true;
                    this.createMapType();
                    if (angular.isDefined(this.attrs.show)) {
                        this.doShow = this.scope.show;
                    }
                    if (this.doShow && this.gMap != null) {
                        this.showOverlay();
                    }
                    this.scope.$watch("show", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                _this.doShow = newValue;
                                if (newValue) {
                                    return _this.showOverlay();
                                } else {
                                    return _this.hideOverlay();
                                }
                            }
                        };
                    }(this), true);
                    this.scope.$watch("options", function(_this) {
                        return function(newValue, oldValue) {
                            if (!_.isEqual(newValue, oldValue)) {
                                return _this.refreshMapType();
                            }
                        };
                    }(this), true);
                    if (angular.isDefined(this.attrs.refresh)) {
                        this.scope.$watch("refresh", function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue)) {
                                    return _this.refreshMapType();
                                }
                            };
                        }(this), true);
                    }
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            _this.hideOverlay();
                            return _this.mapType = null;
                        };
                    }(this));
                }
                MapTypeParentModel.prototype.createMapType = function() {
                    if (this.scope.options.getTile != null) {
                        this.mapType = this.scope.options;
                    } else if (this.scope.options.getTileUrl != null) {
                        this.mapType = new google.maps.ImageMapType(this.scope.options);
                    } else {
                        this.$log.info("options should provide either getTile or getTileUrl methods. Map type creation aborted!!");
                        return;
                    }
                    if (this.attrs.id && this.scope.id) {
                        this.gMap.mapTypes.set(this.scope.id, this.mapType);
                        if (!angular.isDefined(this.attrs.show)) {
                            this.doShow = false;
                        }
                    }
                    return this.mapType.layerId = this.id;
                };
                MapTypeParentModel.prototype.refreshMapType = function() {
                    this.hideOverlay();
                    this.mapType = null;
                    this.createMapType();
                    if (this.doShow && this.gMap != null) {
                        return this.showOverlay();
                    }
                };
                MapTypeParentModel.prototype.showOverlay = function() {
                    return this.gMap.overlayMapTypes.push(this.mapType);
                };
                MapTypeParentModel.prototype.hideOverlay = function() {
                    var found;
                    found = false;
                    return this.gMap.overlayMapTypes.forEach(function(_this) {
                        return function(mapType, index) {
                            if (!found && mapType.layerId === _this.id) {
                                found = true;
                                _this.gMap.overlayMapTypes.removeAt(index);
                            }
                        };
                    }(this));
                };
                return MapTypeParentModel;
            }(BaseObject);
            return MapTypeParentModel;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapMarkersParentModel", [ "uiGmapIMarkerParentModel", "uiGmapModelsWatcher", "uiGmapPropMap", "uiGmapMarkerChildModel", "uiGmap_async", "uiGmapClustererMarkerManager", "uiGmapMarkerManager", "$timeout", "uiGmapIMarker", "uiGmapPromise", "uiGmapGmapUtil", "uiGmapLogger", "uiGmapSpiderfierMarkerManager", function(IMarkerParentModel, ModelsWatcher, PropMap, MarkerChildModel, _async, ClustererMarkerManager, MarkerManager, $timeout, IMarker, uiGmapPromise, GmapUtil, $log, SpiderfierMarkerManager) {
            var MarkersParentModel, _setPlurals;
            _setPlurals = function(val, objToSet) {
                objToSet.plurals = new PropMap();
                objToSet.scope.plurals = objToSet.plurals;
                return objToSet;
            };
            MarkersParentModel = function(superClass) {
                extend(MarkersParentModel, superClass);
                MarkersParentModel.include(GmapUtil);
                MarkersParentModel.include(ModelsWatcher);
                function MarkersParentModel(scope, element, attrs, map) {
                    this.maybeExecMappedEvent = bind(this.maybeExecMappedEvent, this);
                    this.onDestroy = bind(this.onDestroy, this);
                    this.newChildMarker = bind(this.newChildMarker, this);
                    this.pieceMeal = bind(this.pieceMeal, this);
                    this.rebuildAll = bind(this.rebuildAll, this);
                    this.createAllNew = bind(this.createAllNew, this);
                    this.bindToTypeEvents = bind(this.bindToTypeEvents, this);
                    this.createChildScopes = bind(this.createChildScopes, this);
                    this.validateScope = bind(this.validateScope, this);
                    this.onWatch = bind(this.onWatch, this);
                    var self;
                    MarkersParentModel.__super__.constructor.call(this, scope, element, attrs, map);
                    this["interface"] = IMarker;
                    self = this;
                    _setPlurals(new PropMap(), this);
                    this.scope.pluralsUpdate = {
                        updateCtr: 0
                    };
                    this.$log.info(this);
                    this.doRebuildAll = this.scope.doRebuildAll != null ? this.scope.doRebuildAll : false;
                    this.setIdKey(this.scope);
                    this.scope.$watch("doRebuildAll", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                return _this.doRebuildAll = newValue;
                            }
                        };
                    }(this));
                    if (!this.modelsLength()) {
                        this.modelsRendered = false;
                    }
                    this.scope.$watch("models", function(_this) {
                        return function(newValue, oldValue) {
                            if (!_.isEqual(newValue, oldValue) || !_this.modelsRendered) {
                                if (newValue.length === 0 && oldValue.length === 0) {
                                    return;
                                }
                                _this.modelsRendered = true;
                                return _this.onWatch("models", _this.scope, newValue, oldValue);
                            }
                        };
                    }(this), !this.isTrue(attrs.modelsbyref));
                    this.watch("doCluster", this.scope);
                    this.watch("type", this.scope);
                    this.watch("clusterOptions", this.scope);
                    this.watch("clusterEvents", this.scope);
                    this.watch("typeOptions", this.scope);
                    this.watch("typeEvents", this.scope);
                    this.watch("fit", this.scope);
                    this.watch("idKey", this.scope);
                    this.gManager = void 0;
                    this.createAllNew(this.scope);
                }
                MarkersParentModel.prototype.onWatch = function(propNameToWatch, scope, newValue, oldValue) {
                    if (propNameToWatch === "idKey" && newValue !== oldValue) {
                        this.idKey = newValue;
                    }
                    if (this.doRebuildAll || (propNameToWatch === "doCluster" || propNameToWatch === "type")) {
                        return this.rebuildAll(scope);
                    } else {
                        return this.pieceMeal(scope);
                    }
                };
                MarkersParentModel.prototype.validateScope = function(scope) {
                    var modelsNotDefined;
                    modelsNotDefined = angular.isUndefined(scope.models) || scope.models === void 0;
                    if (modelsNotDefined) {
                        this.$log.error(this.constructor.name + ": no valid models attribute found");
                    }
                    return MarkersParentModel.__super__.validateScope.call(this, scope) || modelsNotDefined;
                };
                MarkersParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
                    if (this.gMap == null || this.scope.models == null) {
                        return;
                    }
                    if (isCreatingFromScratch) {
                        return this.createAllNew(this.scope, false);
                    } else {
                        return this.pieceMeal(this.scope, false);
                    }
                };
                MarkersParentModel.prototype.bindToTypeEvents = function(typeEvents, events) {
                    var internalHandles, self;
                    if (events == null) {
                        events = [ "click", "mouseout", "mouseover" ];
                    }
                    self = this;
                    if (!this.origTypeEvents) {
                        this.origTypeEvents = {};
                        _.each(events, function(_this) {
                            return function(eventName) {
                                return _this.origTypeEvents[eventName] = typeEvents != null ? typeEvents[eventName] : void 0;
                            };
                        }(this));
                    } else {
                        angular.extend(typeEvents, this.origTypeEvents);
                    }
                    internalHandles = {};
                    _.each(events, function(_this) {
                        return function(eventName) {
                            return internalHandles[eventName] = function(group) {
                                return self.maybeExecMappedEvent(group, eventName);
                            };
                        };
                    }(this));
                    return angular.extend(typeEvents, internalHandles);
                };
                MarkersParentModel.prototype.createAllNew = function(scope) {
                    var isSpiderfied, maybeCanceled, typeEvents, typeOptions;
                    if (this.gManager != null) {
                        if (this.gManager instanceof SpiderfierMarkerManager) {
                            isSpiderfied = this.gManager.isSpiderfied();
                        }
                        this.gManager.clear();
                        delete this.gManager;
                    }
                    typeEvents = scope.typeEvents || scope.clusterEvents;
                    typeOptions = scope.typeOptions || scope.clusterOptions;
                    if (scope.doCluster || scope.type === "cluster") {
                        if (typeEvents != null) {
                            this.bindToTypeEvents(typeEvents);
                        }
                        this.gManager = new ClustererMarkerManager(this.map, void 0, typeOptions, typeEvents);
                    } else if (scope.type === "spider") {
                        if (typeEvents != null) {
                            this.bindToTypeEvents(typeEvents, [ "spiderfy", "unspiderfy" ]);
                        }
                        this.gManager = new SpiderfierMarkerManager(this.map, void 0, typeOptions, typeEvents, this.scope);
                        if (isSpiderfied) {
                            this.gManager.spiderfy();
                        }
                    } else {
                        this.gManager = new MarkerManager(this.map);
                    }
                    if (this.didQueueInitPromise(this, scope)) {
                        return;
                    }
                    maybeCanceled = null;
                    return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, "createAllNew", function(canceledMsg) {
                        return maybeCanceled = canceledMsg;
                    }, function(_this) {
                        return function() {
                            return _async.each(scope.models, function(model) {
                                _this.newChildMarker(model, scope);
                                return maybeCanceled;
                            }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                                _this.modelsRendered = true;
                                if (scope.fit) {
                                    _this.gManager.fit();
                                }
                                _this.gManager.draw();
                                return _this.scope.pluralsUpdate.updateCtr += 1;
                            }, _async.chunkSizeFrom(scope.chunk));
                        };
                    }(this));
                };
                MarkersParentModel.prototype.rebuildAll = function(scope) {
                    var ref;
                    if (!scope.doRebuild && scope.doRebuild !== void 0) {
                        return;
                    }
                    if ((ref = this.scope.plurals) != null ? ref.length : void 0) {
                        return this.onDestroy(scope).then(function(_this) {
                            return function() {
                                return _this.createAllNew(scope);
                            };
                        }(this));
                    } else {
                        return this.createAllNew(scope);
                    }
                };
                MarkersParentModel.prototype.pieceMeal = function(scope) {
                    var maybeCanceled, payload;
                    if (scope.$$destroyed) {
                        return;
                    }
                    maybeCanceled = null;
                    payload = null;
                    if (this.modelsLength() && this.scope.plurals.length) {
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, "pieceMeal", function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }, function(_this) {
                            return function() {
                                return uiGmapPromise.promise(function() {
                                    return _this.figureOutState(_this.idKey, scope, _this.scope.plurals, _this.modelKeyComparison);
                                }).then(function(state) {
                                    payload = state;
                                    return _async.each(payload.removals, function(child) {
                                        if (child != null) {
                                            if (child.destroy != null) {
                                                child.destroy();
                                            }
                                            _this.scope.plurals.remove(child.id);
                                            return maybeCanceled;
                                        }
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    return _async.each(payload.adds, function(modelToAdd) {
                                        _this.newChildMarker(modelToAdd, scope);
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    return _async.each(payload.updates, function(update) {
                                        _this.updateChild(update.child, update.model);
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    if (payload.adds.length > 0 || payload.removals.length > 0 || payload.updates.length > 0) {
                                        scope.plurals = _this.scope.plurals;
                                        if (scope.fit) {
                                            _this.gManager.fit();
                                        }
                                        _this.gManager.draw();
                                    }
                                    return _this.scope.pluralsUpdate.updateCtr += 1;
                                });
                            };
                        }(this));
                    } else {
                        this.inProgress = false;
                        return this.rebuildAll(scope);
                    }
                };
                MarkersParentModel.prototype.newChildMarker = function(model, scope) {
                    var child, childScope, doDrawSelf, keys;
                    if (model[this.idKey] == null) {
                        this.$log.error("Marker model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
                        return;
                    }
                    this.$log.info("child", child, "markers", this.scope.markerModels);
                    childScope = scope.$new(false);
                    childScope.events = scope.events;
                    keys = {};
                    IMarker.scopeKeys.forEach(function(k) {
                        return keys[k] = scope[k];
                    });
                    child = new MarkerChildModel(childScope, model, keys, this.map, this.DEFAULTS, this.doClick, this.gManager, doDrawSelf = false);
                    this.scope.plurals.put(model[this.idKey], child);
                    return child;
                };
                MarkersParentModel.prototype.onDestroy = function(scope) {
                    MarkersParentModel.__super__.onDestroy.call(this, scope);
                    return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, function(_this) {
                        return function() {
                            return _async.each(_this.scope.plurals.values(), function(model) {
                                if (model != null) {
                                    return model.destroy(false);
                                }
                            }, _async.chunkSizeFrom(_this.scope.cleanchunk, false)).then(function() {
                                if (_this.gManager != null) {
                                    _this.gManager.destroy();
                                }
                                _this.plurals.removeAll();
                                if (_this.plurals !== _this.scope.plurals) {
                                    console.error("plurals out of sync for MarkersParentModel");
                                }
                                return _this.scope.pluralsUpdate.updateCtr += 1;
                            });
                        };
                    }(this));
                };
                MarkersParentModel.prototype.maybeExecMappedEvent = function(group, fnName) {
                    var pair, typeEvents;
                    if (this.scope.$$destroyed) {
                        return;
                    }
                    typeEvents = this.scope.typeEvents || this.scope.clusterEvents;
                    if (_.isFunction(typeEvents != null ? typeEvents[fnName] : void 0)) {
                        pair = this.mapTypeToPlurals(group);
                        if (this.origTypeEvents[fnName]) {
                            return this.origTypeEvents[fnName](pair.group, pair.mapped);
                        }
                    }
                };
                MarkersParentModel.prototype.mapTypeToPlurals = function(group) {
                    var arrayToMap, mapped, ref;
                    if (_.isArray(group)) {
                        arrayToMap = group;
                    } else if (_.isFunction(group.getMarkers)) {
                        arrayToMap = group.getMarkers();
                    }
                    if (arrayToMap == null) {
                        $log.error("Unable to map event as we cannot find the array group to map");
                        return;
                    }
                    if ((ref = this.scope.plurals.values()) != null ? ref.length : void 0) {
                        mapped = arrayToMap.map(function(_this) {
                            return function(g) {
                                return _this.scope.plurals.get(g.key).model;
                            };
                        }(this));
                    } else {
                        mapped = [];
                    }
                    return {
                        cluster: group,
                        mapped: mapped,
                        group: group
                    };
                };
                MarkersParentModel.prototype.getItem = function(scope, modelsPropToIterate, index) {
                    if (modelsPropToIterate === "models") {
                        return scope[modelsPropToIterate][index];
                    }
                    return scope[modelsPropToIterate].get(index);
                };
                return MarkersParentModel;
            }(IMarkerParentModel);
            return MarkersParentModel;
        } ]);
    }).call(this);
    (function() {
        [ "Polygon", "Polyline" ].forEach(function(name) {
            return angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmap" + name + "sParentModel", [ "uiGmapBasePolysParentModel", "uiGmap" + name + "ChildModel", "uiGmapI" + name, function(BasePolysParentModel, ChildModel, IPoly) {
                return BasePolysParentModel(IPoly, ChildModel, name);
            } ]);
        });
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapRectangleParentModel", [ "uiGmapLogger", "uiGmapGmapUtil", "uiGmapEventsHelper", "uiGmapRectangleOptionsBuilder", function($log, GmapUtil, EventsHelper, Builder) {
            var RectangleParentModel;
            return RectangleParentModel = function(superClass) {
                extend(RectangleParentModel, superClass);
                RectangleParentModel.include(GmapUtil);
                RectangleParentModel.include(EventsHelper);
                function RectangleParentModel(scope, element, attrs, map, DEFAULTS) {
                    var bounds, clear, createBounds, dragging, fit, gObject, init, listeners, myListeners, settingBoundsFromScope, updateBounds;
                    this.scope = scope;
                    this.attrs = attrs;
                    this.map = map;
                    this.DEFAULTS = DEFAULTS;
                    bounds = void 0;
                    dragging = false;
                    myListeners = [];
                    listeners = void 0;
                    fit = function(_this) {
                        return function() {
                            if (_this.isTrue(_this.attrs.fit)) {
                                return _this.fitMapBounds(_this.map, bounds);
                            }
                        };
                    }(this);
                    createBounds = function(_this) {
                        return function() {
                            var ref, ref1, ref2;
                            if (_this.scope.bounds != null && ((ref = _this.scope.bounds) != null ? ref.sw : void 0) != null && ((ref1 = _this.scope.bounds) != null ? ref1.ne : void 0) != null && _this.validateBoundPoints(_this.scope.bounds)) {
                                bounds = _this.convertBoundPoints(_this.scope.bounds);
                                return $log.info("new new bounds created: " + JSON.stringify(bounds));
                            } else if (_this.scope.bounds.getNorthEast != null && _this.scope.bounds.getSouthWest != null) {
                                return bounds = _this.scope.bounds;
                            } else {
                                if (_this.scope.bounds != null) {
                                    return $log.error("Invalid bounds for newValue: " + JSON.stringify((ref2 = _this.scope) != null ? ref2.bounds : void 0));
                                }
                            }
                        };
                    }(this);
                    createBounds();
                    gObject = new google.maps.Rectangle(this.buildOpts(bounds));
                    $log.info("gObject (rectangle) created: " + gObject);
                    settingBoundsFromScope = false;
                    updateBounds = function(_this) {
                        return function() {
                            var b, ne, sw;
                            b = gObject.getBounds();
                            ne = b.getNorthEast();
                            sw = b.getSouthWest();
                            if (settingBoundsFromScope) {
                                return;
                            }
                            return _this.scope.$evalAsync(function(s) {
                                if (s.bounds != null && s.bounds.sw != null && s.bounds.ne != null) {
                                    s.bounds.ne = {
                                        latitude: ne.lat(),
                                        longitude: ne.lng()
                                    };
                                    s.bounds.sw = {
                                        latitude: sw.lat(),
                                        longitude: sw.lng()
                                    };
                                }
                                if (s.bounds.getNorthEast != null && s.bounds.getSouthWest != null) {
                                    return s.bounds = b;
                                }
                            });
                        };
                    }(this);
                    init = function(_this) {
                        return function() {
                            fit();
                            _this.removeEvents(myListeners);
                            myListeners.push(google.maps.event.addListener(gObject, "dragstart", function() {
                                return dragging = true;
                            }));
                            myListeners.push(google.maps.event.addListener(gObject, "dragend", function() {
                                dragging = false;
                                return updateBounds();
                            }));
                            return myListeners.push(google.maps.event.addListener(gObject, "bounds_changed", function() {
                                if (dragging) {
                                    return;
                                }
                                return updateBounds();
                            }));
                        };
                    }(this);
                    clear = function(_this) {
                        return function() {
                            _this.removeEvents(myListeners);
                            if (listeners != null) {
                                _this.removeEvents(listeners);
                            }
                            return gObject.setMap(null);
                        };
                    }(this);
                    if (bounds != null) {
                        init();
                    }
                    this.scope.$watch("bounds", function(newValue, oldValue) {
                        var isNew;
                        if (_.isEqual(newValue, oldValue) && bounds != null || dragging) {
                            return;
                        }
                        settingBoundsFromScope = true;
                        if (newValue == null) {
                            clear();
                            return;
                        }
                        if (bounds == null) {
                            isNew = true;
                        } else {
                            fit();
                        }
                        createBounds();
                        gObject.setBounds(bounds);
                        settingBoundsFromScope = false;
                        if (isNew && bounds != null) {
                            return init();
                        }
                    }, true);
                    this.setMyOptions = function(_this) {
                        return function(newVals, oldVals) {
                            if (!_.isEqual(newVals, oldVals)) {
                                if (bounds != null && newVals != null) {
                                    return gObject.setOptions(_this.buildOpts(bounds));
                                }
                            }
                        };
                    }(this);
                    this.props.push("bounds");
                    this.watchProps(this.props);
                    if (this.attrs.events != null) {
                        listeners = this.setEvents(gObject, this.scope, this.scope);
                        this.scope.$watch("events", function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue)) {
                                    if (listeners != null) {
                                        _this.removeEvents(listeners);
                                    }
                                    return listeners = _this.setEvents(gObject, _this.scope, _this.scope);
                                }
                            };
                        }(this));
                    }
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return clear();
                        };
                    }(this));
                    $log.info(this);
                }
                return RectangleParentModel;
            }(Builder);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapSearchBoxParentModel", [ "uiGmapBaseObject", "uiGmapLogger", "uiGmapEventsHelper", "$timeout", "$http", "$templateCache", function(BaseObject, Logger, EventsHelper, $timeout, $http, $templateCache) {
            var SearchBoxParentModel;
            SearchBoxParentModel = function(superClass) {
                extend(SearchBoxParentModel, superClass);
                SearchBoxParentModel.include(EventsHelper);
                function SearchBoxParentModel(scope, element, attrs, gMap, ctrlPosition, template, $log) {
                    var controlDiv;
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.ctrlPosition = ctrlPosition;
                    this.template = template;
                    this.$log = $log != null ? $log : Logger;
                    this.setVisibility = bind(this.setVisibility, this);
                    this.getBounds = bind(this.getBounds, this);
                    this.setBounds = bind(this.setBounds, this);
                    this.createSearchBox = bind(this.createSearchBox, this);
                    this.addToParentDiv = bind(this.addToParentDiv, this);
                    this.addAsMapControl = bind(this.addAsMapControl, this);
                    this.init = bind(this.init, this);
                    if (this.attrs.template == null) {
                        this.$log.error("template attribute for the search-box directive is mandatory. Places Search Box creation aborted!!");
                        return;
                    }
                    if (angular.isUndefined(this.scope.options)) {
                        this.scope.options = {};
                        this.scope.options.visible = true;
                    }
                    if (angular.isUndefined(this.scope.options.visible)) {
                        this.scope.options.visible = true;
                    }
                    if (angular.isUndefined(this.scope.options.autocomplete)) {
                        this.scope.options.autocomplete = false;
                    }
                    this.visible = this.scope.options.visible;
                    this.autocomplete = this.scope.options.autocomplete;
                    controlDiv = angular.element("<div></div>");
                    controlDiv.append(this.template);
                    this.input = controlDiv.find("input")[0];
                    this.init();
                }
                SearchBoxParentModel.prototype.init = function() {
                    this.createSearchBox();
                    this.scope.$watch("options", function(_this) {
                        return function(newValue, oldValue) {
                            if (angular.isObject(newValue)) {
                                if (newValue.bounds != null) {
                                    _this.setBounds(newValue.bounds);
                                }
                                if (newValue.visible != null) {
                                    if (_this.visible !== newValue.visible) {
                                        return _this.setVisibility(newValue.visible);
                                    }
                                }
                            }
                        };
                    }(this), true);
                    if (this.attrs.parentdiv != null) {
                        this.addToParentDiv();
                    } else {
                        this.addAsMapControl();
                    }
                    if (!this.visible) {
                        this.setVisibility(this.visible);
                    }
                    if (this.autocomplete) {
                        this.listener = google.maps.event.addListener(this.gObject, "place_changed", function(_this) {
                            return function() {
                                return _this.places = _this.gObject.getPlace();
                            };
                        }(this));
                    } else {
                        this.listener = google.maps.event.addListener(this.gObject, "places_changed", function(_this) {
                            return function() {
                                return _this.places = _this.gObject.getPlaces();
                            };
                        }(this));
                    }
                    this.listeners = this.setEvents(this.gObject, this.scope, this.scope);
                    this.$log.info(this);
                    return this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return _this.gObject = null;
                        };
                    }(this));
                };
                SearchBoxParentModel.prototype.addAsMapControl = function() {
                    return this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].push(this.input);
                };
                SearchBoxParentModel.prototype.addToParentDiv = function() {
                    this.parentDiv = angular.element(document.getElementById(this.scope.parentdiv));
                    return this.parentDiv.append(this.input);
                };
                SearchBoxParentModel.prototype.createSearchBox = function() {
                    if (this.autocomplete) {
                        return this.gObject = new google.maps.places.Autocomplete(this.input, this.scope.options);
                    } else {
                        return this.gObject = new google.maps.places.SearchBox(this.input, this.scope.options);
                    }
                };
                SearchBoxParentModel.prototype.setBounds = function(bounds) {
                    if (angular.isUndefined(bounds.isEmpty)) {
                        this.$log.error("Error: SearchBoxParentModel setBounds. Bounds not an instance of LatLngBounds.");
                    } else {
                        if (bounds.isEmpty() === false) {
                            if (this.gObject != null) {
                                return this.gObject.setBounds(bounds);
                            }
                        }
                    }
                };
                SearchBoxParentModel.prototype.getBounds = function() {
                    return this.gObject.getBounds();
                };
                SearchBoxParentModel.prototype.setVisibility = function(val) {
                    if (this.attrs.parentdiv != null) {
                        if (val === false) {
                            this.parentDiv.addClass("ng-hide");
                        } else {
                            this.parentDiv.removeClass("ng-hide");
                        }
                    } else {
                        if (val === false) {
                            this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].clear();
                        } else {
                            this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].push(this.input);
                        }
                    }
                    return this.visible = val;
                };
                return SearchBoxParentModel;
            }(BaseObject);
            return SearchBoxParentModel;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapWindowsParentModel", [ "uiGmapIWindowParentModel", "uiGmapModelsWatcher", "uiGmapPropMap", "uiGmapWindowChildModel", "uiGmapLinked", "uiGmap_async", "uiGmapLogger", "$timeout", "$compile", "$http", "$templateCache", "$interpolate", "uiGmapPromise", "uiGmapIWindow", "uiGmapGmapUtil", function(IWindowParentModel, ModelsWatcher, PropMap, WindowChildModel, Linked, _async, $log, $timeout, $compile, $http, $templateCache, $interpolate, uiGmapPromise, IWindow, GmapUtil) {
            var WindowsParentModel;
            WindowsParentModel = function(superClass) {
                extend(WindowsParentModel, superClass);
                WindowsParentModel.include(ModelsWatcher);
                function WindowsParentModel(scope, element, attrs, ctrls, gMap1, markersScope) {
                    this.gMap = gMap1;
                    this.markersScope = markersScope;
                    this.modelKeyComparison = bind(this.modelKeyComparison, this);
                    this.interpolateContent = bind(this.interpolateContent, this);
                    this.setChildScope = bind(this.setChildScope, this);
                    this.createWindow = bind(this.createWindow, this);
                    this.setContentKeys = bind(this.setContentKeys, this);
                    this.pieceMeal = bind(this.pieceMeal, this);
                    this.createAllNew = bind(this.createAllNew, this);
                    this.watchIdKey = bind(this.watchIdKey, this);
                    this.createChildScopes = bind(this.createChildScopes, this);
                    this.watchOurScope = bind(this.watchOurScope, this);
                    this.watchDestroy = bind(this.watchDestroy, this);
                    this.onDestroy = bind(this.onDestroy, this);
                    this.rebuildAll = bind(this.rebuildAll, this);
                    this.doINeedToWipe = bind(this.doINeedToWipe, this);
                    this.watchModels = bind(this.watchModels, this);
                    this.go = bind(this.go, this);
                    WindowsParentModel.__super__.constructor.call(this, scope, element, attrs, ctrls, $timeout, $compile, $http, $templateCache);
                    this["interface"] = IWindow;
                    this.plurals = new PropMap();
                    _.each(IWindow.scopeKeys, function(_this) {
                        return function(name) {
                            return _this[name + "Key"] = void 0;
                        };
                    }(this));
                    this.linked = new Linked(scope, element, attrs, ctrls);
                    this.contentKeys = void 0;
                    this.isIconVisibleOnClick = void 0;
                    this.firstTime = true;
                    this.firstWatchModels = true;
                    this.$log.info(self);
                    this.parentScope = void 0;
                    this.go(scope);
                }
                WindowsParentModel.prototype.go = function(scope) {
                    this.watchOurScope(scope);
                    this.doRebuildAll = this.scope.doRebuildAll != null ? this.scope.doRebuildAll : false;
                    scope.$watch("doRebuildAll", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                return _this.doRebuildAll = newValue;
                            }
                        };
                    }(this));
                    return this.createChildScopes();
                };
                WindowsParentModel.prototype.watchModels = function(scope) {
                    var itemToWatch;
                    itemToWatch = this.markersScope != null ? "pluralsUpdate" : "models";
                    return scope.$watch(itemToWatch, function(_this) {
                        return function(newValue, oldValue) {
                            var doScratch;
                            if (!_.isEqual(newValue, oldValue) || _this.firstWatchModels) {
                                _this.firstWatchModels = false;
                                if (_this.doRebuildAll || _this.doINeedToWipe(scope.models)) {
                                    return _this.rebuildAll(scope, true, true);
                                } else {
                                    doScratch = _this.plurals.length === 0;
                                    if (_this.existingPieces != null) {
                                        return _.last(_this.existingPieces._content).then(function() {
                                            return _this.createChildScopes(doScratch);
                                        });
                                    } else {
                                        return _this.createChildScopes(doScratch);
                                    }
                                }
                            }
                        };
                    }(this), true);
                };
                WindowsParentModel.prototype.doINeedToWipe = function(newValue) {
                    var newValueIsEmpty;
                    newValueIsEmpty = newValue != null ? newValue.length === 0 : true;
                    return this.plurals.length > 0 && newValueIsEmpty;
                };
                WindowsParentModel.prototype.rebuildAll = function(scope, doCreate, doDelete) {
                    return this.onDestroy(doDelete).then(function(_this) {
                        return function() {
                            if (doCreate) {
                                return _this.createChildScopes();
                            }
                        };
                    }(this));
                };
                WindowsParentModel.prototype.onDestroy = function(scope) {
                    WindowsParentModel.__super__.onDestroy.call(this, this.scope);
                    return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, function(_this) {
                        return function() {
                            return _async.each(_this.plurals.values(), function(child) {
                                return child.destroy();
                            }, _async.chunkSizeFrom(_this.scope.cleanchunk, false)).then(function() {
                                var ref;
                                return (ref = _this.plurals) != null ? ref.removeAll() : void 0;
                            });
                        };
                    }(this));
                };
                WindowsParentModel.prototype.watchDestroy = function(scope) {
                    return scope.$on("$destroy", function(_this) {
                        return function() {
                            _this.firstWatchModels = true;
                            _this.firstTime = true;
                            return _this.rebuildAll(scope, false, true);
                        };
                    }(this));
                };
                WindowsParentModel.prototype.watchOurScope = function(scope) {
                    return _.each(IWindow.scopeKeys, function(_this) {
                        return function(name) {
                            var nameKey;
                            nameKey = name + "Key";
                            return _this[nameKey] = typeof scope[name] === "function" ? scope[name]() : scope[name];
                        };
                    }(this));
                };
                WindowsParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
                    var modelsNotDefined, ref, ref1;
                    if (isCreatingFromScratch == null) {
                        isCreatingFromScratch = true;
                    }
                    this.isIconVisibleOnClick = true;
                    if (angular.isDefined(this.linked.attrs.isiconvisibleonclick)) {
                        this.isIconVisibleOnClick = this.linked.scope.isIconVisibleOnClick;
                    }
                    modelsNotDefined = angular.isUndefined(this.linked.scope.models);
                    if (modelsNotDefined && (this.markersScope === void 0 || (((ref = this.markersScope) != null ? ref.plurals : void 0) === void 0 || ((ref1 = this.markersScope) != null ? ref1.models : void 0) === void 0))) {
                        this.$log.error("No models to create windows from! Need direct models or models derived from markers!");
                        return;
                    }
                    if (this.gMap != null) {
                        if (this.linked.scope.models != null) {
                            this.watchIdKey(this.linked.scope);
                            if (isCreatingFromScratch) {
                                return this.createAllNew(this.linked.scope, false);
                            } else {
                                return this.pieceMeal(this.linked.scope, false);
                            }
                        } else {
                            this.parentScope = this.markersScope;
                            this.watchIdKey(this.parentScope);
                            if (isCreatingFromScratch) {
                                return this.createAllNew(this.markersScope, true, "plurals", false);
                            } else {
                                return this.pieceMeal(this.markersScope, true, "plurals", false);
                            }
                        }
                    }
                };
                WindowsParentModel.prototype.watchIdKey = function(scope) {
                    this.setIdKey(scope);
                    return scope.$watch("idKey", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue && newValue == null) {
                                _this.idKey = newValue;
                                return _this.rebuildAll(scope, true, true);
                            }
                        };
                    }(this));
                };
                WindowsParentModel.prototype.createAllNew = function(scope, hasGMarker, modelsPropToIterate, isArray) {
                    var maybeCanceled;
                    if (modelsPropToIterate == null) {
                        modelsPropToIterate = "models";
                    }
                    if (isArray == null) {
                        isArray = false;
                    }
                    if (this.firstTime) {
                        this.watchModels(scope);
                        this.watchDestroy(scope);
                    }
                    this.setContentKeys(scope.models);
                    if (this.didQueueInitPromise(this, scope)) {
                        return;
                    }
                    maybeCanceled = null;
                    return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, "createAllNew", function(canceledMsg) {
                        return maybeCanceled = canceledMsg;
                    }, function(_this) {
                        return function() {
                            return _async.each(scope.models, function(model) {
                                var gMarker, ref;
                                gMarker = hasGMarker ? (ref = _this.getItem(scope, modelsPropToIterate, model[_this.idKey])) != null ? ref.gObject : void 0 : void 0;
                                if (!maybeCanceled) {
                                    if (!gMarker && _this.markersScope) {
                                        $log.error("Unable to get gMarker from markersScope!");
                                    }
                                    _this.createWindow(model, gMarker, _this.gMap);
                                }
                                return maybeCanceled;
                            }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                                return _this.firstTime = false;
                            });
                        };
                    }(this));
                };
                WindowsParentModel.prototype.pieceMeal = function(scope, hasGMarker, modelsPropToIterate, isArray) {
                    var maybeCanceled, payload;
                    if (modelsPropToIterate == null) {
                        modelsPropToIterate = "models";
                    }
                    if (isArray == null) {
                        isArray = true;
                    }
                    if (scope.$$destroyed) {
                        return;
                    }
                    maybeCanceled = null;
                    payload = null;
                    if (scope != null && this.modelsLength() && this.plurals.length) {
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, "pieceMeal", function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }, function(_this) {
                            return function() {
                                return uiGmapPromise.promise(function() {
                                    return _this.figureOutState(_this.idKey, scope, _this.plurals, _this.modelKeyComparison);
                                }).then(function(state) {
                                    payload = state;
                                    return _async.each(payload.removals, function(child) {
                                        if (child != null) {
                                            _this.plurals.remove(child.id);
                                            if (child.destroy != null) {
                                                child.destroy(true);
                                            }
                                            return maybeCanceled;
                                        }
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    return _async.each(payload.adds, function(modelToAdd) {
                                        var gMarker, ref;
                                        gMarker = (ref = _this.getItem(scope, modelsPropToIterate, modelToAdd[_this.idKey])) != null ? ref.gObject : void 0;
                                        if (!gMarker) {
                                            throw "Gmarker undefined";
                                        }
                                        _this.createWindow(modelToAdd, gMarker, _this.gMap);
                                        return maybeCanceled;
                                    });
                                }).then(function() {
                                    return _async.each(payload.updates, function(update) {
                                        _this.updateChild(update.child, update.model);
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk));
                                });
                            };
                        }(this));
                    } else {
                        $log.debug("pieceMeal: rebuildAll");
                        return this.rebuildAll(this.scope, true, true);
                    }
                };
                WindowsParentModel.prototype.setContentKeys = function(models) {
                    if (this.modelsLength(models)) {
                        return this.contentKeys = Object.keys(models[0]);
                    }
                };
                WindowsParentModel.prototype.createWindow = function(model, gMarker, gMap) {
                    var child, childScope, fakeElement, opts, ref, ref1;
                    childScope = this.linked.scope.$new(false);
                    this.setChildScope(childScope, model);
                    childScope.$watch("model", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                return _this.setChildScope(childScope, newValue);
                            }
                        };
                    }(this), true);
                    fakeElement = {
                        html: function(_this) {
                            return function() {
                                return _this.interpolateContent(_this.linked.element.html(), model);
                            };
                        }(this)
                    };
                    this.DEFAULTS = this.scopeOrModelVal(this.optionsKey, this.scope, model) || {};
                    opts = this.createWindowOptions(gMarker, childScope, fakeElement.html(), this.DEFAULTS);
                    child = new WindowChildModel(model, childScope, opts, this.isIconVisibleOnClick, gMap, (ref = this.markersScope) != null ? (ref1 = ref.plurals.get(model[this.idKey])) != null ? ref1.scope : void 0 : void 0, fakeElement, false, true);
                    if (model[this.idKey] == null) {
                        this.$log.error("Window model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
                        return;
                    }
                    this.plurals.put(model[this.idKey], child);
                    return child;
                };
                WindowsParentModel.prototype.setChildScope = function(childScope, model) {
                    _.each(IWindow.scopeKeys, function(_this) {
                        return function(name) {
                            var nameKey, newValue;
                            nameKey = name + "Key";
                            newValue = _this[nameKey] === "self" ? model : model[_this[nameKey]];
                            if (newValue !== childScope[name]) {
                                return childScope[name] = newValue;
                            }
                        };
                    }(this));
                    return childScope.model = model;
                };
                WindowsParentModel.prototype.interpolateContent = function(content, model) {
                    var exp, i, interpModel, key, len, ref;
                    if (this.contentKeys === void 0 || this.contentKeys.length === 0) {
                        return;
                    }
                    exp = $interpolate(content);
                    interpModel = {};
                    ref = this.contentKeys;
                    for (i = 0, len = ref.length; i < len; i++) {
                        key = ref[i];
                        interpModel[key] = model[key];
                    }
                    return exp(interpModel);
                };
                WindowsParentModel.prototype.modelKeyComparison = function(model1, model2) {
                    var isEqual, scope;
                    scope = this.scope.coords != null ? this.scope : this.parentScope;
                    if (scope == null) {
                        throw "No scope or parentScope set!";
                    }
                    isEqual = GmapUtil.equalCoords(this.evalModelHandle(model1, scope.coords), this.evalModelHandle(model2, scope.coords));
                    if (!isEqual) {
                        return isEqual;
                    }
                    isEqual = _.every(_.without(this["interface"].scopeKeys, "coords"), function(_this) {
                        return function(k) {
                            return _this.evalModelHandle(model1, scope[k]) === _this.evalModelHandle(model2, scope[k]);
                        };
                    }(this));
                    return isEqual;
                };
                return WindowsParentModel;
            }(IWindowParentModel);
            return WindowsParentModel;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapCircle", [ "uiGmapICircle", "uiGmapCircleParentModel", function(ICircle, CircleParentModel) {
            return _.extend(ICircle, {
                link: function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            return new CircleParentModel(scope, element, attrs, map);
                        };
                    }(this));
                }
            });
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapControl", [ "uiGmapIControl", "$http", "$templateCache", "$compile", "$controller", "uiGmapGoogleMapApi", function(IControl, $http, $templateCache, $compile, $controller, GoogleMapApi) {
            var Control;
            return Control = function(superClass) {
                extend(Control, superClass);
                function Control() {
                    this.link = bind(this.link, this);
                    Control.__super__.constructor.call(this);
                }
                Control.prototype.link = function(scope, element, attrs, ctrl) {
                    return GoogleMapApi.then(function(_this) {
                        return function(maps) {
                            var index, position;
                            if (angular.isUndefined(scope.template)) {
                                _this.$log.error("mapControl: could not find a valid template property");
                                return;
                            }
                            index = angular.isDefined(scope.index && !isNaN(parseInt(scope.index))) ? parseInt(scope.index) : void 0;
                            position = angular.isDefined(scope.position) ? scope.position.toUpperCase().replace(/-/g, "_") : "TOP_CENTER";
                            if (!maps.ControlPosition[position]) {
                                _this.$log.error("mapControl: invalid position property");
                                return;
                            }
                            return IControl.mapPromise(scope, ctrl).then(function(map) {
                                var control, controlDiv;
                                control = void 0;
                                controlDiv = angular.element("<div></div>");
                                return $http.get(scope.template, {
                                    cache: $templateCache
                                }).success(function(template) {
                                    var templateCtrl, templateScope;
                                    templateScope = scope.$new();
                                    controlDiv.append(template);
                                    if (angular.isDefined(scope.controller)) {
                                        templateCtrl = $controller(scope.controller, {
                                            $scope: templateScope
                                        });
                                        controlDiv.children().data("$ngControllerController", templateCtrl);
                                    }
                                    control = $compile(controlDiv.children())(templateScope);
                                    if (index) {
                                        return control[0].index = index;
                                    }
                                }).error(function(error) {
                                    return _this.$log.error("mapControl: template could not be found");
                                }).then(function() {
                                    return map.controls[google.maps.ControlPosition[position]].push(control[0]);
                                });
                            });
                        };
                    }(this));
                };
                return Control;
            }(IControl);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapDragZoom", [ "uiGmapCtrlHandle", "uiGmapPropertyAction", function(CtrlHandle, PropertyAction) {
            return {
                restrict: "EMA",
                transclude: true,
                template: '<div class="angular-google-map-dragzoom" ng-transclude style="display: none"></div>',
                require: "^" + "uiGmapGoogleMap",
                scope: {
                    keyboardkey: "=",
                    options: "=",
                    spec: "="
                },
                controller: [ "$scope", "$element", function($scope, $element) {
                    $scope.ctrlType = "uiGmapDragZoom";
                    return _.extend(this, CtrlHandle.handle($scope, $element));
                } ],
                link: function(scope, element, attrs, ctrl) {
                    return CtrlHandle.mapPromise(scope, ctrl).then(function(map) {
                        var enableKeyDragZoom, setKeyAction, setOptionsAction;
                        enableKeyDragZoom = function(opts) {
                            map.enableKeyDragZoom(opts);
                            if (scope.spec) {
                                return scope.spec.enableKeyDragZoom(opts);
                            }
                        };
                        setKeyAction = new PropertyAction(function(key, newVal) {
                            if (newVal) {
                                return enableKeyDragZoom({
                                    key: newVal
                                });
                            } else {
                                return enableKeyDragZoom();
                            }
                        });
                        setOptionsAction = new PropertyAction(function(key, newVal) {
                            if (newVal) {
                                return enableKeyDragZoom(newVal);
                            }
                        });
                        scope.$watch("keyboardkey", setKeyAction.sic);
                        setKeyAction.sic(scope.keyboardkey);
                        scope.$watch("options", setOptionsAction.sic);
                        return setOptionsAction.sic(scope.options);
                    });
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapDrawingManager", [ "uiGmapIDrawingManager", "uiGmapDrawingManagerParentModel", function(IDrawingManager, DrawingManagerParentModel) {
            return _.extend(IDrawingManager, {
                link: function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(map) {
                        return new DrawingManagerParentModel(scope, element, attrs, map);
                    });
                }
            });
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapApiFreeDrawPolygons", [ "uiGmapLogger", "uiGmapBaseObject", "uiGmapCtrlHandle", "uiGmapDrawFreeHandChildModel", "uiGmapLodash", function($log, BaseObject, CtrlHandle, DrawFreeHandChildModel, uiGmapLodash) {
            var FreeDrawPolygons;
            return FreeDrawPolygons = function(superClass) {
                extend(FreeDrawPolygons, superClass);
                function FreeDrawPolygons() {
                    this.link = bind(this.link, this);
                    return FreeDrawPolygons.__super__.constructor.apply(this, arguments);
                }
                FreeDrawPolygons.include(CtrlHandle);
                FreeDrawPolygons.prototype.restrict = "EMA";
                FreeDrawPolygons.prototype.replace = true;
                FreeDrawPolygons.prototype.require = "^" + "uiGmapGoogleMap";
                FreeDrawPolygons.prototype.scope = {
                    polygons: "=",
                    draw: "="
                };
                FreeDrawPolygons.prototype.link = function(scope, element, attrs, ctrl) {
                    return this.mapPromise(scope, ctrl).then(function(_this) {
                        return function(map) {
                            var freeHand, listener;
                            if (!scope.polygons) {
                                return $log.error("No polygons to bind to!");
                            }
                            if (!_.isArray(scope.polygons)) {
                                return $log.error("Free Draw Polygons must be of type Array!");
                            }
                            freeHand = new DrawFreeHandChildModel(map, ctrl.getScope());
                            listener = void 0;
                            return scope.draw = function() {
                                if (typeof listener === "function") {
                                    listener();
                                }
                                return freeHand.engage(scope.polygons).then(function() {
                                    var firstTime;
                                    firstTime = true;
                                    return listener = scope.$watchCollection("polygons", function(newValue, oldValue) {
                                        var removals;
                                        if (firstTime || newValue === oldValue) {
                                            firstTime = false;
                                            return;
                                        }
                                        removals = uiGmapLodash.differenceObjects(oldValue, newValue);
                                        return removals.forEach(function(p) {
                                            return p.setMap(null);
                                        });
                                    });
                                });
                            };
                        };
                    }(this));
                };
                return FreeDrawPolygons;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapICircle", [ function() {
            var DEFAULTS;
            DEFAULTS = {};
            return {
                restrict: "EA",
                replace: true,
                require: "^" + "uiGmapGoogleMap",
                scope: {
                    center: "=center",
                    radius: "=radius",
                    stroke: "=stroke",
                    fill: "=fill",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    geodesic: "=",
                    icons: "=icons",
                    visible: "=",
                    events: "=",
                    control: "=",
                    zIndex: "=zindex"
                }
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIControl", [ "uiGmapBaseObject", "uiGmapLogger", "uiGmapCtrlHandle", function(BaseObject, Logger, CtrlHandle) {
            var IControl;
            return IControl = function(superClass) {
                extend(IControl, superClass);
                IControl.extend(CtrlHandle);
                function IControl() {
                    this.restrict = "EA";
                    this.replace = true;
                    this.require = "^" + "uiGmapGoogleMap";
                    this.scope = {
                        template: "@template",
                        position: "@position",
                        controller: "@controller",
                        index: "@index"
                    };
                    this.$log = Logger;
                }
                IControl.prototype.link = function(scope, element, attrs, ctrl) {
                    throw new Exception("Not implemented!!");
                };
                return IControl;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapIDrawingManager", [ function() {
            return {
                restrict: "EA",
                replace: true,
                require: "^" + "uiGmapGoogleMap",
                scope: {
                    static: "@",
                    control: "=",
                    options: "=",
                    events: "="
                }
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIMarker", [ "uiGmapBaseObject", "uiGmapCtrlHandle", function(BaseObject, CtrlHandle) {
            var IMarker;
            return IMarker = function(superClass) {
                extend(IMarker, superClass);
                IMarker.scope = {
                    coords: "=coords",
                    icon: "=icon",
                    click: "&click",
                    options: "=options",
                    events: "=events",
                    fit: "=fit",
                    idKey: "=idkey",
                    control: "=control"
                };
                IMarker.scopeKeys = _.keys(IMarker.scope);
                IMarker.keys = IMarker.scopeKeys;
                IMarker.extend(CtrlHandle);
                function IMarker() {
                    this.restrict = "EMA";
                    this.require = "^" + "uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = true;
                    this.replace = true;
                    this.scope = _.extend(this.scope || {}, IMarker.scope);
                }
                return IMarker;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIPolygon", [ "uiGmapGmapUtil", "uiGmapBaseObject", "uiGmapLogger", "uiGmapCtrlHandle", function(GmapUtil, BaseObject, Logger, CtrlHandle) {
            var IPolygon;
            return IPolygon = function(superClass) {
                extend(IPolygon, superClass);
                IPolygon.scope = {
                    path: "=path",
                    stroke: "=stroke",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    geodesic: "=",
                    fill: "=",
                    icons: "=icons",
                    visible: "=",
                    static: "=",
                    events: "=",
                    zIndex: "=zindex",
                    fit: "=",
                    control: "=control"
                };
                IPolygon.scopeKeys = _.keys(IPolygon.scope);
                IPolygon.include(GmapUtil);
                IPolygon.extend(CtrlHandle);
                function IPolygon() {}
                IPolygon.prototype.restrict = "EMA";
                IPolygon.prototype.replace = true;
                IPolygon.prototype.require = "^" + "uiGmapGoogleMap";
                IPolygon.prototype.scope = IPolygon.scope;
                IPolygon.prototype.DEFAULTS = {};
                IPolygon.prototype.$log = Logger;
                return IPolygon;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIPolyline", [ "uiGmapGmapUtil", "uiGmapBaseObject", "uiGmapLogger", "uiGmapCtrlHandle", function(GmapUtil, BaseObject, Logger, CtrlHandle) {
            var IPolyline;
            return IPolyline = function(superClass) {
                extend(IPolyline, superClass);
                IPolyline.scope = {
                    path: "=",
                    stroke: "=",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    geodesic: "=",
                    icons: "=",
                    visible: "=",
                    static: "=",
                    fit: "=",
                    events: "=",
                    zIndex: "=zindex"
                };
                IPolyline.scopeKeys = _.keys(IPolyline.scope);
                IPolyline.include(GmapUtil);
                IPolyline.extend(CtrlHandle);
                function IPolyline() {}
                IPolyline.prototype.restrict = "EMA";
                IPolyline.prototype.replace = true;
                IPolyline.prototype.require = "^" + "uiGmapGoogleMap";
                IPolyline.prototype.scope = IPolyline.scope;
                IPolyline.prototype.DEFAULTS = {};
                IPolyline.prototype.$log = Logger;
                return IPolyline;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapIRectangle", [ function() {
            "use strict";
            var DEFAULTS;
            DEFAULTS = {};
            return {
                restrict: "EMA",
                require: "^" + "uiGmapGoogleMap",
                replace: true,
                scope: {
                    bounds: "=",
                    stroke: "=",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    fill: "=",
                    visible: "=",
                    events: "="
                }
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIWindow", [ "uiGmapBaseObject", "uiGmapChildEvents", "uiGmapCtrlHandle", function(BaseObject, ChildEvents, CtrlHandle) {
            var IWindow;
            return IWindow = function(superClass) {
                extend(IWindow, superClass);
                IWindow.scope = {
                    coords: "=coords",
                    template: "=template",
                    templateUrl: "=templateurl",
                    templateParameter: "=templateparameter",
                    isIconVisibleOnClick: "=isiconvisibleonclick",
                    closeClick: "&closeclick",
                    options: "=options",
                    control: "=control",
                    show: "=show"
                };
                IWindow.scopeKeys = _.keys(IWindow.scope);
                IWindow.include(ChildEvents);
                IWindow.extend(CtrlHandle);
                function IWindow() {
                    this.restrict = "EMA";
                    this.template = void 0;
                    this.transclude = true;
                    this.priority = -100;
                    this.require = "^" + "uiGmapGoogleMap";
                    this.replace = true;
                    this.scope = _.extend(this.scope || {}, IWindow.scope);
                }
                return IWindow;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMap", [ "$timeout", "$q", "uiGmapLogger", "uiGmapGmapUtil", "uiGmapBaseObject", "uiGmapCtrlHandle", "uiGmapIsReady", "uiGmapuuid", "uiGmapExtendGWin", "uiGmapExtendMarkerClusterer", "uiGmapGoogleMapsUtilV3", "uiGmapGoogleMapApi", "uiGmapEventsHelper", function($timeout, $q, $log, GmapUtil, BaseObject, CtrlHandle, IsReady, uuid, ExtendGWin, ExtendMarkerClusterer, GoogleMapsUtilV3, GoogleMapApi, EventsHelper) {
            "use strict";
            var DEFAULTS, Map, initializeItems;
            DEFAULTS = void 0;
            initializeItems = [ GoogleMapsUtilV3, ExtendGWin, ExtendMarkerClusterer ];
            return Map = function(superClass) {
                extend(Map, superClass);
                Map.include(GmapUtil);
                function Map() {
                    this.link = bind(this.link, this);
                    var ctrlFn, self;
                    ctrlFn = function($scope) {
                        var ctrlObj, retCtrl;
                        retCtrl = void 0;
                        $scope.$on("$destroy", function() {
                            return IsReady.decrement();
                        });
                        ctrlObj = CtrlHandle.handle($scope);
                        $scope.ctrlType = "Map";
                        $scope.deferred.promise.then(function() {
                            return initializeItems.forEach(function(i) {
                                return i.init();
                            });
                        });
                        ctrlObj.getMap = function() {
                            return $scope.map;
                        };
                        retCtrl = _.extend(this, ctrlObj);
                        return retCtrl;
                    };
                    this.controller = [ "$scope", ctrlFn ];
                    self = this;
                }
                Map.prototype.restrict = "EMA";
                Map.prototype.transclude = true;
                Map.prototype.replace = false;
                Map.prototype.template = '<div class="angular-google-map"><div class="angular-google-map-container">\n</div><div ng-transclude style="display: none"></div></div>';
                Map.prototype.scope = {
                    center: "=",
                    zoom: "=",
                    dragging: "=",
                    control: "=",
                    options: "=",
                    events: "=",
                    eventOpts: "=",
                    styles: "=",
                    bounds: "=",
                    update: "="
                };
                Map.prototype.link = function(scope, element, attrs) {
                    var listeners, unbindCenterWatch;
                    listeners = [];
                    scope.$on("$destroy", function() {
                        return EventsHelper.removeEvents(listeners);
                    });
                    scope.idleAndZoomChanged = false;
                    if (scope.center == null) {
                        unbindCenterWatch = scope.$watch("center", function(_this) {
                            return function() {
                                if (!scope.center) {
                                    return;
                                }
                                unbindCenterWatch();
                                return _this.link(scope, element, attrs);
                            };
                        }(this));
                        return;
                    }
                    return GoogleMapApi.then(function(_this) {
                        return function(maps) {
                            var _gMap, customListeners, disabledEvents, dragging, el, eventName, getEventHandler, mapOptions, maybeHookToEvent, opts, ref, resolveSpawned, settingFromDirective, spawned, type, updateCenter, zoomPromise;
                            DEFAULTS = {
                                mapTypeId: maps.MapTypeId.ROADMAP
                            };
                            spawned = IsReady.spawn();
                            resolveSpawned = function() {
                                return spawned.deferred.resolve({
                                    instance: spawned.instance,
                                    map: _gMap
                                });
                            };
                            if (!_this.validateCoords(scope.center)) {
                                $log.error("angular-google-maps: could not find a valid center property");
                                return;
                            }
                            if (!angular.isDefined(scope.zoom)) {
                                $log.error("angular-google-maps: map zoom property not set");
                                return;
                            }
                            el = angular.element(element);
                            el.addClass("angular-google-map");
                            opts = {
                                options: {}
                            };
                            if (attrs.options) {
                                opts.options = scope.options;
                            }
                            if (attrs.styles) {
                                opts.styles = scope.styles;
                            }
                            if (attrs.type) {
                                type = attrs.type.toUpperCase();
                                if (google.maps.MapTypeId.hasOwnProperty(type)) {
                                    opts.mapTypeId = google.maps.MapTypeId[attrs.type.toUpperCase()];
                                } else {
                                    $log.error("angular-google-maps: invalid map type '" + attrs.type + "'");
                                }
                            }
                            mapOptions = angular.extend({}, DEFAULTS, opts, {
                                center: _this.getCoords(scope.center),
                                zoom: scope.zoom,
                                bounds: scope.bounds
                            });
                            _gMap = new google.maps.Map(el.find("div")[1], mapOptions);
                            _gMap["uiGmap_id"] = uuid.generate();
                            dragging = false;
                            listeners.push(google.maps.event.addListenerOnce(_gMap, "idle", function() {
                                scope.deferred.resolve(_gMap);
                                return resolveSpawned();
                            }));
                            disabledEvents = attrs.events && ((ref = scope.events) != null ? ref.blacklist : void 0) != null ? scope.events.blacklist : [];
                            if (_.isString(disabledEvents)) {
                                disabledEvents = [ disabledEvents ];
                            }
                            maybeHookToEvent = function(eventName, fn, prefn) {
                                if (!_.contains(disabledEvents, eventName)) {
                                    if (prefn) {
                                        prefn();
                                    }
                                    return listeners.push(google.maps.event.addListener(_gMap, eventName, function() {
                                        var ref1;
                                        if (!((ref1 = scope.update) != null ? ref1.lazy : void 0)) {
                                            return fn();
                                        }
                                    }));
                                }
                            };
                            if (!_.contains(disabledEvents, "all")) {
                                maybeHookToEvent("dragstart", function() {
                                    dragging = true;
                                    return scope.$evalAsync(function(s) {
                                        if (s.dragging != null) {
                                            return s.dragging = dragging;
                                        }
                                    });
                                });
                                maybeHookToEvent("dragend", function() {
                                    dragging = false;
                                    return scope.$evalAsync(function(s) {
                                        if (s.dragging != null) {
                                            return s.dragging = dragging;
                                        }
                                    });
                                });
                                updateCenter = function(c, s) {
                                    if (c == null) {
                                        c = _gMap.center;
                                    }
                                    if (s == null) {
                                        s = scope;
                                    }
                                    if (_.contains(disabledEvents, "center")) {
                                        return;
                                    }
                                    if (angular.isDefined(s.center.type)) {
                                        if (s.center.coordinates[1] !== c.lat()) {
                                            s.center.coordinates[1] = c.lat();
                                        }
                                        if (s.center.coordinates[0] !== c.lng()) {
                                            return s.center.coordinates[0] = c.lng();
                                        }
                                    } else {
                                        if (s.center.latitude !== c.lat()) {
                                            s.center.latitude = c.lat();
                                        }
                                        if (s.center.longitude !== c.lng()) {
                                            return s.center.longitude = c.lng();
                                        }
                                    }
                                };
                                settingFromDirective = false;
                                maybeHookToEvent("idle", function() {
                                    var b, ne, sw;
                                    b = _gMap.getBounds();
                                    ne = b.getNorthEast();
                                    sw = b.getSouthWest();
                                    settingFromDirective = true;
                                    return scope.$evalAsync(function(s) {
                                        updateCenter();
                                        if (!_.isUndefined(s.bounds) && !_.contains(disabledEvents, "bounds")) {
                                            s.bounds.northeast = {
                                                latitude: ne.lat(),
                                                longitude: ne.lng()
                                            };
                                            s.bounds.southwest = {
                                                latitude: sw.lat(),
                                                longitude: sw.lng()
                                            };
                                        }
                                        if (!_.contains(disabledEvents, "zoom")) {
                                            s.zoom = _gMap.zoom;
                                            scope.idleAndZoomChanged = !scope.idleAndZoomChanged;
                                        }
                                        return settingFromDirective = false;
                                    });
                                });
                            }
                            if (angular.isDefined(scope.events) && scope.events !== null && angular.isObject(scope.events)) {
                                getEventHandler = function(eventName) {
                                    return function() {
                                        return scope.events[eventName].apply(scope, [ _gMap, eventName, arguments ]);
                                    };
                                };
                                customListeners = [];
                                for (eventName in scope.events) {
                                    if (scope.events.hasOwnProperty(eventName) && angular.isFunction(scope.events[eventName])) {
                                        customListeners.push(google.maps.event.addListener(_gMap, eventName, getEventHandler(eventName)));
                                    }
                                }
                                listeners.concat(customListeners);
                            }
                            _gMap.getOptions = function() {
                                return mapOptions;
                            };
                            scope.map = _gMap;
                            if (attrs.control != null && scope.control != null) {
                                scope.control.refresh = function(maybeCoords) {
                                    var coords, ref1, ref2;
                                    if (_gMap == null) {
                                        return;
                                    }
                                    if ((typeof google !== "undefined" && google !== null ? (ref1 = google.maps) != null ? (ref2 = ref1.event) != null ? ref2.trigger : void 0 : void 0 : void 0) != null && _gMap != null) {
                                        google.maps.event.trigger(_gMap, "resize");
                                    }
                                    if ((maybeCoords != null ? maybeCoords.latitude : void 0) != null && (maybeCoords != null ? maybeCoords.longitude : void 0) != null) {
                                        coords = _this.getCoords(maybeCoords);
                                        if (_this.isTrue(attrs.pan)) {
                                            return _gMap.panTo(coords);
                                        } else {
                                            return _gMap.setCenter(coords);
                                        }
                                    }
                                };
                                scope.control.getGMap = function() {
                                    return _gMap;
                                };
                                scope.control.getMapOptions = function() {
                                    return mapOptions;
                                };
                                scope.control.getCustomEventListeners = function() {
                                    return customListeners;
                                };
                                scope.control.removeEvents = function(yourListeners) {
                                    return EventsHelper.removeEvents(yourListeners);
                                };
                            }
                            scope.$watch("center", function(newValue, oldValue) {
                                var coords, settingCenterFromScope;
                                if (newValue === oldValue || settingFromDirective) {
                                    return;
                                }
                                coords = _this.getCoords(scope.center);
                                if (coords.lat() === _gMap.center.lat() && coords.lng() === _gMap.center.lng()) {
                                    return;
                                }
                                settingCenterFromScope = true;
                                if (!dragging) {
                                    if (!_this.validateCoords(newValue)) {
                                        $log.error("Invalid center for newValue: " + JSON.stringify(newValue));
                                    }
                                    if (_this.isTrue(attrs.pan) && scope.zoom === _gMap.zoom) {
                                        _gMap.panTo(coords);
                                    } else {
                                        _gMap.setCenter(coords);
                                    }
                                }
                                return settingCenterFromScope = false;
                            }, true);
                            zoomPromise = null;
                            scope.$watch("zoom", function(newValue, oldValue) {
                                var ref1, ref2, settingZoomFromScope;
                                if (newValue == null) {
                                    return;
                                }
                                if (_.isEqual(newValue, oldValue) || (_gMap != null ? _gMap.getZoom() : void 0) === (scope != null ? scope.zoom : void 0) || settingFromDirective) {
                                    return;
                                }
                                settingZoomFromScope = true;
                                if (zoomPromise != null) {
                                    $timeout.cancel(zoomPromise);
                                }
                                return zoomPromise = $timeout(function() {
                                    _gMap.setZoom(newValue);
                                    return settingZoomFromScope = false;
                                }, ((ref1 = scope.eventOpts) != null ? (ref2 = ref1.debounce) != null ? ref2.zoomMs : void 0 : void 0) + 20, false);
                            });
                            scope.$watch("bounds", function(newValue, oldValue) {
                                var bounds, ne, ref1, ref2, ref3, ref4, sw;
                                if (newValue === oldValue) {
                                    return;
                                }
                                if ((newValue != null ? (ref1 = newValue.northeast) != null ? ref1.latitude : void 0 : void 0) == null || (newValue != null ? (ref2 = newValue.northeast) != null ? ref2.longitude : void 0 : void 0) == null || (newValue != null ? (ref3 = newValue.southwest) != null ? ref3.latitude : void 0 : void 0) == null || (newValue != null ? (ref4 = newValue.southwest) != null ? ref4.longitude : void 0 : void 0) == null) {
                                    $log.error("Invalid map bounds for new value: " + JSON.stringify(newValue));
                                    return;
                                }
                                ne = new google.maps.LatLng(newValue.northeast.latitude, newValue.northeast.longitude);
                                sw = new google.maps.LatLng(newValue.southwest.latitude, newValue.southwest.longitude);
                                bounds = new google.maps.LatLngBounds(sw, ne);
                                return _gMap.fitBounds(bounds);
                            });
                            return [ "options", "styles" ].forEach(function(toWatch) {
                                return scope.$watch(toWatch, function(newValue, oldValue) {
                                    var watchItem;
                                    watchItem = this.exp;
                                    if (_.isEqual(newValue, oldValue)) {
                                        return;
                                    }
                                    if (watchItem === "options") {
                                        opts.options = newValue;
                                    } else {
                                        opts.options[watchItem] = newValue;
                                    }
                                    if (_gMap != null) {
                                        return _gMap.setOptions(opts);
                                    }
                                }, true);
                            });
                        };
                    }(this));
                };
                return Map;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMarker", [ "uiGmapIMarker", "uiGmapMarkerChildModel", "uiGmapMarkerManager", "uiGmapLogger", function(IMarker, MarkerChildModel, MarkerManager, $log) {
            var Marker;
            return Marker = function(superClass) {
                extend(Marker, superClass);
                function Marker() {
                    this.link = bind(this.link, this);
                    Marker.__super__.constructor.call(this);
                    this.template = '<span class="angular-google-map-marker" ng-transclude></span>';
                    $log.info(this);
                }
                Marker.prototype.controller = [ "$scope", "$element", function($scope, $element) {
                    $scope.ctrlType = "Marker";
                    return _.extend(this, IMarker.handle($scope, $element));
                } ];
                Marker.prototype.link = function(scope, element, attrs, ctrl) {
                    var mapPromise;
                    mapPromise = IMarker.mapPromise(scope, ctrl);
                    mapPromise.then(function(_this) {
                        return function(map) {
                            var doClick, doDrawSelf, gManager, keys, m, trackModel;
                            gManager = new MarkerManager(map);
                            keys = _.object(IMarker.keys, IMarker.keys);
                            m = new MarkerChildModel(scope, scope, keys, map, {}, doClick = true, gManager, doDrawSelf = false, trackModel = false);
                            m.deferred.promise.then(function(gMarker) {
                                return scope.deferred.resolve(gMarker);
                            });
                            if (scope.control != null) {
                                return scope.control.getGMarkers = gManager.getGMarkers;
                            }
                        };
                    }(this));
                    return scope.$on("$destroy", function(_this) {
                        return function() {
                            var gManager;
                            if (typeof gManager !== "undefined" && gManager !== null) {
                                gManager.clear();
                            }
                            return gManager = null;
                        };
                    }(this));
                };
                return Marker;
            }(IMarker);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMarkers", [ "uiGmapIMarker", "uiGmapPlural", "uiGmapMarkersParentModel", "uiGmap_sync", "uiGmapLogger", function(IMarker, Plural, MarkersParentModel, _sync, $log) {
            var Markers;
            return Markers = function(superClass) {
                extend(Markers, superClass);
                function Markers() {
                    Markers.__super__.constructor.call(this);
                    this.template = '<span class="angular-google-map-markers" ng-transclude></span>';
                    Plural.extend(this, {
                        doCluster: "=?docluster",
                        clusterOptions: "=clusteroptions",
                        clusterEvents: "=clusterevents",
                        modelsByRef: "=modelsbyref",
                        type: "=?type",
                        typeOptions: "=?typeoptions",
                        typeEvents: "=?typeevents"
                    });
                    $log.info(this);
                }
                Markers.prototype.controller = [ "$scope", "$element", function($scope, $element) {
                    $scope.ctrlType = "Markers";
                    return _.extend(this, IMarker.handle($scope, $element));
                } ];
                Markers.prototype.link = function(scope, element, attrs, ctrl) {
                    var parentModel, ready;
                    parentModel = void 0;
                    ready = function() {
                        return scope.deferred.resolve();
                    };
                    return IMarker.mapPromise(scope, ctrl).then(function(map) {
                        var mapScope;
                        mapScope = ctrl.getScope();
                        mapScope.$watch("idleAndZoomChanged", function() {
                            return _.defer(parentModel.gManager.draw);
                        });
                        parentModel = new MarkersParentModel(scope, element, attrs, map);
                        Plural.link(scope, parentModel);
                        if (scope.control != null) {
                            scope.control.getGMarkers = function() {
                                var ref;
                                return (ref = parentModel.gManager) != null ? ref.getGMarkers() : void 0;
                            };
                            scope.control.getChildMarkers = function() {
                                return parentModel.plurals;
                            };
                        }
                        return _.last(parentModel.existingPieces._content).then(function() {
                            return ready();
                        });
                    });
                };
                return Markers;
            }(IMarker);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapPlural", [ function() {
            var _initControl;
            _initControl = function(scope, parent) {
                if (scope.control == null) {
                    return;
                }
                scope.control.updateModels = function(models) {
                    scope.models = models;
                    return parent.createChildScopes(false);
                };
                scope.control.newModels = function(models) {
                    scope.models = models;
                    return parent.rebuildAll(scope, true, true);
                };
                scope.control.clean = function() {
                    return parent.rebuildAll(scope, false, true);
                };
                scope.control.getPlurals = function() {
                    return parent.plurals;
                };
                scope.control.getManager = function() {
                    return parent.gManager;
                };
                scope.control.hasManager = function() {
                    return parent.gManager != null === true;
                };
                return scope.control.managerDraw = function() {
                    var ref;
                    if (scope.control.hasManager()) {
                        return (ref = scope.control.getManager()) != null ? ref.draw() : void 0;
                    }
                };
            };
            return {
                extend: function(obj, obj2) {
                    return _.extend(obj.scope || {}, obj2 || {}, {
                        idKey: "=idkey",
                        doRebuildAll: "=dorebuildall",
                        models: "=models",
                        chunk: "=chunk",
                        cleanchunk: "=cleanchunk",
                        control: "=control"
                    });
                },
                link: function(scope, parent) {
                    return _initControl(scope, parent);
                }
            };
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolygon", [ "uiGmapIPolygon", "$timeout", "uiGmapPolygonChildModel", function(IPolygon, $timeout, PolygonChild) {
            var Polygon;
            return Polygon = function(superClass) {
                extend(Polygon, superClass);
                function Polygon() {
                    this.link = bind(this.link, this);
                    return Polygon.__super__.constructor.apply(this, arguments);
                }
                Polygon.prototype.link = function(scope, element, attrs, mapCtrl) {
                    var children, promise;
                    children = [];
                    promise = IPolygon.mapPromise(scope, mapCtrl);
                    if (scope.control != null) {
                        scope.control.getInstance = this;
                        scope.control.polygons = children;
                        scope.control.promise = promise;
                    }
                    return promise.then(function(_this) {
                        return function(map) {
                            return children.push(new PolygonChild(scope, attrs, map, _this.DEFAULTS));
                        };
                    }(this));
                };
                return Polygon;
            }(IPolygon);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolygons", [ "uiGmapIPolygon", "$timeout", "uiGmapPolygonsParentModel", "uiGmapPlural", function(Interface, $timeout, ParentModel, Plural) {
            var Polygons;
            return Polygons = function(superClass) {
                extend(Polygons, superClass);
                function Polygons() {
                    this.link = bind(this.link, this);
                    Polygons.__super__.constructor.call(this);
                    Plural.extend(this);
                    this.$log.info(this);
                }
                Polygons.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            if (angular.isUndefined(scope.path) || scope.path === null) {
                                _this.$log.warn("polygons: no valid path attribute found");
                            }
                            if (!scope.models) {
                                _this.$log.warn("polygons: no models found to create from");
                            }
                            return Plural.link(scope, new ParentModel(scope, element, attrs, map, _this.DEFAULTS));
                        };
                    }(this));
                };
                return Polygons;
            }(Interface);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolyline", [ "uiGmapIPolyline", "$timeout", "uiGmapPolylineChildModel", function(IPolyline, $timeout, PolylineChildModel) {
            var Polyline;
            return Polyline = function(superClass) {
                extend(Polyline, superClass);
                function Polyline() {
                    this.link = bind(this.link, this);
                    return Polyline.__super__.constructor.apply(this, arguments);
                }
                Polyline.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return IPolyline.mapPromise(scope, mapCtrl).then(function(_this) {
                        return function(map) {
                            if (angular.isUndefined(scope.path) || scope.path === null || !_this.validatePath(scope.path)) {
                                _this.$log.warn("polyline: no valid path attribute found");
                            }
                            return new PolylineChildModel(scope, attrs, map, _this.DEFAULTS);
                        };
                    }(this));
                };
                return Polyline;
            }(IPolyline);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolylines", [ "uiGmapIPolyline", "$timeout", "uiGmapPolylinesParentModel", "uiGmapPlural", function(IPolyline, $timeout, PolylinesParentModel, Plural) {
            var Polylines;
            return Polylines = function(superClass) {
                extend(Polylines, superClass);
                function Polylines() {
                    this.link = bind(this.link, this);
                    Polylines.__super__.constructor.call(this);
                    Plural.extend(this);
                    this.$log.info(this);
                }
                Polylines.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            if (angular.isUndefined(scope.path) || scope.path === null) {
                                _this.$log.warn("polylines: no valid path attribute found");
                            }
                            if (!scope.models) {
                                _this.$log.warn("polylines: no models found to create from");
                            }
                            return Plural.link(scope, new PolylinesParentModel(scope, element, attrs, map, _this.DEFAULTS));
                        };
                    }(this));
                };
                return Polylines;
            }(IPolyline);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapRectangle", [ "uiGmapLogger", "uiGmapGmapUtil", "uiGmapIRectangle", "uiGmapRectangleParentModel", function($log, GmapUtil, IRectangle, RectangleParentModel) {
            return _.extend(IRectangle, {
                link: function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            return new RectangleParentModel(scope, element, attrs, map);
                        };
                    }(this));
                }
            });
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapWindow", [ "uiGmapIWindow", "uiGmapGmapUtil", "uiGmapWindowChildModel", "uiGmapLodash", "uiGmapLogger", function(IWindow, GmapUtil, WindowChildModel, uiGmapLodash, $log) {
            var Window;
            return Window = function(superClass) {
                extend(Window, superClass);
                Window.include(GmapUtil);
                function Window() {
                    this.link = bind(this.link, this);
                    Window.__super__.constructor.call(this);
                    this.require = [ "^" + "uiGmapGoogleMap", "^?" + "uiGmapMarker" ];
                    this.template = '<span class="angular-google-maps-window" ng-transclude></span>';
                    $log.debug(this);
                    this.childWindows = [];
                }
                Window.prototype.link = function(scope, element, attrs, ctrls) {
                    var markerCtrl, markerScope;
                    markerCtrl = ctrls.length > 1 && ctrls[1] != null ? ctrls[1] : void 0;
                    markerScope = markerCtrl != null ? markerCtrl.getScope() : void 0;
                    this.mapPromise = IWindow.mapPromise(scope, ctrls[0]);
                    return this.mapPromise.then(function(_this) {
                        return function(mapCtrl) {
                            var isIconVisibleOnClick;
                            isIconVisibleOnClick = true;
                            if (angular.isDefined(attrs.isiconvisibleonclick)) {
                                isIconVisibleOnClick = scope.isIconVisibleOnClick;
                            }
                            if (!markerCtrl) {
                                _this.init(scope, element, isIconVisibleOnClick, mapCtrl);
                                return;
                            }
                            return markerScope.deferred.promise.then(function(gMarker) {
                                return _this.init(scope, element, isIconVisibleOnClick, mapCtrl, markerScope);
                            });
                        };
                    }(this));
                };
                Window.prototype.init = function(scope, element, isIconVisibleOnClick, mapCtrl, markerScope) {
                    var childWindow, defaults, gMarker, hasScopeCoords, opts;
                    defaults = scope.options != null ? scope.options : {};
                    hasScopeCoords = scope != null && this.validateCoords(scope.coords);
                    if ((markerScope != null ? markerScope["getGMarker"] : void 0) != null) {
                        gMarker = markerScope.getGMarker();
                    }
                    opts = hasScopeCoords ? this.createWindowOptions(gMarker, scope, element.html(), defaults) : defaults;
                    if (mapCtrl != null) {
                        childWindow = new WindowChildModel({}, scope, opts, isIconVisibleOnClick, mapCtrl, markerScope, element);
                        this.childWindows.push(childWindow);
                        scope.$on("$destroy", function(_this) {
                            return function() {
                                _this.childWindows = uiGmapLodash.withoutObjects(_this.childWindows, [ childWindow ], function(child1, child2) {
                                    return child1.scope.$id === child2.scope.$id;
                                });
                                return _this.childWindows.length = 0;
                            };
                        }(this));
                    }
                    if (scope.control != null) {
                        scope.control.getGWindows = function(_this) {
                            return function() {
                                return _this.childWindows.map(function(child) {
                                    return child.gObject;
                                });
                            };
                        }(this);
                        scope.control.getChildWindows = function(_this) {
                            return function() {
                                return _this.childWindows;
                            };
                        }(this);
                        scope.control.getPlurals = scope.control.getChildWindows;
                        scope.control.showWindow = function(_this) {
                            return function() {
                                return _this.childWindows.map(function(child) {
                                    return child.showWindow();
                                });
                            };
                        }(this);
                        scope.control.hideWindow = function(_this) {
                            return function() {
                                return _this.childWindows.map(function(child) {
                                    return child.hideWindow();
                                });
                            };
                        }(this);
                    }
                    if (this.onChildCreation != null && childWindow != null) {
                        return this.onChildCreation(childWindow);
                    }
                };
                return Window;
            }(IWindow);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapWindows", [ "uiGmapIWindow", "uiGmapPlural", "uiGmapWindowsParentModel", "uiGmapPromise", "uiGmapLogger", function(IWindow, Plural, WindowsParentModel, uiGmapPromise, $log) {
            var Windows;
            return Windows = function(superClass) {
                extend(Windows, superClass);
                function Windows() {
                    this.init = bind(this.init, this);
                    this.link = bind(this.link, this);
                    Windows.__super__.constructor.call(this);
                    this.require = [ "^" + "uiGmapGoogleMap", "^?" + "uiGmapMarkers" ];
                    this.template = '<span class="angular-google-maps-windows" ng-transclude></span>';
                    Plural.extend(this);
                    $log.debug(this);
                }
                Windows.prototype.link = function(scope, element, attrs, ctrls) {
                    var mapScope, markerCtrl, markerScope;
                    mapScope = ctrls[0].getScope();
                    markerCtrl = ctrls.length > 1 && ctrls[1] != null ? ctrls[1] : void 0;
                    markerScope = markerCtrl != null ? markerCtrl.getScope() : void 0;
                    return mapScope.deferred.promise.then(function(_this) {
                        return function(map) {
                            var promise, ref;
                            promise = (markerScope != null ? (ref = markerScope.deferred) != null ? ref.promise : void 0 : void 0) || uiGmapPromise.resolve();
                            return promise.then(function() {
                                var pieces, ref1;
                                pieces = (ref1 = _this.parentModel) != null ? ref1.existingPieces : void 0;
                                if (pieces) {
                                    return pieces.then(function() {
                                        return _this.init(scope, element, attrs, ctrls, map, markerScope);
                                    });
                                } else {
                                    return _this.init(scope, element, attrs, ctrls, map, markerScope);
                                }
                            });
                        };
                    }(this));
                };
                Windows.prototype.init = function(scope, element, attrs, ctrls, map, additionalScope) {
                    var parentModel;
                    parentModel = new WindowsParentModel(scope, element, attrs, ctrls, map, additionalScope);
                    Plural.link(scope, parentModel);
                    if (scope.control != null) {
                        scope.control.getGWindows = function(_this) {
                            return function() {
                                return parentModel.plurals.map(function(child) {
                                    return child.gObject;
                                });
                            };
                        }(this);
                        return scope.control.getChildWindows = function(_this) {
                            return function() {
                                return parentModel.plurals;
                            };
                        }(this);
                    }
                };
                return Windows;
            }(IWindow);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapGoogleMap", [ "uiGmapMap", function(Map) {
            return new Map();
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapMarker", [ "$timeout", "uiGmapMarker", function($timeout, Marker) {
            return new Marker($timeout);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapMarkers", [ "$timeout", "uiGmapMarkers", function($timeout, Markers) {
            return new Markers($timeout);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolygon", [ "uiGmapPolygon", function(Polygon) {
            return new Polygon();
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapCircle", [ "uiGmapCircle", function(Circle) {
            return Circle;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolyline", [ "uiGmapPolyline", function(Polyline) {
            return new Polyline();
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolylines", [ "uiGmapPolylines", function(Polylines) {
            return new Polylines();
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapRectangle", [ "uiGmapLogger", "uiGmapRectangle", function($log, Rectangle) {
            return Rectangle;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapWindow", [ "$timeout", "$compile", "$http", "$templateCache", "uiGmapWindow", function($timeout, $compile, $http, $templateCache, Window) {
            return new Window($timeout, $compile, $http, $templateCache);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapWindows", [ "$timeout", "$compile", "$http", "$templateCache", "$interpolate", "uiGmapWindows", function($timeout, $compile, $http, $templateCache, $interpolate, Windows) {
            return new Windows($timeout, $compile, $http, $templateCache, $interpolate);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps").directive("uiGmapLayer", [ "$timeout", "uiGmapLogger", "uiGmapLayerParentModel", function($timeout, Logger, LayerParentModel) {
            var Layer;
            Layer = function() {
                function Layer() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = "EMA";
                    this.require = "^" + "uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = true;
                    this.template = "<span class='angular-google-map-layer' ng-transclude></span>";
                    this.replace = true;
                    this.scope = {
                        show: "=show",
                        type: "=type",
                        namespace: "=namespace",
                        options: "=options",
                        onCreated: "&oncreated"
                    };
                }
                Layer.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            if (scope.onCreated != null) {
                                return new LayerParentModel(scope, element, attrs, map, scope.onCreated);
                            } else {
                                return new LayerParentModel(scope, element, attrs, map);
                            }
                        };
                    }(this));
                };
                return Layer;
            }();
            return new Layer();
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapMapControl", [ "uiGmapControl", function(Control) {
            return new Control();
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapDragZoom", [ "uiGmapDragZoom", function(DragZoom) {
            return DragZoom;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapDrawingManager", [ "uiGmapDrawingManager", function(DrawingManager) {
            return DrawingManager;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapFreeDrawPolygons", [ "uiGmapApiFreeDrawPolygons", function(FreeDrawPolygons) {
            return new FreeDrawPolygons();
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps").directive("uiGmapMapType", [ "$timeout", "uiGmapLogger", "uiGmapMapTypeParentModel", function($timeout, Logger, MapTypeParentModel) {
            var MapType;
            MapType = function() {
                function MapType() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = "EMA";
                    this.require = "^" + "uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = true;
                    this.template = '<span class="angular-google-map-layer" ng-transclude></span>';
                    this.replace = true;
                    this.scope = {
                        show: "=show",
                        options: "=options",
                        refresh: "=refresh",
                        id: "@"
                    };
                }
                MapType.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            return new MapTypeParentModel(scope, element, attrs, map);
                        };
                    }(this));
                };
                return MapType;
            }();
            return new MapType();
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolygons", [ "uiGmapPolygons", function(Polygons) {
            return new Polygons();
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps").directive("uiGmapSearchBox", [ "uiGmapGoogleMapApi", "uiGmapLogger", "uiGmapSearchBoxParentModel", "$http", "$templateCache", "$compile", function(GoogleMapApi, Logger, SearchBoxParentModel, $http, $templateCache, $compile) {
            var SearchBox;
            SearchBox = function() {
                SearchBox.prototype.require = "ngModel";
                function SearchBox() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = "EMA";
                    this.require = "^" + "uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = true;
                    this.template = "<span class='angular-google-map-search' ng-transclude></span>";
                    this.replace = true;
                    this.scope = {
                        template: "=template",
                        events: "=events",
                        position: "=?position",
                        options: "=?options",
                        parentdiv: "=?parentdiv",
                        ngModel: "=?"
                    };
                }
                SearchBox.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return GoogleMapApi.then(function(_this) {
                        return function(maps) {
                            if (scope.template == null) {
                                $templateCache.put("uigmap-searchbox-default.tpl.html", '<input type="text">');
                                scope.template = "uigmap-searchbox-default.tpl.html";
                            }
                            return $http.get(scope.template, {
                                cache: $templateCache
                            }).success(function(template) {
                                if (angular.isUndefined(scope.events)) {
                                    _this.$log.error("searchBox: the events property is required");
                                    return;
                                }
                                return mapCtrl.getScope().deferred.promise.then(function(map) {
                                    var ctrlPosition;
                                    ctrlPosition = angular.isDefined(scope.position) ? scope.position.toUpperCase().replace(/-/g, "_") : "TOP_LEFT";
                                    if (!maps.ControlPosition[ctrlPosition]) {
                                        _this.$log.error("searchBox: invalid position property");
                                        return;
                                    }
                                    return new SearchBoxParentModel(scope, element, attrs, map, ctrlPosition, $compile(template)(scope));
                                });
                            });
                        };
                    }(this));
                };
                return SearchBox;
            }();
            return new SearchBox();
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapShow", [ "$animate", "uiGmapLogger", function($animate, $log) {
            return {
                scope: {
                    uiGmapShow: "=",
                    uiGmapAfterShow: "&",
                    uiGmapAfterHide: "&"
                },
                link: function(scope, element) {
                    var angular_post_1_3_handle, angular_pre_1_3_handle, handle;
                    angular_post_1_3_handle = function(animateAction, cb) {
                        return $animate[animateAction](element, "ng-hide").then(function() {
                            return cb();
                        });
                    };
                    angular_pre_1_3_handle = function(animateAction, cb) {
                        return $animate[animateAction](element, "ng-hide", cb);
                    };
                    handle = function(animateAction, cb) {
                        if (angular.version.major > 1) {
                            return $log.error("uiGmapShow is not supported for Angular Major greater than 1.\nYour Major is " + angular.version.major + '"');
                        }
                        if (angular.version.major === 1 && angular.version.minor < 3) {
                            return angular_pre_1_3_handle(animateAction, cb);
                        }
                        return angular_post_1_3_handle(animateAction, cb);
                    };
                    return scope.$watch("uiGmapShow", function(show) {
                        if (show) {
                            handle("removeClass", scope.uiGmapAfterShow);
                        }
                        if (!show) {
                            return handle("addClass", scope.uiGmapAfterHide);
                        }
                    });
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapStreetViewPanorama", [ "uiGmapGoogleMapApi", "uiGmapLogger", "uiGmapGmapUtil", "uiGmapEventsHelper", function(GoogleMapApi, $log, GmapUtil, EventsHelper) {
            var name;
            name = "uiGmapStreetViewPanorama";
            return {
                restrict: "EMA",
                template: '<div class="angular-google-map-street-view-panorama"></div>',
                replace: true,
                scope: {
                    focalcoord: "=",
                    radius: "=?",
                    events: "=?",
                    options: "=?",
                    control: "=?",
                    povoptions: "=?",
                    imagestatus: "="
                },
                link: function(scope, element, attrs) {
                    return GoogleMapApi.then(function(_this) {
                        return function(maps) {
                            var clean, create, didCreateOptionsFromDirective, firstTime, handleSettings, listeners, opts, pano, povOpts, sv;
                            pano = void 0;
                            sv = void 0;
                            didCreateOptionsFromDirective = false;
                            listeners = void 0;
                            opts = null;
                            povOpts = null;
                            clean = function() {
                                EventsHelper.removeEvents(listeners);
                                if (pano != null) {
                                    pano.unbind("position");
                                    pano.setVisible(false);
                                }
                                if (sv != null) {
                                    if ((sv != null ? sv.setVisible : void 0) != null) {
                                        sv.setVisible(false);
                                    }
                                    return sv = void 0;
                                }
                            };
                            handleSettings = function(perspectivePoint, focalPoint) {
                                var heading;
                                heading = google.maps.geometry.spherical.computeHeading(perspectivePoint, focalPoint);
                                didCreateOptionsFromDirective = true;
                                scope.radius = scope.radius || 50;
                                povOpts = angular.extend({
                                    heading: heading,
                                    zoom: 1,
                                    pitch: 0
                                }, scope.povoptions || {});
                                opts = opts = angular.extend({
                                    navigationControl: false,
                                    addressControl: false,
                                    linksControl: false,
                                    position: perspectivePoint,
                                    pov: povOpts,
                                    visible: true
                                }, scope.options || {});
                                return didCreateOptionsFromDirective = false;
                            };
                            create = function() {
                                var focalPoint;
                                if (!scope.focalcoord) {
                                    $log.error(name + ": focalCoord needs to be defined");
                                    return;
                                }
                                if (!scope.radius) {
                                    $log.error(name + ": needs a radius to set the camera view from its focal target.");
                                    return;
                                }
                                clean();
                                if (sv == null) {
                                    sv = new google.maps.StreetViewService();
                                }
                                if (scope.events) {
                                    listeners = EventsHelper.setEvents(sv, scope, scope);
                                }
                                focalPoint = GmapUtil.getCoords(scope.focalcoord);
                                return sv.getPanoramaByLocation(focalPoint, scope.radius, function(streetViewPanoramaData, status) {
                                    var ele, perspectivePoint, ref;
                                    if (scope.imagestatus != null) {
                                        scope.imagestatus = status;
                                    }
                                    if (((ref = scope.events) != null ? ref.image_status_changed : void 0) != null) {
                                        scope.events.image_status_changed(sv, "image_status_changed", scope, status);
                                    }
                                    if (status === "OK") {
                                        perspectivePoint = streetViewPanoramaData.location.latLng;
                                        handleSettings(perspectivePoint, focalPoint);
                                        ele = element[0];
                                        return pano = new google.maps.StreetViewPanorama(ele, opts);
                                    }
                                });
                            };
                            if (scope.control != null) {
                                scope.control.getOptions = function() {
                                    return opts;
                                };
                                scope.control.getPovOptions = function() {
                                    return povOpts;
                                };
                                scope.control.getGObject = function() {
                                    return sv;
                                };
                                scope.control.getGPano = function() {
                                    return pano;
                                };
                            }
                            scope.$watch("options", function(newValue, oldValue) {
                                if (newValue === oldValue || newValue === opts || didCreateOptionsFromDirective) {
                                    return;
                                }
                                return create();
                            });
                            firstTime = true;
                            scope.$watch("focalcoord", function(newValue, oldValue) {
                                if (newValue === oldValue && !firstTime) {
                                    return;
                                }
                                if (newValue == null) {
                                    return;
                                }
                                firstTime = false;
                                return create();
                            });
                            return scope.$on("$destroy", function() {
                                return clean();
                            });
                        };
                    }(this));
                }
            };
        } ]);
    }).call(this);
    angular.module("uiGmapgoogle-maps.wrapped").service("uiGmapuuid", function() {
        function UUID() {}
        UUID.generate = function() {
            var a = UUID._gri, b = UUID._ha;
            return b(a(32), 8) + "-" + b(a(16), 4) + "-" + b(16384 | a(12), 4) + "-" + b(32768 | a(14), 4) + "-" + b(a(48), 12);
        };
        UUID._gri = function(a) {
            return 0 > a ? NaN : 30 >= a ? 0 | Math.random() * (1 << a) : 53 >= a ? (0 | 1073741824 * Math.random()) + 1073741824 * (0 | Math.random() * (1 << a - 30)) : NaN;
        };
        UUID._ha = function(a, b) {
            for (var c = a.toString(16), d = b - c.length, e = "0"; 0 < d; d >>>= 1, e += e) d & 1 && (c = e + c);
            return c;
        };
        return UUID;
    });
    angular.module("uiGmapgoogle-maps.wrapped").service("uiGmapGoogleMapsUtilV3", function() {
        return {
            init: _.once(function() {
                function InfoBox(opt_opts) {
                    opt_opts = opt_opts || {};
                    google.maps.OverlayView.apply(this, arguments);
                    this.content_ = opt_opts.content || "";
                    this.disableAutoPan_ = opt_opts.disableAutoPan || false;
                    this.maxWidth_ = opt_opts.maxWidth || 0;
                    this.pixelOffset_ = opt_opts.pixelOffset || new google.maps.Size(0, 0);
                    this.position_ = opt_opts.position || new google.maps.LatLng(0, 0);
                    this.zIndex_ = opt_opts.zIndex || null;
                    this.boxClass_ = opt_opts.boxClass || "infoBox";
                    this.boxStyle_ = opt_opts.boxStyle || {};
                    this.closeBoxMargin_ = opt_opts.closeBoxMargin || "2px";
                    this.closeBoxURL_ = opt_opts.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif";
                    if (opt_opts.closeBoxURL === "") {
                        this.closeBoxURL_ = "";
                    }
                    this.infoBoxClearance_ = opt_opts.infoBoxClearance || new google.maps.Size(1, 1);
                    if (typeof opt_opts.visible === "undefined") {
                        if (typeof opt_opts.isHidden === "undefined") {
                            opt_opts.visible = true;
                        } else {
                            opt_opts.visible = !opt_opts.isHidden;
                        }
                    }
                    this.isHidden_ = !opt_opts.visible;
                    this.alignBottom_ = opt_opts.alignBottom || false;
                    this.pane_ = opt_opts.pane || "floatPane";
                    this.enableEventPropagation_ = opt_opts.enableEventPropagation || false;
                    this.div_ = null;
                    this.closeListener_ = null;
                    this.moveListener_ = null;
                    this.contextListener_ = null;
                    this.eventListeners_ = null;
                    this.fixedWidthSet_ = null;
                }
                InfoBox.prototype = new google.maps.OverlayView();
                InfoBox.prototype.createInfoBoxDiv_ = function() {
                    var i;
                    var events;
                    var bw;
                    var me = this;
                    var cancelHandler = function(e) {
                        e.cancelBubble = true;
                        if (e.stopPropagation) {
                            e.stopPropagation();
                        }
                    };
                    var ignoreHandler = function(e) {
                        e.returnValue = false;
                        if (e.preventDefault) {
                            e.preventDefault();
                        }
                        if (!me.enableEventPropagation_) {
                            cancelHandler(e);
                        }
                    };
                    if (!this.div_) {
                        this.div_ = document.createElement("div");
                        this.setBoxStyle_();
                        if (typeof this.content_.nodeType === "undefined") {
                            this.div_.innerHTML = this.getCloseBoxImg_() + this.content_;
                        } else {
                            this.div_.innerHTML = this.getCloseBoxImg_();
                            this.div_.appendChild(this.content_);
                        }
                        this.getPanes()[this.pane_].appendChild(this.div_);
                        this.addClickHandler_();
                        if (this.div_.style.width) {
                            this.fixedWidthSet_ = true;
                        } else {
                            if (this.maxWidth_ !== 0 && this.div_.offsetWidth > this.maxWidth_) {
                                this.div_.style.width = this.maxWidth_;
                                this.div_.style.overflow = "auto";
                                this.fixedWidthSet_ = true;
                            } else {
                                bw = this.getBoxWidths_();
                                this.div_.style.width = this.div_.offsetWidth - bw.left - bw.right + "px";
                                this.fixedWidthSet_ = false;
                            }
                        }
                        this.panBox_(this.disableAutoPan_);
                        if (!this.enableEventPropagation_) {
                            this.eventListeners_ = [];
                            events = [ "mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove" ];
                            for (i = 0; i < events.length; i++) {
                                this.eventListeners_.push(google.maps.event.addDomListener(this.div_, events[i], cancelHandler));
                            }
                            this.eventListeners_.push(google.maps.event.addDomListener(this.div_, "mouseover", function(e) {
                                this.style.cursor = "default";
                            }));
                        }
                        this.contextListener_ = google.maps.event.addDomListener(this.div_, "contextmenu", ignoreHandler);
                        google.maps.event.trigger(this, "domready");
                    }
                };
                InfoBox.prototype.getCloseBoxImg_ = function() {
                    var img = "";
                    if (this.closeBoxURL_ !== "") {
                        img = "<img";
                        img += " src='" + this.closeBoxURL_ + "'";
                        img += " align=right";
                        img += " style='";
                        img += " position: relative;";
                        img += " cursor: pointer;";
                        img += " margin: " + this.closeBoxMargin_ + ";";
                        img += "'>";
                    }
                    return img;
                };
                InfoBox.prototype.addClickHandler_ = function() {
                    var closeBox;
                    if (this.closeBoxURL_ !== "") {
                        closeBox = this.div_.firstChild;
                        this.closeListener_ = google.maps.event.addDomListener(closeBox, "click", this.getCloseClickHandler_());
                    } else {
                        this.closeListener_ = null;
                    }
                };
                InfoBox.prototype.getCloseClickHandler_ = function() {
                    var me = this;
                    return function(e) {
                        e.cancelBubble = true;
                        if (e.stopPropagation) {
                            e.stopPropagation();
                        }
                        google.maps.event.trigger(me, "closeclick");
                        me.close();
                    };
                };
                InfoBox.prototype.panBox_ = function(disablePan) {
                    var map;
                    var bounds;
                    var xOffset = 0, yOffset = 0;
                    if (!disablePan) {
                        map = this.getMap();
                        if (map instanceof google.maps.Map) {
                            if (!map.getBounds().contains(this.position_)) {
                                map.setCenter(this.position_);
                            }
                            bounds = map.getBounds();
                            var mapDiv = map.getDiv();
                            var mapWidth = mapDiv.offsetWidth;
                            var mapHeight = mapDiv.offsetHeight;
                            var iwOffsetX = this.pixelOffset_.width;
                            var iwOffsetY = this.pixelOffset_.height;
                            var iwWidth = this.div_.offsetWidth;
                            var iwHeight = this.div_.offsetHeight;
                            var padX = this.infoBoxClearance_.width;
                            var padY = this.infoBoxClearance_.height;
                            var pixPosition = this.getProjection().fromLatLngToContainerPixel(this.position_);
                            if (pixPosition.x < -iwOffsetX + padX) {
                                xOffset = pixPosition.x + iwOffsetX - padX;
                            } else if (pixPosition.x + iwWidth + iwOffsetX + padX > mapWidth) {
                                xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth;
                            }
                            if (this.alignBottom_) {
                                if (pixPosition.y < -iwOffsetY + padY + iwHeight) {
                                    yOffset = pixPosition.y + iwOffsetY - padY - iwHeight;
                                } else if (pixPosition.y + iwOffsetY + padY > mapHeight) {
                                    yOffset = pixPosition.y + iwOffsetY + padY - mapHeight;
                                }
                            } else {
                                if (pixPosition.y < -iwOffsetY + padY) {
                                    yOffset = pixPosition.y + iwOffsetY - padY;
                                } else if (pixPosition.y + iwHeight + iwOffsetY + padY > mapHeight) {
                                    yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight;
                                }
                            }
                            if (!(xOffset === 0 && yOffset === 0)) {
                                var c = map.getCenter();
                                map.panBy(xOffset, yOffset);
                            }
                        }
                    }
                };
                InfoBox.prototype.setBoxStyle_ = function() {
                    var i, boxStyle;
                    if (this.div_) {
                        this.div_.className = this.boxClass_;
                        this.div_.style.cssText = "";
                        boxStyle = this.boxStyle_;
                        for (i in boxStyle) {
                            if (boxStyle.hasOwnProperty(i)) {
                                this.div_.style[i] = boxStyle[i];
                            }
                        }
                        this.div_.style.WebkitTransform = "translateZ(0)";
                        if (typeof this.div_.style.opacity !== "undefined" && this.div_.style.opacity !== "") {
                            this.div_.style.MsFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + this.div_.style.opacity * 100 + ')"';
                            this.div_.style.filter = "alpha(opacity=" + this.div_.style.opacity * 100 + ")";
                        }
                        this.div_.style.position = "absolute";
                        this.div_.style.visibility = "hidden";
                        if (this.zIndex_ !== null) {
                            this.div_.style.zIndex = this.zIndex_;
                        }
                    }
                };
                InfoBox.prototype.getBoxWidths_ = function() {
                    var computedStyle;
                    var bw = {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0
                    };
                    var box = this.div_;
                    if (document.defaultView && document.defaultView.getComputedStyle) {
                        computedStyle = box.ownerDocument.defaultView.getComputedStyle(box, "");
                        if (computedStyle) {
                            bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
                            bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
                            bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
                            bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
                        }
                    } else if (document.documentElement.currentStyle) {
                        if (box.currentStyle) {
                            bw.top = parseInt(box.currentStyle.borderTopWidth, 10) || 0;
                            bw.bottom = parseInt(box.currentStyle.borderBottomWidth, 10) || 0;
                            bw.left = parseInt(box.currentStyle.borderLeftWidth, 10) || 0;
                            bw.right = parseInt(box.currentStyle.borderRightWidth, 10) || 0;
                        }
                    }
                    return bw;
                };
                InfoBox.prototype.onRemove = function() {
                    if (this.div_) {
                        this.div_.parentNode.removeChild(this.div_);
                        this.div_ = null;
                    }
                };
                InfoBox.prototype.draw = function() {
                    this.createInfoBoxDiv_();
                    var pixPosition = this.getProjection().fromLatLngToDivPixel(this.position_);
                    this.div_.style.left = pixPosition.x + this.pixelOffset_.width + "px";
                    if (this.alignBottom_) {
                        this.div_.style.bottom = -(pixPosition.y + this.pixelOffset_.height) + "px";
                    } else {
                        this.div_.style.top = pixPosition.y + this.pixelOffset_.height + "px";
                    }
                    if (this.isHidden_) {
                        this.div_.style.visibility = "hidden";
                    } else {
                        this.div_.style.visibility = "visible";
                    }
                };
                InfoBox.prototype.setOptions = function(opt_opts) {
                    if (typeof opt_opts.boxClass !== "undefined") {
                        this.boxClass_ = opt_opts.boxClass;
                        this.setBoxStyle_();
                    }
                    if (typeof opt_opts.boxStyle !== "undefined") {
                        this.boxStyle_ = opt_opts.boxStyle;
                        this.setBoxStyle_();
                    }
                    if (typeof opt_opts.content !== "undefined") {
                        this.setContent(opt_opts.content);
                    }
                    if (typeof opt_opts.disableAutoPan !== "undefined") {
                        this.disableAutoPan_ = opt_opts.disableAutoPan;
                    }
                    if (typeof opt_opts.maxWidth !== "undefined") {
                        this.maxWidth_ = opt_opts.maxWidth;
                    }
                    if (typeof opt_opts.pixelOffset !== "undefined") {
                        this.pixelOffset_ = opt_opts.pixelOffset;
                    }
                    if (typeof opt_opts.alignBottom !== "undefined") {
                        this.alignBottom_ = opt_opts.alignBottom;
                    }
                    if (typeof opt_opts.position !== "undefined") {
                        this.setPosition(opt_opts.position);
                    }
                    if (typeof opt_opts.zIndex !== "undefined") {
                        this.setZIndex(opt_opts.zIndex);
                    }
                    if (typeof opt_opts.closeBoxMargin !== "undefined") {
                        this.closeBoxMargin_ = opt_opts.closeBoxMargin;
                    }
                    if (typeof opt_opts.closeBoxURL !== "undefined") {
                        this.closeBoxURL_ = opt_opts.closeBoxURL;
                    }
                    if (typeof opt_opts.infoBoxClearance !== "undefined") {
                        this.infoBoxClearance_ = opt_opts.infoBoxClearance;
                    }
                    if (typeof opt_opts.isHidden !== "undefined") {
                        this.isHidden_ = opt_opts.isHidden;
                    }
                    if (typeof opt_opts.visible !== "undefined") {
                        this.isHidden_ = !opt_opts.visible;
                    }
                    if (typeof opt_opts.enableEventPropagation !== "undefined") {
                        this.enableEventPropagation_ = opt_opts.enableEventPropagation;
                    }
                    if (this.div_) {
                        this.draw();
                    }
                };
                InfoBox.prototype.setContent = function(content) {
                    this.content_ = content;
                    if (this.div_) {
                        if (this.closeListener_) {
                            google.maps.event.removeListener(this.closeListener_);
                            this.closeListener_ = null;
                        }
                        if (!this.fixedWidthSet_) {
                            this.div_.style.width = "";
                        }
                        if (typeof content.nodeType === "undefined") {
                            this.div_.innerHTML = this.getCloseBoxImg_() + content;
                        } else {
                            this.div_.innerHTML = this.getCloseBoxImg_();
                            this.div_.appendChild(content);
                        }
                        if (!this.fixedWidthSet_) {
                            this.div_.style.width = this.div_.offsetWidth + "px";
                            if (typeof content.nodeType === "undefined") {
                                this.div_.innerHTML = this.getCloseBoxImg_() + content;
                            } else {
                                this.div_.innerHTML = this.getCloseBoxImg_();
                                this.div_.appendChild(content);
                            }
                        }
                        this.addClickHandler_();
                    }
                    google.maps.event.trigger(this, "content_changed");
                };
                InfoBox.prototype.setPosition = function(latlng) {
                    this.position_ = latlng;
                    if (this.div_) {
                        this.draw();
                    }
                    google.maps.event.trigger(this, "position_changed");
                };
                InfoBox.prototype.setZIndex = function(index) {
                    this.zIndex_ = index;
                    if (this.div_) {
                        this.div_.style.zIndex = index;
                    }
                    google.maps.event.trigger(this, "zindex_changed");
                };
                InfoBox.prototype.setVisible = function(isVisible) {
                    this.isHidden_ = !isVisible;
                    if (this.div_) {
                        this.div_.style.visibility = this.isHidden_ ? "hidden" : "visible";
                    }
                };
                InfoBox.prototype.getContent = function() {
                    return this.content_;
                };
                InfoBox.prototype.getPosition = function() {
                    return this.position_;
                };
                InfoBox.prototype.getZIndex = function() {
                    return this.zIndex_;
                };
                InfoBox.prototype.getVisible = function() {
                    var isVisible;
                    if (typeof this.getMap() === "undefined" || this.getMap() === null) {
                        isVisible = false;
                    } else {
                        isVisible = !this.isHidden_;
                    }
                    return isVisible;
                };
                InfoBox.prototype.show = function() {
                    this.isHidden_ = false;
                    if (this.div_) {
                        this.div_.style.visibility = "visible";
                    }
                };
                InfoBox.prototype.hide = function() {
                    this.isHidden_ = true;
                    if (this.div_) {
                        this.div_.style.visibility = "hidden";
                    }
                };
                InfoBox.prototype.open = function(map, anchor) {
                    var me = this;
                    if (anchor) {
                        this.position_ = anchor.getPosition();
                        this.moveListener_ = google.maps.event.addListener(anchor, "position_changed", function() {
                            me.setPosition(this.getPosition());
                        });
                    }
                    this.setMap(map);
                    if (this.div_) {
                        this.panBox_();
                    }
                };
                InfoBox.prototype.close = function() {
                    var i;
                    if (this.closeListener_) {
                        google.maps.event.removeListener(this.closeListener_);
                        this.closeListener_ = null;
                    }
                    if (this.eventListeners_) {
                        for (i = 0; i < this.eventListeners_.length; i++) {
                            google.maps.event.removeListener(this.eventListeners_[i]);
                        }
                        this.eventListeners_ = null;
                    }
                    if (this.moveListener_) {
                        google.maps.event.removeListener(this.moveListener_);
                        this.moveListener_ = null;
                    }
                    if (this.contextListener_) {
                        google.maps.event.removeListener(this.contextListener_);
                        this.contextListener_ = null;
                    }
                    this.setMap(null);
                };
                (function() {
                    var toPixels = function(widthValue) {
                        var px;
                        switch (widthValue) {
                          case "thin":
                            px = "2px";
                            break;

                          case "medium":
                            px = "4px";
                            break;

                          case "thick":
                            px = "6px";
                            break;

                          default:
                            px = widthValue;
                        }
                        return px;
                    };
                    var getBorderWidths = function(h) {
                        var computedStyle;
                        var bw = {};
                        if (document.defaultView && document.defaultView.getComputedStyle) {
                            computedStyle = h.ownerDocument.defaultView.getComputedStyle(h, "");
                            if (computedStyle) {
                                bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
                                bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
                                bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
                                bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
                                return bw;
                            }
                        } else if (document.documentElement.currentStyle) {
                            if (h.currentStyle) {
                                bw.top = parseInt(toPixels(h.currentStyle.borderTopWidth), 10) || 0;
                                bw.bottom = parseInt(toPixels(h.currentStyle.borderBottomWidth), 10) || 0;
                                bw.left = parseInt(toPixels(h.currentStyle.borderLeftWidth), 10) || 0;
                                bw.right = parseInt(toPixels(h.currentStyle.borderRightWidth), 10) || 0;
                                return bw;
                            }
                        }
                        bw.top = parseInt(h.style["border-top-width"], 10) || 0;
                        bw.bottom = parseInt(h.style["border-bottom-width"], 10) || 0;
                        bw.left = parseInt(h.style["border-left-width"], 10) || 0;
                        bw.right = parseInt(h.style["border-right-width"], 10) || 0;
                        return bw;
                    };
                    var scroll = {
                        x: 0,
                        y: 0
                    };
                    var getScrollValue = function(e) {
                        scroll.x = typeof document.documentElement.scrollLeft !== "undefined" ? document.documentElement.scrollLeft : document.body.scrollLeft;
                        scroll.y = typeof document.documentElement.scrollTop !== "undefined" ? document.documentElement.scrollTop : document.body.scrollTop;
                    };
                    getScrollValue();
                    var getMousePosition = function(e) {
                        var posX = 0, posY = 0;
                        e = e || window.event;
                        if (typeof e.pageX !== "undefined") {
                            posX = e.pageX;
                            posY = e.pageY;
                        } else if (typeof e.clientX !== "undefined") {
                            posX = e.clientX + scroll.x;
                            posY = e.clientY + scroll.y;
                        }
                        return {
                            left: posX,
                            top: posY
                        };
                    };
                    var getElementPosition = function(h) {
                        var posX = h.offsetLeft;
                        var posY = h.offsetTop;
                        var parent = h.offsetParent;
                        while (parent !== null) {
                            if (parent !== document.body && parent !== document.documentElement) {
                                posX -= parent.scrollLeft;
                                posY -= parent.scrollTop;
                            }
                            var m = parent;
                            var moffx = m.offsetLeft;
                            var moffy = m.offsetTop;
                            if (!moffx && !moffy && window.getComputedStyle) {
                                var matrix = document.defaultView.getComputedStyle(m, null).MozTransform || document.defaultView.getComputedStyle(m, null).WebkitTransform;
                                if (matrix) {
                                    if (typeof matrix === "string") {
                                        var parms = matrix.split(",");
                                        moffx += parseInt(parms[4], 10) || 0;
                                        moffy += parseInt(parms[5], 10) || 0;
                                    }
                                }
                            }
                            posX += moffx;
                            posY += moffy;
                            parent = parent.offsetParent;
                        }
                        return {
                            left: posX,
                            top: posY
                        };
                    };
                    var setVals = function(obj, vals) {
                        if (obj && vals) {
                            for (var x in vals) {
                                if (vals.hasOwnProperty(x)) {
                                    obj[x] = vals[x];
                                }
                            }
                        }
                        return obj;
                    };
                    var setOpacity = function(h, op) {
                        if (typeof op !== "undefined") {
                            h.style.opacity = op;
                        }
                        if (typeof h.style.opacity !== "undefined" && h.style.opacity !== "") {
                            h.style.filter = "alpha(opacity=" + h.style.opacity * 100 + ")";
                        }
                    };
                    function DragZoom(map, opt_zoomOpts) {
                        var me = this;
                        var ov = new google.maps.OverlayView();
                        ov.onAdd = function() {
                            me.init_(map, opt_zoomOpts);
                        };
                        ov.draw = function() {};
                        ov.onRemove = function() {};
                        ov.setMap(map);
                        this.prjov_ = ov;
                    }
                    DragZoom.prototype.init_ = function(map, opt_zoomOpts) {
                        var i;
                        var me = this;
                        this.map_ = map;
                        opt_zoomOpts = opt_zoomOpts || {};
                        this.key_ = opt_zoomOpts.key || "shift";
                        this.key_ = this.key_.toLowerCase();
                        this.borderWidths_ = getBorderWidths(this.map_.getDiv());
                        this.veilDiv_ = [];
                        for (i = 0; i < 4; i++) {
                            this.veilDiv_[i] = document.createElement("div");
                            this.veilDiv_[i].onselectstart = function() {
                                return false;
                            };
                            setVals(this.veilDiv_[i].style, {
                                backgroundColor: "gray",
                                opacity: .25,
                                cursor: "crosshair"
                            });
                            setVals(this.veilDiv_[i].style, opt_zoomOpts.paneStyle);
                            setVals(this.veilDiv_[i].style, opt_zoomOpts.veilStyle);
                            setVals(this.veilDiv_[i].style, {
                                position: "absolute",
                                overflow: "hidden",
                                display: "none"
                            });
                            if (this.key_ === "shift") {
                                this.veilDiv_[i].style.MozUserSelect = "none";
                            }
                            setOpacity(this.veilDiv_[i]);
                            if (this.veilDiv_[i].style.backgroundColor === "transparent") {
                                this.veilDiv_[i].style.backgroundColor = "white";
                                setOpacity(this.veilDiv_[i], 0);
                            }
                            this.map_.getDiv().appendChild(this.veilDiv_[i]);
                        }
                        this.noZoom_ = opt_zoomOpts.noZoom || false;
                        this.visualEnabled_ = opt_zoomOpts.visualEnabled || false;
                        this.visualClass_ = opt_zoomOpts.visualClass || "";
                        this.visualPosition_ = opt_zoomOpts.visualPosition || google.maps.ControlPosition.LEFT_TOP;
                        this.visualPositionOffset_ = opt_zoomOpts.visualPositionOffset || new google.maps.Size(35, 0);
                        this.visualPositionIndex_ = opt_zoomOpts.visualPositionIndex || null;
                        this.visualSprite_ = opt_zoomOpts.visualSprite || "http" + (document.location.protocol === "https:" ? "s" : "") + "://maps.gstatic.com/mapfiles/ftr/controls/dragzoom_btn.png";
                        this.visualSize_ = opt_zoomOpts.visualSize || new google.maps.Size(20, 20);
                        this.visualTips_ = opt_zoomOpts.visualTips || {};
                        this.visualTips_.off = this.visualTips_.off || "Turn on drag zoom mode";
                        this.visualTips_.on = this.visualTips_.on || "Turn off drag zoom mode";
                        this.boxDiv_ = document.createElement("div");
                        setVals(this.boxDiv_.style, {
                            border: "4px solid #736AFF"
                        });
                        setVals(this.boxDiv_.style, opt_zoomOpts.boxStyle);
                        setVals(this.boxDiv_.style, {
                            position: "absolute",
                            display: "none"
                        });
                        setOpacity(this.boxDiv_);
                        this.map_.getDiv().appendChild(this.boxDiv_);
                        this.boxBorderWidths_ = getBorderWidths(this.boxDiv_);
                        this.listeners_ = [ google.maps.event.addDomListener(document, "keydown", function(e) {
                            me.onKeyDown_(e);
                        }), google.maps.event.addDomListener(document, "keyup", function(e) {
                            me.onKeyUp_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[0], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[1], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[2], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[3], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(document, "mousedown", function(e) {
                            me.onMouseDownDocument_(e);
                        }), google.maps.event.addDomListener(document, "mousemove", function(e) {
                            me.onMouseMove_(e);
                        }), google.maps.event.addDomListener(document, "mouseup", function(e) {
                            me.onMouseUp_(e);
                        }), google.maps.event.addDomListener(window, "scroll", getScrollValue) ];
                        this.hotKeyDown_ = false;
                        this.mouseDown_ = false;
                        this.dragging_ = false;
                        this.startPt_ = null;
                        this.endPt_ = null;
                        this.mapWidth_ = null;
                        this.mapHeight_ = null;
                        this.mousePosn_ = null;
                        this.mapPosn_ = null;
                        if (this.visualEnabled_) {
                            this.buttonDiv_ = this.initControl_(this.visualPositionOffset_);
                            if (this.visualPositionIndex_ !== null) {
                                this.buttonDiv_.index = this.visualPositionIndex_;
                            }
                            this.map_.controls[this.visualPosition_].push(this.buttonDiv_);
                            this.controlIndex_ = this.map_.controls[this.visualPosition_].length - 1;
                        }
                    };
                    DragZoom.prototype.initControl_ = function(offset) {
                        var control;
                        var image;
                        var me = this;
                        control = document.createElement("div");
                        control.className = this.visualClass_;
                        control.style.position = "relative";
                        control.style.overflow = "hidden";
                        control.style.height = this.visualSize_.height + "px";
                        control.style.width = this.visualSize_.width + "px";
                        control.title = this.visualTips_.off;
                        image = document.createElement("img");
                        image.src = this.visualSprite_;
                        image.style.position = "absolute";
                        image.style.left = -(this.visualSize_.width * 2) + "px";
                        image.style.top = 0 + "px";
                        control.appendChild(image);
                        control.onclick = function(e) {
                            me.hotKeyDown_ = !me.hotKeyDown_;
                            if (me.hotKeyDown_) {
                                me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 0) + "px";
                                me.buttonDiv_.title = me.visualTips_.on;
                                me.activatedByControl_ = true;
                                google.maps.event.trigger(me, "activate");
                            } else {
                                me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 2) + "px";
                                me.buttonDiv_.title = me.visualTips_.off;
                                google.maps.event.trigger(me, "deactivate");
                            }
                            me.onMouseMove_(e);
                        };
                        control.onmouseover = function() {
                            me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 1) + "px";
                        };
                        control.onmouseout = function() {
                            if (me.hotKeyDown_) {
                                me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 0) + "px";
                                me.buttonDiv_.title = me.visualTips_.on;
                            } else {
                                me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 2) + "px";
                                me.buttonDiv_.title = me.visualTips_.off;
                            }
                        };
                        control.ondragstart = function() {
                            return false;
                        };
                        setVals(control.style, {
                            cursor: "pointer",
                            marginTop: offset.height + "px",
                            marginLeft: offset.width + "px"
                        });
                        return control;
                    };
                    DragZoom.prototype.isHotKeyDown_ = function(e) {
                        var isHot;
                        e = e || window.event;
                        isHot = e.shiftKey && this.key_ === "shift" || e.altKey && this.key_ === "alt" || e.ctrlKey && this.key_ === "ctrl";
                        if (!isHot) {
                            switch (e.keyCode) {
                              case 16:
                                if (this.key_ === "shift") {
                                    isHot = true;
                                }
                                break;

                              case 17:
                                if (this.key_ === "ctrl") {
                                    isHot = true;
                                }
                                break;

                              case 18:
                                if (this.key_ === "alt") {
                                    isHot = true;
                                }
                                break;
                            }
                        }
                        return isHot;
                    };
                    DragZoom.prototype.isMouseOnMap_ = function() {
                        var mousePosn = this.mousePosn_;
                        if (mousePosn) {
                            var mapPosn = this.mapPosn_;
                            var mapDiv = this.map_.getDiv();
                            return mousePosn.left > mapPosn.left && mousePosn.left < mapPosn.left + mapDiv.offsetWidth && mousePosn.top > mapPosn.top && mousePosn.top < mapPosn.top + mapDiv.offsetHeight;
                        } else {
                            return false;
                        }
                    };
                    DragZoom.prototype.setVeilVisibility_ = function() {
                        var i;
                        if (this.map_ && this.hotKeyDown_ && this.isMouseOnMap_()) {
                            var mapDiv = this.map_.getDiv();
                            this.mapWidth_ = mapDiv.offsetWidth - (this.borderWidths_.left + this.borderWidths_.right);
                            this.mapHeight_ = mapDiv.offsetHeight - (this.borderWidths_.top + this.borderWidths_.bottom);
                            if (this.activatedByControl_) {
                                var left = parseInt(this.buttonDiv_.style.left, 10) + this.visualPositionOffset_.width;
                                var top = parseInt(this.buttonDiv_.style.top, 10) + this.visualPositionOffset_.height;
                                var width = this.visualSize_.width;
                                var height = this.visualSize_.height;
                                this.veilDiv_[0].style.top = "0px";
                                this.veilDiv_[0].style.left = "0px";
                                this.veilDiv_[0].style.width = left + "px";
                                this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                                this.veilDiv_[1].style.top = "0px";
                                this.veilDiv_[1].style.left = left + width + "px";
                                this.veilDiv_[1].style.width = this.mapWidth_ - (left + width) + "px";
                                this.veilDiv_[1].style.height = this.mapHeight_ + "px";
                                this.veilDiv_[2].style.top = "0px";
                                this.veilDiv_[2].style.left = left + "px";
                                this.veilDiv_[2].style.width = width + "px";
                                this.veilDiv_[2].style.height = top + "px";
                                this.veilDiv_[3].style.top = top + height + "px";
                                this.veilDiv_[3].style.left = left + "px";
                                this.veilDiv_[3].style.width = width + "px";
                                this.veilDiv_[3].style.height = this.mapHeight_ - (top + height) + "px";
                                for (i = 0; i < this.veilDiv_.length; i++) {
                                    this.veilDiv_[i].style.display = "block";
                                }
                            } else {
                                this.veilDiv_[0].style.left = "0px";
                                this.veilDiv_[0].style.top = "0px";
                                this.veilDiv_[0].style.width = this.mapWidth_ + "px";
                                this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                                for (i = 1; i < this.veilDiv_.length; i++) {
                                    this.veilDiv_[i].style.width = "0px";
                                    this.veilDiv_[i].style.height = "0px";
                                }
                                for (i = 0; i < this.veilDiv_.length; i++) {
                                    this.veilDiv_[i].style.display = "block";
                                }
                            }
                        } else {
                            for (i = 0; i < this.veilDiv_.length; i++) {
                                this.veilDiv_[i].style.display = "none";
                            }
                        }
                    };
                    DragZoom.prototype.onKeyDown_ = function(e) {
                        if (this.map_ && !this.hotKeyDown_ && this.isHotKeyDown_(e)) {
                            this.mapPosn_ = getElementPosition(this.map_.getDiv());
                            this.hotKeyDown_ = true;
                            this.activatedByControl_ = false;
                            this.setVeilVisibility_();
                            google.maps.event.trigger(this, "activate");
                        }
                    };
                    DragZoom.prototype.getMousePoint_ = function(e) {
                        var mousePosn = getMousePosition(e);
                        var p = new google.maps.Point();
                        p.x = mousePosn.left - this.mapPosn_.left - this.borderWidths_.left;
                        p.y = mousePosn.top - this.mapPosn_.top - this.borderWidths_.top;
                        p.x = Math.min(p.x, this.mapWidth_);
                        p.y = Math.min(p.y, this.mapHeight_);
                        p.x = Math.max(p.x, 0);
                        p.y = Math.max(p.y, 0);
                        return p;
                    };
                    DragZoom.prototype.onMouseDown_ = function(e) {
                        if (this.map_ && this.hotKeyDown_) {
                            this.mapPosn_ = getElementPosition(this.map_.getDiv());
                            this.dragging_ = true;
                            this.startPt_ = this.endPt_ = this.getMousePoint_(e);
                            this.boxDiv_.style.width = this.boxDiv_.style.height = "0px";
                            var prj = this.prjov_.getProjection();
                            var latlng = prj.fromContainerPixelToLatLng(this.startPt_);
                            google.maps.event.trigger(this, "dragstart", latlng);
                        }
                    };
                    DragZoom.prototype.onMouseDownDocument_ = function(e) {
                        this.mouseDown_ = true;
                    };
                    DragZoom.prototype.onMouseMove_ = function(e) {
                        this.mousePosn_ = getMousePosition(e);
                        if (this.dragging_) {
                            this.endPt_ = this.getMousePoint_(e);
                            var left = Math.min(this.startPt_.x, this.endPt_.x);
                            var top = Math.min(this.startPt_.y, this.endPt_.y);
                            var width = Math.abs(this.startPt_.x - this.endPt_.x);
                            var height = Math.abs(this.startPt_.y - this.endPt_.y);
                            var boxWidth = Math.max(0, width - (this.boxBorderWidths_.left + this.boxBorderWidths_.right));
                            var boxHeight = Math.max(0, height - (this.boxBorderWidths_.top + this.boxBorderWidths_.bottom));
                            this.veilDiv_[0].style.top = "0px";
                            this.veilDiv_[0].style.left = "0px";
                            this.veilDiv_[0].style.width = left + "px";
                            this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                            this.veilDiv_[1].style.top = "0px";
                            this.veilDiv_[1].style.left = left + width + "px";
                            this.veilDiv_[1].style.width = this.mapWidth_ - (left + width) + "px";
                            this.veilDiv_[1].style.height = this.mapHeight_ + "px";
                            this.veilDiv_[2].style.top = "0px";
                            this.veilDiv_[2].style.left = left + "px";
                            this.veilDiv_[2].style.width = width + "px";
                            this.veilDiv_[2].style.height = top + "px";
                            this.veilDiv_[3].style.top = top + height + "px";
                            this.veilDiv_[3].style.left = left + "px";
                            this.veilDiv_[3].style.width = width + "px";
                            this.veilDiv_[3].style.height = this.mapHeight_ - (top + height) + "px";
                            this.boxDiv_.style.top = top + "px";
                            this.boxDiv_.style.left = left + "px";
                            this.boxDiv_.style.width = boxWidth + "px";
                            this.boxDiv_.style.height = boxHeight + "px";
                            this.boxDiv_.style.display = "block";
                            google.maps.event.trigger(this, "drag", new google.maps.Point(left, top + height), new google.maps.Point(left + width, top), this.prjov_.getProjection());
                        } else if (!this.mouseDown_) {
                            this.mapPosn_ = getElementPosition(this.map_.getDiv());
                            this.setVeilVisibility_();
                        }
                    };
                    DragZoom.prototype.onMouseUp_ = function(e) {
                        var z;
                        var me = this;
                        this.mouseDown_ = false;
                        if (this.dragging_) {
                            if (this.getMousePoint_(e).x === this.startPt_.x && this.getMousePoint_(e).y === this.startPt_.y) {
                                this.onKeyUp_(e);
                                return;
                            }
                            var left = Math.min(this.startPt_.x, this.endPt_.x);
                            var top = Math.min(this.startPt_.y, this.endPt_.y);
                            var width = Math.abs(this.startPt_.x - this.endPt_.x);
                            var height = Math.abs(this.startPt_.y - this.endPt_.y);
                            var kGoogleCenteringBug = true;
                            if (kGoogleCenteringBug) {
                                left += this.borderWidths_.left;
                                top += this.borderWidths_.top;
                            }
                            var prj = this.prjov_.getProjection();
                            var sw = prj.fromContainerPixelToLatLng(new google.maps.Point(left, top + height));
                            var ne = prj.fromContainerPixelToLatLng(new google.maps.Point(left + width, top));
                            var bnds = new google.maps.LatLngBounds(sw, ne);
                            if (this.noZoom_) {
                                this.boxDiv_.style.display = "none";
                            } else {
                                z = this.map_.getZoom();
                                this.map_.fitBounds(bnds);
                                if (this.map_.getZoom() < z) {
                                    this.map_.setZoom(z);
                                }
                                var swPt = prj.fromLatLngToContainerPixel(sw);
                                var nePt = prj.fromLatLngToContainerPixel(ne);
                                if (kGoogleCenteringBug) {
                                    swPt.x -= this.borderWidths_.left;
                                    swPt.y -= this.borderWidths_.top;
                                    nePt.x -= this.borderWidths_.left;
                                    nePt.y -= this.borderWidths_.top;
                                }
                                this.boxDiv_.style.left = swPt.x + "px";
                                this.boxDiv_.style.top = nePt.y + "px";
                                this.boxDiv_.style.width = Math.abs(nePt.x - swPt.x) - (this.boxBorderWidths_.left + this.boxBorderWidths_.right) + "px";
                                this.boxDiv_.style.height = Math.abs(nePt.y - swPt.y) - (this.boxBorderWidths_.top + this.boxBorderWidths_.bottom) + "px";
                                setTimeout(function() {
                                    me.boxDiv_.style.display = "none";
                                }, 1e3);
                            }
                            this.dragging_ = false;
                            this.onMouseMove_(e);
                            google.maps.event.trigger(this, "dragend", bnds);
                            if (!this.isHotKeyDown_(e)) {
                                this.onKeyUp_(e);
                            }
                        }
                    };
                    DragZoom.prototype.onKeyUp_ = function(e) {
                        var i;
                        var left, top, width, height, prj, sw, ne;
                        var bnds = null;
                        if (this.map_ && this.hotKeyDown_) {
                            this.hotKeyDown_ = false;
                            if (this.dragging_) {
                                this.boxDiv_.style.display = "none";
                                this.dragging_ = false;
                                left = Math.min(this.startPt_.x, this.endPt_.x);
                                top = Math.min(this.startPt_.y, this.endPt_.y);
                                width = Math.abs(this.startPt_.x - this.endPt_.x);
                                height = Math.abs(this.startPt_.y - this.endPt_.y);
                                prj = this.prjov_.getProjection();
                                sw = prj.fromContainerPixelToLatLng(new google.maps.Point(left, top + height));
                                ne = prj.fromContainerPixelToLatLng(new google.maps.Point(left + width, top));
                                bnds = new google.maps.LatLngBounds(sw, ne);
                            }
                            for (i = 0; i < this.veilDiv_.length; i++) {
                                this.veilDiv_[i].style.display = "none";
                            }
                            if (this.visualEnabled_) {
                                this.buttonDiv_.firstChild.style.left = -(this.visualSize_.width * 2) + "px";
                                this.buttonDiv_.title = this.visualTips_.off;
                                this.buttonDiv_.style.display = "";
                            }
                            google.maps.event.trigger(this, "deactivate", bnds);
                        }
                    };
                    google.maps.Map.prototype.enableKeyDragZoom = function(opt_zoomOpts) {
                        this.dragZoom_ = new DragZoom(this, opt_zoomOpts);
                    };
                    google.maps.Map.prototype.disableKeyDragZoom = function() {
                        var i;
                        var d = this.dragZoom_;
                        if (d) {
                            for (i = 0; i < d.listeners_.length; ++i) {
                                google.maps.event.removeListener(d.listeners_[i]);
                            }
                            this.getDiv().removeChild(d.boxDiv_);
                            for (i = 0; i < d.veilDiv_.length; i++) {
                                this.getDiv().removeChild(d.veilDiv_[i]);
                            }
                            if (d.visualEnabled_) {
                                this.controls[d.visualPosition_].removeAt(d.controlIndex_);
                            }
                            d.prjov_.setMap(null);
                            this.dragZoom_ = null;
                        }
                    };
                    google.maps.Map.prototype.keyDragZoomEnabled = function() {
                        return this.dragZoom_ !== null;
                    };
                    google.maps.Map.prototype.getDragZoomObject = function() {
                        return this.dragZoom_;
                    };
                })();
                function ClusterIcon(cluster, styles) {
                    cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);
                    this.cluster_ = cluster;
                    this.className_ = cluster.getMarkerClusterer().getClusterClass();
                    this.styles_ = styles;
                    this.center_ = null;
                    this.div_ = null;
                    this.sums_ = null;
                    this.visible_ = false;
                    this.setMap(cluster.getMap());
                }
                ClusterIcon.prototype.onAdd = function() {
                    var cClusterIcon = this;
                    var cMouseDownInCluster;
                    var cDraggingMapByCluster;
                    this.div_ = document.createElement("div");
                    this.div_.className = this.className_;
                    if (this.visible_) {
                        this.show();
                    }
                    this.getPanes().overlayMouseTarget.appendChild(this.div_);
                    this.boundsChangedListener_ = google.maps.event.addListener(this.getMap(), "bounds_changed", function() {
                        cDraggingMapByCluster = cMouseDownInCluster;
                    });
                    google.maps.event.addDomListener(this.div_, "mousedown", function() {
                        cMouseDownInCluster = true;
                        cDraggingMapByCluster = false;
                    });
                    google.maps.event.addDomListener(this.div_, "click", function(e) {
                        cMouseDownInCluster = false;
                        if (!cDraggingMapByCluster) {
                            var theBounds;
                            var mz;
                            var mc = cClusterIcon.cluster_.getMarkerClusterer();
                            google.maps.event.trigger(mc, "click", cClusterIcon.cluster_);
                            google.maps.event.trigger(mc, "clusterclick", cClusterIcon.cluster_);
                            if (mc.getZoomOnClick()) {
                                mz = mc.getMaxZoom();
                                theBounds = cClusterIcon.cluster_.getBounds();
                                mc.getMap().fitBounds(theBounds);
                                setTimeout(function() {
                                    mc.getMap().fitBounds(theBounds);
                                    if (mz !== null && mc.getMap().getZoom() > mz) {
                                        mc.getMap().setZoom(mz + 1);
                                    }
                                }, 100);
                            }
                            e.cancelBubble = true;
                            if (e.stopPropagation) {
                                e.stopPropagation();
                            }
                        }
                    });
                    google.maps.event.addDomListener(this.div_, "mouseover", function() {
                        var mc = cClusterIcon.cluster_.getMarkerClusterer();
                        google.maps.event.trigger(mc, "mouseover", cClusterIcon.cluster_);
                    });
                    google.maps.event.addDomListener(this.div_, "mouseout", function() {
                        var mc = cClusterIcon.cluster_.getMarkerClusterer();
                        google.maps.event.trigger(mc, "mouseout", cClusterIcon.cluster_);
                    });
                };
                ClusterIcon.prototype.onRemove = function() {
                    if (this.div_ && this.div_.parentNode) {
                        this.hide();
                        google.maps.event.removeListener(this.boundsChangedListener_);
                        google.maps.event.clearInstanceListeners(this.div_);
                        this.div_.parentNode.removeChild(this.div_);
                        this.div_ = null;
                    }
                };
                ClusterIcon.prototype.draw = function() {
                    if (this.visible_) {
                        var pos = this.getPosFromLatLng_(this.center_);
                        this.div_.style.top = pos.y + "px";
                        this.div_.style.left = pos.x + "px";
                    }
                };
                ClusterIcon.prototype.hide = function() {
                    if (this.div_) {
                        this.div_.style.display = "none";
                    }
                    this.visible_ = false;
                };
                ClusterIcon.prototype.show = function() {
                    if (this.div_) {
                        var img = "";
                        var bp = this.backgroundPosition_.split(" ");
                        var spriteH = parseInt(bp[0].trim(), 10);
                        var spriteV = parseInt(bp[1].trim(), 10);
                        var pos = this.getPosFromLatLng_(this.center_);
                        this.div_.style.cssText = this.createCss(pos);
                        img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ";
                        if (!this.cluster_.getMarkerClusterer().enableRetinaIcons_) {
                            img += "clip: rect(" + -1 * spriteV + "px, " + (-1 * spriteH + this.width_) + "px, " + (-1 * spriteV + this.height_) + "px, " + -1 * spriteH + "px);";
                        }
                        img += "'>";
                        this.div_.innerHTML = img + "<div style='" + "position: absolute;" + "top: " + this.anchorText_[0] + "px;" + "left: " + this.anchorText_[1] + "px;" + "color: " + this.textColor_ + ";" + "font-size: " + this.textSize_ + "px;" + "font-family: " + this.fontFamily_ + ";" + "font-weight: " + this.fontWeight_ + ";" + "font-style: " + this.fontStyle_ + ";" + "text-decoration: " + this.textDecoration_ + ";" + "text-align: center;" + "width: " + this.width_ + "px;" + "line-height:" + this.height_ + "px;" + "'>" + this.sums_.text + "</div>";
                        if (typeof this.sums_.title === "undefined" || this.sums_.title === "") {
                            this.div_.title = this.cluster_.getMarkerClusterer().getTitle();
                        } else {
                            this.div_.title = this.sums_.title;
                        }
                        this.div_.style.display = "";
                    }
                    this.visible_ = true;
                };
                ClusterIcon.prototype.useStyle = function(sums) {
                    this.sums_ = sums;
                    var index = Math.max(0, sums.index - 1);
                    index = Math.min(this.styles_.length - 1, index);
                    var style = this.styles_[index];
                    this.url_ = style.url;
                    this.height_ = style.height;
                    this.width_ = style.width;
                    this.anchorText_ = style.anchorText || [ 0, 0 ];
                    this.anchorIcon_ = style.anchorIcon || [ parseInt(this.height_ / 2, 10), parseInt(this.width_ / 2, 10) ];
                    this.textColor_ = style.textColor || "black";
                    this.textSize_ = style.textSize || 11;
                    this.textDecoration_ = style.textDecoration || "none";
                    this.fontWeight_ = style.fontWeight || "bold";
                    this.fontStyle_ = style.fontStyle || "normal";
                    this.fontFamily_ = style.fontFamily || "Arial,sans-serif";
                    this.backgroundPosition_ = style.backgroundPosition || "0 0";
                };
                ClusterIcon.prototype.setCenter = function(center) {
                    this.center_ = center;
                };
                ClusterIcon.prototype.createCss = function(pos) {
                    var style = [];
                    style.push("cursor: pointer;");
                    style.push("position: absolute; top: " + pos.y + "px; left: " + pos.x + "px;");
                    style.push("width: " + this.width_ + "px; height: " + this.height_ + "px;");
                    return style.join("");
                };
                ClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {
                    var pos = this.getProjection().fromLatLngToDivPixel(latlng);
                    pos.x -= this.anchorIcon_[1];
                    pos.y -= this.anchorIcon_[0];
                    pos.x = parseInt(pos.x, 10);
                    pos.y = parseInt(pos.y, 10);
                    return pos;
                };
                function Cluster(mc) {
                    this.markerClusterer_ = mc;
                    this.map_ = mc.getMap();
                    this.gridSize_ = mc.getGridSize();
                    this.minClusterSize_ = mc.getMinimumClusterSize();
                    this.averageCenter_ = mc.getAverageCenter();
                    this.markers_ = [];
                    this.center_ = null;
                    this.bounds_ = null;
                    this.clusterIcon_ = new ClusterIcon(this, mc.getStyles());
                }
                Cluster.prototype.getSize = function() {
                    return this.markers_.length;
                };
                Cluster.prototype.getMarkers = function() {
                    return this.markers_;
                };
                Cluster.prototype.getCenter = function() {
                    return this.center_;
                };
                Cluster.prototype.getMap = function() {
                    return this.map_;
                };
                Cluster.prototype.getMarkerClusterer = function() {
                    return this.markerClusterer_;
                };
                Cluster.prototype.getBounds = function() {
                    var i;
                    var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
                    var markers = this.getMarkers();
                    for (i = 0; i < markers.length; i++) {
                        bounds.extend(markers[i].getPosition());
                    }
                    return bounds;
                };
                Cluster.prototype.remove = function() {
                    this.clusterIcon_.setMap(null);
                    this.markers_ = [];
                    delete this.markers_;
                };
                Cluster.prototype.addMarker = function(marker) {
                    var i;
                    var mCount;
                    var mz;
                    if (this.isMarkerAlreadyAdded_(marker)) {
                        return false;
                    }
                    if (!this.center_) {
                        this.center_ = marker.getPosition();
                        this.calculateBounds_();
                    } else {
                        if (this.averageCenter_) {
                            var l = this.markers_.length + 1;
                            var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;
                            var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
                            this.center_ = new google.maps.LatLng(lat, lng);
                            this.calculateBounds_();
                        }
                    }
                    marker.isAdded = true;
                    this.markers_.push(marker);
                    mCount = this.markers_.length;
                    mz = this.markerClusterer_.getMaxZoom();
                    if (mz !== null && this.map_.getZoom() > mz) {
                        if (marker.getMap() !== this.map_) {
                            marker.setMap(this.map_);
                        }
                    } else if (mCount < this.minClusterSize_) {
                        if (marker.getMap() !== this.map_) {
                            marker.setMap(this.map_);
                        }
                    } else if (mCount === this.minClusterSize_) {
                        for (i = 0; i < mCount; i++) {
                            this.markers_[i].setMap(null);
                        }
                    } else {
                        marker.setMap(null);
                    }
                    this.updateIcon_();
                    return true;
                };
                Cluster.prototype.isMarkerInClusterBounds = function(marker) {
                    return this.bounds_.contains(marker.getPosition());
                };
                Cluster.prototype.calculateBounds_ = function() {
                    var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
                    this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
                };
                Cluster.prototype.updateIcon_ = function() {
                    var mCount = this.markers_.length;
                    var mz = this.markerClusterer_.getMaxZoom();
                    if (mz !== null && this.map_.getZoom() > mz) {
                        this.clusterIcon_.hide();
                        return;
                    }
                    if (mCount < this.minClusterSize_) {
                        this.clusterIcon_.hide();
                        return;
                    }
                    var numStyles = this.markerClusterer_.getStyles().length;
                    var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
                    this.clusterIcon_.setCenter(this.center_);
                    this.clusterIcon_.useStyle(sums);
                    this.clusterIcon_.show();
                };
                Cluster.prototype.isMarkerAlreadyAdded_ = function(marker) {
                    var i;
                    if (this.markers_.indexOf) {
                        return this.markers_.indexOf(marker) !== -1;
                    } else {
                        for (i = 0; i < this.markers_.length; i++) {
                            if (marker === this.markers_[i]) {
                                return true;
                            }
                        }
                    }
                    return false;
                };
                function MarkerClusterer(map, opt_markers, opt_options) {
                    this.extend(MarkerClusterer, google.maps.OverlayView);
                    opt_markers = opt_markers || [];
                    opt_options = opt_options || {};
                    this.markers_ = [];
                    this.clusters_ = [];
                    this.listeners_ = [];
                    this.activeMap_ = null;
                    this.ready_ = false;
                    this.gridSize_ = opt_options.gridSize || 60;
                    this.minClusterSize_ = opt_options.minimumClusterSize || 2;
                    this.maxZoom_ = opt_options.maxZoom || null;
                    this.styles_ = opt_options.styles || [];
                    this.title_ = opt_options.title || "";
                    this.zoomOnClick_ = true;
                    if (opt_options.zoomOnClick !== undefined) {
                        this.zoomOnClick_ = opt_options.zoomOnClick;
                    }
                    this.averageCenter_ = false;
                    if (opt_options.averageCenter !== undefined) {
                        this.averageCenter_ = opt_options.averageCenter;
                    }
                    this.ignoreHidden_ = false;
                    if (opt_options.ignoreHidden !== undefined) {
                        this.ignoreHidden_ = opt_options.ignoreHidden;
                    }
                    this.enableRetinaIcons_ = false;
                    if (opt_options.enableRetinaIcons !== undefined) {
                        this.enableRetinaIcons_ = opt_options.enableRetinaIcons;
                    }
                    this.imagePath_ = opt_options.imagePath || MarkerClusterer.IMAGE_PATH;
                    this.imageExtension_ = opt_options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;
                    this.imageSizes_ = opt_options.imageSizes || MarkerClusterer.IMAGE_SIZES;
                    this.calculator_ = opt_options.calculator || MarkerClusterer.CALCULATOR;
                    this.batchSize_ = opt_options.batchSize || MarkerClusterer.BATCH_SIZE;
                    this.batchSizeIE_ = opt_options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;
                    this.clusterClass_ = opt_options.clusterClass || "cluster";
                    if (navigator.userAgent.toLowerCase().indexOf("msie") !== -1) {
                        this.batchSize_ = this.batchSizeIE_;
                    }
                    this.setupStyles_();
                    this.addMarkers(opt_markers, true);
                    this.setMap(map);
                }
                MarkerClusterer.prototype.onAdd = function() {
                    var cMarkerClusterer = this;
                    this.activeMap_ = this.getMap();
                    this.ready_ = true;
                    this.repaint();
                    this.listeners_ = [ google.maps.event.addListener(this.getMap(), "zoom_changed", function() {
                        cMarkerClusterer.resetViewport_(false);
                        if (this.getZoom() === (this.get("minZoom") || 0) || this.getZoom() === this.get("maxZoom")) {
                            google.maps.event.trigger(this, "idle");
                        }
                    }), google.maps.event.addListener(this.getMap(), "idle", function() {
                        cMarkerClusterer.redraw_();
                    }) ];
                };
                MarkerClusterer.prototype.onRemove = function() {
                    var i;
                    for (i = 0; i < this.markers_.length; i++) {
                        if (this.markers_[i].getMap() !== this.activeMap_) {
                            this.markers_[i].setMap(this.activeMap_);
                        }
                    }
                    for (i = 0; i < this.clusters_.length; i++) {
                        this.clusters_[i].remove();
                    }
                    this.clusters_ = [];
                    for (i = 0; i < this.listeners_.length; i++) {
                        google.maps.event.removeListener(this.listeners_[i]);
                    }
                    this.listeners_ = [];
                    this.activeMap_ = null;
                    this.ready_ = false;
                };
                MarkerClusterer.prototype.draw = function() {};
                MarkerClusterer.prototype.setupStyles_ = function() {
                    var i, size;
                    if (this.styles_.length > 0) {
                        return;
                    }
                    for (i = 0; i < this.imageSizes_.length; i++) {
                        size = this.imageSizes_[i];
                        this.styles_.push({
                            url: this.imagePath_ + (i + 1) + "." + this.imageExtension_,
                            height: size,
                            width: size
                        });
                    }
                };
                MarkerClusterer.prototype.fitMapToMarkers = function() {
                    var i;
                    var markers = this.getMarkers();
                    var bounds = new google.maps.LatLngBounds();
                    for (i = 0; i < markers.length; i++) {
                        bounds.extend(markers[i].getPosition());
                    }
                    this.getMap().fitBounds(bounds);
                };
                MarkerClusterer.prototype.getGridSize = function() {
                    return this.gridSize_;
                };
                MarkerClusterer.prototype.setGridSize = function(gridSize) {
                    this.gridSize_ = gridSize;
                };
                MarkerClusterer.prototype.getMinimumClusterSize = function() {
                    return this.minClusterSize_;
                };
                MarkerClusterer.prototype.setMinimumClusterSize = function(minimumClusterSize) {
                    this.minClusterSize_ = minimumClusterSize;
                };
                MarkerClusterer.prototype.getMaxZoom = function() {
                    return this.maxZoom_;
                };
                MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {
                    this.maxZoom_ = maxZoom;
                };
                MarkerClusterer.prototype.getStyles = function() {
                    return this.styles_;
                };
                MarkerClusterer.prototype.setStyles = function(styles) {
                    this.styles_ = styles;
                };
                MarkerClusterer.prototype.getTitle = function() {
                    return this.title_;
                };
                MarkerClusterer.prototype.setTitle = function(title) {
                    this.title_ = title;
                };
                MarkerClusterer.prototype.getZoomOnClick = function() {
                    return this.zoomOnClick_;
                };
                MarkerClusterer.prototype.setZoomOnClick = function(zoomOnClick) {
                    this.zoomOnClick_ = zoomOnClick;
                };
                MarkerClusterer.prototype.getAverageCenter = function() {
                    return this.averageCenter_;
                };
                MarkerClusterer.prototype.setAverageCenter = function(averageCenter) {
                    this.averageCenter_ = averageCenter;
                };
                MarkerClusterer.prototype.getIgnoreHidden = function() {
                    return this.ignoreHidden_;
                };
                MarkerClusterer.prototype.setIgnoreHidden = function(ignoreHidden) {
                    this.ignoreHidden_ = ignoreHidden;
                };
                MarkerClusterer.prototype.getEnableRetinaIcons = function() {
                    return this.enableRetinaIcons_;
                };
                MarkerClusterer.prototype.setEnableRetinaIcons = function(enableRetinaIcons) {
                    this.enableRetinaIcons_ = enableRetinaIcons;
                };
                MarkerClusterer.prototype.getImageExtension = function() {
                    return this.imageExtension_;
                };
                MarkerClusterer.prototype.setImageExtension = function(imageExtension) {
                    this.imageExtension_ = imageExtension;
                };
                MarkerClusterer.prototype.getImagePath = function() {
                    return this.imagePath_;
                };
                MarkerClusterer.prototype.setImagePath = function(imagePath) {
                    this.imagePath_ = imagePath;
                };
                MarkerClusterer.prototype.getImageSizes = function() {
                    return this.imageSizes_;
                };
                MarkerClusterer.prototype.setImageSizes = function(imageSizes) {
                    this.imageSizes_ = imageSizes;
                };
                MarkerClusterer.prototype.getCalculator = function() {
                    return this.calculator_;
                };
                MarkerClusterer.prototype.setCalculator = function(calculator) {
                    this.calculator_ = calculator;
                };
                MarkerClusterer.prototype.getBatchSizeIE = function() {
                    return this.batchSizeIE_;
                };
                MarkerClusterer.prototype.setBatchSizeIE = function(batchSizeIE) {
                    this.batchSizeIE_ = batchSizeIE;
                };
                MarkerClusterer.prototype.getClusterClass = function() {
                    return this.clusterClass_;
                };
                MarkerClusterer.prototype.setClusterClass = function(clusterClass) {
                    this.clusterClass_ = clusterClass;
                };
                MarkerClusterer.prototype.getMarkers = function() {
                    return this.markers_;
                };
                MarkerClusterer.prototype.getTotalMarkers = function() {
                    return this.markers_.length;
                };
                MarkerClusterer.prototype.getClusters = function() {
                    return this.clusters_;
                };
                MarkerClusterer.prototype.getTotalClusters = function() {
                    return this.clusters_.length;
                };
                MarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {
                    this.pushMarkerTo_(marker);
                    if (!opt_nodraw) {
                        this.redraw_();
                    }
                };
                MarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {
                    var key;
                    for (key in markers) {
                        if (markers.hasOwnProperty(key)) {
                            this.pushMarkerTo_(markers[key]);
                        }
                    }
                    if (!opt_nodraw) {
                        this.redraw_();
                    }
                };
                MarkerClusterer.prototype.pushMarkerTo_ = function(marker) {
                    if (marker.getDraggable()) {
                        var cMarkerClusterer = this;
                        google.maps.event.addListener(marker, "dragend", function() {
                            if (cMarkerClusterer.ready_) {
                                this.isAdded = false;
                                cMarkerClusterer.repaint();
                            }
                        });
                    }
                    marker.isAdded = false;
                    this.markers_.push(marker);
                };
                MarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {
                    var removed = this.removeMarker_(marker);
                    if (!opt_nodraw && removed) {
                        this.repaint();
                    }
                    return removed;
                };
                MarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {
                    var i, r;
                    var removed = false;
                    for (i = 0; i < markers.length; i++) {
                        r = this.removeMarker_(markers[i]);
                        removed = removed || r;
                    }
                    if (!opt_nodraw && removed) {
                        this.repaint();
                    }
                    return removed;
                };
                MarkerClusterer.prototype.removeMarker_ = function(marker) {
                    var i;
                    var index = -1;
                    if (this.markers_.indexOf) {
                        index = this.markers_.indexOf(marker);
                    } else {
                        for (i = 0; i < this.markers_.length; i++) {
                            if (marker === this.markers_[i]) {
                                index = i;
                                break;
                            }
                        }
                    }
                    if (index === -1) {
                        return false;
                    }
                    marker.setMap(null);
                    this.markers_.splice(index, 1);
                    return true;
                };
                MarkerClusterer.prototype.clearMarkers = function() {
                    this.resetViewport_(true);
                    this.markers_ = [];
                };
                MarkerClusterer.prototype.repaint = function() {
                    var oldClusters = this.clusters_.slice();
                    this.clusters_ = [];
                    this.resetViewport_(false);
                    this.redraw_();
                    setTimeout(function() {
                        var i;
                        for (i = 0; i < oldClusters.length; i++) {
                            oldClusters[i].remove();
                        }
                    }, 0);
                };
                MarkerClusterer.prototype.getExtendedBounds = function(bounds) {
                    var projection = this.getProjection();
                    var tr = new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng());
                    var bl = new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng());
                    var trPix = projection.fromLatLngToDivPixel(tr);
                    trPix.x += this.gridSize_;
                    trPix.y -= this.gridSize_;
                    var blPix = projection.fromLatLngToDivPixel(bl);
                    blPix.x -= this.gridSize_;
                    blPix.y += this.gridSize_;
                    var ne = projection.fromDivPixelToLatLng(trPix);
                    var sw = projection.fromDivPixelToLatLng(blPix);
                    bounds.extend(ne);
                    bounds.extend(sw);
                    return bounds;
                };
                MarkerClusterer.prototype.redraw_ = function() {
                    this.createClusters_(0);
                };
                MarkerClusterer.prototype.resetViewport_ = function(opt_hide) {
                    var i, marker;
                    for (i = 0; i < this.clusters_.length; i++) {
                        this.clusters_[i].remove();
                    }
                    this.clusters_ = [];
                    for (i = 0; i < this.markers_.length; i++) {
                        marker = this.markers_[i];
                        marker.isAdded = false;
                        if (opt_hide) {
                            marker.setMap(null);
                        }
                    }
                };
                MarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {
                    var R = 6371;
                    var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
                    var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
                    var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
                    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                    var d = R * c;
                    return d;
                };
                MarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {
                    return bounds.contains(marker.getPosition());
                };
                MarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
                    var i, d, cluster, center;
                    var distance = 4e4;
                    var clusterToAddTo = null;
                    for (i = 0; i < this.clusters_.length; i++) {
                        cluster = this.clusters_[i];
                        center = cluster.getCenter();
                        if (center) {
                            d = this.distanceBetweenPoints_(center, marker.getPosition());
                            if (d < distance) {
                                distance = d;
                                clusterToAddTo = cluster;
                            }
                        }
                    }
                    if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
                        clusterToAddTo.addMarker(marker);
                    } else {
                        cluster = new Cluster(this);
                        cluster.addMarker(marker);
                        this.clusters_.push(cluster);
                    }
                };
                MarkerClusterer.prototype.createClusters_ = function(iFirst) {
                    var i, marker;
                    var mapBounds;
                    var cMarkerClusterer = this;
                    if (!this.ready_) {
                        return;
                    }
                    if (iFirst === 0) {
                        google.maps.event.trigger(this, "clusteringbegin", this);
                        if (typeof this.timerRefStatic !== "undefined") {
                            clearTimeout(this.timerRefStatic);
                            delete this.timerRefStatic;
                        }
                    }
                    if (this.getMap().getZoom() > 3) {
                        mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast());
                    } else {
                        mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
                    }
                    var bounds = this.getExtendedBounds(mapBounds);
                    var iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);
                    for (i = iFirst; i < iLast; i++) {
                        marker = this.markers_[i];
                        if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
                            if (!this.ignoreHidden_ || this.ignoreHidden_ && marker.getVisible()) {
                                this.addToClosestCluster_(marker);
                            }
                        }
                    }
                    if (iLast < this.markers_.length) {
                        this.timerRefStatic = setTimeout(function() {
                            cMarkerClusterer.createClusters_(iLast);
                        }, 0);
                    } else {
                        delete this.timerRefStatic;
                        google.maps.event.trigger(this, "clusteringend", this);
                    }
                };
                MarkerClusterer.prototype.extend = function(obj1, obj2) {
                    return function(object) {
                        var property;
                        for (property in object.prototype) {
                            this.prototype[property] = object.prototype[property];
                        }
                        return this;
                    }.apply(obj1, [ obj2 ]);
                };
                MarkerClusterer.CALCULATOR = function(markers, numStyles) {
                    var index = 0;
                    var title = "";
                    var count = markers.length.toString();
                    var dv = count;
                    while (dv !== 0) {
                        dv = parseInt(dv / 10, 10);
                        index++;
                    }
                    index = Math.min(index, numStyles);
                    return {
                        text: count,
                        index: index,
                        title: title
                    };
                };
                MarkerClusterer.BATCH_SIZE = 2e3;
                MarkerClusterer.BATCH_SIZE_IE = 500;
                MarkerClusterer.IMAGE_PATH = "http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclustererplus/images/m";
                MarkerClusterer.IMAGE_EXTENSION = "png";
                MarkerClusterer.IMAGE_SIZES = [ 53, 56, 66, 78, 90 ];
                function inherits(childCtor, parentCtor) {
                    function tempCtor() {}
                    tempCtor.prototype = parentCtor.prototype;
                    childCtor.superClass_ = parentCtor.prototype;
                    childCtor.prototype = new tempCtor();
                    childCtor.prototype.constructor = childCtor;
                }
                function MarkerLabel_(marker, crossURL, handCursorURL) {
                    this.marker_ = marker;
                    this.handCursorURL_ = marker.handCursorURL;
                    this.labelDiv_ = document.createElement("div");
                    this.labelDiv_.style.cssText = "position: absolute; overflow: hidden;";
                    this.eventDiv_ = document.createElement("div");
                    this.eventDiv_.style.cssText = this.labelDiv_.style.cssText;
                    this.eventDiv_.setAttribute("onselectstart", "return false;");
                    this.eventDiv_.setAttribute("ondragstart", "return false;");
                    this.crossDiv_ = MarkerLabel_.getSharedCross(crossURL);
                }
                inherits(MarkerLabel_, google.maps.OverlayView);
                MarkerLabel_.getSharedCross = function(crossURL) {
                    var div;
                    if (typeof MarkerLabel_.getSharedCross.crossDiv === "undefined") {
                        div = document.createElement("img");
                        div.style.cssText = "position: absolute; z-index: 1000002; display: none;";
                        div.style.marginLeft = "-8px";
                        div.style.marginTop = "-9px";
                        div.src = crossURL;
                        MarkerLabel_.getSharedCross.crossDiv = div;
                    }
                    return MarkerLabel_.getSharedCross.crossDiv;
                };
                MarkerLabel_.prototype.onAdd = function() {
                    var me = this;
                    var cMouseIsDown = false;
                    var cDraggingLabel = false;
                    var cSavedZIndex;
                    var cLatOffset, cLngOffset;
                    var cIgnoreClick;
                    var cRaiseEnabled;
                    var cStartPosition;
                    var cStartCenter;
                    var cRaiseOffset = 20;
                    var cDraggingCursor = "url(" + this.handCursorURL_ + ")";
                    var cAbortEvent = function(e) {
                        if (e.preventDefault) {
                            e.preventDefault();
                        }
                        e.cancelBubble = true;
                        if (e.stopPropagation) {
                            e.stopPropagation();
                        }
                    };
                    var cStopBounce = function() {
                        me.marker_.setAnimation(null);
                    };
                    this.getPanes().overlayImage.appendChild(this.labelDiv_);
                    this.getPanes().overlayMouseTarget.appendChild(this.eventDiv_);
                    if (typeof MarkerLabel_.getSharedCross.processed === "undefined") {
                        this.getPanes().overlayImage.appendChild(this.crossDiv_);
                        MarkerLabel_.getSharedCross.processed = true;
                    }
                    this.listeners_ = [ google.maps.event.addDomListener(this.eventDiv_, "mouseover", function(e) {
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                            this.style.cursor = "pointer";
                            google.maps.event.trigger(me.marker_, "mouseover", e);
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "mouseout", function(e) {
                        if ((me.marker_.getDraggable() || me.marker_.getClickable()) && !cDraggingLabel) {
                            this.style.cursor = me.marker_.getCursor();
                            google.maps.event.trigger(me.marker_, "mouseout", e);
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "mousedown", function(e) {
                        cDraggingLabel = false;
                        if (me.marker_.getDraggable()) {
                            cMouseIsDown = true;
                            this.style.cursor = cDraggingCursor;
                        }
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                            google.maps.event.trigger(me.marker_, "mousedown", e);
                            cAbortEvent(e);
                        }
                    }), google.maps.event.addDomListener(document, "mouseup", function(mEvent) {
                        var position;
                        if (cMouseIsDown) {
                            cMouseIsDown = false;
                            me.eventDiv_.style.cursor = "pointer";
                            google.maps.event.trigger(me.marker_, "mouseup", mEvent);
                        }
                        if (cDraggingLabel) {
                            if (cRaiseEnabled) {
                                position = me.getProjection().fromLatLngToDivPixel(me.marker_.getPosition());
                                position.y += cRaiseOffset;
                                me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position));
                                try {
                                    me.marker_.setAnimation(google.maps.Animation.BOUNCE);
                                    setTimeout(cStopBounce, 1406);
                                } catch (e) {}
                            }
                            me.crossDiv_.style.display = "none";
                            me.marker_.setZIndex(cSavedZIndex);
                            cIgnoreClick = true;
                            cDraggingLabel = false;
                            mEvent.latLng = me.marker_.getPosition();
                            google.maps.event.trigger(me.marker_, "dragend", mEvent);
                        }
                    }), google.maps.event.addListener(me.marker_.getMap(), "mousemove", function(mEvent) {
                        var position;
                        if (cMouseIsDown) {
                            if (cDraggingLabel) {
                                mEvent.latLng = new google.maps.LatLng(mEvent.latLng.lat() - cLatOffset, mEvent.latLng.lng() - cLngOffset);
                                position = me.getProjection().fromLatLngToDivPixel(mEvent.latLng);
                                if (cRaiseEnabled) {
                                    me.crossDiv_.style.left = position.x + "px";
                                    me.crossDiv_.style.top = position.y + "px";
                                    me.crossDiv_.style.display = "";
                                    position.y -= cRaiseOffset;
                                }
                                me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position));
                                if (cRaiseEnabled) {
                                    me.eventDiv_.style.top = position.y + cRaiseOffset + "px";
                                }
                                google.maps.event.trigger(me.marker_, "drag", mEvent);
                            } else {
                                cLatOffset = mEvent.latLng.lat() - me.marker_.getPosition().lat();
                                cLngOffset = mEvent.latLng.lng() - me.marker_.getPosition().lng();
                                cSavedZIndex = me.marker_.getZIndex();
                                cStartPosition = me.marker_.getPosition();
                                cStartCenter = me.marker_.getMap().getCenter();
                                cRaiseEnabled = me.marker_.get("raiseOnDrag");
                                cDraggingLabel = true;
                                me.marker_.setZIndex(1e6);
                                mEvent.latLng = me.marker_.getPosition();
                                google.maps.event.trigger(me.marker_, "dragstart", mEvent);
                            }
                        }
                    }), google.maps.event.addDomListener(document, "keydown", function(e) {
                        if (cDraggingLabel) {
                            if (e.keyCode === 27) {
                                cRaiseEnabled = false;
                                me.marker_.setPosition(cStartPosition);
                                me.marker_.getMap().setCenter(cStartCenter);
                                google.maps.event.trigger(document, "mouseup", e);
                            }
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "click", function(e) {
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                            if (cIgnoreClick) {
                                cIgnoreClick = false;
                            } else {
                                google.maps.event.trigger(me.marker_, "click", e);
                                cAbortEvent(e);
                            }
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "dblclick", function(e) {
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                            google.maps.event.trigger(me.marker_, "dblclick", e);
                            cAbortEvent(e);
                        }
                    }), google.maps.event.addListener(this.marker_, "dragstart", function(mEvent) {
                        if (!cDraggingLabel) {
                            cRaiseEnabled = this.get("raiseOnDrag");
                        }
                    }), google.maps.event.addListener(this.marker_, "drag", function(mEvent) {
                        if (!cDraggingLabel) {
                            if (cRaiseEnabled) {
                                me.setPosition(cRaiseOffset);
                                me.labelDiv_.style.zIndex = 1e6 + (this.get("labelInBackground") ? -1 : +1);
                            }
                        }
                    }), google.maps.event.addListener(this.marker_, "dragend", function(mEvent) {
                        if (!cDraggingLabel) {
                            if (cRaiseEnabled) {
                                me.setPosition(0);
                            }
                        }
                    }), google.maps.event.addListener(this.marker_, "position_changed", function() {
                        me.setPosition();
                    }), google.maps.event.addListener(this.marker_, "zindex_changed", function() {
                        me.setZIndex();
                    }), google.maps.event.addListener(this.marker_, "visible_changed", function() {
                        me.setVisible();
                    }), google.maps.event.addListener(this.marker_, "labelvisible_changed", function() {
                        me.setVisible();
                    }), google.maps.event.addListener(this.marker_, "title_changed", function() {
                        me.setTitle();
                    }), google.maps.event.addListener(this.marker_, "labelcontent_changed", function() {
                        me.setContent();
                    }), google.maps.event.addListener(this.marker_, "labelanchor_changed", function() {
                        me.setAnchor();
                    }), google.maps.event.addListener(this.marker_, "labelclass_changed", function() {
                        me.setStyles();
                    }), google.maps.event.addListener(this.marker_, "labelstyle_changed", function() {
                        me.setStyles();
                    }) ];
                };
                MarkerLabel_.prototype.onRemove = function() {
                    var i;
                    this.labelDiv_.parentNode.removeChild(this.labelDiv_);
                    this.eventDiv_.parentNode.removeChild(this.eventDiv_);
                    for (i = 0; i < this.listeners_.length; i++) {
                        google.maps.event.removeListener(this.listeners_[i]);
                    }
                };
                MarkerLabel_.prototype.draw = function() {
                    this.setContent();
                    this.setTitle();
                    this.setStyles();
                };
                MarkerLabel_.prototype.setContent = function() {
                    var content = this.marker_.get("labelContent");
                    if (typeof content.nodeType === "undefined") {
                        this.labelDiv_.innerHTML = content;
                        this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;
                    } else {
                        this.labelDiv_.innerHTML = "";
                        this.labelDiv_.appendChild(content);
                        content = content.cloneNode(true);
                        this.eventDiv_.innerHTML = "";
                        this.eventDiv_.appendChild(content);
                    }
                };
                MarkerLabel_.prototype.setTitle = function() {
                    this.eventDiv_.title = this.marker_.getTitle() || "";
                };
                MarkerLabel_.prototype.setStyles = function() {
                    var i, labelStyle;
                    this.labelDiv_.className = this.marker_.get("labelClass");
                    this.eventDiv_.className = this.labelDiv_.className;
                    this.labelDiv_.style.cssText = "";
                    this.eventDiv_.style.cssText = "";
                    labelStyle = this.marker_.get("labelStyle");
                    for (i in labelStyle) {
                        if (labelStyle.hasOwnProperty(i)) {
                            this.labelDiv_.style[i] = labelStyle[i];
                            this.eventDiv_.style[i] = labelStyle[i];
                        }
                    }
                    this.setMandatoryStyles();
                };
                MarkerLabel_.prototype.setMandatoryStyles = function() {
                    this.labelDiv_.style.position = "absolute";
                    this.labelDiv_.style.overflow = "hidden";
                    if (typeof this.labelDiv_.style.opacity !== "undefined" && this.labelDiv_.style.opacity !== "") {
                        this.labelDiv_.style.MsFilter = '"progid:DXImageTransform.Microsoft.Alpha(opacity=' + this.labelDiv_.style.opacity * 100 + ')"';
                        this.labelDiv_.style.filter = "alpha(opacity=" + this.labelDiv_.style.opacity * 100 + ")";
                    }
                    this.eventDiv_.style.position = this.labelDiv_.style.position;
                    this.eventDiv_.style.overflow = this.labelDiv_.style.overflow;
                    this.eventDiv_.style.opacity = .01;
                    this.eventDiv_.style.MsFilter = '"progid:DXImageTransform.Microsoft.Alpha(opacity=1)"';
                    this.eventDiv_.style.filter = "alpha(opacity=1)";
                    this.setAnchor();
                    this.setPosition();
                    this.setVisible();
                };
                MarkerLabel_.prototype.setAnchor = function() {
                    var anchor = this.marker_.get("labelAnchor");
                    this.labelDiv_.style.marginLeft = -anchor.x + "px";
                    this.labelDiv_.style.marginTop = -anchor.y + "px";
                    this.eventDiv_.style.marginLeft = -anchor.x + "px";
                    this.eventDiv_.style.marginTop = -anchor.y + "px";
                };
                MarkerLabel_.prototype.setPosition = function(yOffset) {
                    var position = this.getProjection().fromLatLngToDivPixel(this.marker_.getPosition());
                    if (typeof yOffset === "undefined") {
                        yOffset = 0;
                    }
                    this.labelDiv_.style.left = Math.round(position.x) + "px";
                    this.labelDiv_.style.top = Math.round(position.y - yOffset) + "px";
                    this.eventDiv_.style.left = this.labelDiv_.style.left;
                    this.eventDiv_.style.top = this.labelDiv_.style.top;
                    this.setZIndex();
                };
                MarkerLabel_.prototype.setZIndex = function() {
                    var zAdjust = this.marker_.get("labelInBackground") ? -1 : +1;
                    if (typeof this.marker_.getZIndex() === "undefined") {
                        this.labelDiv_.style.zIndex = parseInt(this.labelDiv_.style.top, 10) + zAdjust;
                        this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
                    } else {
                        this.labelDiv_.style.zIndex = this.marker_.getZIndex() + zAdjust;
                        this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
                    }
                };
                MarkerLabel_.prototype.setVisible = function() {
                    if (this.marker_.get("labelVisible")) {
                        this.labelDiv_.style.display = this.marker_.getVisible() ? "block" : "none";
                    } else {
                        this.labelDiv_.style.display = "none";
                    }
                    this.eventDiv_.style.display = this.labelDiv_.style.display;
                };
                function MarkerWithLabel(opt_options) {
                    opt_options = opt_options || {};
                    opt_options.labelContent = opt_options.labelContent || "";
                    opt_options.labelAnchor = opt_options.labelAnchor || new google.maps.Point(0, 0);
                    opt_options.labelClass = opt_options.labelClass || "markerLabels";
                    opt_options.labelStyle = opt_options.labelStyle || {};
                    opt_options.labelInBackground = opt_options.labelInBackground || false;
                    if (typeof opt_options.labelVisible === "undefined") {
                        opt_options.labelVisible = true;
                    }
                    if (typeof opt_options.raiseOnDrag === "undefined") {
                        opt_options.raiseOnDrag = true;
                    }
                    if (typeof opt_options.clickable === "undefined") {
                        opt_options.clickable = true;
                    }
                    if (typeof opt_options.draggable === "undefined") {
                        opt_options.draggable = false;
                    }
                    if (typeof opt_options.optimized === "undefined") {
                        opt_options.optimized = false;
                    }
                    opt_options.crossImage = opt_options.crossImage || "http" + (document.location.protocol === "https:" ? "s" : "") + "://maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png";
                    opt_options.handCursor = opt_options.handCursor || "http" + (document.location.protocol === "https:" ? "s" : "") + "://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur";
                    opt_options.optimized = false;
                    this.label = new MarkerLabel_(this, opt_options.crossImage, opt_options.handCursor);
                    google.maps.Marker.apply(this, arguments);
                }
                inherits(MarkerWithLabel, google.maps.Marker);
                MarkerWithLabel.prototype.setMap = function(theMap) {
                    google.maps.Marker.prototype.setMap.apply(this, arguments);
                    this.label.setMap(theMap);
                };
                function RichMarker(opt_options) {
                    var options = opt_options || {};
                    this.ready_ = false;
                    this.dragging_ = false;
                    if (opt_options["visible"] == undefined) {
                        opt_options["visible"] = true;
                    }
                    if (opt_options["shadow"] == undefined) {
                        opt_options["shadow"] = "7px -3px 5px rgba(88,88,88,0.7)";
                    }
                    if (opt_options["anchor"] == undefined) {
                        opt_options["anchor"] = RichMarkerPosition["BOTTOM"];
                    }
                    this.setValues(options);
                }
                RichMarker.prototype = new google.maps.OverlayView();
                window["RichMarker"] = RichMarker;
                RichMarker.prototype.getVisible = function() {
                    return this.get("visible");
                };
                RichMarker.prototype["getVisible"] = RichMarker.prototype.getVisible;
                RichMarker.prototype.setVisible = function(visible) {
                    this.set("visible", visible);
                };
                RichMarker.prototype["setVisible"] = RichMarker.prototype.setVisible;
                RichMarker.prototype.visible_changed = function() {
                    if (this.ready_) {
                        this.markerWrapper_.style["display"] = this.getVisible() ? "" : "none";
                        this.draw();
                    }
                };
                RichMarker.prototype["visible_changed"] = RichMarker.prototype.visible_changed;
                RichMarker.prototype.setFlat = function(flat) {
                    this.set("flat", !!flat);
                };
                RichMarker.prototype["setFlat"] = RichMarker.prototype.setFlat;
                RichMarker.prototype.getFlat = function() {
                    return this.get("flat");
                };
                RichMarker.prototype["getFlat"] = RichMarker.prototype.getFlat;
                RichMarker.prototype.getWidth = function() {
                    return this.get("width");
                };
                RichMarker.prototype["getWidth"] = RichMarker.prototype.getWidth;
                RichMarker.prototype.getHeight = function() {
                    return this.get("height");
                };
                RichMarker.prototype["getHeight"] = RichMarker.prototype.getHeight;
                RichMarker.prototype.setShadow = function(shadow) {
                    this.set("shadow", shadow);
                    this.flat_changed();
                };
                RichMarker.prototype["setShadow"] = RichMarker.prototype.setShadow;
                RichMarker.prototype.getShadow = function() {
                    return this.get("shadow");
                };
                RichMarker.prototype["getShadow"] = RichMarker.prototype.getShadow;
                RichMarker.prototype.flat_changed = function() {
                    if (!this.ready_) {
                        return;
                    }
                    this.markerWrapper_.style["boxShadow"] = this.markerWrapper_.style["webkitBoxShadow"] = this.markerWrapper_.style["MozBoxShadow"] = this.getFlat() ? "" : this.getShadow();
                };
                RichMarker.prototype["flat_changed"] = RichMarker.prototype.flat_changed;
                RichMarker.prototype.setZIndex = function(index) {
                    this.set("zIndex", index);
                };
                RichMarker.prototype["setZIndex"] = RichMarker.prototype.setZIndex;
                RichMarker.prototype.getZIndex = function() {
                    return this.get("zIndex");
                };
                RichMarker.prototype["getZIndex"] = RichMarker.prototype.getZIndex;
                RichMarker.prototype.zIndex_changed = function() {
                    if (this.getZIndex() && this.ready_) {
                        this.markerWrapper_.style.zIndex = this.getZIndex();
                    }
                };
                RichMarker.prototype["zIndex_changed"] = RichMarker.prototype.zIndex_changed;
                RichMarker.prototype.getDraggable = function() {
                    return this.get("draggable");
                };
                RichMarker.prototype["getDraggable"] = RichMarker.prototype.getDraggable;
                RichMarker.prototype.setDraggable = function(draggable) {
                    this.set("draggable", !!draggable);
                };
                RichMarker.prototype["setDraggable"] = RichMarker.prototype.setDraggable;
                RichMarker.prototype.draggable_changed = function() {
                    if (this.ready_) {
                        if (this.getDraggable()) {
                            this.addDragging_(this.markerWrapper_);
                        } else {
                            this.removeDragListeners_();
                        }
                    }
                };
                RichMarker.prototype["draggable_changed"] = RichMarker.prototype.draggable_changed;
                RichMarker.prototype.getPosition = function() {
                    return this.get("position");
                };
                RichMarker.prototype["getPosition"] = RichMarker.prototype.getPosition;
                RichMarker.prototype.setPosition = function(position) {
                    this.set("position", position);
                };
                RichMarker.prototype["setPosition"] = RichMarker.prototype.setPosition;
                RichMarker.prototype.position_changed = function() {
                    this.draw();
                };
                RichMarker.prototype["position_changed"] = RichMarker.prototype.position_changed;
                RichMarker.prototype.getAnchor = function() {
                    return this.get("anchor");
                };
                RichMarker.prototype["getAnchor"] = RichMarker.prototype.getAnchor;
                RichMarker.prototype.setAnchor = function(anchor) {
                    this.set("anchor", anchor);
                };
                RichMarker.prototype["setAnchor"] = RichMarker.prototype.setAnchor;
                RichMarker.prototype.anchor_changed = function() {
                    this.draw();
                };
                RichMarker.prototype["anchor_changed"] = RichMarker.prototype.anchor_changed;
                RichMarker.prototype.htmlToDocumentFragment_ = function(htmlString) {
                    var tempDiv = document.createElement("DIV");
                    tempDiv.innerHTML = htmlString;
                    if (tempDiv.childNodes.length == 1) {
                        return tempDiv.removeChild(tempDiv.firstChild);
                    } else {
                        var fragment = document.createDocumentFragment();
                        while (tempDiv.firstChild) {
                            fragment.appendChild(tempDiv.firstChild);
                        }
                        return fragment;
                    }
                };
                RichMarker.prototype.removeChildren_ = function(node) {
                    if (!node) {
                        return;
                    }
                    var child;
                    while (child = node.firstChild) {
                        node.removeChild(child);
                    }
                };
                RichMarker.prototype.setContent = function(content) {
                    this.set("content", content);
                };
                RichMarker.prototype["setContent"] = RichMarker.prototype.setContent;
                RichMarker.prototype.getContent = function() {
                    return this.get("content");
                };
                RichMarker.prototype["getContent"] = RichMarker.prototype.getContent;
                RichMarker.prototype.content_changed = function() {
                    if (!this.markerContent_) {
                        return;
                    }
                    this.removeChildren_(this.markerContent_);
                    var content = this.getContent();
                    if (content) {
                        if (typeof content == "string") {
                            content = content.replace(/^\s*([\S\s]*)\b\s*$/, "$1");
                            content = this.htmlToDocumentFragment_(content);
                        }
                        this.markerContent_.appendChild(content);
                        var that = this;
                        var images = this.markerContent_.getElementsByTagName("IMG");
                        for (var i = 0, image; image = images[i]; i++) {
                            google.maps.event.addDomListener(image, "mousedown", function(e) {
                                if (that.getDraggable()) {
                                    if (e.preventDefault) {
                                        e.preventDefault();
                                    }
                                    e.returnValue = false;
                                }
                            });
                            google.maps.event.addDomListener(image, "load", function() {
                                that.draw();
                            });
                        }
                        google.maps.event.trigger(this, "domready");
                    }
                    if (this.ready_) {
                        this.draw();
                    }
                };
                RichMarker.prototype["content_changed"] = RichMarker.prototype.content_changed;
                RichMarker.prototype.setCursor_ = function(whichCursor) {
                    if (!this.ready_) {
                        return;
                    }
                    var cursor = "";
                    if (navigator.userAgent.indexOf("Gecko/") !== -1) {
                        if (whichCursor == "dragging") {
                            cursor = "-moz-grabbing";
                        }
                        if (whichCursor == "dragready") {
                            cursor = "-moz-grab";
                        }
                        if (whichCursor == "draggable") {
                            cursor = "pointer";
                        }
                    } else {
                        if (whichCursor == "dragging" || whichCursor == "dragready") {
                            cursor = "move";
                        }
                        if (whichCursor == "draggable") {
                            cursor = "pointer";
                        }
                    }
                    if (this.markerWrapper_.style.cursor != cursor) {
                        this.markerWrapper_.style.cursor = cursor;
                    }
                };
                RichMarker.prototype.startDrag = function(e) {
                    if (!this.getDraggable()) {
                        return;
                    }
                    if (!this.dragging_) {
                        this.dragging_ = true;
                        var map = this.getMap();
                        this.mapDraggable_ = map.get("draggable");
                        map.set("draggable", false);
                        this.mouseX_ = e.clientX;
                        this.mouseY_ = e.clientY;
                        this.setCursor_("dragready");
                        this.markerWrapper_.style["MozUserSelect"] = "none";
                        this.markerWrapper_.style["KhtmlUserSelect"] = "none";
                        this.markerWrapper_.style["WebkitUserSelect"] = "none";
                        this.markerWrapper_["unselectable"] = "on";
                        this.markerWrapper_["onselectstart"] = function() {
                            return false;
                        };
                        this.addDraggingListeners_();
                        google.maps.event.trigger(this, "dragstart");
                    }
                };
                RichMarker.prototype.stopDrag = function() {
                    if (!this.getDraggable()) {
                        return;
                    }
                    if (this.dragging_) {
                        this.dragging_ = false;
                        this.getMap().set("draggable", this.mapDraggable_);
                        this.mouseX_ = this.mouseY_ = this.mapDraggable_ = null;
                        this.markerWrapper_.style["MozUserSelect"] = "";
                        this.markerWrapper_.style["KhtmlUserSelect"] = "";
                        this.markerWrapper_.style["WebkitUserSelect"] = "";
                        this.markerWrapper_["unselectable"] = "off";
                        this.markerWrapper_["onselectstart"] = function() {};
                        this.removeDraggingListeners_();
                        this.setCursor_("draggable");
                        google.maps.event.trigger(this, "dragend");
                        this.draw();
                    }
                };
                RichMarker.prototype.drag = function(e) {
                    if (!this.getDraggable() || !this.dragging_) {
                        this.stopDrag();
                        return;
                    }
                    var dx = this.mouseX_ - e.clientX;
                    var dy = this.mouseY_ - e.clientY;
                    this.mouseX_ = e.clientX;
                    this.mouseY_ = e.clientY;
                    var left = parseInt(this.markerWrapper_.style["left"], 10) - dx;
                    var top = parseInt(this.markerWrapper_.style["top"], 10) - dy;
                    this.markerWrapper_.style["left"] = left + "px";
                    this.markerWrapper_.style["top"] = top + "px";
                    var offset = this.getOffset_();
                    var point = new google.maps.Point(left - offset.width, top - offset.height);
                    var projection = this.getProjection();
                    this.setPosition(projection.fromDivPixelToLatLng(point));
                    this.setCursor_("dragging");
                    google.maps.event.trigger(this, "drag");
                };
                RichMarker.prototype.removeDragListeners_ = function() {
                    if (this.draggableListener_) {
                        google.maps.event.removeListener(this.draggableListener_);
                        delete this.draggableListener_;
                    }
                    this.setCursor_("");
                };
                RichMarker.prototype.addDragging_ = function(node) {
                    if (!node) {
                        return;
                    }
                    var that = this;
                    this.draggableListener_ = google.maps.event.addDomListener(node, "mousedown", function(e) {
                        that.startDrag(e);
                    });
                    this.setCursor_("draggable");
                };
                RichMarker.prototype.addDraggingListeners_ = function() {
                    var that = this;
                    if (this.markerWrapper_.setCapture) {
                        this.markerWrapper_.setCapture(true);
                        this.draggingListeners_ = [ google.maps.event.addDomListener(this.markerWrapper_, "mousemove", function(e) {
                            that.drag(e);
                        }, true), google.maps.event.addDomListener(this.markerWrapper_, "mouseup", function() {
                            that.stopDrag();
                            that.markerWrapper_.releaseCapture();
                        }, true) ];
                    } else {
                        this.draggingListeners_ = [ google.maps.event.addDomListener(window, "mousemove", function(e) {
                            that.drag(e);
                        }, true), google.maps.event.addDomListener(window, "mouseup", function() {
                            that.stopDrag();
                        }, true) ];
                    }
                };
                RichMarker.prototype.removeDraggingListeners_ = function() {
                    if (this.draggingListeners_) {
                        for (var i = 0, listener; listener = this.draggingListeners_[i]; i++) {
                            google.maps.event.removeListener(listener);
                        }
                        this.draggingListeners_.length = 0;
                    }
                };
                RichMarker.prototype.getOffset_ = function() {
                    var anchor = this.getAnchor();
                    if (typeof anchor == "object") {
                        return anchor;
                    }
                    var offset = new google.maps.Size(0, 0);
                    if (!this.markerContent_) {
                        return offset;
                    }
                    var width = this.markerContent_.offsetWidth;
                    var height = this.markerContent_.offsetHeight;
                    switch (anchor) {
                      case RichMarkerPosition["TOP_LEFT"]:
                        break;

                      case RichMarkerPosition["TOP"]:
                        offset.width = -width / 2;
                        break;

                      case RichMarkerPosition["TOP_RIGHT"]:
                        offset.width = -width;
                        break;

                      case RichMarkerPosition["LEFT"]:
                        offset.height = -height / 2;
                        break;

                      case RichMarkerPosition["MIDDLE"]:
                        offset.width = -width / 2;
                        offset.height = -height / 2;
                        break;

                      case RichMarkerPosition["RIGHT"]:
                        offset.width = -width;
                        offset.height = -height / 2;
                        break;

                      case RichMarkerPosition["BOTTOM_LEFT"]:
                        offset.height = -height;
                        break;

                      case RichMarkerPosition["BOTTOM"]:
                        offset.width = -width / 2;
                        offset.height = -height;
                        break;

                      case RichMarkerPosition["BOTTOM_RIGHT"]:
                        offset.width = -width;
                        offset.height = -height;
                        break;
                    }
                    return offset;
                };
                RichMarker.prototype.onAdd = function() {
                    if (!this.markerWrapper_) {
                        this.markerWrapper_ = document.createElement("DIV");
                        this.markerWrapper_.style["position"] = "absolute";
                    }
                    if (this.getZIndex()) {
                        this.markerWrapper_.style["zIndex"] = this.getZIndex();
                    }
                    this.markerWrapper_.style["display"] = this.getVisible() ? "" : "none";
                    if (!this.markerContent_) {
                        this.markerContent_ = document.createElement("DIV");
                        this.markerWrapper_.appendChild(this.markerContent_);
                        var that = this;
                        google.maps.event.addDomListener(this.markerContent_, "click", function(e) {
                            google.maps.event.trigger(that, "click");
                        });
                        google.maps.event.addDomListener(this.markerContent_, "mouseover", function(e) {
                            google.maps.event.trigger(that, "mouseover");
                        });
                        google.maps.event.addDomListener(this.markerContent_, "mouseout", function(e) {
                            google.maps.event.trigger(that, "mouseout");
                        });
                    }
                    this.ready_ = true;
                    this.content_changed();
                    this.flat_changed();
                    this.draggable_changed();
                    var panes = this.getPanes();
                    if (panes) {
                        panes.overlayMouseTarget.appendChild(this.markerWrapper_);
                    }
                    google.maps.event.trigger(this, "ready");
                };
                RichMarker.prototype["onAdd"] = RichMarker.prototype.onAdd;
                RichMarker.prototype.draw = function() {
                    if (!this.ready_ || this.dragging_) {
                        return;
                    }
                    var projection = this.getProjection();
                    if (!projection) {
                        return;
                    }
                    var latLng = this.get("position");
                    var pos = projection.fromLatLngToDivPixel(latLng);
                    var offset = this.getOffset_();
                    this.markerWrapper_.style["top"] = pos.y + offset.height + "px";
                    this.markerWrapper_.style["left"] = pos.x + offset.width + "px";
                    var height = this.markerContent_.offsetHeight;
                    var width = this.markerContent_.offsetWidth;
                    if (width != this.get("width")) {
                        this.set("width", width);
                    }
                    if (height != this.get("height")) {
                        this.set("height", height);
                    }
                };
                RichMarker.prototype["draw"] = RichMarker.prototype.draw;
                RichMarker.prototype.onRemove = function() {
                    if (this.markerWrapper_ && this.markerWrapper_.parentNode) {
                        this.markerWrapper_.parentNode.removeChild(this.markerWrapper_);
                    }
                    this.removeDragListeners_();
                };
                RichMarker.prototype["onRemove"] = RichMarker.prototype.onRemove;
                var RichMarkerPosition = {
                    TOP_LEFT: 1,
                    TOP: 2,
                    TOP_RIGHT: 3,
                    LEFT: 4,
                    MIDDLE: 5,
                    RIGHT: 6,
                    BOTTOM_LEFT: 7,
                    BOTTOM: 8,
                    BOTTOM_RIGHT: 9
                };
                window["RichMarkerPosition"] = RichMarkerPosition;
                window.InfoBox = InfoBox;
                window.Cluster = Cluster;
                window.ClusterIcon = ClusterIcon;
                window.MarkerClusterer = MarkerClusterer;
                window.MarkerLabel_ = MarkerLabel_;
                window.MarkerWithLabel = MarkerWithLabel;
                window.RichMarker = RichMarker;
            })
        };
    });
    (function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                exports: {},
                id: moduleId,
                loaded: false
            };
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            module.loaded = true;
            return module.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
    })([ function(module, exports, __webpack_require__) {
        angular.module("uiGmapgoogle-maps.wrapped").service("uiGmapDataStructures", function() {
            return {
                Graph: __webpack_require__(1).Graph,
                Queue: __webpack_require__(1).Queue
            };
        });
    }, function(module, exports, __webpack_require__) {
        (function() {
            module.exports = {
                Graph: __webpack_require__(2),
                Heap: __webpack_require__(3),
                LinkedList: __webpack_require__(4),
                Map: __webpack_require__(5),
                Queue: __webpack_require__(6),
                RedBlackTree: __webpack_require__(7),
                Trie: __webpack_require__(8)
            };
        }).call(this);
    }, function(module, exports) {
        (function() {
            var Graph, __hasProp = {}.hasOwnProperty;
            Graph = function() {
                function Graph() {
                    this._nodes = {};
                    this.nodeSize = 0;
                    this.edgeSize = 0;
                }
                Graph.prototype.addNode = function(id) {
                    if (!this._nodes[id]) {
                        this.nodeSize++;
                        return this._nodes[id] = {
                            _outEdges: {},
                            _inEdges: {}
                        };
                    }
                };
                Graph.prototype.getNode = function(id) {
                    return this._nodes[id];
                };
                Graph.prototype.removeNode = function(id) {
                    var inEdgeId, nodeToRemove, outEdgeId, _ref, _ref1;
                    nodeToRemove = this._nodes[id];
                    if (!nodeToRemove) {
                        return;
                    } else {
                        _ref = nodeToRemove._outEdges;
                        for (outEdgeId in _ref) {
                            if (!__hasProp.call(_ref, outEdgeId)) continue;
                            this.removeEdge(id, outEdgeId);
                        }
                        _ref1 = nodeToRemove._inEdges;
                        for (inEdgeId in _ref1) {
                            if (!__hasProp.call(_ref1, inEdgeId)) continue;
                            this.removeEdge(inEdgeId, id);
                        }
                        this.nodeSize--;
                        delete this._nodes[id];
                    }
                    return nodeToRemove;
                };
                Graph.prototype.addEdge = function(fromId, toId, weight) {
                    var edgeToAdd, fromNode, toNode;
                    if (weight == null) {
                        weight = 1;
                    }
                    if (this.getEdge(fromId, toId)) {
                        return;
                    }
                    fromNode = this._nodes[fromId];
                    toNode = this._nodes[toId];
                    if (!fromNode || !toNode) {
                        return;
                    }
                    edgeToAdd = {
                        weight: weight
                    };
                    fromNode._outEdges[toId] = edgeToAdd;
                    toNode._inEdges[fromId] = edgeToAdd;
                    this.edgeSize++;
                    return edgeToAdd;
                };
                Graph.prototype.getEdge = function(fromId, toId) {
                    var fromNode, toNode;
                    fromNode = this._nodes[fromId];
                    toNode = this._nodes[toId];
                    if (!fromNode || !toNode) {} else {
                        return fromNode._outEdges[toId];
                    }
                };
                Graph.prototype.removeEdge = function(fromId, toId) {
                    var edgeToDelete, fromNode, toNode;
                    fromNode = this._nodes[fromId];
                    toNode = this._nodes[toId];
                    edgeToDelete = this.getEdge(fromId, toId);
                    if (!edgeToDelete) {
                        return;
                    }
                    delete fromNode._outEdges[toId];
                    delete toNode._inEdges[fromId];
                    this.edgeSize--;
                    return edgeToDelete;
                };
                Graph.prototype.getInEdgesOf = function(nodeId) {
                    var fromId, inEdges, toNode, _ref;
                    toNode = this._nodes[nodeId];
                    inEdges = [];
                    _ref = toNode != null ? toNode._inEdges : void 0;
                    for (fromId in _ref) {
                        if (!__hasProp.call(_ref, fromId)) continue;
                        inEdges.push(this.getEdge(fromId, nodeId));
                    }
                    return inEdges;
                };
                Graph.prototype.getOutEdgesOf = function(nodeId) {
                    var fromNode, outEdges, toId, _ref;
                    fromNode = this._nodes[nodeId];
                    outEdges = [];
                    _ref = fromNode != null ? fromNode._outEdges : void 0;
                    for (toId in _ref) {
                        if (!__hasProp.call(_ref, toId)) continue;
                        outEdges.push(this.getEdge(nodeId, toId));
                    }
                    return outEdges;
                };
                Graph.prototype.getAllEdgesOf = function(nodeId) {
                    var i, inEdges, outEdges, selfEdge, _i, _ref, _ref1;
                    inEdges = this.getInEdgesOf(nodeId);
                    outEdges = this.getOutEdgesOf(nodeId);
                    if (inEdges.length === 0) {
                        return outEdges;
                    }
                    selfEdge = this.getEdge(nodeId, nodeId);
                    for (i = _i = 0, _ref = inEdges.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                        if (inEdges[i] === selfEdge) {
                            _ref1 = [ inEdges[inEdges.length - 1], inEdges[i] ], inEdges[i] = _ref1[0], inEdges[inEdges.length - 1] = _ref1[1];
                            inEdges.pop();
                            break;
                        }
                    }
                    return inEdges.concat(outEdges);
                };
                Graph.prototype.forEachNode = function(operation) {
                    var nodeId, nodeObject, _ref;
                    _ref = this._nodes;
                    for (nodeId in _ref) {
                        if (!__hasProp.call(_ref, nodeId)) continue;
                        nodeObject = _ref[nodeId];
                        operation(nodeObject, nodeId);
                    }
                };
                Graph.prototype.forEachEdge = function(operation) {
                    var edgeObject, nodeId, nodeObject, toId, _ref, _ref1;
                    _ref = this._nodes;
                    for (nodeId in _ref) {
                        if (!__hasProp.call(_ref, nodeId)) continue;
                        nodeObject = _ref[nodeId];
                        _ref1 = nodeObject._outEdges;
                        for (toId in _ref1) {
                            if (!__hasProp.call(_ref1, toId)) continue;
                            edgeObject = _ref1[toId];
                            operation(edgeObject);
                        }
                    }
                };
                return Graph;
            }();
            module.exports = Graph;
        }).call(this);
    }, function(module, exports) {
        (function() {
            var Heap, _leftChild, _parent, _rightChild;
            Heap = function() {
                function Heap(dataToHeapify) {
                    var i, item, _i, _j, _len, _ref;
                    if (dataToHeapify == null) {
                        dataToHeapify = [];
                    }
                    this._data = [ void 0 ];
                    for (_i = 0, _len = dataToHeapify.length; _i < _len; _i++) {
                        item = dataToHeapify[_i];
                        if (item != null) {
                            this._data.push(item);
                        }
                    }
                    if (this._data.length > 1) {
                        for (i = _j = 2, _ref = this._data.length; 2 <= _ref ? _j < _ref : _j > _ref; i = 2 <= _ref ? ++_j : --_j) {
                            this._upHeap(i);
                        }
                    }
                    this.size = this._data.length - 1;
                }
                Heap.prototype.add = function(value) {
                    if (value == null) {
                        return;
                    }
                    this._data.push(value);
                    this._upHeap(this._data.length - 1);
                    this.size++;
                    return value;
                };
                Heap.prototype.removeMin = function() {
                    var min;
                    if (this._data.length === 1) {
                        return;
                    }
                    this.size--;
                    if (this._data.length === 2) {
                        return this._data.pop();
                    }
                    min = this._data[1];
                    this._data[1] = this._data.pop();
                    this._downHeap();
                    return min;
                };
                Heap.prototype.peekMin = function() {
                    return this._data[1];
                };
                Heap.prototype._upHeap = function(index) {
                    var valueHolder, _ref;
                    valueHolder = this._data[index];
                    while (this._data[index] < this._data[_parent(index)] && index > 1) {
                        _ref = [ this._data[_parent(index)], this._data[index] ], this._data[index] = _ref[0], 
                        this._data[_parent(index)] = _ref[1];
                        index = _parent(index);
                    }
                };
                Heap.prototype._downHeap = function() {
                    var currentIndex, smallerChildIndex, _ref;
                    currentIndex = 1;
                    while (_leftChild(currentIndex < this._data.length)) {
                        smallerChildIndex = _leftChild(currentIndex);
                        if (smallerChildIndex < this._data.length - 1) {
                            if (this._data[_rightChild(currentIndex)] < this._data[smallerChildIndex]) {
                                smallerChildIndex = _rightChild(currentIndex);
                            }
                        }
                        if (this._data[smallerChildIndex] < this._data[currentIndex]) {
                            _ref = [ this._data[currentIndex], this._data[smallerChildIndex] ], this._data[smallerChildIndex] = _ref[0], 
                            this._data[currentIndex] = _ref[1];
                            currentIndex = smallerChildIndex;
                        } else {
                            break;
                        }
                    }
                };
                return Heap;
            }();
            _parent = function(index) {
                return index >> 1;
            };
            _leftChild = function(index) {
                return index << 1;
            };
            _rightChild = function(index) {
                return (index << 1) + 1;
            };
            module.exports = Heap;
        }).call(this);
    }, function(module, exports) {
        (function() {
            var LinkedList;
            LinkedList = function() {
                function LinkedList(valuesToAdd) {
                    var value, _i, _len;
                    if (valuesToAdd == null) {
                        valuesToAdd = [];
                    }
                    this.head = {
                        prev: void 0,
                        value: void 0,
                        next: void 0
                    };
                    this.tail = {
                        prev: void 0,
                        value: void 0,
                        next: void 0
                    };
                    this.size = 0;
                    for (_i = 0, _len = valuesToAdd.length; _i < _len; _i++) {
                        value = valuesToAdd[_i];
                        this.add(value);
                    }
                }
                LinkedList.prototype.at = function(position) {
                    var currentNode, i, _i, _j, _ref;
                    if (!(-this.size <= position && position < this.size)) {
                        return;
                    }
                    position = this._adjust(position);
                    if (position * 2 < this.size) {
                        currentNode = this.head;
                        for (i = _i = 1; _i <= position; i = _i += 1) {
                            currentNode = currentNode.next;
                        }
                    } else {
                        currentNode = this.tail;
                        for (i = _j = 1, _ref = this.size - position - 1; _j <= _ref; i = _j += 1) {
                            currentNode = currentNode.prev;
                        }
                    }
                    return currentNode;
                };
                LinkedList.prototype.add = function(value, position) {
                    var currentNode, nodeToAdd, _ref, _ref1, _ref2;
                    if (position == null) {
                        position = this.size;
                    }
                    if (!(-this.size <= position && position <= this.size)) {
                        return;
                    }
                    nodeToAdd = {
                        value: value
                    };
                    position = this._adjust(position);
                    if (this.size === 0) {
                        this.head = nodeToAdd;
                    } else {
                        if (position === 0) {
                            _ref = [ nodeToAdd, this.head, nodeToAdd ], this.head.prev = _ref[0], nodeToAdd.next = _ref[1], 
                            this.head = _ref[2];
                        } else {
                            currentNode = this.at(position - 1);
                            _ref1 = [ currentNode.next, nodeToAdd, nodeToAdd, currentNode ], nodeToAdd.next = _ref1[0], 
                            (_ref2 = currentNode.next) != null ? _ref2.prev = _ref1[1] : void 0, currentNode.next = _ref1[2], 
                            nodeToAdd.prev = _ref1[3];
                        }
                    }
                    if (position === this.size) {
                        this.tail = nodeToAdd;
                    }
                    this.size++;
                    return value;
                };
                LinkedList.prototype.removeAt = function(position) {
                    var currentNode, valueToReturn, _ref;
                    if (position == null) {
                        position = this.size - 1;
                    }
                    if (!(-this.size <= position && position < this.size)) {
                        return;
                    }
                    if (this.size === 0) {
                        return;
                    }
                    position = this._adjust(position);
                    if (this.size === 1) {
                        valueToReturn = this.head.value;
                        this.head.value = this.tail.value = void 0;
                    } else {
                        if (position === 0) {
                            valueToReturn = this.head.value;
                            this.head = this.head.next;
                            this.head.prev = void 0;
                        } else {
                            currentNode = this.at(position);
                            valueToReturn = currentNode.value;
                            currentNode.prev.next = currentNode.next;
                            if ((_ref = currentNode.next) != null) {
                                _ref.prev = currentNode.prev;
                            }
                            if (position === this.size - 1) {
                                this.tail = currentNode.prev;
                            }
                        }
                    }
                    this.size--;
                    return valueToReturn;
                };
                LinkedList.prototype.remove = function(value) {
                    var currentNode;
                    if (value == null) {
                        return;
                    }
                    currentNode = this.head;
                    while (currentNode && currentNode.value !== value) {
                        currentNode = currentNode.next;
                    }
                    if (!currentNode) {
                        return;
                    }
                    if (this.size === 1) {
                        this.head.value = this.tail.value = void 0;
                    } else if (currentNode === this.head) {
                        this.head = this.head.next;
                        this.head.prev = void 0;
                    } else if (currentNode === this.tail) {
                        this.tail = this.tail.prev;
                        this.tail.next = void 0;
                    } else {
                        currentNode.prev.next = currentNode.next;
                        currentNode.next.prev = currentNode.prev;
                    }
                    this.size--;
                    return value;
                };
                LinkedList.prototype.indexOf = function(value, startingPosition) {
                    var currentNode, position;
                    if (startingPosition == null) {
                        startingPosition = 0;
                    }
                    if (this.head.value == null && !this.head.next || startingPosition >= this.size) {
                        return -1;
                    }
                    startingPosition = Math.max(0, this._adjust(startingPosition));
                    currentNode = this.at(startingPosition);
                    position = startingPosition;
                    while (currentNode) {
                        if (currentNode.value === value) {
                            break;
                        }
                        currentNode = currentNode.next;
                        position++;
                    }
                    if (position === this.size) {
                        return -1;
                    } else {
                        return position;
                    }
                };
                LinkedList.prototype._adjust = function(position) {
                    if (position < 0) {
                        return this.size + position;
                    } else {
                        return position;
                    }
                };
                return LinkedList;
            }();
            module.exports = LinkedList;
        }).call(this);
    }, function(module, exports) {
        (function() {
            var Map, SPECIAL_TYPE_KEY_PREFIX, _extractDataType, _isSpecialType, __hasProp = {}.hasOwnProperty;
            SPECIAL_TYPE_KEY_PREFIX = "_mapId_";
            Map = function() {
                Map._mapIdTracker = 0;
                Map._newMapId = function() {
                    return this._mapIdTracker++;
                };
                function Map(objectToMap) {
                    var key, value;
                    this._content = {};
                    this._itemId = 0;
                    this._id = Map._newMapId();
                    this.size = 0;
                    for (key in objectToMap) {
                        if (!__hasProp.call(objectToMap, key)) continue;
                        value = objectToMap[key];
                        this.set(key, value);
                    }
                }
                Map.prototype.hash = function(key, makeHash) {
                    var propertyForMap, type;
                    if (makeHash == null) {
                        makeHash = false;
                    }
                    type = _extractDataType(key);
                    if (_isSpecialType(key)) {
                        propertyForMap = SPECIAL_TYPE_KEY_PREFIX + this._id;
                        if (makeHash && !key[propertyForMap]) {
                            key[propertyForMap] = this._itemId++;
                        }
                        return propertyForMap + "_" + key[propertyForMap];
                    } else {
                        return type + "_" + key;
                    }
                };
                Map.prototype.set = function(key, value) {
                    if (!this.has(key)) {
                        this.size++;
                    }
                    this._content[this.hash(key, true)] = [ value, key ];
                    return value;
                };
                Map.prototype.get = function(key) {
                    var _ref;
                    return (_ref = this._content[this.hash(key)]) != null ? _ref[0] : void 0;
                };
                Map.prototype.has = function(key) {
                    return this.hash(key) in this._content;
                };
                Map.prototype["delete"] = function(key) {
                    var hashedKey;
                    hashedKey = this.hash(key);
                    if (hashedKey in this._content) {
                        delete this._content[hashedKey];
                        if (_isSpecialType(key)) {
                            delete key[SPECIAL_TYPE_KEY_PREFIX + this._id];
                        }
                        this.size--;
                        return true;
                    }
                    return false;
                };
                Map.prototype.forEach = function(operation) {
                    var key, value, _ref;
                    _ref = this._content;
                    for (key in _ref) {
                        if (!__hasProp.call(_ref, key)) continue;
                        value = _ref[key];
                        operation(value[1], value[0]);
                    }
                };
                return Map;
            }();
            _isSpecialType = function(key) {
                var simpleHashableTypes, simpleType, type, _i, _len;
                simpleHashableTypes = [ "Boolean", "Number", "String", "Undefined", "Null", "RegExp", "Function" ];
                type = _extractDataType(key);
                for (_i = 0, _len = simpleHashableTypes.length; _i < _len; _i++) {
                    simpleType = simpleHashableTypes[_i];
                    if (type === simpleType) {
                        return false;
                    }
                }
                return true;
            };
            _extractDataType = function(type) {
                return Object.prototype.toString.apply(type).match(/\[object (.+)\]/)[1];
            };
            module.exports = Map;
        }).call(this);
    }, function(module, exports) {
        (function() {
            var Queue;
            Queue = function() {
                function Queue(initialArray) {
                    if (initialArray == null) {
                        initialArray = [];
                    }
                    this._content = initialArray;
                    this._dequeueIndex = 0;
                    this.size = this._content.length;
                }
                Queue.prototype.enqueue = function(item) {
                    this.size++;
                    this._content.push(item);
                    return item;
                };
                Queue.prototype.dequeue = function() {
                    var itemToDequeue;
                    if (this.size === 0) {
                        return;
                    }
                    this.size--;
                    itemToDequeue = this._content[this._dequeueIndex];
                    this._dequeueIndex++;
                    if (this._dequeueIndex * 2 > this._content.length) {
                        this._content = this._content.slice(this._dequeueIndex);
                        this._dequeueIndex = 0;
                    }
                    return itemToDequeue;
                };
                Queue.prototype.peek = function() {
                    return this._content[this._dequeueIndex];
                };
                return Queue;
            }();
            module.exports = Queue;
        }).call(this);
    }, function(module, exports) {
        (function() {
            var BLACK, NODE_FOUND, NODE_TOO_BIG, NODE_TOO_SMALL, RED, RedBlackTree, STOP_SEARCHING, _findNode, _grandParentOf, _isLeft, _leftOrRight, _peekMaxNode, _peekMinNode, _siblingOf, _uncleOf;
            NODE_FOUND = 0;
            NODE_TOO_BIG = 1;
            NODE_TOO_SMALL = 2;
            STOP_SEARCHING = 3;
            RED = 1;
            BLACK = 2;
            RedBlackTree = function() {
                function RedBlackTree(valuesToAdd) {
                    var value, _i, _len;
                    if (valuesToAdd == null) {
                        valuesToAdd = [];
                    }
                    this._root;
                    this.size = 0;
                    for (_i = 0, _len = valuesToAdd.length; _i < _len; _i++) {
                        value = valuesToAdd[_i];
                        if (value != null) {
                            this.add(value);
                        }
                    }
                }
                RedBlackTree.prototype.add = function(value) {
                    var currentNode, foundNode, nodeToInsert, _ref;
                    if (value == null) {
                        return;
                    }
                    this.size++;
                    nodeToInsert = {
                        value: value,
                        _color: RED
                    };
                    if (!this._root) {
                        this._root = nodeToInsert;
                    } else {
                        foundNode = _findNode(this._root, function(node) {
                            if (value === node.value) {
                                return NODE_FOUND;
                            } else {
                                if (value < node.value) {
                                    if (node._left) {
                                        return NODE_TOO_BIG;
                                    } else {
                                        nodeToInsert._parent = node;
                                        node._left = nodeToInsert;
                                        return STOP_SEARCHING;
                                    }
                                } else {
                                    if (node._right) {
                                        return NODE_TOO_SMALL;
                                    } else {
                                        nodeToInsert._parent = node;
                                        node._right = nodeToInsert;
                                        return STOP_SEARCHING;
                                    }
                                }
                            }
                        });
                        if (foundNode != null) {
                            return;
                        }
                    }
                    currentNode = nodeToInsert;
                    while (true) {
                        if (currentNode === this._root) {
                            currentNode._color = BLACK;
                            break;
                        }
                        if (currentNode._parent._color === BLACK) {
                            break;
                        }
                        if (((_ref = _uncleOf(currentNode)) != null ? _ref._color : void 0) === RED) {
                            currentNode._parent._color = BLACK;
                            _uncleOf(currentNode)._color = BLACK;
                            _grandParentOf(currentNode)._color = RED;
                            currentNode = _grandParentOf(currentNode);
                            continue;
                        }
                        if (!_isLeft(currentNode) && _isLeft(currentNode._parent)) {
                            this._rotateLeft(currentNode._parent);
                            currentNode = currentNode._left;
                        } else if (_isLeft(currentNode) && !_isLeft(currentNode._parent)) {
                            this._rotateRight(currentNode._parent);
                            currentNode = currentNode._right;
                        }
                        currentNode._parent._color = BLACK;
                        _grandParentOf(currentNode)._color = RED;
                        if (_isLeft(currentNode)) {
                            this._rotateRight(_grandParentOf(currentNode));
                        } else {
                            this._rotateLeft(_grandParentOf(currentNode));
                        }
                        break;
                    }
                    return value;
                };
                RedBlackTree.prototype.has = function(value) {
                    var foundNode;
                    foundNode = _findNode(this._root, function(node) {
                        if (value === node.value) {
                            return NODE_FOUND;
                        } else if (value < node.value) {
                            return NODE_TOO_BIG;
                        } else {
                            return NODE_TOO_SMALL;
                        }
                    });
                    if (foundNode) {
                        return true;
                    } else {
                        return false;
                    }
                };
                RedBlackTree.prototype.peekMin = function() {
                    var _ref;
                    return (_ref = _peekMinNode(this._root)) != null ? _ref.value : void 0;
                };
                RedBlackTree.prototype.peekMax = function() {
                    var _ref;
                    return (_ref = _peekMaxNode(this._root)) != null ? _ref.value : void 0;
                };
                RedBlackTree.prototype.remove = function(value) {
                    var foundNode;
                    foundNode = _findNode(this._root, function(node) {
                        if (value === node.value) {
                            return NODE_FOUND;
                        } else if (value < node.value) {
                            return NODE_TOO_BIG;
                        } else {
                            return NODE_TOO_SMALL;
                        }
                    });
                    if (!foundNode) {
                        return;
                    }
                    this._removeNode(this._root, foundNode);
                    this.size--;
                    return value;
                };
                RedBlackTree.prototype.removeMin = function() {
                    var nodeToRemove, valueToReturn;
                    nodeToRemove = _peekMinNode(this._root);
                    if (!nodeToRemove) {
                        return;
                    }
                    valueToReturn = nodeToRemove.value;
                    this._removeNode(this._root, nodeToRemove);
                    return valueToReturn;
                };
                RedBlackTree.prototype.removeMax = function() {
                    var nodeToRemove, valueToReturn;
                    nodeToRemove = _peekMaxNode(this._root);
                    if (!nodeToRemove) {
                        return;
                    }
                    valueToReturn = nodeToRemove.value;
                    this._removeNode(this._root, nodeToRemove);
                    return valueToReturn;
                };
                RedBlackTree.prototype._removeNode = function(root, node) {
                    var sibling, successor, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
                    if (node._left && node._right) {
                        successor = _peekMinNode(node._right);
                        node.value = successor.value;
                        node = successor;
                    }
                    successor = node._left || node._right;
                    if (!successor) {
                        successor = {
                            color: BLACK,
                            _right: void 0,
                            _left: void 0,
                            isLeaf: true
                        };
                    }
                    successor._parent = node._parent;
                    if ((_ref = node._parent) != null) {
                        _ref[_leftOrRight(node)] = successor;
                    }
                    if (node._color === BLACK) {
                        if (successor._color === RED) {
                            successor._color = BLACK;
                            if (!successor._parent) {
                                this._root = successor;
                            }
                        } else {
                            while (true) {
                                if (!successor._parent) {
                                    if (!successor.isLeaf) {
                                        this._root = successor;
                                    } else {
                                        this._root = void 0;
                                    }
                                    break;
                                }
                                sibling = _siblingOf(successor);
                                if ((sibling != null ? sibling._color : void 0) === RED) {
                                    successor._parent._color = RED;
                                    sibling._color = BLACK;
                                    if (_isLeft(successor)) {
                                        this._rotateLeft(successor._parent);
                                    } else {
                                        this._rotateRight(successor._parent);
                                    }
                                }
                                sibling = _siblingOf(successor);
                                if (successor._parent._color === BLACK && (!sibling || sibling._color === BLACK && (!sibling._left || sibling._left._color === BLACK) && (!sibling._right || sibling._right._color === BLACK))) {
                                    if (sibling != null) {
                                        sibling._color = RED;
                                    }
                                    if (successor.isLeaf) {
                                        successor._parent[_leftOrRight(successor)] = void 0;
                                    }
                                    successor = successor._parent;
                                    continue;
                                }
                                if (successor._parent._color === RED && (!sibling || sibling._color === BLACK && (!sibling._left || ((_ref1 = sibling._left) != null ? _ref1._color : void 0) === BLACK) && (!sibling._right || ((_ref2 = sibling._right) != null ? _ref2._color : void 0) === BLACK))) {
                                    if (sibling != null) {
                                        sibling._color = RED;
                                    }
                                    successor._parent._color = BLACK;
                                    break;
                                }
                                if ((sibling != null ? sibling._color : void 0) === BLACK) {
                                    if (_isLeft(successor) && (!sibling._right || sibling._right._color === BLACK) && ((_ref3 = sibling._left) != null ? _ref3._color : void 0) === RED) {
                                        sibling._color = RED;
                                        if ((_ref4 = sibling._left) != null) {
                                            _ref4._color = BLACK;
                                        }
                                        this._rotateRight(sibling);
                                    } else if (!_isLeft(successor) && (!sibling._left || sibling._left._color === BLACK) && ((_ref5 = sibling._right) != null ? _ref5._color : void 0) === RED) {
                                        sibling._color = RED;
                                        if ((_ref6 = sibling._right) != null) {
                                            _ref6._color = BLACK;
                                        }
                                        this._rotateLeft(sibling);
                                    }
                                    break;
                                }
                                sibling = _siblingOf(successor);
                                sibling._color = successor._parent._color;
                                if (_isLeft(successor)) {
                                    sibling._right._color = BLACK;
                                    this._rotateRight(successor._parent);
                                } else {
                                    sibling._left._color = BLACK;
                                    this._rotateLeft(successor._parent);
                                }
                            }
                        }
                    }
                    if (successor.isLeaf) {
                        return (_ref7 = successor._parent) != null ? _ref7[_leftOrRight(successor)] = void 0 : void 0;
                    }
                };
                RedBlackTree.prototype._rotateLeft = function(node) {
                    var _ref, _ref1;
                    if ((_ref = node._parent) != null) {
                        _ref[_leftOrRight(node)] = node._right;
                    }
                    node._right._parent = node._parent;
                    node._parent = node._right;
                    node._right = node._right._left;
                    node._parent._left = node;
                    if ((_ref1 = node._right) != null) {
                        _ref1._parent = node;
                    }
                    if (node._parent._parent == null) {
                        return this._root = node._parent;
                    }
                };
                RedBlackTree.prototype._rotateRight = function(node) {
                    var _ref, _ref1;
                    if ((_ref = node._parent) != null) {
                        _ref[_leftOrRight(node)] = node._left;
                    }
                    node._left._parent = node._parent;
                    node._parent = node._left;
                    node._left = node._left._right;
                    node._parent._right = node;
                    if ((_ref1 = node._left) != null) {
                        _ref1._parent = node;
                    }
                    if (node._parent._parent == null) {
                        return this._root = node._parent;
                    }
                };
                return RedBlackTree;
            }();
            _isLeft = function(node) {
                return node === node._parent._left;
            };
            _leftOrRight = function(node) {
                if (_isLeft(node)) {
                    return "_left";
                } else {
                    return "_right";
                }
            };
            _findNode = function(startingNode, comparator) {
                var comparisonResult, currentNode, foundNode;
                currentNode = startingNode;
                foundNode = void 0;
                while (currentNode) {
                    comparisonResult = comparator(currentNode);
                    if (comparisonResult === NODE_FOUND) {
                        foundNode = currentNode;
                        break;
                    }
                    if (comparisonResult === NODE_TOO_BIG) {
                        currentNode = currentNode._left;
                    } else if (comparisonResult === NODE_TOO_SMALL) {
                        currentNode = currentNode._right;
                    } else if (comparisonResult === STOP_SEARCHING) {
                        break;
                    }
                }
                return foundNode;
            };
            _peekMinNode = function(startingNode) {
                return _findNode(startingNode, function(node) {
                    if (node._left) {
                        return NODE_TOO_BIG;
                    } else {
                        return NODE_FOUND;
                    }
                });
            };
            _peekMaxNode = function(startingNode) {
                return _findNode(startingNode, function(node) {
                    if (node._right) {
                        return NODE_TOO_SMALL;
                    } else {
                        return NODE_FOUND;
                    }
                });
            };
            _grandParentOf = function(node) {
                var _ref;
                return (_ref = node._parent) != null ? _ref._parent : void 0;
            };
            _uncleOf = function(node) {
                if (!_grandParentOf(node)) {
                    return;
                }
                if (_isLeft(node._parent)) {
                    return _grandParentOf(node)._right;
                } else {
                    return _grandParentOf(node)._left;
                }
            };
            _siblingOf = function(node) {
                if (_isLeft(node)) {
                    return node._parent._right;
                } else {
                    return node._parent._left;
                }
            };
            module.exports = RedBlackTree;
        }).call(this);
    }, function(module, exports, __webpack_require__) {
        (function() {
            var Queue, Trie, WORD_END, _hasAtLeastNChildren, __hasProp = {}.hasOwnProperty;
            Queue = __webpack_require__(6);
            WORD_END = "end";
            Trie = function() {
                function Trie(words) {
                    var word, _i, _len;
                    if (words == null) {
                        words = [];
                    }
                    this._root = {};
                    this.size = 0;
                    for (_i = 0, _len = words.length; _i < _len; _i++) {
                        word = words[_i];
                        this.add(word);
                    }
                }
                Trie.prototype.add = function(word) {
                    var currentNode, letter, _i, _len;
                    if (word == null) {
                        return;
                    }
                    this.size++;
                    currentNode = this._root;
                    for (_i = 0, _len = word.length; _i < _len; _i++) {
                        letter = word[_i];
                        if (currentNode[letter] == null) {
                            currentNode[letter] = {};
                        }
                        currentNode = currentNode[letter];
                    }
                    currentNode[WORD_END] = true;
                    return word;
                };
                Trie.prototype.has = function(word) {
                    var currentNode, letter, _i, _len;
                    if (word == null) {
                        return false;
                    }
                    currentNode = this._root;
                    for (_i = 0, _len = word.length; _i < _len; _i++) {
                        letter = word[_i];
                        if (currentNode[letter] == null) {
                            return false;
                        }
                        currentNode = currentNode[letter];
                    }
                    if (currentNode[WORD_END]) {
                        return true;
                    } else {
                        return false;
                    }
                };
                Trie.prototype.longestPrefixOf = function(word) {
                    var currentNode, letter, prefix, _i, _len;
                    if (word == null) {
                        return "";
                    }
                    currentNode = this._root;
                    prefix = "";
                    for (_i = 0, _len = word.length; _i < _len; _i++) {
                        letter = word[_i];
                        if (currentNode[letter] == null) {
                            break;
                        }
                        prefix += letter;
                        currentNode = currentNode[letter];
                    }
                    return prefix;
                };
                Trie.prototype.wordsWithPrefix = function(prefix) {
                    var accumulatedLetters, currentNode, letter, node, queue, subNode, words, _i, _len, _ref;
                    if (prefix == null) {
                        return [];
                    }
                    prefix != null || (prefix = "");
                    words = [];
                    currentNode = this._root;
                    for (_i = 0, _len = prefix.length; _i < _len; _i++) {
                        letter = prefix[_i];
                        currentNode = currentNode[letter];
                        if (currentNode == null) {
                            return [];
                        }
                    }
                    queue = new Queue();
                    queue.enqueue([ currentNode, "" ]);
                    while (queue.size !== 0) {
                        _ref = queue.dequeue(), node = _ref[0], accumulatedLetters = _ref[1];
                        if (node[WORD_END]) {
                            words.push(prefix + accumulatedLetters);
                        }
                        for (letter in node) {
                            if (!__hasProp.call(node, letter)) continue;
                            subNode = node[letter];
                            queue.enqueue([ subNode, accumulatedLetters + letter ]);
                        }
                    }
                    return words;
                };
                Trie.prototype.remove = function(word) {
                    var currentNode, i, letter, prefix, _i, _j, _len, _ref;
                    if (word == null) {
                        return;
                    }
                    currentNode = this._root;
                    prefix = [];
                    for (_i = 0, _len = word.length; _i < _len; _i++) {
                        letter = word[_i];
                        if (currentNode[letter] == null) {
                            return;
                        }
                        currentNode = currentNode[letter];
                        prefix.push([ letter, currentNode ]);
                    }
                    if (!currentNode[WORD_END]) {
                        return;
                    }
                    this.size--;
                    delete currentNode[WORD_END];
                    if (_hasAtLeastNChildren(currentNode, 1)) {
                        return word;
                    }
                    for (i = _j = _ref = prefix.length - 1; _ref <= 1 ? _j <= 1 : _j >= 1; i = _ref <= 1 ? ++_j : --_j) {
                        if (!_hasAtLeastNChildren(prefix[i][1], 1)) {
                            delete prefix[i - 1][1][prefix[i][0]];
                        } else {
                            break;
                        }
                    }
                    if (!_hasAtLeastNChildren(this._root[prefix[0][0]], 1)) {
                        delete this._root[prefix[0][0]];
                    }
                    return word;
                };
                return Trie;
            }();
            _hasAtLeastNChildren = function(node, n) {
                var child, childCount;
                if (n === 0) {
                    return true;
                }
                childCount = 0;
                for (child in node) {
                    if (!__hasProp.call(node, child)) continue;
                    childCount++;
                    if (childCount >= n) {
                        return true;
                    }
                }
                return false;
            };
            module.exports = Trie;
        }).call(this);
    } ]);
    angular.module("uiGmapgoogle-maps.wrapped").service("uiGmapMarkerSpiderfier", [ "uiGmapGoogleMapApi", function(GoogleMapApi) {
        var self = this;
        var hasProp = {}.hasOwnProperty, slice = [].slice;
        this["OverlappingMarkerSpiderfier"] = function() {
            var ge, gm, j, lcH, lcU, len, mt, p, ref, twoPi, x;
            p = _Class.prototype;
            ref = [ _Class, p ];
            for (j = 0, len = ref.length; j < len; j++) {
                x = ref[j];
                x["VERSION"] = "0.3.3";
            }
            gm = void 0;
            ge = void 0;
            mt = void 0;
            twoPi = Math.PI * 2;
            p["keepSpiderfied"] = false;
            p["markersWontHide"] = false;
            p["markersWontMove"] = false;
            p["nearbyDistance"] = 20;
            p["circleSpiralSwitchover"] = 9;
            p["circleFootSeparation"] = 23;
            p["circleStartAngle"] = twoPi / 12;
            p["spiralFootSeparation"] = 26;
            p["spiralLengthStart"] = 11;
            p["spiralLengthFactor"] = 4;
            p["spiderfiedZIndex"] = 1e3;
            p["usualLegZIndex"] = 10;
            p["highlightedLegZIndex"] = 20;
            p["event"] = "click";
            p["minZoomLevel"] = false;
            p["legWeight"] = 1.5;
            p["legColors"] = {
                usual: {},
                highlighted: {}
            };
            lcU = p["legColors"]["usual"];
            lcH = p["legColors"]["highlighted"];
            _Class["initializeGoogleMaps"] = function(google) {
                gm = google.maps;
                ge = gm.event;
                mt = gm.MapTypeId;
                lcU[mt.HYBRID] = lcU[mt.SATELLITE] = "#fff";
                lcH[mt.HYBRID] = lcH[mt.SATELLITE] = "#f00";
                lcU[mt.TERRAIN] = lcU[mt.ROADMAP] = "#444";
                lcH[mt.TERRAIN] = lcH[mt.ROADMAP] = "#f00";
                this.ProjHelper = function(map) {
                    return this.setMap(map);
                };
                this.ProjHelper.prototype = new gm.OverlayView();
                return this.ProjHelper.prototype["draw"] = function() {};
            };
            function _Class(map1, opts) {
                var e, k, l, len1, ref1, v;
                this.map = map1;
                if (opts == null) {
                    opts = {};
                }
                for (k in opts) {
                    if (!hasProp.call(opts, k)) continue;
                    v = opts[k];
                    this[k] = v;
                }
                this.projHelper = new this.constructor.ProjHelper(this.map);
                this.initMarkerArrays();
                this.listeners = {};
                ref1 = [ "click", "zoom_changed", "maptypeid_changed" ];
                for (l = 0, len1 = ref1.length; l < len1; l++) {
                    e = ref1[l];
                    ge.addListener(this.map, e, function(_this) {
                        return function() {
                            return _this["unspiderfy"]();
                        };
                    }(this));
                }
            }
            p.initMarkerArrays = function() {
                this.markers = [];
                return this.markerListenerRefs = [];
            };
            p["addMarker"] = function(marker) {
                var listenerRefs;
                if (marker["_oms"] != null) {
                    return this;
                }
                marker["_oms"] = true;
                listenerRefs = [ ge.addListener(marker, this["event"], function(_this) {
                    return function(event) {
                        return _this.spiderListener(marker, event);
                    };
                }(this)) ];
                if (!this["markersWontHide"]) {
                    listenerRefs.push(ge.addListener(marker, "visible_changed", function(_this) {
                        return function() {
                            return _this.markerChangeListener(marker, false);
                        };
                    }(this)));
                }
                if (!this["markersWontMove"]) {
                    listenerRefs.push(ge.addListener(marker, "position_changed", function(_this) {
                        return function() {
                            return _this.markerChangeListener(marker, true);
                        };
                    }(this)));
                }
                this.markerListenerRefs.push(listenerRefs);
                this.markers.push(marker);
                return this;
            };
            p.markerChangeListener = function(marker, positionChanged) {
                if (marker["_omsData"] != null && (positionChanged || !marker.getVisible()) && !(this.spiderfying != null || this.unspiderfying != null)) {
                    return this["unspiderfy"](positionChanged ? marker : null);
                }
            };
            p["getMarkers"] = function() {
                return this.markers.slice(0);
            };
            p["removeMarker"] = function(marker) {
                var i, l, len1, listenerRef, listenerRefs;
                if (marker["_omsData"] != null) {
                    this["unspiderfy"]();
                }
                i = this.arrIndexOf(this.markers, marker);
                if (i < 0) {
                    return this;
                }
                listenerRefs = this.markerListenerRefs.splice(i, 1)[0];
                for (l = 0, len1 = listenerRefs.length; l < len1; l++) {
                    listenerRef = listenerRefs[l];
                    ge.removeListener(listenerRef);
                }
                delete marker["_oms"];
                this.markers.splice(i, 1);
                return this;
            };
            p["clearMarkers"] = function() {
                var i, l, len1, len2, listenerRef, listenerRefs, marker, n, ref1;
                this["unspiderfy"]();
                ref1 = this.markers;
                for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
                    marker = ref1[i];
                    listenerRefs = this.markerListenerRefs[i];
                    for (n = 0, len2 = listenerRefs.length; n < len2; n++) {
                        listenerRef = listenerRefs[n];
                        ge.removeListener(listenerRef);
                    }
                    delete marker["_oms"];
                }
                this.initMarkerArrays();
                return this;
            };
            p["addListener"] = function(event, func) {
                var base;
                ((base = this.listeners)[event] != null ? base[event] : base[event] = []).push(func);
                return this;
            };
            p["removeListener"] = function(event, func) {
                var i;
                i = this.arrIndexOf(this.listeners[event], func);
                if (!(i < 0)) {
                    this.listeners[event].splice(i, 1);
                }
                return this;
            };
            p["clearListeners"] = function(event) {
                this.listeners[event] = [];
                return this;
            };
            p.trigger = function() {
                var args, event, func, l, len1, ref1, ref2, results;
                event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
                ref2 = (ref1 = this.listeners[event]) != null ? ref1 : [];
                results = [];
                for (l = 0, len1 = ref2.length; l < len1; l++) {
                    func = ref2[l];
                    results.push(func.apply(null, args));
                }
                return results;
            };
            p.generatePtsCircle = function(count, centerPt) {
                var angle, angleStep, circumference, i, l, legLength, ref1, results;
                circumference = this["circleFootSeparation"] * (2 + count);
                legLength = circumference / twoPi;
                angleStep = twoPi / count;
                results = [];
                for (i = l = 0, ref1 = count; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
                    angle = this["circleStartAngle"] + i * angleStep;
                    results.push(new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle)));
                }
                return results;
            };
            p.generatePtsSpiral = function(count, centerPt) {
                var angle, i, l, legLength, pt, ref1, results;
                legLength = this["spiralLengthStart"];
                angle = 0;
                results = [];
                for (i = l = 0, ref1 = count; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
                    angle += this["spiralFootSeparation"] / legLength + i * 5e-4;
                    pt = new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle));
                    legLength += twoPi * this["spiralLengthFactor"] / angle;
                    results.push(pt);
                }
                return results;
            };
            p.spiderListener = function(marker, event) {
                var $this, clear, l, len1, m, mPt, markerPt, markerSpiderfied, nDist, nearbyMarkerData, nonNearbyMarkers, pxSq, ref1;
                markerSpiderfied = marker["_omsData"] != null;
                if (!(markerSpiderfied && this["keepSpiderfied"])) {
                    if (this["event"] === "mouseover") {
                        $this = this;
                        clear = function() {
                            return $this["unspiderfy"]();
                        };
                        window.clearTimeout(p.timeout);
                        p.timeout = setTimeout(clear, 3e3);
                    } else {
                        this["unspiderfy"]();
                    }
                }
                if (markerSpiderfied || this.map.getStreetView().getVisible() || this.map.getMapTypeId() === "GoogleEarthAPI") {
                    return this.trigger("click", marker, event);
                } else {
                    nearbyMarkerData = [];
                    nonNearbyMarkers = [];
                    nDist = this["nearbyDistance"];
                    pxSq = nDist * nDist;
                    markerPt = this.llToPt(marker.position);
                    ref1 = this.markers;
                    for (l = 0, len1 = ref1.length; l < len1; l++) {
                        m = ref1[l];
                        if (!(m.map != null && m.getVisible())) {
                            continue;
                        }
                        mPt = this.llToPt(m.position);
                        if (this.ptDistanceSq(mPt, markerPt) < pxSq) {
                            nearbyMarkerData.push({
                                marker: m,
                                markerPt: mPt
                            });
                        } else {
                            nonNearbyMarkers.push(m);
                        }
                    }
                    if (nearbyMarkerData.length === 1) {
                        return this.trigger("click", marker, event);
                    } else {
                        return this.spiderfy(nearbyMarkerData, nonNearbyMarkers);
                    }
                }
            };
            p["markersNearMarker"] = function(marker, firstOnly) {
                var l, len1, m, mPt, markerPt, markers, nDist, pxSq, ref1, ref2, ref3;
                if (firstOnly == null) {
                    firstOnly = false;
                }
                if (this.projHelper.getProjection() == null) {
                    throw "Must wait for 'idle' event on map before calling markersNearMarker";
                }
                nDist = this["nearbyDistance"];
                pxSq = nDist * nDist;
                markerPt = this.llToPt(marker.position);
                markers = [];
                ref1 = this.markers;
                for (l = 0, len1 = ref1.length; l < len1; l++) {
                    m = ref1[l];
                    if (m === marker || m.map == null || !m.getVisible()) {
                        continue;
                    }
                    mPt = this.llToPt((ref2 = (ref3 = m["_omsData"]) != null ? ref3.usualPosition : void 0) != null ? ref2 : m.position);
                    if (this.ptDistanceSq(mPt, markerPt) < pxSq) {
                        markers.push(m);
                        if (firstOnly) {
                            break;
                        }
                    }
                }
                return markers;
            };
            p["markersNearAnyOtherMarker"] = function() {
                var i, i1, i2, l, len1, len2, len3, m, m1, m1Data, m2, m2Data, mData, n, nDist, pxSq, q, ref1, ref2, ref3, results;
                if (this.projHelper.getProjection() == null) {
                    throw "Must wait for 'idle' event on map before calling markersNearAnyOtherMarker";
                }
                nDist = this["nearbyDistance"];
                pxSq = nDist * nDist;
                mData = function() {
                    var l, len1, ref1, ref2, ref3, results;
                    ref1 = this.markers;
                    results = [];
                    for (l = 0, len1 = ref1.length; l < len1; l++) {
                        m = ref1[l];
                        results.push({
                            pt: this.llToPt((ref2 = (ref3 = m["_omsData"]) != null ? ref3.usualPosition : void 0) != null ? ref2 : m.position),
                            willSpiderfy: false
                        });
                    }
                    return results;
                }.call(this);
                ref1 = this.markers;
                for (i1 = l = 0, len1 = ref1.length; l < len1; i1 = ++l) {
                    m1 = ref1[i1];
                    if (!(m1.map != null && m1.getVisible())) {
                        continue;
                    }
                    m1Data = mData[i1];
                    if (m1Data.willSpiderfy) {
                        continue;
                    }
                    ref2 = this.markers;
                    for (i2 = n = 0, len2 = ref2.length; n < len2; i2 = ++n) {
                        m2 = ref2[i2];
                        if (i2 === i1) {
                            continue;
                        }
                        if (!(m2.map != null && m2.getVisible())) {
                            continue;
                        }
                        m2Data = mData[i2];
                        if (i2 < i1 && !m2Data.willSpiderfy) {
                            continue;
                        }
                        if (this.ptDistanceSq(m1Data.pt, m2Data.pt) < pxSq) {
                            m1Data.willSpiderfy = m2Data.willSpiderfy = true;
                            break;
                        }
                    }
                }
                ref3 = this.markers;
                results = [];
                for (i = q = 0, len3 = ref3.length; q < len3; i = ++q) {
                    m = ref3[i];
                    if (mData[i].willSpiderfy) {
                        results.push(m);
                    }
                }
                return results;
            };
            p.makeHighlightListenerFuncs = function(marker) {
                return {
                    highlight: function(_this) {
                        return function() {
                            return marker["_omsData"].leg.setOptions({
                                strokeColor: _this["legColors"]["highlighted"][_this.map.mapTypeId],
                                zIndex: _this["highlightedLegZIndex"]
                            });
                        };
                    }(this),
                    unhighlight: function(_this) {
                        return function() {
                            return marker["_omsData"].leg.setOptions({
                                strokeColor: _this["legColors"]["usual"][_this.map.mapTypeId],
                                zIndex: _this["usualLegZIndex"]
                            });
                        };
                    }(this)
                };
            };
            p.spiderfy = function(markerData, nonNearbyMarkers) {
                var bodyPt, footLl, footPt, footPts, highlightListenerFuncs, leg, marker, md, nearestMarkerDatum, numFeet, spiderfiedMarkers;
                if (this["minZoomLevel"] && this.map.getZoom() < this["minZoomLevel"]) {
                    return false;
                }
                this.spiderfying = true;
                numFeet = markerData.length;
                bodyPt = this.ptAverage(function() {
                    var l, len1, results;
                    results = [];
                    for (l = 0, len1 = markerData.length; l < len1; l++) {
                        md = markerData[l];
                        results.push(md.markerPt);
                    }
                    return results;
                }());
                footPts = numFeet >= this["circleSpiralSwitchover"] ? this.generatePtsSpiral(numFeet, bodyPt).reverse() : this.generatePtsCircle(numFeet, bodyPt);
                spiderfiedMarkers = function() {
                    var l, len1, results;
                    results = [];
                    for (l = 0, len1 = footPts.length; l < len1; l++) {
                        footPt = footPts[l];
                        footLl = this.ptToLl(footPt);
                        nearestMarkerDatum = this.minExtract(markerData, function(_this) {
                            return function(md) {
                                return _this.ptDistanceSq(md.markerPt, footPt);
                            };
                        }(this));
                        marker = nearestMarkerDatum.marker;
                        leg = new gm.Polyline({
                            map: this.map,
                            path: [ marker.position, footLl ],
                            strokeColor: this["legColors"]["usual"][this.map.mapTypeId],
                            strokeWeight: this["legWeight"],
                            zIndex: this["usualLegZIndex"]
                        });
                        marker["_omsData"] = {
                            usualPosition: marker.position,
                            leg: leg
                        };
                        if (this["legColors"]["highlighted"][this.map.mapTypeId] !== this["legColors"]["usual"][this.map.mapTypeId]) {
                            highlightListenerFuncs = this.makeHighlightListenerFuncs(marker);
                            marker["_omsData"].hightlightListeners = {
                                highlight: ge.addListener(marker, "mouseover", highlightListenerFuncs.highlight),
                                unhighlight: ge.addListener(marker, "mouseout", highlightListenerFuncs.unhighlight)
                            };
                        }
                        marker.setPosition(footLl);
                        marker.setZIndex(Math.round(this["spiderfiedZIndex"] + footPt.y));
                        results.push(marker);
                    }
                    return results;
                }.call(this);
                delete this.spiderfying;
                this.spiderfied = true;
                return this.trigger("spiderfy", spiderfiedMarkers, nonNearbyMarkers);
            };
            p["unspiderfy"] = function(markerNotToMove) {
                var l, len1, listeners, marker, nonNearbyMarkers, ref1, unspiderfiedMarkers;
                if (markerNotToMove == null) {
                    markerNotToMove = null;
                }
                if (this.spiderfied == null) {
                    return this;
                }
                this.unspiderfying = true;
                unspiderfiedMarkers = [];
                nonNearbyMarkers = [];
                ref1 = this.markers;
                for (l = 0, len1 = ref1.length; l < len1; l++) {
                    marker = ref1[l];
                    if (marker["_omsData"] != null) {
                        marker["_omsData"].leg.setMap(null);
                        if (marker !== markerNotToMove) {
                            marker.setPosition(marker["_omsData"].usualPosition);
                        }
                        marker.setZIndex(null);
                        listeners = marker["_omsData"].hightlightListeners;
                        if (listeners != null) {
                            ge.removeListener(listeners.highlight);
                            ge.removeListener(listeners.unhighlight);
                        }
                        delete marker["_omsData"];
                        unspiderfiedMarkers.push(marker);
                    } else {
                        nonNearbyMarkers.push(marker);
                    }
                }
                delete this.unspiderfying;
                delete this.spiderfied;
                this.trigger("unspiderfy", unspiderfiedMarkers, nonNearbyMarkers);
                return this;
            };
            p.ptDistanceSq = function(pt1, pt2) {
                var dx, dy;
                dx = pt1.x - pt2.x;
                dy = pt1.y - pt2.y;
                return dx * dx + dy * dy;
            };
            p.ptAverage = function(pts) {
                var l, len1, numPts, pt, sumX, sumY;
                sumX = sumY = 0;
                for (l = 0, len1 = pts.length; l < len1; l++) {
                    pt = pts[l];
                    sumX += pt.x;
                    sumY += pt.y;
                }
                numPts = pts.length;
                return new gm.Point(sumX / numPts, sumY / numPts);
            };
            p.llToPt = function(ll) {
                return this.projHelper.getProjection().fromLatLngToDivPixel(ll);
            };
            p.ptToLl = function(pt) {
                return this.projHelper.getProjection().fromDivPixelToLatLng(pt);
            };
            p.minExtract = function(set, func) {
                var bestIndex, bestVal, index, item, l, len1, val;
                for (index = l = 0, len1 = set.length; l < len1; index = ++l) {
                    item = set[index];
                    val = func(item);
                    if (typeof bestIndex === "undefined" || bestIndex === null || val < bestVal) {
                        bestVal = val;
                        bestIndex = index;
                    }
                }
                return set.splice(bestIndex, 1)[0];
            };
            p.arrIndexOf = function(arr, obj) {
                var i, l, len1, o;
                if (arr.indexOf != null) {
                    return arr.indexOf(obj);
                }
                for (i = l = 0, len1 = arr.length; l < len1; i = ++l) {
                    o = arr[i];
                    if (o === obj) {
                        return i;
                    }
                }
                return -1;
            };
            return _Class;
        }();
        GoogleMapApi.then(function() {
            self.OverlappingMarkerSpiderfier.initializeGoogleMaps(window.google);
        });
        return this.OverlappingMarkerSpiderfier;
    } ]);
    angular.module("uiGmapgoogle-maps.extensions").service("uiGmapExtendMarkerClusterer", [ "uiGmapLodash", "uiGmapPropMap", function(uiGmapLodash, PropMap) {
        return {
            init: _.once(function() {
                (function() {
                    var __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
                        for (var key in parent) {
                            if (__hasProp.call(parent, key)) child[key] = parent[key];
                        }
                        function ctor() {
                            this.constructor = child;
                        }
                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    };
                    window.NgMapCluster = function(_super) {
                        __extends(NgMapCluster, _super);
                        function NgMapCluster(opts) {
                            NgMapCluster.__super__.constructor.call(this, opts);
                            this.markers_ = new PropMap();
                        }
                        NgMapCluster.prototype.addMarker = function(marker) {
                            var i;
                            var mCount;
                            var mz;
                            if (this.isMarkerAlreadyAdded_(marker)) {
                                var oldMarker = this.markers_.get(marker.key);
                                if (oldMarker.getPosition().lat() == marker.getPosition().lat() && oldMarker.getPosition().lon() == marker.getPosition().lon()) return false;
                            }
                            if (!this.center_) {
                                this.center_ = marker.getPosition();
                                this.calculateBounds_();
                            } else {
                                if (this.averageCenter_) {
                                    var l = this.markers_.length + 1;
                                    var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;
                                    var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
                                    this.center_ = new google.maps.LatLng(lat, lng);
                                    this.calculateBounds_();
                                }
                            }
                            marker.isAdded = true;
                            this.markers_.push(marker);
                            mCount = this.markers_.length;
                            mz = this.markerClusterer_.getMaxZoom();
                            if (mz !== null && this.map_.getZoom() > mz) {
                                if (marker.getMap() !== this.map_) {
                                    marker.setMap(this.map_);
                                }
                            } else if (mCount < this.minClusterSize_) {
                                if (marker.getMap() !== this.map_) {
                                    marker.setMap(this.map_);
                                }
                            } else if (mCount === this.minClusterSize_) {
                                this.markers_.each(function(m) {
                                    m.setMap(null);
                                });
                            } else {
                                marker.setMap(null);
                            }
                            return true;
                        };
                        NgMapCluster.prototype.isMarkerAlreadyAdded_ = function(marker) {
                            return uiGmapLodash.isNullOrUndefined(this.markers_.get(marker.key));
                        };
                        NgMapCluster.prototype.getBounds = function() {
                            var i;
                            var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
                            this.getMarkers().each(function(m) {
                                bounds.extend(m.getPosition());
                            });
                            return bounds;
                        };
                        NgMapCluster.prototype.remove = function() {
                            this.clusterIcon_.setMap(null);
                            this.markers_ = new PropMap();
                            delete this.markers_;
                        };
                        return NgMapCluster;
                    }(Cluster);
                    window.NgMapMarkerClusterer = function(_super) {
                        __extends(NgMapMarkerClusterer, _super);
                        function NgMapMarkerClusterer(map, opt_markers, opt_options) {
                            NgMapMarkerClusterer.__super__.constructor.call(this, map, opt_markers, opt_options);
                            this.markers_ = new PropMap();
                        }
                        NgMapMarkerClusterer.prototype.clearMarkers = function() {
                            this.resetViewport_(true);
                            this.markers_ = new PropMap();
                        };
                        NgMapMarkerClusterer.prototype.removeMarker_ = function(marker) {
                            if (!this.markers_.get(marker.key)) {
                                return false;
                            }
                            marker.setMap(null);
                            this.markers_.remove(marker.key);
                            return true;
                        };
                        NgMapMarkerClusterer.prototype.createClusters_ = function(iFirst) {
                            var i, marker;
                            var mapBounds;
                            var cMarkerClusterer = this;
                            if (!this.ready_) {
                                return;
                            }
                            if (iFirst === 0) {
                                google.maps.event.trigger(this, "clusteringbegin", this);
                                if (typeof this.timerRefStatic !== "undefined") {
                                    clearTimeout(this.timerRefStatic);
                                    delete this.timerRefStatic;
                                }
                            }
                            if (this.getMap().getZoom() > 3) {
                                mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast());
                            } else {
                                mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
                            }
                            var bounds = this.getExtendedBounds(mapBounds);
                            var iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);
                            var _ms = this.markers_.values();
                            for (i = iFirst; i < iLast; i++) {
                                marker = _ms[i];
                                if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
                                    if (!this.ignoreHidden_ || this.ignoreHidden_ && marker.getVisible()) {
                                        this.addToClosestCluster_(marker);
                                    }
                                }
                            }
                            if (iLast < this.markers_.length) {
                                this.timerRefStatic = setTimeout(function() {
                                    cMarkerClusterer.createClusters_(iLast);
                                }, 0);
                            } else {
                                for (i = 0; i < this.clusters_.length; i++) {
                                    this.clusters_[i].updateIcon_();
                                }
                                delete this.timerRefStatic;
                                google.maps.event.trigger(this, "clusteringend", this);
                            }
                        };
                        NgMapMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
                            var i, d, cluster, center;
                            var distance = 4e4;
                            var clusterToAddTo = null;
                            for (i = 0; i < this.clusters_.length; i++) {
                                cluster = this.clusters_[i];
                                center = cluster.getCenter();
                                if (center) {
                                    d = this.distanceBetweenPoints_(center, marker.getPosition());
                                    if (d < distance) {
                                        distance = d;
                                        clusterToAddTo = cluster;
                                    }
                                }
                            }
                            if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
                                clusterToAddTo.addMarker(marker);
                            } else {
                                cluster = new NgMapCluster(this);
                                cluster.addMarker(marker);
                                this.clusters_.push(cluster);
                            }
                        };
                        NgMapMarkerClusterer.prototype.redraw_ = function() {
                            this.createClusters_(0);
                        };
                        NgMapMarkerClusterer.prototype.resetViewport_ = function(opt_hide) {
                            var i, marker;
                            for (i = 0; i < this.clusters_.length; i++) {
                                this.clusters_[i].remove();
                            }
                            this.clusters_ = [];
                            this.markers_.each(function(marker) {
                                marker.isAdded = false;
                                if (opt_hide) {
                                    marker.setMap(null);
                                }
                            });
                        };
                        NgMapMarkerClusterer.prototype.extend = function(obj1, obj2) {
                            return function(object) {
                                var property;
                                for (property in object.prototype) {
                                    if (property !== "constructor") this.prototype[property] = object.prototype[property];
                                }
                                return this;
                            }.apply(obj1, [ obj2 ]);
                        };
                        ClusterIcon.prototype.show = function() {
                            if (this.div_) {
                                var img = "";
                                var bp = this.backgroundPosition_.split(" ");
                                var spriteH = parseInt(bp[0].trim(), 10);
                                var spriteV = parseInt(bp[1].trim(), 10);
                                var pos = this.getPosFromLatLng_(this.center_);
                                this.div_.style.cssText = this.createCss(pos);
                                img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ";
                                if (!this.cluster_.getMarkerClusterer().enableRetinaIcons_) {
                                    img += "clip: rect(" + -1 * spriteV + "px, " + (-1 * spriteH + this.width_) + "px, " + (-1 * spriteV + this.height_) + "px, " + -1 * spriteH + "px);";
                                } else {
                                    img += "width: " + this.width_ + "px;" + "height: " + this.height_ + "px;";
                                }
                                img += "'>";
                                this.div_.innerHTML = img + "<div style='" + "position: absolute;" + "top: " + this.anchorText_[0] + "px;" + "left: " + this.anchorText_[1] + "px;" + "color: " + this.textColor_ + ";" + "font-size: " + this.textSize_ + "px;" + "font-family: " + this.fontFamily_ + ";" + "font-weight: " + this.fontWeight_ + ";" + "font-style: " + this.fontStyle_ + ";" + "text-decoration: " + this.textDecoration_ + ";" + "text-align: center;" + "width: " + this.width_ + "px;" + "line-height:" + this.height_ + "px;" + "'>" + this.sums_.text + "</div>";
                                if (typeof this.sums_.title === "undefined" || this.sums_.title === "") {
                                    this.div_.title = this.cluster_.getMarkerClusterer().getTitle();
                                } else {
                                    this.div_.title = this.sums_.title;
                                }
                                this.div_.style.display = "";
                            }
                            this.visible_ = true;
                        };
                        return NgMapMarkerClusterer;
                    }(MarkerClusterer);
                }).call(this);
            })
        };
    } ]);
})(window, angular);

!function() {
    "use strict";
    var e = angular.module("ngImgCrop", []);
    e.factory("cropAreaCircle", [ "cropArea", function(e) {
        var t = function() {
            e.apply(this, arguments), this._boxResizeBaseSize = 20, this._boxResizeNormalRatio = .9, 
            this._boxResizeHoverRatio = 1.2, this._iconMoveNormalRatio = .9, this._iconMoveHoverRatio = 1.2, 
            this._boxResizeNormalSize = this._boxResizeBaseSize * this._boxResizeNormalRatio, 
            this._boxResizeHoverSize = this._boxResizeBaseSize * this._boxResizeHoverRatio, 
            this._posDragStartX = 0, this._posDragStartY = 0, this._posResizeStartX = 0, this._posResizeStartY = 0, 
            this._posResizeStartSize = 0, this._boxResizeIsHover = !1, this._areaIsHover = !1, 
            this._boxResizeIsDragging = !1, this._areaIsDragging = !1;
        };
        return t.prototype = new e(), t.prototype._calcCirclePerimeterCoords = function(e) {
            var t = this._size / 2, i = e * (Math.PI / 180), r = this._x + t * Math.cos(i), s = this._y + t * Math.sin(i);
            return [ r, s ];
        }, t.prototype._calcResizeIconCenterCoords = function() {
            return this._calcCirclePerimeterCoords(-45);
        }, t.prototype._isCoordWithinArea = function(e) {
            return Math.sqrt((e[0] - this._x) * (e[0] - this._x) + (e[1] - this._y) * (e[1] - this._y)) < this._size / 2;
        }, t.prototype._isCoordWithinBoxResize = function(e) {
            var t = this._calcResizeIconCenterCoords(), i = this._boxResizeHoverSize / 2;
            return e[0] > t[0] - i && e[0] < t[0] + i && e[1] > t[1] - i && e[1] < t[1] + i;
        }, t.prototype._drawArea = function(e, t, i) {
            e.arc(t[0], t[1], i / 2, 0, 2 * Math.PI);
        }, t.prototype.draw = function() {
            e.prototype.draw.apply(this, arguments), this._cropCanvas.drawIconMove([ this._x, this._y ], this._areaIsHover ? this._iconMoveHoverRatio : this._iconMoveNormalRatio), 
            this._cropCanvas.drawIconResizeBoxNESW(this._calcResizeIconCenterCoords(), this._boxResizeBaseSize, this._boxResizeIsHover ? this._boxResizeHoverRatio : this._boxResizeNormalRatio);
        }, t.prototype.processMouseMove = function(e, t) {
            var i = "default", r = !1;
            if (this._boxResizeIsHover = !1, this._areaIsHover = !1, this._areaIsDragging) this._x = e - this._posDragStartX, 
            this._y = t - this._posDragStartY, this._areaIsHover = !0, i = "move", r = !0, this._events.trigger("area-move"); else if (this._boxResizeIsDragging) {
                i = "nesw-resize";
                var s, o, a;
                o = e - this._posResizeStartX, a = this._posResizeStartY - t, s = o > a ? this._posResizeStartSize + 2 * a : this._posResizeStartSize + 2 * o, 
                this._size = Math.max(this._minSize, s), this._boxResizeIsHover = !0, r = !0, this._events.trigger("area-resize");
            } else this._isCoordWithinBoxResize([ e, t ]) ? (i = "nesw-resize", this._areaIsHover = !1, 
            this._boxResizeIsHover = !0, r = !0) : this._isCoordWithinArea([ e, t ]) && (i = "move", 
            this._areaIsHover = !0, r = !0);
            return this._dontDragOutside(), angular.element(this._ctx.canvas).css({
                cursor: i
            }), r;
        }, t.prototype.processMouseDown = function(e, t) {
            this._isCoordWithinBoxResize([ e, t ]) ? (this._areaIsDragging = !1, this._areaIsHover = !1, 
            this._boxResizeIsDragging = !0, this._boxResizeIsHover = !0, this._posResizeStartX = e, 
            this._posResizeStartY = t, this._posResizeStartSize = this._size, this._events.trigger("area-resize-start")) : this._isCoordWithinArea([ e, t ]) && (this._areaIsDragging = !0, 
            this._areaIsHover = !0, this._boxResizeIsDragging = !1, this._boxResizeIsHover = !1, 
            this._posDragStartX = e - this._x, this._posDragStartY = t - this._y, this._events.trigger("area-move-start"));
        }, t.prototype.processMouseUp = function() {
            this._areaIsDragging && (this._areaIsDragging = !1, this._events.trigger("area-move-end")), 
            this._boxResizeIsDragging && (this._boxResizeIsDragging = !1, this._events.trigger("area-resize-end")), 
            this._areaIsHover = !1, this._boxResizeIsHover = !1, this._posDragStartX = 0, this._posDragStartY = 0;
        }, t;
    } ]), e.factory("cropAreaSquare", [ "cropArea", function(e) {
        var t = function() {
            e.apply(this, arguments), this._resizeCtrlBaseRadius = 10, this._resizeCtrlNormalRatio = .75, 
            this._resizeCtrlHoverRatio = 1, this._iconMoveNormalRatio = .9, this._iconMoveHoverRatio = 1.2, 
            this._resizeCtrlNormalRadius = this._resizeCtrlBaseRadius * this._resizeCtrlNormalRatio, 
            this._resizeCtrlHoverRadius = this._resizeCtrlBaseRadius * this._resizeCtrlHoverRatio, 
            this._posDragStartX = 0, this._posDragStartY = 0, this._posResizeStartX = 0, this._posResizeStartY = 0, 
            this._posResizeStartSize = 0, this._resizeCtrlIsHover = -1, this._areaIsHover = !1, 
            this._resizeCtrlIsDragging = -1, this._areaIsDragging = !1;
        };
        return t.prototype = new e(), t.prototype._calcSquareCorners = function() {
            var e = this._size / 2;
            return [ [ this._x - e, this._y - e ], [ this._x + e, this._y - e ], [ this._x - e, this._y + e ], [ this._x + e, this._y + e ] ];
        }, t.prototype._calcSquareDimensions = function() {
            var e = this._size / 2;
            return {
                left: this._x - e,
                top: this._y - e,
                right: this._x + e,
                bottom: this._y + e
            };
        }, t.prototype._isCoordWithinArea = function(e) {
            var t = this._calcSquareDimensions();
            return e[0] >= t.left && e[0] <= t.right && e[1] >= t.top && e[1] <= t.bottom;
        }, t.prototype._isCoordWithinResizeCtrl = function(e) {
            for (var t = this._calcSquareCorners(), i = -1, r = 0, s = t.length; s > r; r++) {
                var o = t[r];
                if (e[0] > o[0] - this._resizeCtrlHoverRadius && e[0] < o[0] + this._resizeCtrlHoverRadius && e[1] > o[1] - this._resizeCtrlHoverRadius && e[1] < o[1] + this._resizeCtrlHoverRadius) {
                    i = r;
                    break;
                }
            }
            return i;
        }, t.prototype._drawArea = function(e, t, i) {
            var r = i / 2;
            e.rect(t[0] - r, t[1] - r, i, i);
        }, t.prototype.draw = function() {
            e.prototype.draw.apply(this, arguments), this._cropCanvas.drawIconMove([ this._x, this._y ], this._areaIsHover ? this._iconMoveHoverRatio : this._iconMoveNormalRatio);
            for (var t = this._calcSquareCorners(), i = 0, r = t.length; r > i; i++) {
                var s = t[i];
                this._cropCanvas.drawIconResizeCircle(s, this._resizeCtrlBaseRadius, this._resizeCtrlIsHover === i ? this._resizeCtrlHoverRatio : this._resizeCtrlNormalRatio);
            }
        }, t.prototype.processMouseMove = function(e, t) {
            var i = "default", r = !1;
            if (this._resizeCtrlIsHover = -1, this._areaIsHover = !1, this._areaIsDragging) this._x = e - this._posDragStartX, 
            this._y = t - this._posDragStartY, this._areaIsHover = !0, i = "move", r = !0, this._events.trigger("area-move"); else if (this._resizeCtrlIsDragging > -1) {
                var s, o;
                switch (this._resizeCtrlIsDragging) {
                  case 0:
                    s = -1, o = -1, i = "nwse-resize";
                    break;

                  case 1:
                    s = 1, o = -1, i = "nesw-resize";
                    break;

                  case 2:
                    s = -1, o = 1, i = "nesw-resize";
                    break;

                  case 3:
                    s = 1, o = 1, i = "nwse-resize";
                }
                var a, n = (e - this._posResizeStartX) * s, h = (t - this._posResizeStartY) * o;
                a = n > h ? this._posResizeStartSize + h : this._posResizeStartSize + n;
                var c = this._size;
                this._size = Math.max(this._minSize, a);
                var l = (this._size - c) / 2;
                this._x += l * s, this._y += l * o, this._resizeCtrlIsHover = this._resizeCtrlIsDragging, 
                r = !0, this._events.trigger("area-resize");
            } else {
                var u = this._isCoordWithinResizeCtrl([ e, t ]);
                if (u > -1) {
                    switch (u) {
                      case 0:
                        i = "nwse-resize";
                        break;

                      case 1:
                        i = "nesw-resize";
                        break;

                      case 2:
                        i = "nesw-resize";
                        break;

                      case 3:
                        i = "nwse-resize";
                    }
                    this._areaIsHover = !1, this._resizeCtrlIsHover = u, r = !0;
                } else this._isCoordWithinArea([ e, t ]) && (i = "move", this._areaIsHover = !0, 
                r = !0);
            }
            return this._dontDragOutside(), angular.element(this._ctx.canvas).css({
                cursor: i
            }), r;
        }, t.prototype.processMouseDown = function(e, t) {
            var i = this._isCoordWithinResizeCtrl([ e, t ]);
            i > -1 ? (this._areaIsDragging = !1, this._areaIsHover = !1, this._resizeCtrlIsDragging = i, 
            this._resizeCtrlIsHover = i, this._posResizeStartX = e, this._posResizeStartY = t, 
            this._posResizeStartSize = this._size, this._events.trigger("area-resize-start")) : this._isCoordWithinArea([ e, t ]) && (this._areaIsDragging = !0, 
            this._areaIsHover = !0, this._resizeCtrlIsDragging = -1, this._resizeCtrlIsHover = -1, 
            this._posDragStartX = e - this._x, this._posDragStartY = t - this._y, this._events.trigger("area-move-start"));
        }, t.prototype.processMouseUp = function() {
            this._areaIsDragging && (this._areaIsDragging = !1, this._events.trigger("area-move-end")), 
            this._resizeCtrlIsDragging > -1 && (this._resizeCtrlIsDragging = -1, this._events.trigger("area-resize-end")), 
            this._areaIsHover = !1, this._resizeCtrlIsHover = -1, this._posDragStartX = 0, this._posDragStartY = 0;
        }, t;
    } ]), e.factory("cropArea", [ "cropCanvas", function(e) {
        var t = function(t, i) {
            this._ctx = t, this._events = i, this._minSize = 80, this._cropCanvas = new e(t), 
            this._image = new Image(), this._x = 0, this._y = 0, this._size = 200;
        };
        return t.prototype.getImage = function() {
            return this._image;
        }, t.prototype.setImage = function(e) {
            this._image = e;
        }, t.prototype.getX = function() {
            return this._x;
        }, t.prototype.setX = function(e) {
            this._x = e, this._dontDragOutside();
        }, t.prototype.getY = function() {
            return this._y;
        }, t.prototype.setY = function(e) {
            this._y = e, this._dontDragOutside();
        }, t.prototype.getSize = function() {
            return this._size;
        }, t.prototype.setSize = function(e) {
            this._size = Math.max(this._minSize, e), this._dontDragOutside();
        }, t.prototype.getMinSize = function() {
            return this._minSize;
        }, t.prototype.setMinSize = function(e) {
            this._minSize = e, this._size = Math.max(this._minSize, this._size), this._dontDragOutside();
        }, t.prototype._dontDragOutside = function() {
            var e = this._ctx.canvas.height, t = this._ctx.canvas.width;
            this._size > t && (this._size = t), this._size > e && (this._size = e), this._x < this._size / 2 && (this._x = this._size / 2), 
            this._x > t - this._size / 2 && (this._x = t - this._size / 2), this._y < this._size / 2 && (this._y = this._size / 2), 
            this._y > e - this._size / 2 && (this._y = e - this._size / 2);
        }, t.prototype._drawArea = function() {}, t.prototype.draw = function() {
            this._cropCanvas.drawCropArea(this._image, [ this._x, this._y ], this._size, this._drawArea);
        }, t.prototype.processMouseMove = function() {}, t.prototype.processMouseDown = function() {}, 
        t.prototype.processMouseUp = function() {}, t;
    } ]), e.factory("cropCanvas", [ function() {
        var e = [ [ -.5, -2 ], [ -3, -4.5 ], [ -.5, -7 ], [ -7, -7 ], [ -7, -.5 ], [ -4.5, -3 ], [ -2, -.5 ] ], t = [ [ .5, -2 ], [ 3, -4.5 ], [ .5, -7 ], [ 7, -7 ], [ 7, -.5 ], [ 4.5, -3 ], [ 2, -.5 ] ], i = [ [ -.5, 2 ], [ -3, 4.5 ], [ -.5, 7 ], [ -7, 7 ], [ -7, .5 ], [ -4.5, 3 ], [ -2, .5 ] ], r = [ [ .5, 2 ], [ 3, 4.5 ], [ .5, 7 ], [ 7, 7 ], [ 7, .5 ], [ 4.5, 3 ], [ 2, .5 ] ], s = [ [ -1.5, -2.5 ], [ -1.5, -6 ], [ -5, -6 ], [ 0, -11 ], [ 5, -6 ], [ 1.5, -6 ], [ 1.5, -2.5 ] ], o = [ [ -2.5, -1.5 ], [ -6, -1.5 ], [ -6, -5 ], [ -11, 0 ], [ -6, 5 ], [ -6, 1.5 ], [ -2.5, 1.5 ] ], a = [ [ -1.5, 2.5 ], [ -1.5, 6 ], [ -5, 6 ], [ 0, 11 ], [ 5, 6 ], [ 1.5, 6 ], [ 1.5, 2.5 ] ], n = [ [ 2.5, -1.5 ], [ 6, -1.5 ], [ 6, -5 ], [ 11, 0 ], [ 6, 5 ], [ 6, 1.5 ], [ 2.5, 1.5 ] ], h = {
            areaOutline: "#fff",
            resizeBoxStroke: "#fff",
            resizeBoxFill: "#444",
            resizeBoxArrowFill: "#fff",
            resizeCircleStroke: "#fff",
            resizeCircleFill: "#444",
            moveIconFill: "#fff"
        };
        return function(c) {
            var l = function(e, t, i) {
                return [ i * e[0] + t[0], i * e[1] + t[1] ];
            }, u = function(e, t, i, r) {
                c.save(), c.fillStyle = t, c.beginPath();
                var s, o = l(e[0], i, r);
                c.moveTo(o[0], o[1]);
                for (var a in e) a > 0 && (s = l(e[a], i, r), c.lineTo(s[0], s[1]));
                c.lineTo(o[0], o[1]), c.fill(), c.closePath(), c.restore();
            };
            this.drawIconMove = function(e, t) {
                u(s, h.moveIconFill, e, t), u(o, h.moveIconFill, e, t), u(a, h.moveIconFill, e, t), 
                u(n, h.moveIconFill, e, t);
            }, this.drawIconResizeCircle = function(e, t, i) {
                var r = t * i;
                c.save(), c.strokeStyle = h.resizeCircleStroke, c.lineWidth = 2, c.fillStyle = h.resizeCircleFill, 
                c.beginPath(), c.arc(e[0], e[1], r, 0, 2 * Math.PI), c.fill(), c.stroke(), c.closePath(), 
                c.restore();
            }, this.drawIconResizeBoxBase = function(e, t, i) {
                var r = t * i;
                c.save(), c.strokeStyle = h.resizeBoxStroke, c.lineWidth = 2, c.fillStyle = h.resizeBoxFill, 
                c.fillRect(e[0] - r / 2, e[1] - r / 2, r, r), c.strokeRect(e[0] - r / 2, e[1] - r / 2, r, r), 
                c.restore();
            }, this.drawIconResizeBoxNESW = function(e, r, s) {
                this.drawIconResizeBoxBase(e, r, s), u(t, h.resizeBoxArrowFill, e, s), u(i, h.resizeBoxArrowFill, e, s);
            }, this.drawIconResizeBoxNWSE = function(t, i, s) {
                this.drawIconResizeBoxBase(t, i, s), u(e, h.resizeBoxArrowFill, t, s), u(r, h.resizeBoxArrowFill, t, s);
            }, this.drawCropArea = function(e, t, i, r) {
                var s = e.width / c.canvas.width, o = e.height / c.canvas.height, a = t[0] - i / 2, n = t[1] - i / 2;
                c.save(), c.strokeStyle = h.areaOutline, c.lineWidth = 2, c.beginPath(), r(c, t, i), 
                c.stroke(), c.clip(), i > 0 && c.drawImage(e, a * s, n * o, i * s, i * o, a, n, i, i), 
                c.beginPath(), r(c, t, i), c.stroke(), c.clip(), c.restore();
            };
        };
    } ]), e.service("cropEXIF", [ function() {
        function e(e) {
            return !!e.exifdata;
        }
        function t(e, t) {
            t = t || e.match(/^data\:([^\;]+)\;base64,/im)[1] || "", e = e.replace(/^data\:([^\;]+)\;base64,/gim, "");
            for (var i = atob(e), r = i.length, s = new ArrayBuffer(r), o = new Uint8Array(s), a = 0; r > a; a++) o[a] = i.charCodeAt(a);
            return s;
        }
        function i(e, t) {
            var i = new XMLHttpRequest();
            i.open("GET", e, !0), i.responseType = "blob", i.onload = function() {
                (200 == this.status || 0 === this.status) && t(this.response);
            }, i.send();
        }
        function r(e, r) {
            function a(t) {
                var i = s(t), a = o(t);
                e.exifdata = i || {}, e.iptcdata = a || {}, r && r.call(e);
            }
            if (e.src) if (/^data\:/i.test(e.src)) {
                var n = t(e.src);
                a(n);
            } else if (/^blob\:/i.test(e.src)) {
                var h = new FileReader();
                h.onload = function(e) {
                    a(e.target.result);
                }, i(e.src, function(e) {
                    h.readAsArrayBuffer(e);
                });
            } else {
                var c = new XMLHttpRequest();
                c.onload = function() {
                    if (200 != this.status && 0 !== this.status) throw "Could not load image";
                    a(c.response), c = null;
                }, c.open("GET", e.src, !0), c.responseType = "arraybuffer", c.send(null);
            } else if (window.FileReader && (e instanceof window.Blob || e instanceof window.File)) {
                var h = new FileReader();
                h.onload = function(e) {
                    u && console.log("Got file of length " + e.target.result.byteLength), a(e.target.result);
                }, h.readAsArrayBuffer(e);
            }
        }
        function s(e) {
            var t = new DataView(e);
            if (u && console.log("Got file of length " + e.byteLength), 255 != t.getUint8(0) || 216 != t.getUint8(1)) return u && console.log("Not a valid JPEG"), 
            !1;
            for (var i, r = 2, s = e.byteLength; s > r; ) {
                if (255 != t.getUint8(r)) return u && console.log("Not a valid marker at offset " + r + ", found: " + t.getUint8(r)), 
                !1;
                if (i = t.getUint8(r + 1), u && console.log(i), 225 == i) return u && console.log("Found 0xFFE1 marker"), 
                l(t, r + 4, t.getUint16(r + 2) - 2);
                r += 2 + t.getUint16(r + 2);
            }
        }
        function o(e) {
            var t = new DataView(e);
            if (u && console.log("Got file of length " + e.byteLength), 255 != t.getUint8(0) || 216 != t.getUint8(1)) return u && console.log("Not a valid JPEG"), 
            !1;
            for (var i = 2, r = e.byteLength, s = function(e, t) {
                return 56 === e.getUint8(t) && 66 === e.getUint8(t + 1) && 73 === e.getUint8(t + 2) && 77 === e.getUint8(t + 3) && 4 === e.getUint8(t + 4) && 4 === e.getUint8(t + 5);
            }; r > i; ) {
                if (s(t, i)) {
                    var o = t.getUint8(i + 7);
                    o % 2 !== 0 && (o += 1), 0 === o && (o = 4);
                    var n = i + 8 + o, h = t.getUint16(i + 6 + o);
                    return a(e, n, h);
                }
                i++;
            }
        }
        function a(e, t, i) {
            for (var r, s, o, a, n, h = new DataView(e), l = {}, u = t; t + i > u; ) 28 === h.getUint8(u) && 2 === h.getUint8(u + 1) && (a = h.getUint8(u + 2), 
            a in _ && (o = h.getInt16(u + 3), n = o + 5, s = _[a], r = c(h, u + 5, o), l.hasOwnProperty(s) ? l[s] instanceof Array ? l[s].push(r) : l[s] = [ l[s], r ] : l[s] = r)), 
            u++;
            return l;
        }
        function n(e, t, i, r, s) {
            var o, a, n, c = e.getUint16(i, !s), l = {};
            for (n = 0; c > n; n++) o = i + 12 * n + 2, a = r[e.getUint16(o, !s)], !a && u && console.log("Unknown tag: " + e.getUint16(o, !s)), 
            l[a] = h(e, o, t, i, s);
            return l;
        }
        function h(e, t, i, r, s) {
            var o, a, n, h, l, u, g = e.getUint16(t + 2, !s), d = e.getUint32(t + 4, !s), f = e.getUint32(t + 8, !s) + i;
            switch (g) {
              case 1:
              case 7:
                if (1 == d) return e.getUint8(t + 8, !s);
                for (o = d > 4 ? f : t + 8, a = [], h = 0; d > h; h++) a[h] = e.getUint8(o + h);
                return a;

              case 2:
                return o = d > 4 ? f : t + 8, c(e, o, d - 1);

              case 3:
                if (1 == d) return e.getUint16(t + 8, !s);
                for (o = d > 2 ? f : t + 8, a = [], h = 0; d > h; h++) a[h] = e.getUint16(o + 2 * h, !s);
                return a;

              case 4:
                if (1 == d) return e.getUint32(t + 8, !s);
                for (a = [], h = 0; d > h; h++) a[h] = e.getUint32(f + 4 * h, !s);
                return a;

              case 5:
                if (1 == d) return l = e.getUint32(f, !s), u = e.getUint32(f + 4, !s), n = new Number(l / u), 
                n.numerator = l, n.denominator = u, n;
                for (a = [], h = 0; d > h; h++) l = e.getUint32(f + 8 * h, !s), u = e.getUint32(f + 4 + 8 * h, !s), 
                a[h] = new Number(l / u), a[h].numerator = l, a[h].denominator = u;
                return a;

              case 9:
                if (1 == d) return e.getInt32(t + 8, !s);
                for (a = [], h = 0; d > h; h++) a[h] = e.getInt32(f + 4 * h, !s);
                return a;

              case 10:
                if (1 == d) return e.getInt32(f, !s) / e.getInt32(f + 4, !s);
                for (a = [], h = 0; d > h; h++) a[h] = e.getInt32(f + 8 * h, !s) / e.getInt32(f + 4 + 8 * h, !s);
                return a;
            }
        }
        function c(e, t, i) {
            for (var r = "", s = t; t + i > s; s++) r += String.fromCharCode(e.getUint8(s));
            return r;
        }
        function l(e, t) {
            if ("Exif" != c(e, t, 4)) return u && console.log("Not valid EXIF data! " + c(e, t, 4)), 
            !1;
            var i, r, s, o, a, h = t + 6;
            if (18761 == e.getUint16(h)) i = !1; else {
                if (19789 != e.getUint16(h)) return u && console.log("Not valid TIFF data! (no 0x4949 or 0x4D4D)"), 
                !1;
                i = !0;
            }
            if (42 != e.getUint16(h + 2, !i)) return u && console.log("Not valid TIFF data! (no 0x002A)"), 
            !1;
            var l = e.getUint32(h + 4, !i);
            if (8 > l) return u && console.log("Not valid TIFF data! (First offset less than 8)", e.getUint32(h + 4, !i)), 
            !1;
            if (r = n(e, h, h + l, d, i), r.ExifIFDPointer) {
                o = n(e, h, h + r.ExifIFDPointer, g, i);
                for (s in o) {
                    switch (s) {
                      case "LightSource":
                      case "Flash":
                      case "MeteringMode":
                      case "ExposureProgram":
                      case "SensingMethod":
                      case "SceneCaptureType":
                      case "SceneType":
                      case "CustomRendered":
                      case "WhiteBalance":
                      case "GainControl":
                      case "Contrast":
                      case "Saturation":
                      case "Sharpness":
                      case "SubjectDistanceRange":
                      case "FileSource":
                        o[s] = p[s][o[s]];
                        break;

                      case "ExifVersion":
                      case "FlashpixVersion":
                        o[s] = String.fromCharCode(o[s][0], o[s][1], o[s][2], o[s][3]);
                        break;

                      case "ComponentsConfiguration":
                        o[s] = p.Components[o[s][0]] + p.Components[o[s][1]] + p.Components[o[s][2]] + p.Components[o[s][3]];
                    }
                    r[s] = o[s];
                }
            }
            if (r.GPSInfoIFDPointer) {
                a = n(e, h, h + r.GPSInfoIFDPointer, f, i);
                for (s in a) {
                    switch (s) {
                      case "GPSVersionID":
                        a[s] = a[s][0] + "." + a[s][1] + "." + a[s][2] + "." + a[s][3];
                    }
                    r[s] = a[s];
                }
            }
            return r;
        }
        var u = !1, g = this.Tags = {
            36864: "ExifVersion",
            40960: "FlashpixVersion",
            40961: "ColorSpace",
            40962: "PixelXDimension",
            40963: "PixelYDimension",
            37121: "ComponentsConfiguration",
            37122: "CompressedBitsPerPixel",
            37500: "MakerNote",
            37510: "UserComment",
            40964: "RelatedSoundFile",
            36867: "DateTimeOriginal",
            36868: "DateTimeDigitized",
            37520: "SubsecTime",
            37521: "SubsecTimeOriginal",
            37522: "SubsecTimeDigitized",
            33434: "ExposureTime",
            33437: "FNumber",
            34850: "ExposureProgram",
            34852: "SpectralSensitivity",
            34855: "ISOSpeedRatings",
            34856: "OECF",
            37377: "ShutterSpeedValue",
            37378: "ApertureValue",
            37379: "BrightnessValue",
            37380: "ExposureBias",
            37381: "MaxApertureValue",
            37382: "SubjectDistance",
            37383: "MeteringMode",
            37384: "LightSource",
            37385: "Flash",
            37396: "SubjectArea",
            37386: "FocalLength",
            41483: "FlashEnergy",
            41484: "SpatialFrequencyResponse",
            41486: "FocalPlaneXResolution",
            41487: "FocalPlaneYResolution",
            41488: "FocalPlaneResolutionUnit",
            41492: "SubjectLocation",
            41493: "ExposureIndex",
            41495: "SensingMethod",
            41728: "FileSource",
            41729: "SceneType",
            41730: "CFAPattern",
            41985: "CustomRendered",
            41986: "ExposureMode",
            41987: "WhiteBalance",
            41988: "DigitalZoomRation",
            41989: "FocalLengthIn35mmFilm",
            41990: "SceneCaptureType",
            41991: "GainControl",
            41992: "Contrast",
            41993: "Saturation",
            41994: "Sharpness",
            41995: "DeviceSettingDescription",
            41996: "SubjectDistanceRange",
            40965: "InteroperabilityIFDPointer",
            42016: "ImageUniqueID"
        }, d = this.TiffTags = {
            256: "ImageWidth",
            257: "ImageHeight",
            34665: "ExifIFDPointer",
            34853: "GPSInfoIFDPointer",
            40965: "InteroperabilityIFDPointer",
            258: "BitsPerSample",
            259: "Compression",
            262: "PhotometricInterpretation",
            274: "Orientation",
            277: "SamplesPerPixel",
            284: "PlanarConfiguration",
            530: "YCbCrSubSampling",
            531: "YCbCrPositioning",
            282: "XResolution",
            283: "YResolution",
            296: "ResolutionUnit",
            273: "StripOffsets",
            278: "RowsPerStrip",
            279: "StripByteCounts",
            513: "JPEGInterchangeFormat",
            514: "JPEGInterchangeFormatLength",
            301: "TransferFunction",
            318: "WhitePoint",
            319: "PrimaryChromaticities",
            529: "YCbCrCoefficients",
            532: "ReferenceBlackWhite",
            306: "DateTime",
            270: "ImageDescription",
            271: "Make",
            272: "Model",
            305: "Software",
            315: "Artist",
            33432: "Copyright"
        }, f = this.GPSTags = {
            0: "GPSVersionID",
            1: "GPSLatitudeRef",
            2: "GPSLatitude",
            3: "GPSLongitudeRef",
            4: "GPSLongitude",
            5: "GPSAltitudeRef",
            6: "GPSAltitude",
            7: "GPSTimeStamp",
            8: "GPSSatellites",
            9: "GPSStatus",
            10: "GPSMeasureMode",
            11: "GPSDOP",
            12: "GPSSpeedRef",
            13: "GPSSpeed",
            14: "GPSTrackRef",
            15: "GPSTrack",
            16: "GPSImgDirectionRef",
            17: "GPSImgDirection",
            18: "GPSMapDatum",
            19: "GPSDestLatitudeRef",
            20: "GPSDestLatitude",
            21: "GPSDestLongitudeRef",
            22: "GPSDestLongitude",
            23: "GPSDestBearingRef",
            24: "GPSDestBearing",
            25: "GPSDestDistanceRef",
            26: "GPSDestDistance",
            27: "GPSProcessingMethod",
            28: "GPSAreaInformation",
            29: "GPSDateStamp",
            30: "GPSDifferential"
        }, p = this.StringValues = {
            ExposureProgram: {
                0: "Not defined",
                1: "Manual",
                2: "Normal program",
                3: "Aperture priority",
                4: "Shutter priority",
                5: "Creative program",
                6: "Action program",
                7: "Portrait mode",
                8: "Landscape mode"
            },
            MeteringMode: {
                0: "Unknown",
                1: "Average",
                2: "CenterWeightedAverage",
                3: "Spot",
                4: "MultiSpot",
                5: "Pattern",
                6: "Partial",
                255: "Other"
            },
            LightSource: {
                0: "Unknown",
                1: "Daylight",
                2: "Fluorescent",
                3: "Tungsten (incandescent light)",
                4: "Flash",
                9: "Fine weather",
                10: "Cloudy weather",
                11: "Shade",
                12: "Daylight fluorescent (D 5700 - 7100K)",
                13: "Day white fluorescent (N 4600 - 5400K)",
                14: "Cool white fluorescent (W 3900 - 4500K)",
                15: "White fluorescent (WW 3200 - 3700K)",
                17: "Standard light A",
                18: "Standard light B",
                19: "Standard light C",
                20: "D55",
                21: "D65",
                22: "D75",
                23: "D50",
                24: "ISO studio tungsten",
                255: "Other"
            },
            Flash: {
                0: "Flash did not fire",
                1: "Flash fired",
                5: "Strobe return light not detected",
                7: "Strobe return light detected",
                9: "Flash fired, compulsory flash mode",
                13: "Flash fired, compulsory flash mode, return light not detected",
                15: "Flash fired, compulsory flash mode, return light detected",
                16: "Flash did not fire, compulsory flash mode",
                24: "Flash did not fire, auto mode",
                25: "Flash fired, auto mode",
                29: "Flash fired, auto mode, return light not detected",
                31: "Flash fired, auto mode, return light detected",
                32: "No flash function",
                65: "Flash fired, red-eye reduction mode",
                69: "Flash fired, red-eye reduction mode, return light not detected",
                71: "Flash fired, red-eye reduction mode, return light detected",
                73: "Flash fired, compulsory flash mode, red-eye reduction mode",
                77: "Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",
                79: "Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",
                89: "Flash fired, auto mode, red-eye reduction mode",
                93: "Flash fired, auto mode, return light not detected, red-eye reduction mode",
                95: "Flash fired, auto mode, return light detected, red-eye reduction mode"
            },
            SensingMethod: {
                1: "Not defined",
                2: "One-chip color area sensor",
                3: "Two-chip color area sensor",
                4: "Three-chip color area sensor",
                5: "Color sequential area sensor",
                7: "Trilinear sensor",
                8: "Color sequential linear sensor"
            },
            SceneCaptureType: {
                0: "Standard",
                1: "Landscape",
                2: "Portrait",
                3: "Night scene"
            },
            SceneType: {
                1: "Directly photographed"
            },
            CustomRendered: {
                0: "Normal process",
                1: "Custom process"
            },
            WhiteBalance: {
                0: "Auto white balance",
                1: "Manual white balance"
            },
            GainControl: {
                0: "None",
                1: "Low gain up",
                2: "High gain up",
                3: "Low gain down",
                4: "High gain down"
            },
            Contrast: {
                0: "Normal",
                1: "Soft",
                2: "Hard"
            },
            Saturation: {
                0: "Normal",
                1: "Low saturation",
                2: "High saturation"
            },
            Sharpness: {
                0: "Normal",
                1: "Soft",
                2: "Hard"
            },
            SubjectDistanceRange: {
                0: "Unknown",
                1: "Macro",
                2: "Close view",
                3: "Distant view"
            },
            FileSource: {
                3: "DSC"
            },
            Components: {
                0: "",
                1: "Y",
                2: "Cb",
                3: "Cr",
                4: "R",
                5: "G",
                6: "B"
            }
        }, _ = {
            120: "caption",
            110: "credit",
            25: "keywords",
            55: "dateCreated",
            80: "byline",
            85: "bylineTitle",
            122: "captionWriter",
            105: "headline",
            116: "copyright",
            15: "category"
        };
        this.getData = function(t, i) {
            return (t instanceof Image || t instanceof HTMLImageElement) && !t.complete ? !1 : (e(t) ? i && i.call(t) : r(t, i), 
            !0);
        }, this.getTag = function(t, i) {
            return e(t) ? t.exifdata[i] : void 0;
        }, this.getAllTags = function(t) {
            if (!e(t)) return {};
            var i, r = t.exifdata, s = {};
            for (i in r) r.hasOwnProperty(i) && (s[i] = r[i]);
            return s;
        }, this.pretty = function(t) {
            if (!e(t)) return "";
            var i, r = t.exifdata, s = "";
            for (i in r) r.hasOwnProperty(i) && (s += "object" == typeof r[i] ? r[i] instanceof Number ? i + " : " + r[i] + " [" + r[i].numerator + "/" + r[i].denominator + "]\r\n" : i + " : [" + r[i].length + " values]\r\n" : i + " : " + r[i] + "\r\n");
            return s;
        }, this.readFromBinaryFile = function(e) {
            return s(e);
        };
    } ]), e.factory("cropHost", [ "$document", "cropAreaCircle", "cropAreaSquare", "cropEXIF", function(e, t, i, r) {
        var s = function(e) {
            var t = e.getBoundingClientRect(), i = document.body, r = document.documentElement, s = window.pageYOffset || r.scrollTop || i.scrollTop, o = window.pageXOffset || r.scrollLeft || i.scrollLeft, a = r.clientTop || i.clientTop || 0, n = r.clientLeft || i.clientLeft || 0, h = t.top + s - a, c = t.left + o - n;
            return {
                top: Math.round(h),
                left: Math.round(c)
            };
        };
        return function(o, a, n) {
            function h() {
                c.clearRect(0, 0, c.canvas.width, c.canvas.height), null !== l && (c.drawImage(l, 0, 0, c.canvas.width, c.canvas.height), 
                c.save(), c.fillStyle = "rgba(0, 0, 0, 0.65)", c.fillRect(0, 0, c.canvas.width, c.canvas.height), 
                c.restore(), u.draw());
            }
            var c = null, l = null, u = null, g = [ 100, 100 ], d = [ 300, 300 ], f = 200, p = "image/png", _ = null, m = function() {
                if (null !== l) {
                    u.setImage(l);
                    var e = [ l.width, l.height ], t = l.width / l.height, i = e;
                    i[0] > d[0] ? (i[0] = d[0], i[1] = i[0] / t) : i[0] < g[0] && (i[0] = g[0], i[1] = i[0] / t), 
                    i[1] > d[1] ? (i[1] = d[1], i[0] = i[1] * t) : i[1] < g[1] && (i[1] = g[1], i[0] = i[1] * t), 
                    o.prop("width", i[0]).prop("height", i[1]).css({
                        "margin-left": -i[0] / 2 + "px",
                        "margin-top": -i[1] / 2 + "px"
                    }), u.setX(c.canvas.width / 2), u.setY(c.canvas.height / 2), u.setSize(Math.min(200, c.canvas.width / 2, c.canvas.height / 2));
                } else o.prop("width", 0).prop("height", 0).css({
                    "margin-top": 0
                });
                h();
            }, v = function(e) {
                return angular.isDefined(e.changedTouches) ? e.changedTouches : e.originalEvent.changedTouches;
            }, S = function(e) {
                if (null !== l) {
                    var t, i, r = s(c.canvas);
                    "touchmove" === e.type ? (t = v(e)[0].pageX, i = v(e)[0].pageY) : (t = e.pageX, 
                    i = e.pageY), u.processMouseMove(t - r.left, i - r.top), h();
                }
            }, z = function(e) {
                if (e.preventDefault(), e.stopPropagation(), null !== l) {
                    var t, i, r = s(c.canvas);
                    "touchstart" === e.type ? (t = v(e)[0].pageX, i = v(e)[0].pageY) : (t = e.pageX, 
                    i = e.pageY), u.processMouseDown(t - r.left, i - r.top), h();
                }
            }, I = function(e) {
                if (null !== l) {
                    var t, i, r = s(c.canvas);
                    "touchend" === e.type ? (t = v(e)[0].pageX, i = v(e)[0].pageY) : (t = e.pageX, i = e.pageY), 
                    u.processMouseUp(t - r.left, i - r.top), h();
                }
            };
            this.getResultImageDataURI = function() {
                var e, t;
                return t = angular.element("<canvas></canvas>")[0], e = t.getContext("2d"), t.width = f, 
                t.height = f, null !== l && e.drawImage(l, (u.getX() - u.getSize() / 2) * (l.width / c.canvas.width), (u.getY() - u.getSize() / 2) * (l.height / c.canvas.height), u.getSize() * (l.width / c.canvas.width), u.getSize() * (l.height / c.canvas.height), 0, 0, f, f), 
                null !== _ ? t.toDataURL(p, _) : t.toDataURL(p);
            }, this.setNewImageSource = function(e) {
                if (l = null, m(), n.trigger("image-updated"), e) {
                    var t = new Image();
                    "http" === e.substring(0, 4).toLowerCase() && (t.crossOrigin = "anonymous"), t.onload = function() {
                        n.trigger("load-done"), r.getData(t, function() {
                            var e = r.getTag(t, "Orientation");
                            if ([ 3, 6, 8 ].indexOf(e) > -1) {
                                var i = document.createElement("canvas"), s = i.getContext("2d"), o = t.width, a = t.height, h = 0, c = 0, u = 0;
                                switch (e) {
                                  case 3:
                                    h = -t.width, c = -t.height, u = 180;
                                    break;

                                  case 6:
                                    o = t.height, a = t.width, c = -t.height, u = 90;
                                    break;

                                  case 8:
                                    o = t.height, a = t.width, h = -t.width, u = 270;
                                }
                                i.width = o, i.height = a, s.rotate(u * Math.PI / 180), s.drawImage(t, h, c), l = new Image(), 
                                l.src = i.toDataURL("image/png");
                            } else l = t;
                            m(), n.trigger("image-updated");
                        });
                    }, t.onerror = function() {
                        n.trigger("load-error");
                    }, n.trigger("load-start"), t.src = e;
                }
            }, this.setMaxDimensions = function(e, t) {
                if (d = [ e, t ], null !== l) {
                    var i = c.canvas.width, r = c.canvas.height, s = [ l.width, l.height ], a = l.width / l.height, n = s;
                    n[0] > d[0] ? (n[0] = d[0], n[1] = n[0] / a) : n[0] < g[0] && (n[0] = g[0], n[1] = n[0] / a), 
                    n[1] > d[1] ? (n[1] = d[1], n[0] = n[1] * a) : n[1] < g[1] && (n[1] = g[1], n[0] = n[1] * a), 
                    o.prop("width", n[0]).prop("height", n[1]).css({
                        "margin-left": -n[0] / 2 + "px",
                        "margin-top": -n[1] / 2 + "px"
                    });
                    var f = c.canvas.width / i, p = c.canvas.height / r, _ = Math.min(f, p);
                    u.setX(u.getX() * f), u.setY(u.getY() * p), u.setSize(u.getSize() * _);
                } else o.prop("width", 0).prop("height", 0).css({
                    "margin-top": 0
                });
                h();
            }, this.setAreaMinSize = function(e) {
                e = parseInt(e, 10), isNaN(e) || (u.setMinSize(e), h());
            }, this.setResultImageSize = function(e) {
                e = parseInt(e, 10), isNaN(e) || (f = e);
            }, this.setResultImageFormat = function(e) {
                p = e;
            }, this.setResultImageQuality = function(e) {
                e = parseFloat(e), !isNaN(e) && e >= 0 && 1 >= e && (_ = e);
            }, this.setAreaType = function(e) {
                var r = u.getSize(), s = u.getMinSize(), o = u.getX(), a = u.getY(), g = t;
                "square" === e && (g = i), u = new g(c, n), u.setMinSize(s), u.setSize(r), u.setX(o), 
                u.setY(a), null !== l && u.setImage(l), h();
            }, c = o[0].getContext("2d"), u = new t(c, n), e.on("mousemove", S), o.on("mousedown", z), 
            e.on("mouseup", I), e.on("touchmove", S), o.on("touchstart", z), e.on("touchend", I), 
            this.destroy = function() {
                e.off("mousemove", S), o.off("mousedown", z), e.off("mouseup", S), e.off("touchmove", S), 
                o.off("touchstart", z), e.off("touchend", S), o.remove();
            };
        };
    } ]), e.factory("cropPubSub", [ function() {
        return function() {
            var e = {};
            this.on = function(t, i) {
                return t.split(" ").forEach(function(t) {
                    e[t] || (e[t] = []), e[t].push(i);
                }), this;
            }, this.trigger = function(t, i) {
                return angular.forEach(e[t], function(e) {
                    e.call(null, i);
                }), this;
            };
        };
    } ]), e.directive("imgCrop", [ "$timeout", "cropHost", "cropPubSub", function(e, t, i) {
        return {
            restrict: "E",
            scope: {
                image: "=",
                resultImage: "=",
                changeOnFly: "=",
                areaType: "@",
                areaMinSize: "=",
                resultImageSize: "=",
                resultImageFormat: "@",
                resultImageQuality: "=",
                onChange: "&",
                onLoadBegin: "&",
                onLoadDone: "&",
                onLoadError: "&"
            },
            template: "<canvas></canvas>",
            controller: [ "$scope", function(e) {
                e.events = new i();
            } ],
            link: function(i, r) {
                var s, o = i.events, a = new t(r.find("canvas"), {}, o), n = function(e) {
                    var t = a.getResultImageDataURI();
                    s !== t && (s = t, angular.isDefined(e.resultImage) && (e.resultImage = t), e.onChange({
                        $dataURI: e.resultImage
                    }));
                }, h = function(t) {
                    return function() {
                        e(function() {
                            i.$apply(function(e) {
                                t(e);
                            });
                        });
                    };
                };
                o.on("load-start", h(function(e) {
                    e.onLoadBegin({});
                })).on("load-done", h(function(e) {
                    e.onLoadDone({});
                })).on("load-error", h(function(e) {
                    e.onLoadError({});
                })).on("area-move area-resize", h(function(e) {
                    e.changeOnFly && n(e);
                })).on("area-move-end area-resize-end image-updated", h(function(e) {
                    n(e);
                })), i.$watch("image", function() {
                    a.setNewImageSource(i.image);
                }), i.$watch("areaType", function() {
                    a.setAreaType(i.areaType), n(i);
                }), i.$watch("areaMinSize", function() {
                    a.setAreaMinSize(i.areaMinSize), n(i);
                }), i.$watch("resultImageSize", function() {
                    a.setResultImageSize(i.resultImageSize), n(i);
                }), i.$watch("resultImageFormat", function() {
                    a.setResultImageFormat(i.resultImageFormat), n(i);
                }), i.$watch("resultImageQuality", function() {
                    a.setResultImageQuality(i.resultImageQuality), n(i);
                }), i.$watch(function() {
                    return [ r[0].clientWidth, r[0].clientHeight ];
                }, function(e) {
                    a.setMaxDimensions(e[0], e[1]), n(i);
                }, !0), i.$on("$destroy", function() {
                    a.destroy();
                });
            }
        };
    } ]);
}();

angular.module("ngTableExport", []).config([ "$compileProvider", function(a) {
    a.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|data):/);
} ]).directive("exportCsv", [ "$parse", function(a) {
    return {
        restrict: "A",
        scope: !1,
        link: function(b, c, d) {
            var e = "", f = {
                stringify: function(a) {
                    return '"' + a.replace(/^\s\s*/, "").replace(/\s*\s$/, "").replace(/"/g, '""') + '"';
                },
                generate: function() {
                    e = "";
                    var a = c.find("tr");
                    angular.forEach(a, function(a, b) {
                        var c = angular.element(a), d = c.find("th"), g = "";
                        c.hasClass("ng-table-filters") || (0 == d.length && (d = c.find("td")), 1 != b && (angular.forEach(d, function(a) {
                            g += f.stringify(angular.element(a).text()) + ";";
                        }), g = g.slice(0, g.length - 1)), e += g + "\n");
                    });
                },
                link: function() {
                    return "data:text/csv;charset=UTF-8," + encodeURIComponent(e);
                }
            };
            a(d.exportCsv).assign(b.$parent, f);
        }
    };
} ]);

(function($) {
    $.color = {};
    $.color.make = function(r, g, b, a) {
        var o = {};
        o.r = r || 0;
        o.g = g || 0;
        o.b = b || 0;
        o.a = a != null ? a : 1;
        o.add = function(c, d) {
            for (var i = 0; i < c.length; ++i) o[c.charAt(i)] += d;
            return o.normalize();
        };
        o.scale = function(c, f) {
            for (var i = 0; i < c.length; ++i) o[c.charAt(i)] *= f;
            return o.normalize();
        };
        o.toString = function() {
            if (o.a >= 1) {
                return "rgb(" + [ o.r, o.g, o.b ].join(",") + ")";
            } else {
                return "rgba(" + [ o.r, o.g, o.b, o.a ].join(",") + ")";
            }
        };
        o.normalize = function() {
            function clamp(min, value, max) {
                return value < min ? min : value > max ? max : value;
            }
            o.r = clamp(0, parseInt(o.r), 255);
            o.g = clamp(0, parseInt(o.g), 255);
            o.b = clamp(0, parseInt(o.b), 255);
            o.a = clamp(0, o.a, 1);
            return o;
        };
        o.clone = function() {
            return $.color.make(o.r, o.b, o.g, o.a);
        };
        return o.normalize();
    };
    $.color.extract = function(elem, css) {
        var c;
        do {
            c = elem.css(css).toLowerCase();
            if (c != "" && c != "transparent") break;
            elem = elem.parent();
        } while (elem.length && !$.nodeName(elem.get(0), "body"));
        if (c == "rgba(0, 0, 0, 0)") c = "transparent";
        return $.color.parse(c);
    };
    $.color.parse = function(str) {
        var res, m = $.color.make;
        if (res = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(str)) return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10));
        if (res = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str)) return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10), parseFloat(res[4]));
        if (res = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(str)) return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55);
        if (res = /rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str)) return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55, parseFloat(res[4]));
        if (res = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str)) return m(parseInt(res[1], 16), parseInt(res[2], 16), parseInt(res[3], 16));
        if (res = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str)) return m(parseInt(res[1] + res[1], 16), parseInt(res[2] + res[2], 16), parseInt(res[3] + res[3], 16));
        var name = $.trim(str).toLowerCase();
        if (name == "transparent") return m(255, 255, 255, 0); else {
            res = lookupColors[name] || [ 0, 0, 0 ];
            return m(res[0], res[1], res[2]);
        }
    };
    var lookupColors = {
        aqua: [ 0, 255, 255 ],
        azure: [ 240, 255, 255 ],
        beige: [ 245, 245, 220 ],
        black: [ 0, 0, 0 ],
        blue: [ 0, 0, 255 ],
        brown: [ 165, 42, 42 ],
        cyan: [ 0, 255, 255 ],
        darkblue: [ 0, 0, 139 ],
        darkcyan: [ 0, 139, 139 ],
        darkgrey: [ 169, 169, 169 ],
        darkgreen: [ 0, 100, 0 ],
        darkkhaki: [ 189, 183, 107 ],
        darkmagenta: [ 139, 0, 139 ],
        darkolivegreen: [ 85, 107, 47 ],
        darkorange: [ 255, 140, 0 ],
        darkorchid: [ 153, 50, 204 ],
        darkred: [ 139, 0, 0 ],
        darksalmon: [ 233, 150, 122 ],
        darkviolet: [ 148, 0, 211 ],
        fuchsia: [ 255, 0, 255 ],
        gold: [ 255, 215, 0 ],
        green: [ 0, 128, 0 ],
        indigo: [ 75, 0, 130 ],
        khaki: [ 240, 230, 140 ],
        lightblue: [ 173, 216, 230 ],
        lightcyan: [ 224, 255, 255 ],
        lightgreen: [ 144, 238, 144 ],
        lightgrey: [ 211, 211, 211 ],
        lightpink: [ 255, 182, 193 ],
        lightyellow: [ 255, 255, 224 ],
        lime: [ 0, 255, 0 ],
        magenta: [ 255, 0, 255 ],
        maroon: [ 128, 0, 0 ],
        navy: [ 0, 0, 128 ],
        olive: [ 128, 128, 0 ],
        orange: [ 255, 165, 0 ],
        pink: [ 255, 192, 203 ],
        purple: [ 128, 0, 128 ],
        violet: [ 128, 0, 128 ],
        red: [ 255, 0, 0 ],
        silver: [ 192, 192, 192 ],
        white: [ 255, 255, 255 ],
        yellow: [ 255, 255, 0 ]
    };
})(jQuery);

(function($) {
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    if (!$.fn.detach) {
        $.fn.detach = function() {
            return this.each(function() {
                if (this.parentNode) {
                    this.parentNode.removeChild(this);
                }
            });
        };
    }
    function Canvas(cls, container) {
        var element = container.children("." + cls)[0];
        if (element == null) {
            element = document.createElement("canvas");
            element.className = cls;
            $(element).css({
                direction: "ltr",
                position: "absolute",
                left: 0,
                top: 0
            }).appendTo(container);
            if (!element.getContext) {
                if (window.G_vmlCanvasManager) {
                    element = window.G_vmlCanvasManager.initElement(element);
                } else {
                    throw new Error("Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.");
                }
            }
        }
        this.element = element;
        var context = this.context = element.getContext("2d");
        var devicePixelRatio = window.devicePixelRatio || 1, backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
        this.pixelRatio = devicePixelRatio / backingStoreRatio;
        this.resize(container.width(), container.height());
        this.textContainer = null;
        this.text = {};
        this._textCache = {};
    }
    Canvas.prototype.resize = function(width, height) {
        if (width <= 0 || height <= 0) {
            throw new Error("Invalid dimensions for plot, width = " + width + ", height = " + height);
        }
        var element = this.element, context = this.context, pixelRatio = this.pixelRatio;
        if (this.width != width) {
            element.width = width * pixelRatio;
            element.style.width = width + "px";
            this.width = width;
        }
        if (this.height != height) {
            element.height = height * pixelRatio;
            element.style.height = height + "px";
            this.height = height;
        }
        context.restore();
        context.save();
        context.scale(pixelRatio, pixelRatio);
    };
    Canvas.prototype.clear = function() {
        this.context.clearRect(0, 0, this.width, this.height);
    };
    Canvas.prototype.render = function() {
        var cache = this._textCache;
        for (var layerKey in cache) {
            if (hasOwnProperty.call(cache, layerKey)) {
                var layer = this.getTextLayer(layerKey), layerCache = cache[layerKey];
                layer.hide();
                for (var styleKey in layerCache) {
                    if (hasOwnProperty.call(layerCache, styleKey)) {
                        var styleCache = layerCache[styleKey];
                        for (var key in styleCache) {
                            if (hasOwnProperty.call(styleCache, key)) {
                                var positions = styleCache[key].positions;
                                for (var i = 0, position; position = positions[i]; i++) {
                                    if (position.active) {
                                        if (!position.rendered) {
                                            layer.append(position.element);
                                            position.rendered = true;
                                        }
                                    } else {
                                        positions.splice(i--, 1);
                                        if (position.rendered) {
                                            position.element.detach();
                                        }
                                    }
                                }
                                if (positions.length == 0) {
                                    delete styleCache[key];
                                }
                            }
                        }
                    }
                }
                layer.show();
            }
        }
    };
    Canvas.prototype.getTextLayer = function(classes) {
        var layer = this.text[classes];
        if (layer == null) {
            if (this.textContainer == null) {
                this.textContainer = $("<div class='flot-text'></div>").css({
                    position: "absolute",
                    top: 0,
                    left: 0,
                    bottom: 0,
                    right: 0,
                    "font-size": "smaller",
                    color: "#545454"
                }).insertAfter(this.element);
            }
            layer = this.text[classes] = $("<div></div>").addClass(classes).css({
                position: "absolute",
                top: 0,
                left: 0,
                bottom: 0,
                right: 0
            }).appendTo(this.textContainer);
        }
        return layer;
    };
    Canvas.prototype.getTextInfo = function(layer, text, font, angle, width) {
        var textStyle, layerCache, styleCache, info;
        text = "" + text;
        if (typeof font === "object") {
            textStyle = font.style + " " + font.variant + " " + font.weight + " " + font.size + "px/" + font.lineHeight + "px " + font.family;
        } else {
            textStyle = font;
        }
        layerCache = this._textCache[layer];
        if (layerCache == null) {
            layerCache = this._textCache[layer] = {};
        }
        styleCache = layerCache[textStyle];
        if (styleCache == null) {
            styleCache = layerCache[textStyle] = {};
        }
        info = styleCache[text];
        if (info == null) {
            var element = $("<div></div>").html(text).css({
                position: "absolute",
                "max-width": width,
                top: -9999
            }).appendTo(this.getTextLayer(layer));
            if (typeof font === "object") {
                element.css({
                    font: textStyle,
                    color: font.color
                });
            } else if (typeof font === "string") {
                element.addClass(font);
            }
            info = styleCache[text] = {
                width: element.outerWidth(true),
                height: element.outerHeight(true),
                element: element,
                positions: []
            };
            element.detach();
        }
        return info;
    };
    Canvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {
        var info = this.getTextInfo(layer, text, font, angle, width), positions = info.positions;
        if (halign == "center") {
            x -= info.width / 2;
        } else if (halign == "right") {
            x -= info.width;
        }
        if (valign == "middle") {
            y -= info.height / 2;
        } else if (valign == "bottom") {
            y -= info.height;
        }
        for (var i = 0, position; position = positions[i]; i++) {
            if (position.x == x && position.y == y) {
                position.active = true;
                return;
            }
        }
        position = {
            active: true,
            rendered: false,
            element: positions.length ? info.element.clone() : info.element,
            x: x,
            y: y
        };
        positions.push(position);
        position.element.css({
            top: Math.round(y),
            left: Math.round(x),
            "text-align": halign
        });
    };
    Canvas.prototype.removeText = function(layer, x, y, text, font, angle) {
        if (text == null) {
            var layerCache = this._textCache[layer];
            if (layerCache != null) {
                for (var styleKey in layerCache) {
                    if (hasOwnProperty.call(layerCache, styleKey)) {
                        var styleCache = layerCache[styleKey];
                        for (var key in styleCache) {
                            if (hasOwnProperty.call(styleCache, key)) {
                                var positions = styleCache[key].positions;
                                for (var i = 0, position; position = positions[i]; i++) {
                                    position.active = false;
                                }
                            }
                        }
                    }
                }
            }
        } else {
            var positions = this.getTextInfo(layer, text, font, angle).positions;
            for (var i = 0, position; position = positions[i]; i++) {
                if (position.x == x && position.y == y) {
                    position.active = false;
                }
            }
        }
    };
    function Plot(placeholder, data_, options_, plugins) {
        var series = [], options = {
            colors: [ "#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed" ],
            legend: {
                show: true,
                noColumns: 1,
                labelFormatter: null,
                labelBoxBorderColor: "#ccc",
                container: null,
                position: "ne",
                margin: 5,
                backgroundColor: null,
                backgroundOpacity: .85,
                sorted: null
            },
            xaxis: {
                show: null,
                position: "bottom",
                mode: null,
                font: null,
                color: null,
                tickColor: null,
                transform: null,
                inverseTransform: null,
                min: null,
                max: null,
                autoscaleMargin: null,
                ticks: null,
                tickFormatter: null,
                labelWidth: null,
                labelHeight: null,
                reserveSpace: null,
                tickLength: null,
                alignTicksWithAxis: null,
                tickDecimals: null,
                tickSize: null,
                minTickSize: null
            },
            yaxis: {
                autoscaleMargin: .02,
                position: "left"
            },
            xaxes: [],
            yaxes: [],
            series: {
                points: {
                    show: false,
                    radius: 3,
                    lineWidth: 2,
                    fill: true,
                    fillColor: "#ffffff",
                    symbol: "circle"
                },
                lines: {
                    lineWidth: 2,
                    fill: false,
                    fillColor: null,
                    steps: false
                },
                bars: {
                    show: false,
                    lineWidth: 2,
                    barWidth: 1,
                    fill: true,
                    fillColor: null,
                    align: "left",
                    horizontal: false,
                    zero: true
                },
                shadowSize: 3,
                highlightColor: null
            },
            grid: {
                show: true,
                aboveData: false,
                color: "#545454",
                backgroundColor: null,
                borderColor: null,
                tickColor: null,
                margin: 0,
                labelMargin: 5,
                axisMargin: 8,
                borderWidth: 2,
                minBorderMargin: null,
                markings: null,
                markingsColor: "#f4f4f4",
                markingsLineWidth: 2,
                clickable: false,
                hoverable: false,
                autoHighlight: true,
                mouseActiveRadius: 10
            },
            interaction: {
                redrawOverlayInterval: 1e3 / 60
            },
            hooks: {}
        }, surface = null, overlay = null, eventHolder = null, ctx = null, octx = null, xaxes = [], yaxes = [], plotOffset = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        }, plotWidth = 0, plotHeight = 0, hooks = {
            processOptions: [],
            processRawData: [],
            processDatapoints: [],
            processOffset: [],
            drawBackground: [],
            drawSeries: [],
            draw: [],
            bindEvents: [],
            drawOverlay: [],
            shutdown: []
        }, plot = this;
        plot.setData = setData;
        plot.setupGrid = setupGrid;
        plot.draw = draw;
        plot.getPlaceholder = function() {
            return placeholder;
        };
        plot.getCanvas = function() {
            return surface.element;
        };
        plot.getPlotOffset = function() {
            return plotOffset;
        };
        plot.width = function() {
            return plotWidth;
        };
        plot.height = function() {
            return plotHeight;
        };
        plot.offset = function() {
            var o = eventHolder.offset();
            o.left += plotOffset.left;
            o.top += plotOffset.top;
            return o;
        };
        plot.getData = function() {
            return series;
        };
        plot.getAxes = function() {
            var res = {}, i;
            $.each(xaxes.concat(yaxes), function(_, axis) {
                if (axis) res[axis.direction + (axis.n != 1 ? axis.n : "") + "axis"] = axis;
            });
            return res;
        };
        plot.getXAxes = function() {
            return xaxes;
        };
        plot.getYAxes = function() {
            return yaxes;
        };
        plot.c2p = canvasToAxisCoords;
        plot.p2c = axisToCanvasCoords;
        plot.getOptions = function() {
            return options;
        };
        plot.highlight = highlight;
        plot.unhighlight = unhighlight;
        plot.triggerRedrawOverlay = triggerRedrawOverlay;
        plot.pointOffset = function(point) {
            return {
                left: parseInt(xaxes[axisNumber(point, "x") - 1].p2c(+point.x) + plotOffset.left, 10),
                top: parseInt(yaxes[axisNumber(point, "y") - 1].p2c(+point.y) + plotOffset.top, 10)
            };
        };
        plot.shutdown = shutdown;
        plot.destroy = function() {
            shutdown();
            placeholder.removeData("plot").empty();
            series = [];
            options = null;
            surface = null;
            overlay = null;
            eventHolder = null;
            ctx = null;
            octx = null;
            xaxes = [];
            yaxes = [];
            hooks = null;
            highlights = [];
            plot = null;
        };
        plot.resize = function() {
            var width = placeholder.width(), height = placeholder.height();
            surface.resize(width, height);
            overlay.resize(width, height);
        };
        plot.hooks = hooks;
        initPlugins(plot);
        parseOptions(options_);
        setupCanvases();
        setData(data_);
        setupGrid();
        draw();
        bindEvents();
        function executeHooks(hook, args) {
            args = [ plot ].concat(args);
            for (var i = 0; i < hook.length; ++i) hook[i].apply(this, args);
        }
        function initPlugins() {
            var classes = {
                Canvas: Canvas
            };
            for (var i = 0; i < plugins.length; ++i) {
                var p = plugins[i];
                p.init(plot, classes);
                if (p.options) $.extend(true, options, p.options);
            }
        }
        function parseOptions(opts) {
            $.extend(true, options, opts);
            if (opts && opts.colors) {
                options.colors = opts.colors;
            }
            if (options.xaxis.color == null) options.xaxis.color = $.color.parse(options.grid.color).scale("a", .22).toString();
            if (options.yaxis.color == null) options.yaxis.color = $.color.parse(options.grid.color).scale("a", .22).toString();
            if (options.xaxis.tickColor == null) options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;
            if (options.yaxis.tickColor == null) options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;
            if (options.grid.borderColor == null) options.grid.borderColor = options.grid.color;
            if (options.grid.tickColor == null) options.grid.tickColor = $.color.parse(options.grid.color).scale("a", .22).toString();
            var i, axisOptions, axisCount, fontSize = placeholder.css("font-size"), fontSizeDefault = fontSize ? +fontSize.replace("px", "") : 13, fontDefaults = {
                style: placeholder.css("font-style"),
                size: Math.round(.8 * fontSizeDefault),
                variant: placeholder.css("font-variant"),
                weight: placeholder.css("font-weight"),
                family: placeholder.css("font-family")
            };
            axisCount = options.xaxes.length || 1;
            for (i = 0; i < axisCount; ++i) {
                axisOptions = options.xaxes[i];
                if (axisOptions && !axisOptions.tickColor) {
                    axisOptions.tickColor = axisOptions.color;
                }
                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);
                options.xaxes[i] = axisOptions;
                if (axisOptions.font) {
                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
                    if (!axisOptions.font.color) {
                        axisOptions.font.color = axisOptions.color;
                    }
                    if (!axisOptions.font.lineHeight) {
                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
                    }
                }
            }
            axisCount = options.yaxes.length || 1;
            for (i = 0; i < axisCount; ++i) {
                axisOptions = options.yaxes[i];
                if (axisOptions && !axisOptions.tickColor) {
                    axisOptions.tickColor = axisOptions.color;
                }
                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);
                options.yaxes[i] = axisOptions;
                if (axisOptions.font) {
                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
                    if (!axisOptions.font.color) {
                        axisOptions.font.color = axisOptions.color;
                    }
                    if (!axisOptions.font.lineHeight) {
                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
                    }
                }
            }
            if (options.xaxis.noTicks && options.xaxis.ticks == null) options.xaxis.ticks = options.xaxis.noTicks;
            if (options.yaxis.noTicks && options.yaxis.ticks == null) options.yaxis.ticks = options.yaxis.noTicks;
            if (options.x2axis) {
                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);
                options.xaxes[1].position = "top";
                if (options.x2axis.min == null) {
                    options.xaxes[1].min = null;
                }
                if (options.x2axis.max == null) {
                    options.xaxes[1].max = null;
                }
            }
            if (options.y2axis) {
                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);
                options.yaxes[1].position = "right";
                if (options.y2axis.min == null) {
                    options.yaxes[1].min = null;
                }
                if (options.y2axis.max == null) {
                    options.yaxes[1].max = null;
                }
            }
            if (options.grid.coloredAreas) options.grid.markings = options.grid.coloredAreas;
            if (options.grid.coloredAreasColor) options.grid.markingsColor = options.grid.coloredAreasColor;
            if (options.lines) $.extend(true, options.series.lines, options.lines);
            if (options.points) $.extend(true, options.series.points, options.points);
            if (options.bars) $.extend(true, options.series.bars, options.bars);
            if (options.shadowSize != null) options.series.shadowSize = options.shadowSize;
            if (options.highlightColor != null) options.series.highlightColor = options.highlightColor;
            for (i = 0; i < options.xaxes.length; ++i) getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];
            for (i = 0; i < options.yaxes.length; ++i) getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];
            for (var n in hooks) if (options.hooks[n] && options.hooks[n].length) hooks[n] = hooks[n].concat(options.hooks[n]);
            executeHooks(hooks.processOptions, [ options ]);
        }
        function setData(d) {
            series = parseData(d);
            fillInSeriesOptions();
            processData();
        }
        function parseData(d) {
            var res = [];
            for (var i = 0; i < d.length; ++i) {
                var s = $.extend(true, {}, options.series);
                if (d[i].data != null) {
                    s.data = d[i].data;
                    delete d[i].data;
                    $.extend(true, s, d[i]);
                    d[i].data = s.data;
                } else s.data = d[i];
                res.push(s);
            }
            return res;
        }
        function axisNumber(obj, coord) {
            var a = obj[coord + "axis"];
            if (typeof a == "object") a = a.n;
            if (typeof a != "number") a = 1;
            return a;
        }
        function allAxes() {
            return $.grep(xaxes.concat(yaxes), function(a) {
                return a;
            });
        }
        function canvasToAxisCoords(pos) {
            var res = {}, i, axis;
            for (i = 0; i < xaxes.length; ++i) {
                axis = xaxes[i];
                if (axis && axis.used) res["x" + axis.n] = axis.c2p(pos.left);
            }
            for (i = 0; i < yaxes.length; ++i) {
                axis = yaxes[i];
                if (axis && axis.used) res["y" + axis.n] = axis.c2p(pos.top);
            }
            if (res.x1 !== undefined) res.x = res.x1;
            if (res.y1 !== undefined) res.y = res.y1;
            return res;
        }
        function axisToCanvasCoords(pos) {
            var res = {}, i, axis, key;
            for (i = 0; i < xaxes.length; ++i) {
                axis = xaxes[i];
                if (axis && axis.used) {
                    key = "x" + axis.n;
                    if (pos[key] == null && axis.n == 1) key = "x";
                    if (pos[key] != null) {
                        res.left = axis.p2c(pos[key]);
                        break;
                    }
                }
            }
            for (i = 0; i < yaxes.length; ++i) {
                axis = yaxes[i];
                if (axis && axis.used) {
                    key = "y" + axis.n;
                    if (pos[key] == null && axis.n == 1) key = "y";
                    if (pos[key] != null) {
                        res.top = axis.p2c(pos[key]);
                        break;
                    }
                }
            }
            return res;
        }
        function getOrCreateAxis(axes, number) {
            if (!axes[number - 1]) axes[number - 1] = {
                n: number,
                direction: axes == xaxes ? "x" : "y",
                options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)
            };
            return axes[number - 1];
        }
        function fillInSeriesOptions() {
            var neededColors = series.length, maxIndex = -1, i;
            for (i = 0; i < series.length; ++i) {
                var sc = series[i].color;
                if (sc != null) {
                    neededColors--;
                    if (typeof sc == "number" && sc > maxIndex) {
                        maxIndex = sc;
                    }
                }
            }
            if (neededColors <= maxIndex) {
                neededColors = maxIndex + 1;
            }
            var c, colors = [], colorPool = options.colors, colorPoolSize = colorPool.length, variation = 0;
            for (i = 0; i < neededColors; i++) {
                c = $.color.parse(colorPool[i % colorPoolSize] || "#666");
                if (i % colorPoolSize == 0 && i) {
                    if (variation >= 0) {
                        if (variation < .5) {
                            variation = -variation - .2;
                        } else variation = 0;
                    } else variation = -variation;
                }
                colors[i] = c.scale("rgb", 1 + variation);
            }
            var colori = 0, s;
            for (i = 0; i < series.length; ++i) {
                s = series[i];
                if (s.color == null) {
                    s.color = colors[colori].toString();
                    ++colori;
                } else if (typeof s.color == "number") s.color = colors[s.color].toString();
                if (s.lines.show == null) {
                    var v, show = true;
                    for (v in s) if (s[v] && s[v].show) {
                        show = false;
                        break;
                    }
                    if (show) s.lines.show = true;
                }
                if (s.lines.zero == null) {
                    s.lines.zero = !!s.lines.fill;
                }
                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, "x"));
                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, "y"));
            }
        }
        function processData() {
            var topSentry = Number.POSITIVE_INFINITY, bottomSentry = Number.NEGATIVE_INFINITY, fakeInfinity = Number.MAX_VALUE, i, j, k, m, length, s, points, ps, x, y, axis, val, f, p, data, format;
            function updateAxis(axis, min, max) {
                if (min < axis.datamin && min != -fakeInfinity) axis.datamin = min;
                if (max > axis.datamax && max != fakeInfinity) axis.datamax = max;
            }
            $.each(allAxes(), function(_, axis) {
                axis.datamin = topSentry;
                axis.datamax = bottomSentry;
                axis.used = false;
            });
            for (i = 0; i < series.length; ++i) {
                s = series[i];
                s.datapoints = {
                    points: []
                };
                executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);
            }
            for (i = 0; i < series.length; ++i) {
                s = series[i];
                data = s.data;
                format = s.datapoints.format;
                if (!format) {
                    format = [];
                    format.push({
                        x: true,
                        number: true,
                        required: true
                    });
                    format.push({
                        y: true,
                        number: true,
                        required: true
                    });
                    if (s.bars.show || s.lines.show && s.lines.fill) {
                        var autoscale = !!(s.bars.show && s.bars.zero || s.lines.show && s.lines.zero);
                        format.push({
                            y: true,
                            number: true,
                            required: false,
                            defaultValue: 0,
                            autoscale: autoscale
                        });
                        if (s.bars.horizontal) {
                            delete format[format.length - 1].y;
                            format[format.length - 1].x = true;
                        }
                    }
                    s.datapoints.format = format;
                }
                if (s.datapoints.pointsize != null) continue;
                s.datapoints.pointsize = format.length;
                ps = s.datapoints.pointsize;
                points = s.datapoints.points;
                var insertSteps = s.lines.show && s.lines.steps;
                s.xaxis.used = s.yaxis.used = true;
                for (j = k = 0; j < data.length; ++j, k += ps) {
                    p = data[j];
                    var nullify = p == null;
                    if (!nullify) {
                        for (m = 0; m < ps; ++m) {
                            val = p[m];
                            f = format[m];
                            if (f) {
                                if (f.number && val != null) {
                                    val = +val;
                                    if (isNaN(val)) val = null; else if (val == Infinity) val = fakeInfinity; else if (val == -Infinity) val = -fakeInfinity;
                                }
                                if (val == null) {
                                    if (f.required) nullify = true;
                                    if (f.defaultValue != null) val = f.defaultValue;
                                }
                            }
                            points[k + m] = val;
                        }
                    }
                    if (nullify) {
                        for (m = 0; m < ps; ++m) {
                            val = points[k + m];
                            if (val != null) {
                                f = format[m];
                                if (f.autoscale !== false) {
                                    if (f.x) {
                                        updateAxis(s.xaxis, val, val);
                                    }
                                    if (f.y) {
                                        updateAxis(s.yaxis, val, val);
                                    }
                                }
                            }
                            points[k + m] = null;
                        }
                    } else {
                        if (insertSteps && k > 0 && points[k - ps] != null && points[k - ps] != points[k] && points[k - ps + 1] != points[k + 1]) {
                            for (m = 0; m < ps; ++m) points[k + ps + m] = points[k + m];
                            points[k + 1] = points[k - ps + 1];
                            k += ps;
                        }
                    }
                }
            }
            for (i = 0; i < series.length; ++i) {
                s = series[i];
                executeHooks(hooks.processDatapoints, [ s, s.datapoints ]);
            }
            for (i = 0; i < series.length; ++i) {
                s = series[i];
                points = s.datapoints.points;
                ps = s.datapoints.pointsize;
                format = s.datapoints.format;
                var xmin = topSentry, ymin = topSentry, xmax = bottomSentry, ymax = bottomSentry;
                for (j = 0; j < points.length; j += ps) {
                    if (points[j] == null) continue;
                    for (m = 0; m < ps; ++m) {
                        val = points[j + m];
                        f = format[m];
                        if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity) continue;
                        if (f.x) {
                            if (val < xmin) xmin = val;
                            if (val > xmax) xmax = val;
                        }
                        if (f.y) {
                            if (val < ymin) ymin = val;
                            if (val > ymax) ymax = val;
                        }
                    }
                }
                if (s.bars.show) {
                    var delta;
                    switch (s.bars.align) {
                      case "left":
                        delta = 0;
                        break;

                      case "right":
                        delta = -s.bars.barWidth;
                        break;

                      default:
                        delta = -s.bars.barWidth / 2;
                    }
                    if (s.bars.horizontal) {
                        ymin += delta;
                        ymax += delta + s.bars.barWidth;
                    } else {
                        xmin += delta;
                        xmax += delta + s.bars.barWidth;
                    }
                }
                updateAxis(s.xaxis, xmin, xmax);
                updateAxis(s.yaxis, ymin, ymax);
            }
            $.each(allAxes(), function(_, axis) {
                if (axis.datamin == topSentry) axis.datamin = null;
                if (axis.datamax == bottomSentry) axis.datamax = null;
            });
        }
        function setupCanvases() {
            placeholder.css("padding", 0).children().filter(function() {
                return !$(this).hasClass("flot-overlay") && !$(this).hasClass("flot-base");
            }).remove();
            if (placeholder.css("position") == "static") placeholder.css("position", "relative");
            surface = new Canvas("flot-base", placeholder);
            overlay = new Canvas("flot-overlay", placeholder);
            ctx = surface.context;
            octx = overlay.context;
            eventHolder = $(overlay.element).unbind();
            var existing = placeholder.data("plot");
            if (existing) {
                existing.shutdown();
                overlay.clear();
            }
            placeholder.data("plot", plot);
        }
        function bindEvents() {
            if (options.grid.hoverable) {
                eventHolder.mousemove(onMouseMove);
                eventHolder.bind("mouseleave", onMouseLeave);
            }
            if (options.grid.clickable) eventHolder.click(onClick);
            executeHooks(hooks.bindEvents, [ eventHolder ]);
        }
        function shutdown() {
            if (redrawTimeout) clearTimeout(redrawTimeout);
            eventHolder.unbind("mousemove", onMouseMove);
            eventHolder.unbind("mouseleave", onMouseLeave);
            eventHolder.unbind("click", onClick);
            executeHooks(hooks.shutdown, [ eventHolder ]);
        }
        function setTransformationHelpers(axis) {
            function identity(x) {
                return x;
            }
            var s, m, t = axis.options.transform || identity, it = axis.options.inverseTransform;
            if (axis.direction == "x") {
                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));
                m = Math.min(t(axis.max), t(axis.min));
            } else {
                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));
                s = -s;
                m = Math.max(t(axis.max), t(axis.min));
            }
            if (t == identity) axis.p2c = function(p) {
                return (p - m) * s;
            }; else axis.p2c = function(p) {
                return (t(p) - m) * s;
            };
            if (!it) axis.c2p = function(c) {
                return m + c / s;
            }; else axis.c2p = function(c) {
                return it(m + c / s);
            };
        }
        function measureTickLabels(axis) {
            var opts = axis.options, ticks = axis.ticks || [], labelWidth = opts.labelWidth || 0, labelHeight = opts.labelHeight || 0, maxWidth = labelWidth || (axis.direction == "x" ? Math.floor(surface.width / (ticks.length || 1)) : null), legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis", layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles, font = opts.font || "flot-tick-label tickLabel";
            for (var i = 0; i < ticks.length; ++i) {
                var t = ticks[i];
                if (!t.label) continue;
                var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);
                labelWidth = Math.max(labelWidth, info.width);
                labelHeight = Math.max(labelHeight, info.height);
            }
            axis.labelWidth = opts.labelWidth || labelWidth;
            axis.labelHeight = opts.labelHeight || labelHeight;
        }
        function allocateAxisBoxFirstPhase(axis) {
            var lw = axis.labelWidth, lh = axis.labelHeight, pos = axis.options.position, isXAxis = axis.direction === "x", tickLength = axis.options.tickLength, axisMargin = options.grid.axisMargin, padding = options.grid.labelMargin, innermost = true, outermost = true, first = true, found = false;
            $.each(isXAxis ? xaxes : yaxes, function(i, a) {
                if (a && (a.show || a.reserveSpace)) {
                    if (a === axis) {
                        found = true;
                    } else if (a.options.position === pos) {
                        if (found) {
                            outermost = false;
                        } else {
                            innermost = false;
                        }
                    }
                    if (!found) {
                        first = false;
                    }
                }
            });
            if (outermost) {
                axisMargin = 0;
            }
            if (tickLength == null) {
                tickLength = first ? "full" : 5;
            }
            if (!isNaN(+tickLength)) padding += +tickLength;
            if (isXAxis) {
                lh += padding;
                if (pos == "bottom") {
                    plotOffset.bottom += lh + axisMargin;
                    axis.box = {
                        top: surface.height - plotOffset.bottom,
                        height: lh
                    };
                } else {
                    axis.box = {
                        top: plotOffset.top + axisMargin,
                        height: lh
                    };
                    plotOffset.top += lh + axisMargin;
                }
            } else {
                lw += padding;
                if (pos == "left") {
                    axis.box = {
                        left: plotOffset.left + axisMargin,
                        width: lw
                    };
                    plotOffset.left += lw + axisMargin;
                } else {
                    plotOffset.right += lw + axisMargin;
                    axis.box = {
                        left: surface.width - plotOffset.right,
                        width: lw
                    };
                }
            }
            axis.position = pos;
            axis.tickLength = tickLength;
            axis.box.padding = padding;
            axis.innermost = innermost;
        }
        function allocateAxisBoxSecondPhase(axis) {
            if (axis.direction == "x") {
                axis.box.left = plotOffset.left - axis.labelWidth / 2;
                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;
            } else {
                axis.box.top = plotOffset.top - axis.labelHeight / 2;
                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;
            }
        }
        function adjustLayoutForThingsStickingOut() {
            var minMargin = options.grid.minBorderMargin, axis, i;
            if (minMargin == null) {
                minMargin = 0;
                for (i = 0; i < series.length; ++i) minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth / 2));
            }
            var margins = {
                left: minMargin,
                right: minMargin,
                top: minMargin,
                bottom: minMargin
            };
            $.each(allAxes(), function(_, axis) {
                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {
                    if (axis.direction === "x") {
                        margins.left = Math.max(margins.left, axis.labelWidth / 2);
                        margins.right = Math.max(margins.right, axis.labelWidth / 2);
                    } else {
                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);
                        margins.top = Math.max(margins.top, axis.labelHeight / 2);
                    }
                }
            });
            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));
            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));
            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));
            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));
        }
        function setupGrid() {
            var i, axes = allAxes(), showGrid = options.grid.show;
            for (var a in plotOffset) {
                var margin = options.grid.margin || 0;
                plotOffset[a] = typeof margin == "number" ? margin : margin[a] || 0;
            }
            executeHooks(hooks.processOffset, [ plotOffset ]);
            for (var a in plotOffset) {
                if (typeof options.grid.borderWidth == "object") {
                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;
                } else {
                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;
                }
            }
            $.each(axes, function(_, axis) {
                var axisOpts = axis.options;
                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;
                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;
                setRange(axis);
            });
            if (showGrid) {
                var allocatedAxes = $.grep(axes, function(axis) {
                    return axis.show || axis.reserveSpace;
                });
                $.each(allocatedAxes, function(_, axis) {
                    setupTickGeneration(axis);
                    setTicks(axis);
                    snapRangeToTicks(axis, axis.ticks);
                    measureTickLabels(axis);
                });
                for (i = allocatedAxes.length - 1; i >= 0; --i) allocateAxisBoxFirstPhase(allocatedAxes[i]);
                adjustLayoutForThingsStickingOut();
                $.each(allocatedAxes, function(_, axis) {
                    allocateAxisBoxSecondPhase(axis);
                });
            }
            plotWidth = surface.width - plotOffset.left - plotOffset.right;
            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;
            $.each(axes, function(_, axis) {
                setTransformationHelpers(axis);
            });
            if (showGrid) {
                drawAxisLabels();
            }
            insertLegend();
        }
        function setRange(axis) {
            var opts = axis.options, min = +(opts.min != null ? opts.min : axis.datamin), max = +(opts.max != null ? opts.max : axis.datamax), delta = max - min;
            if (delta == 0) {
                var widen = max == 0 ? 1 : .01;
                if (opts.min == null) min -= widen;
                if (opts.max == null || opts.min != null) max += widen;
            } else {
                var margin = opts.autoscaleMargin;
                if (margin != null) {
                    if (opts.min == null) {
                        min -= delta * margin;
                        if (min < 0 && axis.datamin != null && axis.datamin >= 0) min = 0;
                    }
                    if (opts.max == null) {
                        max += delta * margin;
                        if (max > 0 && axis.datamax != null && axis.datamax <= 0) max = 0;
                    }
                }
            }
            axis.min = min;
            axis.max = max;
        }
        function setupTickGeneration(axis) {
            var opts = axis.options;
            var noTicks;
            if (typeof opts.ticks == "number" && opts.ticks > 0) noTicks = opts.ticks; else noTicks = .3 * Math.sqrt(axis.direction == "x" ? surface.width : surface.height);
            var delta = (axis.max - axis.min) / noTicks, dec = -Math.floor(Math.log(delta) / Math.LN10), maxDec = opts.tickDecimals;
            if (maxDec != null && dec > maxDec) {
                dec = maxDec;
            }
            var magn = Math.pow(10, -dec), norm = delta / magn, size;
            if (norm < 1.5) {
                size = 1;
            } else if (norm < 3) {
                size = 2;
                if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {
                    size = 2.5;
                    ++dec;
                }
            } else if (norm < 7.5) {
                size = 5;
            } else {
                size = 10;
            }
            size *= magn;
            if (opts.minTickSize != null && size < opts.minTickSize) {
                size = opts.minTickSize;
            }
            axis.delta = delta;
            axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);
            axis.tickSize = opts.tickSize || size;
            if (opts.mode == "time" && !axis.tickGenerator) {
                throw new Error("Time mode requires the flot.time plugin.");
            }
            if (!axis.tickGenerator) {
                axis.tickGenerator = function(axis) {
                    var ticks = [], start = floorInBase(axis.min, axis.tickSize), i = 0, v = Number.NaN, prev;
                    do {
                        prev = v;
                        v = start + i * axis.tickSize;
                        ticks.push(v);
                        ++i;
                    } while (v < axis.max && v != prev);
                    return ticks;
                };
                axis.tickFormatter = function(value, axis) {
                    var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;
                    var formatted = "" + Math.round(value * factor) / factor;
                    if (axis.tickDecimals != null) {
                        var decimal = formatted.indexOf(".");
                        var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;
                        if (precision < axis.tickDecimals) {
                            return (precision ? formatted : formatted + ".") + ("" + factor).substr(1, axis.tickDecimals - precision);
                        }
                    }
                    return formatted;
                };
            }
            if ($.isFunction(opts.tickFormatter)) axis.tickFormatter = function(v, axis) {
                return "" + opts.tickFormatter(v, axis);
            };
            if (opts.alignTicksWithAxis != null) {
                var otherAxis = (axis.direction == "x" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];
                if (otherAxis && otherAxis.used && otherAxis != axis) {
                    var niceTicks = axis.tickGenerator(axis);
                    if (niceTicks.length > 0) {
                        if (opts.min == null) axis.min = Math.min(axis.min, niceTicks[0]);
                        if (opts.max == null && niceTicks.length > 1) axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);
                    }
                    axis.tickGenerator = function(axis) {
                        var ticks = [], v, i;
                        for (i = 0; i < otherAxis.ticks.length; ++i) {
                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);
                            v = axis.min + v * (axis.max - axis.min);
                            ticks.push(v);
                        }
                        return ticks;
                    };
                    if (!axis.mode && opts.tickDecimals == null) {
                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1), ts = axis.tickGenerator(axis);
                        if (!(ts.length > 1 && /\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec)))) axis.tickDecimals = extraDec;
                    }
                }
            }
        }
        function setTicks(axis) {
            var oticks = axis.options.ticks, ticks = [];
            if (oticks == null || typeof oticks == "number" && oticks > 0) ticks = axis.tickGenerator(axis); else if (oticks) {
                if ($.isFunction(oticks)) ticks = oticks(axis); else ticks = oticks;
            }
            var i, v;
            axis.ticks = [];
            for (i = 0; i < ticks.length; ++i) {
                var label = null;
                var t = ticks[i];
                if (typeof t == "object") {
                    v = +t[0];
                    if (t.length > 1) label = t[1];
                } else v = +t;
                if (label == null) label = axis.tickFormatter(v, axis);
                if (!isNaN(v)) axis.ticks.push({
                    v: v,
                    label: label
                });
            }
        }
        function snapRangeToTicks(axis, ticks) {
            if (axis.options.autoscaleMargin && ticks.length > 0) {
                if (axis.options.min == null) axis.min = Math.min(axis.min, ticks[0].v);
                if (axis.options.max == null && ticks.length > 1) axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);
            }
        }
        function draw() {
            surface.clear();
            executeHooks(hooks.drawBackground, [ ctx ]);
            var grid = options.grid;
            if (grid.show && grid.backgroundColor) drawBackground();
            if (grid.show && !grid.aboveData) {
                drawGrid();
            }
            for (var i = 0; i < series.length; ++i) {
                executeHooks(hooks.drawSeries, [ ctx, series[i] ]);
                drawSeries(series[i]);
            }
            executeHooks(hooks.draw, [ ctx ]);
            if (grid.show && grid.aboveData) {
                drawGrid();
            }
            surface.render();
            triggerRedrawOverlay();
        }
        function extractRange(ranges, coord) {
            var axis, from, to, key, axes = allAxes();
            for (var i = 0; i < axes.length; ++i) {
                axis = axes[i];
                if (axis.direction == coord) {
                    key = coord + axis.n + "axis";
                    if (!ranges[key] && axis.n == 1) key = coord + "axis";
                    if (ranges[key]) {
                        from = ranges[key].from;
                        to = ranges[key].to;
                        break;
                    }
                }
            }
            if (!ranges[key]) {
                axis = coord == "x" ? xaxes[0] : yaxes[0];
                from = ranges[coord + "1"];
                to = ranges[coord + "2"];
            }
            if (from != null && to != null && from > to) {
                var tmp = from;
                from = to;
                to = tmp;
            }
            return {
                from: from,
                to: to,
                axis: axis
            };
        }
        function drawBackground() {
            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);
            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, "rgba(255, 255, 255, 0)");
            ctx.fillRect(0, 0, plotWidth, plotHeight);
            ctx.restore();
        }
        function drawGrid() {
            var i, axes, bw, bc;
            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);
            var markings = options.grid.markings;
            if (markings) {
                if ($.isFunction(markings)) {
                    axes = plot.getAxes();
                    axes.xmin = axes.xaxis.min;
                    axes.xmax = axes.xaxis.max;
                    axes.ymin = axes.yaxis.min;
                    axes.ymax = axes.yaxis.max;
                    markings = markings(axes);
                }
                for (i = 0; i < markings.length; ++i) {
                    var m = markings[i], xrange = extractRange(m, "x"), yrange = extractRange(m, "y");
                    if (xrange.from == null) xrange.from = xrange.axis.min;
                    if (xrange.to == null) xrange.to = xrange.axis.max;
                    if (yrange.from == null) yrange.from = yrange.axis.min;
                    if (yrange.to == null) yrange.to = yrange.axis.max;
                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max || yrange.to < yrange.axis.min || yrange.from > yrange.axis.max) continue;
                    xrange.from = Math.max(xrange.from, xrange.axis.min);
                    xrange.to = Math.min(xrange.to, xrange.axis.max);
                    yrange.from = Math.max(yrange.from, yrange.axis.min);
                    yrange.to = Math.min(yrange.to, yrange.axis.max);
                    var xequal = xrange.from === xrange.to, yequal = yrange.from === yrange.to;
                    if (xequal && yequal) {
                        continue;
                    }
                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));
                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));
                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));
                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));
                    if (xequal || yequal) {
                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth, subPixel = lineWidth % 2 ? .5 : 0;
                        ctx.beginPath();
                        ctx.strokeStyle = m.color || options.grid.markingsColor;
                        ctx.lineWidth = lineWidth;
                        if (xequal) {
                            ctx.moveTo(xrange.to + subPixel, yrange.from);
                            ctx.lineTo(xrange.to + subPixel, yrange.to);
                        } else {
                            ctx.moveTo(xrange.from, yrange.to + subPixel);
                            ctx.lineTo(xrange.to, yrange.to + subPixel);
                        }
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = m.color || options.grid.markingsColor;
                        ctx.fillRect(xrange.from, yrange.to, xrange.to - xrange.from, yrange.from - yrange.to);
                    }
                }
            }
            axes = allAxes();
            bw = options.grid.borderWidth;
            for (var j = 0; j < axes.length; ++j) {
                var axis = axes[j], box = axis.box, t = axis.tickLength, x, y, xoff, yoff;
                if (!axis.show || axis.ticks.length == 0) continue;
                ctx.lineWidth = 1;
                if (axis.direction == "x") {
                    x = 0;
                    if (t == "full") y = axis.position == "top" ? 0 : plotHeight; else y = box.top - plotOffset.top + (axis.position == "top" ? box.height : 0);
                } else {
                    y = 0;
                    if (t == "full") x = axis.position == "left" ? 0 : plotWidth; else x = box.left - plotOffset.left + (axis.position == "left" ? box.width : 0);
                }
                if (!axis.innermost) {
                    ctx.strokeStyle = axis.options.color;
                    ctx.beginPath();
                    xoff = yoff = 0;
                    if (axis.direction == "x") xoff = plotWidth + 1; else yoff = plotHeight + 1;
                    if (ctx.lineWidth == 1) {
                        if (axis.direction == "x") {
                            y = Math.floor(y) + .5;
                        } else {
                            x = Math.floor(x) + .5;
                        }
                    }
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + xoff, y + yoff);
                    ctx.stroke();
                }
                ctx.strokeStyle = axis.options.tickColor;
                ctx.beginPath();
                for (i = 0; i < axis.ticks.length; ++i) {
                    var v = axis.ticks[i].v;
                    xoff = yoff = 0;
                    if (isNaN(v) || v < axis.min || v > axis.max || t == "full" && (typeof bw == "object" && bw[axis.position] > 0 || bw > 0) && (v == axis.min || v == axis.max)) continue;
                    if (axis.direction == "x") {
                        x = axis.p2c(v);
                        yoff = t == "full" ? -plotHeight : t;
                        if (axis.position == "top") yoff = -yoff;
                    } else {
                        y = axis.p2c(v);
                        xoff = t == "full" ? -plotWidth : t;
                        if (axis.position == "left") xoff = -xoff;
                    }
                    if (ctx.lineWidth == 1) {
                        if (axis.direction == "x") x = Math.floor(x) + .5; else y = Math.floor(y) + .5;
                    }
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + xoff, y + yoff);
                }
                ctx.stroke();
            }
            if (bw) {
                bc = options.grid.borderColor;
                if (typeof bw == "object" || typeof bc == "object") {
                    if (typeof bw !== "object") {
                        bw = {
                            top: bw,
                            right: bw,
                            bottom: bw,
                            left: bw
                        };
                    }
                    if (typeof bc !== "object") {
                        bc = {
                            top: bc,
                            right: bc,
                            bottom: bc,
                            left: bc
                        };
                    }
                    if (bw.top > 0) {
                        ctx.strokeStyle = bc.top;
                        ctx.lineWidth = bw.top;
                        ctx.beginPath();
                        ctx.moveTo(0 - bw.left, 0 - bw.top / 2);
                        ctx.lineTo(plotWidth, 0 - bw.top / 2);
                        ctx.stroke();
                    }
                    if (bw.right > 0) {
                        ctx.strokeStyle = bc.right;
                        ctx.lineWidth = bw.right;
                        ctx.beginPath();
                        ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);
                        ctx.lineTo(plotWidth + bw.right / 2, plotHeight);
                        ctx.stroke();
                    }
                    if (bw.bottom > 0) {
                        ctx.strokeStyle = bc.bottom;
                        ctx.lineWidth = bw.bottom;
                        ctx.beginPath();
                        ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);
                        ctx.lineTo(0, plotHeight + bw.bottom / 2);
                        ctx.stroke();
                    }
                    if (bw.left > 0) {
                        ctx.strokeStyle = bc.left;
                        ctx.lineWidth = bw.left;
                        ctx.beginPath();
                        ctx.moveTo(0 - bw.left / 2, plotHeight + bw.bottom);
                        ctx.lineTo(0 - bw.left / 2, 0);
                        ctx.stroke();
                    }
                } else {
                    ctx.lineWidth = bw;
                    ctx.strokeStyle = options.grid.borderColor;
                    ctx.strokeRect(-bw / 2, -bw / 2, plotWidth + bw, plotHeight + bw);
                }
            }
            ctx.restore();
        }
        function drawAxisLabels() {
            $.each(allAxes(), function(_, axis) {
                var box = axis.box, legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis", layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles, font = axis.options.font || "flot-tick-label tickLabel", tick, x, y, halign, valign;
                surface.removeText(layer);
                if (!axis.show || axis.ticks.length == 0) return;
                for (var i = 0; i < axis.ticks.length; ++i) {
                    tick = axis.ticks[i];
                    if (!tick.label || tick.v < axis.min || tick.v > axis.max) continue;
                    if (axis.direction == "x") {
                        halign = "center";
                        x = plotOffset.left + axis.p2c(tick.v);
                        if (axis.position == "bottom") {
                            y = box.top + box.padding;
                        } else {
                            y = box.top + box.height - box.padding;
                            valign = "bottom";
                        }
                    } else {
                        valign = "middle";
                        y = plotOffset.top + axis.p2c(tick.v);
                        if (axis.position == "left") {
                            x = box.left + box.width - box.padding;
                            halign = "right";
                        } else {
                            x = box.left + box.padding;
                        }
                    }
                    surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);
                }
            });
        }
        function drawSeries(series) {
            if (series.lines.show) drawSeriesLines(series);
            if (series.bars.show) drawSeriesBars(series);
            if (series.points.show) drawSeriesPoints(series);
        }
        function drawSeriesLines(series) {
            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {
                var points = datapoints.points, ps = datapoints.pointsize, prevx = null, prevy = null;
                ctx.beginPath();
                for (var i = ps; i < points.length; i += ps) {
                    var x1 = points[i - ps], y1 = points[i - ps + 1], x2 = points[i], y2 = points[i + 1];
                    if (x1 == null || x2 == null) continue;
                    if (y1 <= y2 && y1 < axisy.min) {
                        if (y2 < axisy.min) continue;
                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.min;
                    } else if (y2 <= y1 && y2 < axisy.min) {
                        if (y1 < axisy.min) continue;
                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.min;
                    }
                    if (y1 >= y2 && y1 > axisy.max) {
                        if (y2 > axisy.max) continue;
                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.max;
                    } else if (y2 >= y1 && y2 > axisy.max) {
                        if (y1 > axisy.max) continue;
                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.max;
                    }
                    if (x1 <= x2 && x1 < axisx.min) {
                        if (x2 < axisx.min) continue;
                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.min;
                    } else if (x2 <= x1 && x2 < axisx.min) {
                        if (x1 < axisx.min) continue;
                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.min;
                    }
                    if (x1 >= x2 && x1 > axisx.max) {
                        if (x2 > axisx.max) continue;
                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.max;
                    } else if (x2 >= x1 && x2 > axisx.max) {
                        if (x1 > axisx.max) continue;
                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.max;
                    }
                    if (x1 != prevx || y1 != prevy) ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);
                    prevx = x2;
                    prevy = y2;
                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);
                }
                ctx.stroke();
            }
            function plotLineArea(datapoints, axisx, axisy) {
                var points = datapoints.points, ps = datapoints.pointsize, bottom = Math.min(Math.max(0, axisy.min), axisy.max), i = 0, top, areaOpen = false, ypos = 1, segmentStart = 0, segmentEnd = 0;
                while (true) {
                    if (ps > 0 && i > points.length + ps) break;
                    i += ps;
                    var x1 = points[i - ps], y1 = points[i - ps + ypos], x2 = points[i], y2 = points[i + ypos];
                    if (areaOpen) {
                        if (ps > 0 && x1 != null && x2 == null) {
                            segmentEnd = i;
                            ps = -ps;
                            ypos = 2;
                            continue;
                        }
                        if (ps < 0 && i == segmentStart + ps) {
                            ctx.fill();
                            areaOpen = false;
                            ps = -ps;
                            ypos = 1;
                            i = segmentStart = segmentEnd + ps;
                            continue;
                        }
                    }
                    if (x1 == null || x2 == null) continue;
                    if (x1 <= x2 && x1 < axisx.min) {
                        if (x2 < axisx.min) continue;
                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.min;
                    } else if (x2 <= x1 && x2 < axisx.min) {
                        if (x1 < axisx.min) continue;
                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.min;
                    }
                    if (x1 >= x2 && x1 > axisx.max) {
                        if (x2 > axisx.max) continue;
                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.max;
                    } else if (x2 >= x1 && x2 > axisx.max) {
                        if (x1 > axisx.max) continue;
                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.max;
                    }
                    if (!areaOpen) {
                        ctx.beginPath();
                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));
                        areaOpen = true;
                    }
                    if (y1 >= axisy.max && y2 >= axisy.max) {
                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));
                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));
                        continue;
                    } else if (y1 <= axisy.min && y2 <= axisy.min) {
                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));
                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));
                        continue;
                    }
                    var x1old = x1, x2old = x2;
                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {
                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.min;
                    } else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {
                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.min;
                    }
                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {
                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.max;
                    } else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {
                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.max;
                    }
                    if (x1 != x1old) {
                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));
                    }
                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));
                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
                    if (x2 != x2old) {
                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));
                    }
                }
            }
            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);
            ctx.lineJoin = "round";
            var lw = series.lines.lineWidth, sw = series.shadowSize;
            if (lw > 0 && sw > 0) {
                ctx.lineWidth = sw;
                ctx.strokeStyle = "rgba(0,0,0,0.1)";
                var angle = Math.PI / 18;
                plotLine(series.datapoints, Math.sin(angle) * (lw / 2 + sw / 2), Math.cos(angle) * (lw / 2 + sw / 2), series.xaxis, series.yaxis);
                ctx.lineWidth = sw / 2;
                plotLine(series.datapoints, Math.sin(angle) * (lw / 2 + sw / 4), Math.cos(angle) * (lw / 2 + sw / 4), series.xaxis, series.yaxis);
            }
            ctx.lineWidth = lw;
            ctx.strokeStyle = series.color;
            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);
            if (fillStyle) {
                ctx.fillStyle = fillStyle;
                plotLineArea(series.datapoints, series.xaxis, series.yaxis);
            }
            if (lw > 0) plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);
            ctx.restore();
        }
        function drawSeriesPoints(series) {
            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {
                var points = datapoints.points, ps = datapoints.pointsize;
                for (var i = 0; i < points.length; i += ps) {
                    var x = points[i], y = points[i + 1];
                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) continue;
                    ctx.beginPath();
                    x = axisx.p2c(x);
                    y = axisy.p2c(y) + offset;
                    if (symbol == "circle") ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false); else symbol(ctx, x, y, radius, shadow);
                    ctx.closePath();
                    if (fillStyle) {
                        ctx.fillStyle = fillStyle;
                        ctx.fill();
                    }
                    ctx.stroke();
                }
            }
            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);
            var lw = series.points.lineWidth, sw = series.shadowSize, radius = series.points.radius, symbol = series.points.symbol;
            if (lw == 0) lw = 1e-4;
            if (lw > 0 && sw > 0) {
                var w = sw / 2;
                ctx.lineWidth = w;
                ctx.strokeStyle = "rgba(0,0,0,0.1)";
                plotPoints(series.datapoints, radius, null, w + w / 2, true, series.xaxis, series.yaxis, symbol);
                ctx.strokeStyle = "rgba(0,0,0,0.2)";
                plotPoints(series.datapoints, radius, null, w / 2, true, series.xaxis, series.yaxis, symbol);
            }
            ctx.lineWidth = lw;
            ctx.strokeStyle = series.color;
            plotPoints(series.datapoints, radius, getFillStyle(series.points, series.color), 0, false, series.xaxis, series.yaxis, symbol);
            ctx.restore();
        }
        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {
            var left, right, bottom, top, drawLeft, drawRight, drawTop, drawBottom, tmp;
            if (horizontal) {
                drawBottom = drawRight = drawTop = true;
                drawLeft = false;
                left = b;
                right = x;
                top = y + barLeft;
                bottom = y + barRight;
                if (right < left) {
                    tmp = right;
                    right = left;
                    left = tmp;
                    drawLeft = true;
                    drawRight = false;
                }
            } else {
                drawLeft = drawRight = drawTop = true;
                drawBottom = false;
                left = x + barLeft;
                right = x + barRight;
                bottom = b;
                top = y;
                if (top < bottom) {
                    tmp = top;
                    top = bottom;
                    bottom = tmp;
                    drawBottom = true;
                    drawTop = false;
                }
            }
            if (right < axisx.min || left > axisx.max || top < axisy.min || bottom > axisy.max) return;
            if (left < axisx.min) {
                left = axisx.min;
                drawLeft = false;
            }
            if (right > axisx.max) {
                right = axisx.max;
                drawRight = false;
            }
            if (bottom < axisy.min) {
                bottom = axisy.min;
                drawBottom = false;
            }
            if (top > axisy.max) {
                top = axisy.max;
                drawTop = false;
            }
            left = axisx.p2c(left);
            bottom = axisy.p2c(bottom);
            right = axisx.p2c(right);
            top = axisy.p2c(top);
            if (fillStyleCallback) {
                c.fillStyle = fillStyleCallback(bottom, top);
                c.fillRect(left, top, right - left, bottom - top);
            }
            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {
                c.beginPath();
                c.moveTo(left, bottom);
                if (drawLeft) c.lineTo(left, top); else c.moveTo(left, top);
                if (drawTop) c.lineTo(right, top); else c.moveTo(right, top);
                if (drawRight) c.lineTo(right, bottom); else c.moveTo(right, bottom);
                if (drawBottom) c.lineTo(left, bottom); else c.moveTo(left, bottom);
                c.stroke();
            }
        }
        function drawSeriesBars(series) {
            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {
                var points = datapoints.points, ps = datapoints.pointsize;
                for (var i = 0; i < points.length; i += ps) {
                    if (points[i] == null) continue;
                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);
                }
            }
            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);
            ctx.lineWidth = series.bars.lineWidth;
            ctx.strokeStyle = series.color;
            var barLeft;
            switch (series.bars.align) {
              case "left":
                barLeft = 0;
                break;

              case "right":
                barLeft = -series.bars.barWidth;
                break;

              default:
                barLeft = -series.bars.barWidth / 2;
            }
            var fillStyleCallback = series.bars.fill ? function(bottom, top) {
                return getFillStyle(series.bars, series.color, bottom, top);
            } : null;
            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);
            ctx.restore();
        }
        function getFillStyle(filloptions, seriesColor, bottom, top) {
            var fill = filloptions.fill;
            if (!fill) return null;
            if (filloptions.fillColor) return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);
            var c = $.color.parse(seriesColor);
            c.a = typeof fill == "number" ? fill : .4;
            c.normalize();
            return c.toString();
        }
        function insertLegend() {
            if (options.legend.container != null) {
                $(options.legend.container).html("");
            } else {
                placeholder.find(".legend").remove();
            }
            if (!options.legend.show) {
                return;
            }
            var fragments = [], entries = [], rowStarted = false, lf = options.legend.labelFormatter, s, label;
            for (var i = 0; i < series.length; ++i) {
                s = series[i];
                if (s.label) {
                    label = lf ? lf(s.label, s) : s.label;
                    if (label) {
                        entries.push({
                            label: label,
                            color: s.color
                        });
                    }
                }
            }
            if (options.legend.sorted) {
                if ($.isFunction(options.legend.sorted)) {
                    entries.sort(options.legend.sorted);
                } else if (options.legend.sorted == "reverse") {
                    entries.reverse();
                } else {
                    var ascending = options.legend.sorted != "descending";
                    entries.sort(function(a, b) {
                        return a.label == b.label ? 0 : a.label < b.label != ascending ? 1 : -1;
                    });
                }
            }
            for (var i = 0; i < entries.length; ++i) {
                var entry = entries[i];
                if (i % options.legend.noColumns == 0) {
                    if (rowStarted) fragments.push("</tr>");
                    fragments.push("<tr>");
                    rowStarted = true;
                }
                fragments.push('<td class="legendColorBox"><div style="border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px"><div style="width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden"></div></div></td>' + '<td class="legendLabel">' + entry.label + "</td>");
            }
            if (rowStarted) fragments.push("</tr>");
            if (fragments.length == 0) return;
            var table = '<table style="font-size:smaller;color:' + options.grid.color + '">' + fragments.join("") + "</table>";
            if (options.legend.container != null) $(options.legend.container).html(table); else {
                var pos = "", p = options.legend.position, m = options.legend.margin;
                if (m[0] == null) m = [ m, m ];
                if (p.charAt(0) == "n") pos += "top:" + (m[1] + plotOffset.top) + "px;"; else if (p.charAt(0) == "s") pos += "bottom:" + (m[1] + plotOffset.bottom) + "px;";
                if (p.charAt(1) == "e") pos += "right:" + (m[0] + plotOffset.right) + "px;"; else if (p.charAt(1) == "w") pos += "left:" + (m[0] + plotOffset.left) + "px;";
                var legend = $('<div class="legend">' + table.replace('style="', 'style="position:absolute;' + pos + ";") + "</div>").appendTo(placeholder);
                if (options.legend.backgroundOpacity != 0) {
                    var c = options.legend.backgroundColor;
                    if (c == null) {
                        c = options.grid.backgroundColor;
                        if (c && typeof c == "string") c = $.color.parse(c); else c = $.color.extract(legend, "background-color");
                        c.a = 1;
                        c = c.toString();
                    }
                    var div = legend.children();
                    $('<div style="position:absolute;width:' + div.width() + "px;height:" + div.height() + "px;" + pos + "background-color:" + c + ';"> </div>').prependTo(legend).css("opacity", options.legend.backgroundOpacity);
                }
            }
        }
        var highlights = [], redrawTimeout = null;
        function findNearbyItem(mouseX, mouseY, seriesFilter) {
            var maxDistance = options.grid.mouseActiveRadius, smallestDistance = maxDistance * maxDistance + 1, item = null, foundPoint = false, i, j, ps;
            for (i = series.length - 1; i >= 0; --i) {
                if (!seriesFilter(series[i])) continue;
                var s = series[i], axisx = s.xaxis, axisy = s.yaxis, points = s.datapoints.points, mx = axisx.c2p(mouseX), my = axisy.c2p(mouseY), maxx = maxDistance / axisx.scale, maxy = maxDistance / axisy.scale;
                ps = s.datapoints.pointsize;
                if (axisx.options.inverseTransform) maxx = Number.MAX_VALUE;
                if (axisy.options.inverseTransform) maxy = Number.MAX_VALUE;
                if (s.lines.show || s.points.show) {
                    for (j = 0; j < points.length; j += ps) {
                        var x = points[j], y = points[j + 1];
                        if (x == null) continue;
                        if (x - mx > maxx || x - mx < -maxx || y - my > maxy || y - my < -maxy) continue;
                        var dx = Math.abs(axisx.p2c(x) - mouseX), dy = Math.abs(axisy.p2c(y) - mouseY), dist = dx * dx + dy * dy;
                        if (dist < smallestDistance) {
                            smallestDistance = dist;
                            item = [ i, j / ps ];
                        }
                    }
                }
                if (s.bars.show && !item) {
                    var barLeft, barRight;
                    switch (s.bars.align) {
                      case "left":
                        barLeft = 0;
                        break;

                      case "right":
                        barLeft = -s.bars.barWidth;
                        break;

                      default:
                        barLeft = -s.bars.barWidth / 2;
                    }
                    barRight = barLeft + s.bars.barWidth;
                    for (j = 0; j < points.length; j += ps) {
                        var x = points[j], y = points[j + 1], b = points[j + 2];
                        if (x == null) continue;
                        if (series[i].bars.horizontal ? mx <= Math.max(b, x) && mx >= Math.min(b, x) && my >= y + barLeft && my <= y + barRight : mx >= x + barLeft && mx <= x + barRight && my >= Math.min(b, y) && my <= Math.max(b, y)) item = [ i, j / ps ];
                    }
                }
            }
            if (item) {
                i = item[0];
                j = item[1];
                ps = series[i].datapoints.pointsize;
                return {
                    datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),
                    dataIndex: j,
                    series: series[i],
                    seriesIndex: i
                };
            }
            return null;
        }
        function onMouseMove(e) {
            if (options.grid.hoverable) triggerClickHoverEvent("plothover", e, function(s) {
                return s["hoverable"] != false;
            });
        }
        function onMouseLeave(e) {
            if (options.grid.hoverable) triggerClickHoverEvent("plothover", e, function(s) {
                return false;
            });
        }
        function onClick(e) {
            triggerClickHoverEvent("plotclick", e, function(s) {
                return s["clickable"] != false;
            });
        }
        function triggerClickHoverEvent(eventname, event, seriesFilter) {
            var offset = eventHolder.offset(), canvasX = event.pageX - offset.left - plotOffset.left, canvasY = event.pageY - offset.top - plotOffset.top, pos = canvasToAxisCoords({
                left: canvasX,
                top: canvasY
            });
            pos.pageX = event.pageX;
            pos.pageY = event.pageY;
            var item = findNearbyItem(canvasX, canvasY, seriesFilter);
            if (item) {
                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);
                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);
            }
            if (options.grid.autoHighlight) {
                for (var i = 0; i < highlights.length; ++i) {
                    var h = highlights[i];
                    if (h.auto == eventname && !(item && h.series == item.series && h.point[0] == item.datapoint[0] && h.point[1] == item.datapoint[1])) unhighlight(h.series, h.point);
                }
                if (item) highlight(item.series, item.datapoint, eventname);
            }
            placeholder.trigger(eventname, [ pos, item ]);
        }
        function triggerRedrawOverlay() {
            var t = options.interaction.redrawOverlayInterval;
            if (t == -1) {
                drawOverlay();
                return;
            }
            if (!redrawTimeout) redrawTimeout = setTimeout(drawOverlay, t);
        }
        function drawOverlay() {
            redrawTimeout = null;
            octx.save();
            overlay.clear();
            octx.translate(plotOffset.left, plotOffset.top);
            var i, hi;
            for (i = 0; i < highlights.length; ++i) {
                hi = highlights[i];
                if (hi.series.bars.show) drawBarHighlight(hi.series, hi.point); else drawPointHighlight(hi.series, hi.point);
            }
            octx.restore();
            executeHooks(hooks.drawOverlay, [ octx ]);
        }
        function highlight(s, point, auto) {
            if (typeof s == "number") s = series[s];
            if (typeof point == "number") {
                var ps = s.datapoints.pointsize;
                point = s.datapoints.points.slice(ps * point, ps * (point + 1));
            }
            var i = indexOfHighlight(s, point);
            if (i == -1) {
                highlights.push({
                    series: s,
                    point: point,
                    auto: auto
                });
                triggerRedrawOverlay();
            } else if (!auto) highlights[i].auto = false;
        }
        function unhighlight(s, point) {
            if (s == null && point == null) {
                highlights = [];
                triggerRedrawOverlay();
                return;
            }
            if (typeof s == "number") s = series[s];
            if (typeof point == "number") {
                var ps = s.datapoints.pointsize;
                point = s.datapoints.points.slice(ps * point, ps * (point + 1));
            }
            var i = indexOfHighlight(s, point);
            if (i != -1) {
                highlights.splice(i, 1);
                triggerRedrawOverlay();
            }
        }
        function indexOfHighlight(s, p) {
            for (var i = 0; i < highlights.length; ++i) {
                var h = highlights[i];
                if (h.series == s && h.point[0] == p[0] && h.point[1] == p[1]) return i;
            }
            return -1;
        }
        function drawPointHighlight(series, point) {
            var x = point[0], y = point[1], axisx = series.xaxis, axisy = series.yaxis, highlightColor = typeof series.highlightColor === "string" ? series.highlightColor : $.color.parse(series.color).scale("a", .5).toString();
            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) return;
            var pointRadius = series.points.radius + series.points.lineWidth / 2;
            octx.lineWidth = pointRadius;
            octx.strokeStyle = highlightColor;
            var radius = 1.5 * pointRadius;
            x = axisx.p2c(x);
            y = axisy.p2c(y);
            octx.beginPath();
            if (series.points.symbol == "circle") octx.arc(x, y, radius, 0, 2 * Math.PI, false); else series.points.symbol(octx, x, y, radius, false);
            octx.closePath();
            octx.stroke();
        }
        function drawBarHighlight(series, point) {
            var highlightColor = typeof series.highlightColor === "string" ? series.highlightColor : $.color.parse(series.color).scale("a", .5).toString(), fillStyle = highlightColor, barLeft;
            switch (series.bars.align) {
              case "left":
                barLeft = 0;
                break;

              case "right":
                barLeft = -series.bars.barWidth;
                break;

              default:
                barLeft = -series.bars.barWidth / 2;
            }
            octx.lineWidth = series.bars.lineWidth;
            octx.strokeStyle = highlightColor;
            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth, function() {
                return fillStyle;
            }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);
        }
        function getColorOrGradient(spec, bottom, top, defaultColor) {
            if (typeof spec == "string") return spec; else {
                var gradient = ctx.createLinearGradient(0, top, 0, bottom);
                for (var i = 0, l = spec.colors.length; i < l; ++i) {
                    var c = spec.colors[i];
                    if (typeof c != "string") {
                        var co = $.color.parse(defaultColor);
                        if (c.brightness != null) co = co.scale("rgb", c.brightness);
                        if (c.opacity != null) co.a *= c.opacity;
                        c = co.toString();
                    }
                    gradient.addColorStop(i / (l - 1), c);
                }
                return gradient;
            }
        }
    }
    $.plot = function(placeholder, data, options) {
        var plot = new Plot($(placeholder), data, options, $.plot.plugins);
        return plot;
    };
    $.plot.version = "0.8.3";
    $.plot.plugins = [];
    $.fn.plot = function(data, options) {
        return this.each(function() {
            $.plot(this, data, options);
        });
    };
    function floorInBase(n, base) {
        return base * Math.floor(n / base);
    }
})(jQuery);

(function($) {
    var options = {
        xaxis: {
            timezone: null,
            timeformat: null,
            twelveHourClock: false,
            monthNames: null
        }
    };
    function floorInBase(n, base) {
        return base * Math.floor(n / base);
    }
    function formatDate(d, fmt, monthNames, dayNames) {
        if (typeof d.strftime == "function") {
            return d.strftime(fmt);
        }
        var leftPad = function(n, pad) {
            n = "" + n;
            pad = "" + (pad == null ? "0" : pad);
            return n.length == 1 ? pad + n : n;
        };
        var r = [];
        var escape = false;
        var hours = d.getHours();
        var isAM = hours < 12;
        if (monthNames == null) {
            monthNames = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
        }
        if (dayNames == null) {
            dayNames = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ];
        }
        var hours12;
        if (hours > 12) {
            hours12 = hours - 12;
        } else if (hours == 0) {
            hours12 = 12;
        } else {
            hours12 = hours;
        }
        for (var i = 0; i < fmt.length; ++i) {
            var c = fmt.charAt(i);
            if (escape) {
                switch (c) {
                  case "a":
                    c = "" + dayNames[d.getDay()];
                    break;

                  case "b":
                    c = "" + monthNames[d.getMonth()];
                    break;

                  case "d":
                    c = leftPad(d.getDate());
                    break;

                  case "e":
                    c = leftPad(d.getDate(), " ");
                    break;

                  case "h":
                  case "H":
                    c = leftPad(hours);
                    break;

                  case "I":
                    c = leftPad(hours12);
                    break;

                  case "l":
                    c = leftPad(hours12, " ");
                    break;

                  case "m":
                    c = leftPad(d.getMonth() + 1);
                    break;

                  case "M":
                    c = leftPad(d.getMinutes());
                    break;

                  case "q":
                    c = "" + (Math.floor(d.getMonth() / 3) + 1);
                    break;

                  case "S":
                    c = leftPad(d.getSeconds());
                    break;

                  case "y":
                    c = leftPad(d.getFullYear() % 100);
                    break;

                  case "Y":
                    c = "" + d.getFullYear();
                    break;

                  case "p":
                    c = isAM ? "" + "am" : "" + "pm";
                    break;

                  case "P":
                    c = isAM ? "" + "AM" : "" + "PM";
                    break;

                  case "w":
                    c = "" + d.getDay();
                    break;
                }
                r.push(c);
                escape = false;
            } else {
                if (c == "%") {
                    escape = true;
                } else {
                    r.push(c);
                }
            }
        }
        return r.join("");
    }
    function makeUtcWrapper(d) {
        function addProxyMethod(sourceObj, sourceMethod, targetObj, targetMethod) {
            sourceObj[sourceMethod] = function() {
                return targetObj[targetMethod].apply(targetObj, arguments);
            };
        }
        var utc = {
            date: d
        };
        if (d.strftime != undefined) {
            addProxyMethod(utc, "strftime", d, "strftime");
        }
        addProxyMethod(utc, "getTime", d, "getTime");
        addProxyMethod(utc, "setTime", d, "setTime");
        var props = [ "Date", "Day", "FullYear", "Hours", "Milliseconds", "Minutes", "Month", "Seconds" ];
        for (var p = 0; p < props.length; p++) {
            addProxyMethod(utc, "get" + props[p], d, "getUTC" + props[p]);
            addProxyMethod(utc, "set" + props[p], d, "setUTC" + props[p]);
        }
        return utc;
    }
    function dateGenerator(ts, opts) {
        if (opts.timezone == "browser") {
            return new Date(ts);
        } else if (!opts.timezone || opts.timezone == "utc") {
            return makeUtcWrapper(new Date(ts));
        } else if (typeof timezoneJS != "undefined" && typeof timezoneJS.Date != "undefined") {
            var d = new timezoneJS.Date();
            d.setTimezone(opts.timezone);
            d.setTime(ts);
            return d;
        } else {
            return makeUtcWrapper(new Date(ts));
        }
    }
    var timeUnitSize = {
        second: 1e3,
        minute: 60 * 1e3,
        hour: 60 * 60 * 1e3,
        day: 24 * 60 * 60 * 1e3,
        month: 30 * 24 * 60 * 60 * 1e3,
        quarter: 3 * 30 * 24 * 60 * 60 * 1e3,
        year: 365.2425 * 24 * 60 * 60 * 1e3
    };
    var baseSpec = [ [ 1, "second" ], [ 2, "second" ], [ 5, "second" ], [ 10, "second" ], [ 30, "second" ], [ 1, "minute" ], [ 2, "minute" ], [ 5, "minute" ], [ 10, "minute" ], [ 30, "minute" ], [ 1, "hour" ], [ 2, "hour" ], [ 4, "hour" ], [ 8, "hour" ], [ 12, "hour" ], [ 1, "day" ], [ 2, "day" ], [ 3, "day" ], [ .25, "month" ], [ .5, "month" ], [ 1, "month" ], [ 2, "month" ] ];
    var specMonths = baseSpec.concat([ [ 3, "month" ], [ 6, "month" ], [ 1, "year" ] ]);
    var specQuarters = baseSpec.concat([ [ 1, "quarter" ], [ 2, "quarter" ], [ 1, "year" ] ]);
    function init(plot) {
        plot.hooks.processOptions.push(function(plot, options) {
            $.each(plot.getAxes(), function(axisName, axis) {
                var opts = axis.options;
                if (opts.mode == "time") {
                    axis.tickGenerator = function(axis) {
                        var ticks = [];
                        var d = dateGenerator(axis.min, opts);
                        var minSize = 0;
                        var spec = opts.tickSize && opts.tickSize[1] === "quarter" || opts.minTickSize && opts.minTickSize[1] === "quarter" ? specQuarters : specMonths;
                        if (opts.minTickSize != null) {
                            if (typeof opts.tickSize == "number") {
                                minSize = opts.tickSize;
                            } else {
                                minSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];
                            }
                        }
                        for (var i = 0; i < spec.length - 1; ++i) {
                            if (axis.delta < (spec[i][0] * timeUnitSize[spec[i][1]] + spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2 && spec[i][0] * timeUnitSize[spec[i][1]] >= minSize) {
                                break;
                            }
                        }
                        var size = spec[i][0];
                        var unit = spec[i][1];
                        if (unit == "year") {
                            if (opts.minTickSize != null && opts.minTickSize[1] == "year") {
                                size = Math.floor(opts.minTickSize[0]);
                            } else {
                                var magn = Math.pow(10, Math.floor(Math.log(axis.delta / timeUnitSize.year) / Math.LN10));
                                var norm = axis.delta / timeUnitSize.year / magn;
                                if (norm < 1.5) {
                                    size = 1;
                                } else if (norm < 3) {
                                    size = 2;
                                } else if (norm < 7.5) {
                                    size = 5;
                                } else {
                                    size = 10;
                                }
                                size *= magn;
                            }
                            if (size < 1) {
                                size = 1;
                            }
                        }
                        axis.tickSize = opts.tickSize || [ size, unit ];
                        var tickSize = axis.tickSize[0];
                        unit = axis.tickSize[1];
                        var step = tickSize * timeUnitSize[unit];
                        if (unit == "second") {
                            d.setSeconds(floorInBase(d.getSeconds(), tickSize));
                        } else if (unit == "minute") {
                            d.setMinutes(floorInBase(d.getMinutes(), tickSize));
                        } else if (unit == "hour") {
                            d.setHours(floorInBase(d.getHours(), tickSize));
                        } else if (unit == "month") {
                            d.setMonth(floorInBase(d.getMonth(), tickSize));
                        } else if (unit == "quarter") {
                            d.setMonth(3 * floorInBase(d.getMonth() / 3, tickSize));
                        } else if (unit == "year") {
                            d.setFullYear(floorInBase(d.getFullYear(), tickSize));
                        }
                        d.setMilliseconds(0);
                        if (step >= timeUnitSize.minute) {
                            d.setSeconds(0);
                        }
                        if (step >= timeUnitSize.hour) {
                            d.setMinutes(0);
                        }
                        if (step >= timeUnitSize.day) {
                            d.setHours(0);
                        }
                        if (step >= timeUnitSize.day * 4) {
                            d.setDate(1);
                        }
                        if (step >= timeUnitSize.month * 2) {
                            d.setMonth(floorInBase(d.getMonth(), 3));
                        }
                        if (step >= timeUnitSize.quarter * 2) {
                            d.setMonth(floorInBase(d.getMonth(), 6));
                        }
                        if (step >= timeUnitSize.year) {
                            d.setMonth(0);
                        }
                        var carry = 0;
                        var v = Number.NaN;
                        var prev;
                        do {
                            prev = v;
                            v = d.getTime();
                            ticks.push(v);
                            if (unit == "month" || unit == "quarter") {
                                if (tickSize < 1) {
                                    d.setDate(1);
                                    var start = d.getTime();
                                    d.setMonth(d.getMonth() + (unit == "quarter" ? 3 : 1));
                                    var end = d.getTime();
                                    d.setTime(v + carry * timeUnitSize.hour + (end - start) * tickSize);
                                    carry = d.getHours();
                                    d.setHours(0);
                                } else {
                                    d.setMonth(d.getMonth() + tickSize * (unit == "quarter" ? 3 : 1));
                                }
                            } else if (unit == "year") {
                                d.setFullYear(d.getFullYear() + tickSize);
                            } else {
                                d.setTime(v + step);
                            }
                        } while (v < axis.max && v != prev);
                        return ticks;
                    };
                    axis.tickFormatter = function(v, axis) {
                        var d = dateGenerator(v, axis.options);
                        if (opts.timeformat != null) {
                            return formatDate(d, opts.timeformat, opts.monthNames, opts.dayNames);
                        }
                        var useQuarters = axis.options.tickSize && axis.options.tickSize[1] == "quarter" || axis.options.minTickSize && axis.options.minTickSize[1] == "quarter";
                        var t = axis.tickSize[0] * timeUnitSize[axis.tickSize[1]];
                        var span = axis.max - axis.min;
                        var suffix = opts.twelveHourClock ? " %p" : "";
                        var hourCode = opts.twelveHourClock ? "%I" : "%H";
                        var fmt;
                        if (t < timeUnitSize.minute) {
                            fmt = hourCode + ":%M:%S" + suffix;
                        } else if (t < timeUnitSize.day) {
                            if (span < 2 * timeUnitSize.day) {
                                fmt = hourCode + ":%M" + suffix;
                            } else {
                                fmt = "%b %d " + hourCode + ":%M" + suffix;
                            }
                        } else if (t < timeUnitSize.month) {
                            fmt = "%b %d";
                        } else if (useQuarters && t < timeUnitSize.quarter || !useQuarters && t < timeUnitSize.year) {
                            if (span < timeUnitSize.year) {
                                fmt = "%b";
                            } else {
                                fmt = "%b %Y";
                            }
                        } else if (useQuarters && t < timeUnitSize.year) {
                            if (span < timeUnitSize.year) {
                                fmt = "Q%q";
                            } else {
                                fmt = "Q%q %Y";
                            }
                        } else {
                            fmt = "%Y";
                        }
                        var rt = formatDate(d, fmt, opts.monthNames, opts.dayNames);
                        return rt;
                    };
                }
            });
        });
    }
    $.plot.plugins.push({
        init: init,
        options: options,
        name: "time",
        version: "1.0"
    });
    $.plot.formatDate = formatDate;
    $.plot.dateGenerator = dateGenerator;
})(jQuery);

(function($) {
    var defaultOptions = {
        tooltip: {
            show: false,
            cssClass: "flotTip",
            content: "%s | X: %x | Y: %y",
            xDateFormat: null,
            yDateFormat: null,
            monthNames: null,
            dayNames: null,
            shifts: {
                x: 10,
                y: 20
            },
            defaultTheme: true,
            snap: true,
            lines: false,
            clickTips: false,
            onHover: function(flotItem, $tooltipEl) {},
            $compat: false
        }
    };
    defaultOptions.tooltipOpts = defaultOptions.tooltip;
    var FlotTooltip = function(plot) {
        this.tipPosition = {
            x: 0,
            y: 0
        };
        this.init(plot);
    };
    FlotTooltip.prototype.init = function(plot) {
        var that = this;
        var plotPluginsLength = $.plot.plugins.length;
        this.plotPlugins = [];
        if (plotPluginsLength) {
            for (var p = 0; p < plotPluginsLength; p++) {
                this.plotPlugins.push($.plot.plugins[p].name);
            }
        }
        plot.hooks.bindEvents.push(function(plot, eventHolder) {
            that.plotOptions = plot.getOptions();
            if (typeof that.plotOptions.tooltip === "boolean") {
                that.plotOptions.tooltipOpts.show = that.plotOptions.tooltip;
                that.plotOptions.tooltip = that.plotOptions.tooltipOpts;
                delete that.plotOptions.tooltipOpts;
            }
            if (that.plotOptions.tooltip.show === false || typeof that.plotOptions.tooltip.show === "undefined") return;
            that.tooltipOptions = that.plotOptions.tooltip;
            if (that.tooltipOptions.$compat) {
                that.wfunc = "width";
                that.hfunc = "height";
            } else {
                that.wfunc = "innerWidth";
                that.hfunc = "innerHeight";
            }
            var $tip = that.getDomElement();
            $(plot.getPlaceholder()).bind("plothover", plothover);
            if (that.tooltipOptions.clickTips) {
                $(plot.getPlaceholder()).bind("plotclick", plotclick);
            }
            that.clickmode = false;
            $(eventHolder).bind("mousemove", mouseMove);
        });
        plot.hooks.shutdown.push(function(plot, eventHolder) {
            $(plot.getPlaceholder()).unbind("plothover", plothover);
            $(plot.getPlaceholder()).unbind("plotclick", plotclick);
            plot.removeTooltip();
            $(eventHolder).unbind("mousemove", mouseMove);
        });
        function mouseMove(e) {
            var pos = {};
            pos.x = e.pageX;
            pos.y = e.pageY;
            plot.setTooltipPosition(pos);
        }
        function plotclick(event, pos, item) {
            if (!that.clickmode) {
                plothover(event, pos, item);
                if (that.getDomElement().is(":visible")) {
                    $(plot.getPlaceholder()).unbind("plothover", plothover);
                    that.clickmode = true;
                }
            } else {
                $(plot.getPlaceholder()).bind("plothover", plothover);
                plot.hideTooltip();
                that.clickmode = false;
            }
        }
        function plothover(event, pos, item) {
            var lineDistance = function(p1x, p1y, p2x, p2y) {
                return Math.sqrt((p2x - p1x) * (p2x - p1x) + (p2y - p1y) * (p2y - p1y));
            };
            var dotLineLength = function(x, y, x0, y0, x1, y1, o) {
                if (o && !(o = function(x, y, x0, y0, x1, y1) {
                    if (typeof x0 !== "undefined") return {
                        x: x0,
                        y: y
                    }; else if (typeof y0 !== "undefined") return {
                        x: x,
                        y: y0
                    };
                    var left, tg = -1 / ((y1 - y0) / (x1 - x0));
                    return {
                        x: left = (x1 * (x * tg - y + y0) + x0 * (x * -tg + y - y1)) / (tg * (x1 - x0) + y0 - y1),
                        y: tg * left - tg * x + y
                    };
                }(x, y, x0, y0, x1, y1), o.x >= Math.min(x0, x1) && o.x <= Math.max(x0, x1) && o.y >= Math.min(y0, y1) && o.y <= Math.max(y0, y1))) {
                    var l1 = lineDistance(x, y, x0, y0), l2 = lineDistance(x, y, x1, y1);
                    return l1 > l2 ? l2 : l1;
                } else {
                    var a = y0 - y1, b = x1 - x0, c = x0 * y1 - y0 * x1;
                    return Math.abs(a * x + b * y + c) / Math.sqrt(a * a + b * b);
                }
            };
            if (item) {
                plot.showTooltip(item, that.tooltipOptions.snap ? item : pos);
            } else if (that.plotOptions.series.lines.show && that.tooltipOptions.lines === true) {
                var maxDistance = that.plotOptions.grid.mouseActiveRadius;
                var closestTrace = {
                    distance: maxDistance + 1
                };
                var ttPos = pos;
                $.each(plot.getData(), function(i, series) {
                    var xBeforeIndex = 0, xAfterIndex = -1;
                    for (var j = 1; j < series.data.length; j++) {
                        if (series.data[j - 1][0] <= pos.x && series.data[j][0] >= pos.x) {
                            xBeforeIndex = j - 1;
                            xAfterIndex = j;
                        }
                    }
                    if (xAfterIndex === -1) {
                        plot.hideTooltip();
                        return;
                    }
                    var pointPrev = {
                        x: series.data[xBeforeIndex][0],
                        y: series.data[xBeforeIndex][1]
                    }, pointNext = {
                        x: series.data[xAfterIndex][0],
                        y: series.data[xAfterIndex][1]
                    };
                    var distToLine = dotLineLength(series.xaxis.p2c(pos.x), series.yaxis.p2c(pos.y), series.xaxis.p2c(pointPrev.x), series.yaxis.p2c(pointPrev.y), series.xaxis.p2c(pointNext.x), series.yaxis.p2c(pointNext.y), false);
                    if (distToLine < closestTrace.distance) {
                        var closestIndex = lineDistance(pointPrev.x, pointPrev.y, pos.x, pos.y) < lineDistance(pos.x, pos.y, pointNext.x, pointNext.y) ? xBeforeIndex : xAfterIndex;
                        var pointSize = series.datapoints.pointsize;
                        var pointOnLine = [ pos.x, pointPrev.y + (pointNext.y - pointPrev.y) * ((pos.x - pointPrev.x) / (pointNext.x - pointPrev.x)) ];
                        var item = {
                            datapoint: pointOnLine,
                            dataIndex: closestIndex,
                            series: series,
                            seriesIndex: i
                        };
                        closestTrace = {
                            distance: distToLine,
                            item: item
                        };
                        if (that.tooltipOptions.snap) {
                            ttPos = {
                                pageX: series.xaxis.p2c(pointOnLine[0]),
                                pageY: series.yaxis.p2c(pointOnLine[1])
                            };
                        }
                    }
                });
                if (closestTrace.distance < maxDistance + 1) plot.showTooltip(closestTrace.item, ttPos); else plot.hideTooltip();
            } else {
                plot.hideTooltip();
            }
        }
        plot.setTooltipPosition = function(pos) {
            var $tip = that.getDomElement();
            var totalTipWidth = $tip.outerWidth() + that.tooltipOptions.shifts.x;
            var totalTipHeight = $tip.outerHeight() + that.tooltipOptions.shifts.y;
            if (pos.x - $(window).scrollLeft() > $(window)[that.wfunc]() - totalTipWidth) {
                pos.x -= totalTipWidth;
            }
            if (pos.y - $(window).scrollTop() > $(window)[that.hfunc]() - totalTipHeight) {
                pos.y -= totalTipHeight;
            }
            if (isNaN(pos.x)) {
                that.tipPosition.x = that.tipPosition.xPrev;
            } else {
                that.tipPosition.x = pos.x;
                that.tipPosition.xPrev = pos.x;
            }
            if (isNaN(pos.y)) {
                that.tipPosition.y = that.tipPosition.yPrev;
            } else {
                that.tipPosition.y = pos.y;
                that.tipPosition.yPrev = pos.y;
            }
        };
        plot.showTooltip = function(target, position, targetPosition) {
            var $tip = that.getDomElement();
            var tipText = that.stringFormat(that.tooltipOptions.content, target);
            if (tipText === "") return;
            $tip.html(tipText);
            plot.setTooltipPosition({
                x: position.pageX,
                y: position.pageY
            });
            $tip.css({
                left: that.tipPosition.x + that.tooltipOptions.shifts.x,
                top: that.tipPosition.y + that.tooltipOptions.shifts.y
            }).show();
            if (typeof that.tooltipOptions.onHover === "function") {
                that.tooltipOptions.onHover(target, $tip);
            }
        };
        plot.hideTooltip = function() {
            that.getDomElement().hide().html("");
        };
        plot.removeTooltip = function() {
            that.getDomElement().remove();
        };
    };
    FlotTooltip.prototype.getDomElement = function() {
        var $tip = $("<div>");
        if (this.tooltipOptions && this.tooltipOptions.cssClass) {
            $tip = $("." + this.tooltipOptions.cssClass);
            if ($tip.length === 0) {
                $tip = $("<div />").addClass(this.tooltipOptions.cssClass);
                $tip.appendTo("body").hide().css({
                    position: "absolute"
                });
                if (this.tooltipOptions.defaultTheme) {
                    $tip.css({
                        background: "#fff",
                        "z-index": "1040",
                        padding: "0.4em 0.6em",
                        "border-radius": "0.5em",
                        "font-size": "0.8em",
                        border: "1px solid #111",
                        display: "none",
                        "white-space": "nowrap"
                    });
                }
            }
        }
        return $tip;
    };
    FlotTooltip.prototype.stringFormat = function(content, item) {
        var percentPattern = /%p\.{0,1}(\d{0,})/;
        var seriesPattern = /%s/;
        var colorPattern = /%c/;
        var xLabelPattern = /%lx/;
        var yLabelPattern = /%ly/;
        var xPattern = /%x\.{0,1}(\d{0,})/;
        var yPattern = /%y\.{0,1}(\d{0,})/;
        var xPatternWithoutPrecision = "%x";
        var yPatternWithoutPrecision = "%y";
        var customTextPattern = "%ct";
        var nPiePattern = "%n";
        var x, y, customText, p, n;
        if (typeof item.series.threshold !== "undefined") {
            x = item.datapoint[0];
            y = item.datapoint[1];
            customText = item.datapoint[2];
        } else if (typeof item.series.curvedLines !== "undefined") {
            x = item.datapoint[0];
            y = item.datapoint[1];
        } else if (typeof item.series.lines !== "undefined" && item.series.lines.steps) {
            x = item.series.datapoints.points[item.dataIndex * 2];
            y = item.series.datapoints.points[item.dataIndex * 2 + 1];
            customText = "";
        } else {
            x = item.series.data[item.dataIndex][0];
            y = item.series.data[item.dataIndex][1];
            customText = item.series.data[item.dataIndex][2];
        }
        if (item.series.label === null && item.series.originSeries) {
            item.series.label = item.series.originSeries.label;
        }
        if (typeof content === "function") {
            content = content(item.series.label, x, y, item);
        }
        if (typeof content === "boolean" && !content) {
            return "";
        }
        if (customText) content = content.replace(customTextPattern, customText);
        if (typeof item.series.percent !== "undefined") {
            p = item.series.percent;
        } else if (typeof item.series.percents !== "undefined") {
            p = item.series.percents[item.dataIndex];
        }
        if (typeof p === "number") {
            content = this.adjustValPrecision(percentPattern, content, p);
        }
        if (item.series.hasOwnProperty("pie")) {
            if (typeof (item.series.data[0][1] !== "undefined")) {
                n = item.series.data[0][1];
            }
        }
        if (typeof n === "number") {
            content = content.replace(nPiePattern, n);
        }
        if (typeof item.series.label !== "undefined") {
            content = content.replace(seriesPattern, item.series.label);
        } else {
            content = content.replace(seriesPattern, "");
        }
        if (typeof item.series.color !== "undefined") {
            content = content.replace(colorPattern, item.series.color);
        } else {
            content = content.replace(colorPattern, "");
        }
        if (this.hasAxisLabel("xaxis", item)) {
            content = content.replace(xLabelPattern, item.series.xaxis.options.axisLabel);
        } else {
            content = content.replace(xLabelPattern, "");
        }
        if (this.hasAxisLabel("yaxis", item)) {
            content = content.replace(yLabelPattern, item.series.yaxis.options.axisLabel);
        } else {
            content = content.replace(yLabelPattern, "");
        }
        if (this.isTimeMode("xaxis", item) && this.isXDateFormat(item)) {
            content = content.replace(xPattern, this.timestampToDate(x, this.tooltipOptions.xDateFormat, item.series.xaxis.options));
        }
        if (this.isTimeMode("yaxis", item) && this.isYDateFormat(item)) {
            content = content.replace(yPattern, this.timestampToDate(y, this.tooltipOptions.yDateFormat, item.series.yaxis.options));
        }
        if (typeof x === "number") {
            content = this.adjustValPrecision(xPattern, content, x);
        }
        if (typeof y === "number") {
            content = this.adjustValPrecision(yPattern, content, y);
        }
        if (typeof item.series.xaxis.ticks !== "undefined") {
            var ticks;
            if (this.hasRotatedXAxisTicks(item)) {
                ticks = "rotatedTicks";
            } else {
                ticks = "ticks";
            }
            var tickIndex = item.dataIndex + item.seriesIndex;
            for (var xIndex in item.series.xaxis[ticks]) {
                if (item.series.xaxis[ticks].hasOwnProperty(tickIndex) && !this.isTimeMode("xaxis", item)) {
                    var valueX = this.isCategoriesMode("xaxis", item) ? item.series.xaxis[ticks][tickIndex].label : item.series.xaxis[ticks][tickIndex].v;
                    if (valueX === x) {
                        content = content.replace(xPattern, item.series.xaxis[ticks][tickIndex].label.replace(/\$/g, "$$$$"));
                    }
                }
            }
        }
        if (typeof item.series.yaxis.ticks !== "undefined") {
            for (var yIndex in item.series.yaxis.ticks) {
                if (item.series.yaxis.ticks.hasOwnProperty(yIndex)) {
                    var valueY = this.isCategoriesMode("yaxis", item) ? item.series.yaxis.ticks[yIndex].label : item.series.yaxis.ticks[yIndex].v;
                    if (valueY === y) {
                        content = content.replace(yPattern, item.series.yaxis.ticks[yIndex].label.replace(/\$/g, "$$$$"));
                    }
                }
            }
        }
        if (typeof item.series.xaxis.tickFormatter !== "undefined") {
            content = content.replace(xPatternWithoutPrecision, item.series.xaxis.tickFormatter(x, item.series.xaxis).replace(/\$/g, "$$"));
        }
        if (typeof item.series.yaxis.tickFormatter !== "undefined") {
            content = content.replace(yPatternWithoutPrecision, item.series.yaxis.tickFormatter(y, item.series.yaxis).replace(/\$/g, "$$"));
        }
        return content;
    };
    FlotTooltip.prototype.isTimeMode = function(axisName, item) {
        return typeof item.series[axisName].options.mode !== "undefined" && item.series[axisName].options.mode === "time";
    };
    FlotTooltip.prototype.isXDateFormat = function(item) {
        return typeof this.tooltipOptions.xDateFormat !== "undefined" && this.tooltipOptions.xDateFormat !== null;
    };
    FlotTooltip.prototype.isYDateFormat = function(item) {
        return typeof this.tooltipOptions.yDateFormat !== "undefined" && this.tooltipOptions.yDateFormat !== null;
    };
    FlotTooltip.prototype.isCategoriesMode = function(axisName, item) {
        return typeof item.series[axisName].options.mode !== "undefined" && item.series[axisName].options.mode === "categories";
    };
    FlotTooltip.prototype.timestampToDate = function(tmst, dateFormat, options) {
        var theDate = $.plot.dateGenerator(tmst, options);
        return $.plot.formatDate(theDate, dateFormat, this.tooltipOptions.monthNames, this.tooltipOptions.dayNames);
    };
    FlotTooltip.prototype.adjustValPrecision = function(pattern, content, value) {
        var precision;
        var matchResult = content.match(pattern);
        if (matchResult !== null) {
            if (RegExp.$1 !== "") {
                precision = RegExp.$1;
                value = value.toFixed(precision);
                content = content.replace(pattern, value);
            }
        }
        return content;
    };
    FlotTooltip.prototype.hasAxisLabel = function(axisName, item) {
        return $.inArray("axisLabels", this.plotPlugins) !== -1 && typeof item.series[axisName].options.axisLabel !== "undefined" && item.series[axisName].options.axisLabel.length > 0;
    };
    FlotTooltip.prototype.hasRotatedXAxisTicks = function(item) {
        return $.inArray("tickRotor", this.plotPlugins) !== -1 && typeof item.series.xaxis.rotatedTicks !== "undefined";
    };
    var init = function(plot) {
        new FlotTooltip(plot);
    };
    $.plot.plugins.push({
        init: init,
        options: defaultOptions,
        name: "tooltip",
        version: "0.8.5"
    });
})(jQuery);

angular.module("angular-flot", []).directive("flot", [ "$timeout", function($timeout) {
    return {
        restrict: "EA",
        template: "<div></div>",
        scope: {
            dataset: "=",
            options: "=",
            callback: "=",
            onPlotClick: "&",
            onPlotHover: "&",
            onPlotSelected: "&",
            onPlotUnselected: "&"
        },
        link: function(scope, element, attributes) {
            var plot = null;
            var width = attributes.width || "100%";
            var height = attributes.height || "100%";
            if (((scope.options || {}).legend || {}).container instanceof jQuery) {
                throw new Error('Please use a jQuery expression string with the "legend.container" option.');
            }
            if (!scope.dataset) {
                scope.dataset = [];
            }
            if (!scope.options) {
                scope.options = {
                    legend: {
                        show: false
                    }
                };
            }
            var plotArea = $(element.children()[0]);
            plotArea.css({
                width: width,
                height: height
            });
            var init = function() {
                var plotObj = $.plot(plotArea, scope.dataset, scope.options);
                if (scope.callback) {
                    scope.callback(plotObj);
                }
                return plotObj;
            };
            plotArea.on("plotclick", function onPlotClick(event, pos, item) {
                $timeout(function onApplyPlotClick() {
                    scope.onPlotClick({
                        event: event,
                        pos: pos,
                        item: item
                    });
                });
            });
            plotArea.on("plotselected", function onPlotSelected(event, ranges) {
                $timeout(function onApplyPlotSelected() {
                    scope.onPlotSelected({
                        event: event,
                        ranges: ranges
                    });
                });
            });
            plotArea.on("plotunselected", function onPlotUnselected(event) {
                $timeout(function onApplyPlotUnselected() {
                    scope.onPlotUnselected({
                        event: event
                    });
                });
            });
            plotArea.on("plothover", function onPlotHover(event, pos, item) {
                $timeout(function onApplyPlotHover() {
                    scope.onPlotHover({
                        event: event,
                        pos: pos,
                        item: item
                    });
                });
            });
            var onOptionsChanged = function() {
                plot = init();
            };
            var unwatchOptions = scope.$watch("options", onOptionsChanged, true);
            var onDatasetChanged = function(dataset) {
                if (plot) {
                    plot.setData(dataset);
                    plot.setupGrid();
                    return plot.draw();
                } else {
                    plot = init();
                }
            };
            var unwatchDataset = scope.$watch("dataset", onDatasetChanged, true);
            attributes.$observe("width", function(value) {
                if (!value) return;
                width = value;
                plotArea.css("width", value);
            });
            attributes.$observe("height", function(value) {
                if (!value) return;
                height = value;
                plotArea.css("height", value);
            });
            element.on("$destroy", function onDestroy() {
                plotArea.off("plotclick");
                plotArea.off("plothover");
                plotArea.off("plotselected");
                plotArea.off("unplotselected");
                plot.destroy();
                unwatchDataset();
                unwatchOptions();
            });
        }
    };
} ]);

"format amd";

(function() {
    "use strict";
    function angularMoment(angular, moment) {
        return angular.module("angularMoment", []).constant("angularMomentConfig", {
            preprocess: null,
            timezone: "",
            format: null,
            statefulFilters: true
        }).constant("moment", moment).constant("amTimeAgoConfig", {
            withoutSuffix: false,
            serverTime: null,
            titleFormat: null,
            fullDateThreshold: null,
            fullDateFormat: null
        }).directive("amTimeAgo", [ "$window", "moment", "amMoment", "amTimeAgoConfig", "angularMomentConfig", function($window, moment, amMoment, amTimeAgoConfig, angularMomentConfig) {
            return function(scope, element, attr) {
                var activeTimeout = null;
                var currentValue;
                var currentFormat = angularMomentConfig.format;
                var withoutSuffix = amTimeAgoConfig.withoutSuffix;
                var titleFormat = amTimeAgoConfig.titleFormat;
                var fullDateThreshold = amTimeAgoConfig.fullDateThreshold;
                var fullDateFormat = amTimeAgoConfig.fullDateFormat;
                var localDate = new Date().getTime();
                var preprocess = angularMomentConfig.preprocess;
                var modelName = attr.amTimeAgo;
                var currentFrom;
                var isTimeElement = "TIME" === element[0].nodeName.toUpperCase();
                function getNow() {
                    var now;
                    if (currentFrom) {
                        now = currentFrom;
                    } else if (amTimeAgoConfig.serverTime) {
                        var localNow = new Date().getTime();
                        var nowMillis = localNow - localDate + amTimeAgoConfig.serverTime;
                        now = moment(nowMillis);
                    } else {
                        now = moment();
                    }
                    return now;
                }
                function cancelTimer() {
                    if (activeTimeout) {
                        $window.clearTimeout(activeTimeout);
                        activeTimeout = null;
                    }
                }
                function updateTime(momentInstance) {
                    var daysAgo = getNow().diff(momentInstance, "day");
                    var showFullDate = fullDateThreshold && daysAgo >= fullDateThreshold;
                    if (showFullDate) {
                        element.text(momentInstance.format(fullDateFormat));
                    } else {
                        element.text(momentInstance.from(getNow(), withoutSuffix));
                    }
                    if (titleFormat && !element.attr("title")) {
                        element.attr("title", momentInstance.local().format(titleFormat));
                    }
                    if (!showFullDate) {
                        var howOld = Math.abs(getNow().diff(momentInstance, "minute"));
                        var secondsUntilUpdate = 3600;
                        if (howOld < 1) {
                            secondsUntilUpdate = 1;
                        } else if (howOld < 60) {
                            secondsUntilUpdate = 30;
                        } else if (howOld < 180) {
                            secondsUntilUpdate = 300;
                        }
                        activeTimeout = $window.setTimeout(function() {
                            updateTime(momentInstance);
                        }, secondsUntilUpdate * 1e3);
                    }
                }
                function updateDateTimeAttr(value) {
                    if (isTimeElement) {
                        element.attr("datetime", value);
                    }
                }
                function updateMoment() {
                    cancelTimer();
                    if (currentValue) {
                        var momentValue = amMoment.preprocessDate(currentValue, preprocess, currentFormat);
                        updateTime(momentValue);
                        updateDateTimeAttr(momentValue.toISOString());
                    }
                }
                scope.$watch(modelName, function(value) {
                    if (typeof value === "undefined" || value === null || value === "") {
                        cancelTimer();
                        if (currentValue) {
                            element.text("");
                            updateDateTimeAttr("");
                            currentValue = null;
                        }
                        return;
                    }
                    currentValue = value;
                    updateMoment();
                });
                if (angular.isDefined(attr.amFrom)) {
                    scope.$watch(attr.amFrom, function(value) {
                        if (typeof value === "undefined" || value === null || value === "") {
                            currentFrom = null;
                        } else {
                            currentFrom = moment(value);
                        }
                        updateMoment();
                    });
                }
                if (angular.isDefined(attr.amWithoutSuffix)) {
                    scope.$watch(attr.amWithoutSuffix, function(value) {
                        if (typeof value === "boolean") {
                            withoutSuffix = value;
                            updateMoment();
                        } else {
                            withoutSuffix = amTimeAgoConfig.withoutSuffix;
                        }
                    });
                }
                attr.$observe("amFormat", function(format) {
                    if (typeof format !== "undefined") {
                        currentFormat = format;
                        updateMoment();
                    }
                });
                attr.$observe("amPreprocess", function(newValue) {
                    preprocess = newValue;
                    updateMoment();
                });
                attr.$observe("amFullDateThreshold", function(newValue) {
                    fullDateThreshold = newValue;
                    updateMoment();
                });
                attr.$observe("amFullDateFormat", function(newValue) {
                    fullDateFormat = newValue;
                    updateMoment();
                });
                scope.$on("$destroy", function() {
                    cancelTimer();
                });
                scope.$on("amMoment:localeChanged", function() {
                    updateMoment();
                });
            };
        } ]).service("amMoment", [ "moment", "$rootScope", "$log", "angularMomentConfig", function(moment, $rootScope, $log, angularMomentConfig) {
            this.preprocessors = {
                utc: moment.utc,
                unix: moment.unix
            };
            this.changeLocale = function(locale, customization) {
                var result = moment.locale(locale, customization);
                if (angular.isDefined(locale)) {
                    $rootScope.$broadcast("amMoment:localeChanged");
                }
                return result;
            };
            this.changeTimezone = function(timezone) {
                angularMomentConfig.timezone = timezone;
                $rootScope.$broadcast("amMoment:timezoneChanged");
            };
            this.preprocessDate = function(value, preprocess, format) {
                if (angular.isUndefined(preprocess)) {
                    preprocess = angularMomentConfig.preprocess;
                }
                if (this.preprocessors[preprocess]) {
                    return this.preprocessors[preprocess](value, format);
                }
                if (preprocess) {
                    $log.warn("angular-moment: Ignoring unsupported value for preprocess: " + preprocess);
                }
                if (!isNaN(parseFloat(value)) && isFinite(value)) {
                    return moment(parseInt(value, 10));
                }
                return moment(value, format);
            };
            this.applyTimezone = function(aMoment, timezone) {
                timezone = timezone || angularMomentConfig.timezone;
                if (!timezone) {
                    return aMoment;
                }
                if (timezone.match(/^Z|[+-]\d\d:?\d\d$/i)) {
                    aMoment = aMoment.utcOffset(timezone);
                } else if (aMoment.tz) {
                    aMoment = aMoment.tz(timezone);
                } else {
                    $log.warn("angular-moment: named timezone specified but moment.tz() is undefined. Did you forget to include moment-timezone.js?");
                }
                return aMoment;
            };
        } ]).filter("amCalendar", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amCalendarFilter(value, preprocess, timezone) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                value = amMoment.preprocessDate(value, preprocess);
                var date = moment(value);
                if (!date.isValid()) {
                    return "";
                }
                return amMoment.applyTimezone(date, timezone).calendar();
            }
            amCalendarFilter.$stateful = angularMomentConfig.statefulFilters;
            return amCalendarFilter;
        } ]).filter("amDifference", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amDifferenceFilter(value, otherValue, unit, usePrecision, preprocessValue, preprocessOtherValue) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                value = amMoment.preprocessDate(value, preprocessValue);
                var date = moment(value);
                if (!date.isValid()) {
                    return "";
                }
                var date2;
                if (typeof otherValue === "undefined" || otherValue === null) {
                    date2 = moment();
                } else {
                    otherValue = amMoment.preprocessDate(otherValue, preprocessOtherValue);
                    date2 = moment(otherValue);
                    if (!date2.isValid()) {
                        return "";
                    }
                }
                return amMoment.applyTimezone(date).diff(amMoment.applyTimezone(date2), unit, usePrecision);
            }
            amDifferenceFilter.$stateful = angularMomentConfig.statefulFilters;
            return amDifferenceFilter;
        } ]).filter("amDateFormat", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amDateFormatFilter(value, format, preprocess, timezone, inputFormat) {
                var currentFormat = inputFormat || angularMomentConfig.format;
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                value = amMoment.preprocessDate(value, preprocess, currentFormat);
                var date = moment(value);
                if (!date.isValid()) {
                    return "";
                }
                return amMoment.applyTimezone(date, timezone).format(format);
            }
            amDateFormatFilter.$stateful = angularMomentConfig.statefulFilters;
            return amDateFormatFilter;
        } ]).filter("amDurationFormat", [ "moment", "angularMomentConfig", function(moment, angularMomentConfig) {
            function amDurationFormatFilter(value, format, suffix) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                return moment.duration(value, format).humanize(suffix);
            }
            amDurationFormatFilter.$stateful = angularMomentConfig.statefulFilters;
            return amDurationFormatFilter;
        } ]).filter("amTimeAgo", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amTimeAgoFilter(value, preprocess, suffix, from) {
                var date, dateFrom;
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                value = amMoment.preprocessDate(value, preprocess);
                date = moment(value);
                if (!date.isValid()) {
                    return "";
                }
                dateFrom = moment(from);
                if (typeof from !== "undefined" && dateFrom.isValid()) {
                    return amMoment.applyTimezone(date).from(dateFrom, suffix);
                }
                return amMoment.applyTimezone(date).fromNow(suffix);
            }
            amTimeAgoFilter.$stateful = angularMomentConfig.statefulFilters;
            return amTimeAgoFilter;
        } ]).filter("amSubtract", [ "moment", "angularMomentConfig", function(moment, angularMomentConfig) {
            function amSubtractFilter(value, amount, type) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                return moment(value).subtract(parseInt(amount, 10), type);
            }
            amSubtractFilter.$stateful = angularMomentConfig.statefulFilters;
            return amSubtractFilter;
        } ]).filter("amAdd", [ "moment", "angularMomentConfig", function(moment, angularMomentConfig) {
            function amAddFilter(value, amount, type) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                return moment(value).add(parseInt(amount, 10), type);
            }
            amAddFilter.$stateful = angularMomentConfig.statefulFilters;
            return amAddFilter;
        } ]);
    }
    if (typeof define === "function" && define.amd) {
        define([ "angular", "moment" ], angularMoment);
    } else if (typeof module !== "undefined" && module && module.exports) {
        angularMoment(angular, require("moment"));
        module.exports = "angularMoment";
    } else {
        angularMoment(angular, (typeof global !== "undefined" ? global : window).moment);
    }
})();

!function($) {
    var Slider = function(element, options) {
        this.dragLocked = false;
        this.limit = 1e5;
        this.element = $(element).hide();
        this.picker = $('<div class="slider">' + '<div class="slider-track">' + '<div class="slider-selection"></div>' + '<div class="slider-handle"></div>' + '<div class="slider-handle"></div>' + "</div>" + '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>' + "</div>").insertBefore(this.element).append(this.element);
        this.id = this.element.data("slider-id") || options.id;
        if (this.id) {
            this.picker[0].id = this.id;
        }
        if (typeof Modernizr !== "undefined" && Modernizr.touch) {
            this.touchCapable = true;
        }
        var tooltip = this.element.data("slider-tooltip") || options.tooltip;
        this.tooltip = this.picker.find(".tooltip");
        this.tooltipInner = this.tooltip.find("div.tooltip-inner");
        this.orientation = this.element.data("slider-orientation") || options.orientation;
        switch (this.orientation) {
          case "vertical":
            this.picker.addClass("slider-vertical");
            this.stylePos = "top";
            this.mousePos = "pageY";
            this.sizePos = "offsetHeight";
            this.tooltip.addClass("right")[0].style.left = "100%";
            break;

          default:
            this.picker.addClass("slider-horizontal").css("width", this.element.outerWidth());
            this.orientation = "horizontal";
            this.stylePos = "left";
            this.mousePos = "pageX";
            this.sizePos = "offsetWidth";
            this.tooltip.addClass("top")[0].style.top = -this.tooltip.outerHeight() - 14 + "px";
            break;
        }
        this.min = this.element.data("slider-min") || options.min;
        this.max = this.element.data("slider-max") || options.max;
        this.step = this.element.data("slider-step") || options.step;
        this.value = this.element.data("slider-value") || options.value;
        if (this.value[1]) {
            this.range = true;
        }
        this.selection = this.element.data("slider-selection") || options.selection;
        this.selectionEl = this.picker.find(".slider-selection");
        if (this.selection === "none") {
            this.selectionEl.addClass("hide");
        }
        this.selectionElStyle = this.selectionEl[0].style;
        this.handle1 = this.picker.find(".slider-handle:first");
        this.handle1Stype = this.handle1[0].style;
        this.handle2 = this.picker.find(".slider-handle:last");
        this.handle2Stype = this.handle2[0].style;
        var handle = this.element.data("slider-handle") || options.handle;
        switch (handle) {
          case "round":
            this.handle1.addClass("round");
            this.handle2.addClass("round");
            break;

          case "triangle":
            this.handle1.addClass("triangle");
            this.handle2.addClass("triangle");
            break;
        }
        if (this.range) {
            this.value[0] = Math.max(this.min, Math.min(this.max, this.value[0]));
            this.value[1] = Math.max(this.min, Math.min(this.max, this.value[1]));
        } else {
            this.value = [ Math.max(this.min, Math.min(this.max, this.value)) ];
            this.handle2.addClass("hide");
            if (this.selection == "after") {
                this.value[1] = this.max;
            } else {
                this.value[1] = this.min;
            }
        }
        this.diff = this.max - this.min;
        this.percentage = [ (this.value[0] - this.min) * 100 / this.diff, (this.value[1] - this.min) * 100 / this.diff, this.step * 100 / this.diff ];
        this.offset = this.picker.offset();
        this.size = this.picker[0][this.sizePos];
        this.formater = options.formater;
        this.reversed = this.element.data("slider-reversed") || options.reversed;
        this.layout();
        if (this.touchCapable) {
            this.picker.on({
                touchstart: $.proxy(this.mousedown, this)
            });
        } else {
            this.picker.on({
                mousedown: $.proxy(this.mousedown, this)
            });
        }
        if (tooltip === "show") {
            this.picker.on({
                mouseenter: $.proxy(this.showTooltip, this),
                mouseleave: $.proxy(this.hideTooltip, this)
            });
        } else {
            this.tooltip.addClass("hide");
        }
    };
    Slider.prototype = {
        constructor: Slider,
        over: false,
        inDrag: false,
        showTooltip: function() {
            this.tooltip.addClass("in");
            this.over = true;
        },
        hideTooltip: function() {
            if (this.inDrag === false) {
                this.tooltip.removeClass("in");
            }
            this.over = false;
        },
        layout: function() {
            var positionPercentages;
            if (this.reversed) {
                positionPercentages = [ this.percentage[1] - this.percentage[0], this.percentage[1] ];
            } else {
                positionPercentages = [ this.percentage[0], this.percentage[1] ];
            }
            this.handle1Stype[this.stylePos] = positionPercentages[0] + "%";
            this.handle2Stype[this.stylePos] = positionPercentages[1] + "%";
            if (this.orientation == "vertical") {
                this.selectionElStyle.top = Math.min(positionPercentages[0], positionPercentages[1]) + "%";
                this.selectionElStyle.height = Math.abs(positionPercentages[0] - positionPercentages[1]) + "%";
            } else {
                this.selectionElStyle.left = Math.min(positionPercentages[0], positionPercentages[1]) + "%";
                this.selectionElStyle.width = Math.abs(positionPercentages[0] - positionPercentages[1]) + "%";
            }
            if (this.range) {
                this.tooltipInner.text(this.formater(this.value[0]) + " : " + this.formater(this.value[1]));
                this.tooltip[0].style[this.stylePos] = this.size * (positionPercentages[0] + (positionPercentages[1] - positionPercentages[0]) / 2) / 100 - (this.orientation === "vertical" ? this.tooltip.outerHeight() / 2 : this.tooltip.outerWidth() / 2) + "px";
            } else {
                this.tooltipInner.text(this.formater(this.value[0]));
                this.tooltip[0].style[this.stylePos] = this.size * positionPercentages[0] / 100 - (this.orientation === "vertical" ? this.tooltip.outerHeight() / 2 : this.tooltip.outerWidth() / 2) + "px";
            }
        },
        mousedown: function(ev) {
            if (!this.dragLocked) {
                if (this.touchCapable && ev.type === "touchstart") {
                    ev = ev.originalEvent;
                }
                this.offset = this.picker.offset();
                this.size = this.picker[0][this.sizePos];
                var percentage = this.getPercentage(ev);
                if (this.range) {
                    var diff1 = Math.abs(this.percentage[0] - percentage);
                    var diff2 = Math.abs(this.percentage[1] - percentage);
                    this.dragged = diff1 < diff2 ? 0 : 1;
                } else {
                    this.dragged = 0;
                }
                this.percentage[this.dragged] = this.reversed ? this.percentage[1] - percentage : percentage;
                this.layout();
                if (this.touchCapable) {
                    $(document).on({
                        touchmove: $.proxy(this.mousemove, this),
                        touchend: $.proxy(this.mouseup, this)
                    });
                } else {
                    $(document).on({
                        mousemove: $.proxy(this.mousemove, this),
                        mouseup: $.proxy(this.mouseup, this)
                    });
                }
                this.inDrag = true;
                var val = this.calculateValue();
                this.setValue(val);
                this.element.trigger({
                    type: "slideStart",
                    value: val
                }).trigger({
                    type: "slide",
                    value: val
                });
                return false;
            }
        },
        mousemove: function(ev) {
            if (!this.dragLocked) {
                if (this.touchCapable && ev.type === "touchmove") {
                    ev = ev.originalEvent;
                }
                var percentage = this.getPercentage(ev);
                if (this.range) {
                    if (this.dragged === 0 && this.percentage[1] < percentage) {
                        this.percentage[0] = this.percentage[1];
                        this.dragged = 1;
                    } else if (this.dragged === 1 && this.percentage[0] > percentage) {
                        this.percentage[1] = this.percentage[0];
                        this.dragged = 0;
                    }
                }
                x = this.reversed ? this.percentage[1] - percentage : percentage;
                if (x > this.limit) {
                    return;
                }
                this.percentage[this.dragged] = x;
                this.layout();
                var val = this.calculateValue();
                this.setValue(val);
                this.element.trigger({
                    type: "slide",
                    value: val
                }).data("value", val).prop("value", val);
                return false;
            }
        },
        mouseup: function(ev) {
            if (this.touchCapable) {
                $(document).off({
                    touchmove: this.mousemove,
                    touchend: this.mouseup
                });
            } else {
                $(document).off({
                    mousemove: this.mousemove,
                    mouseup: this.mouseup
                });
            }
            this.inDrag = false;
            if (this.over == false) {
                this.hideTooltip();
            }
            this.element;
            var val = this.calculateValue();
            this.layout();
            this.element.trigger({
                type: "slideStop",
                value: val
            }).data("value", val).prop("value", val);
            return false;
        },
        calculateValue: function() {
            var val;
            if (this.range) {
                val = [ this.min + Math.round(this.diff * this.percentage[0] / 100 / this.step) * this.step, this.min + Math.round(this.diff * this.percentage[1] / 100 / this.step) * this.step ];
                this.value = val;
            } else {
                val = this.min + Math.round(this.diff * this.percentage[0] / 100 / this.step) * this.step;
                this.value = [ val, this.value[1] ];
            }
            return val;
        },
        getPercentage: function(ev) {
            if (this.touchCapable) {
                ev = ev.touches[0];
            }
            var percentage = (ev[this.mousePos] - this.offset[this.stylePos]) * 100 / this.size;
            percentage = Math.round(percentage / this.percentage[2]) * this.percentage[2];
            return Math.max(0, Math.min(100, percentage));
        },
        getValue: function() {
            if (this.range) {
                return this.value;
            }
            return this.value[0];
        },
        setLimit: function(val) {
            this.limit = val;
        },
        setDragLocked: function(val) {
            this.dragLocked = val;
        },
        getDragLocked: function(val) {
            return this.dragLocked;
        },
        setValue: function(val) {
            this.value = val;
            if (this.range) {
                this.value[0] = Math.max(this.min, Math.min(this.max, this.value[0]));
                this.value[1] = Math.max(this.min, Math.min(this.max, this.value[1]));
            } else {
                this.value = [ Math.max(this.min, Math.min(this.max, this.value)) ];
                this.handle2.addClass("hide");
                if (this.selection == "after") {
                    this.value[1] = this.max;
                } else {
                    this.value[1] = this.min;
                }
            }
            this.diff = this.max - this.min;
            this.percentage = [ (this.value[0] - this.min) * 100 / this.diff, (this.value[1] - this.min) * 100 / this.diff, this.step * 100 / this.diff ];
            this.layout();
        },
        destroy: function() {
            this.element.show().insertBefore(this.picker);
            this.picker.remove();
        }
    };
    $.fn.slider = function(option, val) {
        return this.each(function() {
            var $this = $(this), data = $this.data("slider"), options = typeof option === "object" && option;
            if (!data) {
                $this.data("slider", data = new Slider(this, $.extend({}, $.fn.slider.defaults, options)));
            }
            if (typeof option == "string") {
                data[option](val);
            }
        });
    };
    $.fn.slider.defaults = {
        min: 0,
        max: 10,
        step: 1,
        orientation: "horizontal",
        value: 5,
        selection: "before",
        tooltip: "show",
        handle: "round",
        reversed: false,
        limit: 1e5,
        dragLocked: false,
        formater: function(value) {
            return value;
        }
    };
    $.fn.slider.Constructor = Slider;
}(window.jQuery);

(function() {
    "use strict";
    var legacySupport = angular.version.major === 1 && angular.version.minor === 0;
    angular.module("ui-rangeSlider", []).directive("rangeSlider", [ "$document", "$filter", "$log", function($document, $filter, $log) {
        var eventNamespace = ".rangeSlider", defaults = {
            disabled: false,
            orientation: "horizontal",
            step: 0,
            decimalPlaces: 0,
            showValues: true,
            preventEqualMinMax: false,
            attachHandleValues: false
        }, actions = window.navigator.pointerEnabled ? {
            start: "pointerdown",
            move: "pointermove",
            end: "pointerup",
            over: "pointerdown",
            out: "mouseout"
        } : window.navigator.msPointerEnabled ? {
            start: "MSPointerDown",
            move: "MSPointerMove",
            end: "MSPointerUp",
            over: "MSPointerDown",
            out: "mouseout"
        } : {
            start: "mousedown touchstart",
            move: "mousemove touchmove",
            end: "mouseup touchend",
            over: "mouseover touchstart",
            out: "mouseout"
        }, onEvent = actions.start + eventNamespace, moveEvent = actions.move + eventNamespace, offEvent = actions.end + eventNamespace, overEvent = actions.over + eventNamespace, outEvent = actions.out + eventNamespace, client = function(f) {
            try {
                return [ f.clientX || f.originalEvent.clientX || f.originalEvent.touches[0].clientX, f.clientY || f.originalEvent.clientY || f.originalEvent.touches[0].clientY ];
            } catch (e) {
                return [ "x", "y" ];
            }
        }, restrict = function(value) {
            return value < 0 ? 0 : value > 100 ? 100 : value;
        }, isNumber = function(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }, scopeOptions = {
            disabled: "=?",
            min: "=",
            max: "=",
            modelMin: "=?",
            modelMax: "=?",
            onHandleDown: "&",
            onHandleUp: "&",
            orientation: "@",
            step: "@",
            decimalPlaces: "@",
            filter: "@",
            filterOptions: "@",
            showValues: "@",
            pinHandle: "@",
            preventEqualMinMax: "@",
            attachHandleValues: "@",
            getterSetter: "@"
        };
        if (legacySupport) {
            scopeOptions.disabled = "=";
            scopeOptions.modelMin = "=";
            scopeOptions.modelMax = "=";
        }
        return {
            restrict: "A",
            replace: true,
            template: [ '<div class="ngrs-range-slider">', '<div class="ngrs-runner">', '<div class="ngrs-handle ngrs-handle-min"><i></i></div>', '<div class="ngrs-handle ngrs-handle-max"><i></i></div>', '<div class="ngrs-join"></div>', "</div>", '<div class="ngrs-value-runner">', '<div class="ngrs-value ngrs-value-min" ng-show="showValues"><div>{{filteredModelMin}}</div></div>', '<div class="ngrs-value ngrs-value-max" ng-show="showValues"><div>{{filteredModelMax}}</div></div>', "</div>", "</div>" ].join(""),
            scope: scopeOptions,
            link: function(scope, element, attrs, controller) {
                var $slider = angular.element(element), handles = [ element.find(".ngrs-handle-min"), element.find(".ngrs-handle-max") ], values = [ element.find(".ngrs-value-min"), element.find(".ngrs-value-max") ], join = element.find(".ngrs-join"), pos = "left", posOpp = "right", orientation = 0, allowedRange = [ 0, 0 ], range = 0, down = false;
                scope.filteredModelMin = modelMin();
                scope.filteredModelMax = modelMax();
                attrs.$observe("disabled", function(val) {
                    if (!angular.isDefined(val)) {
                        scope.disabled = defaults.disabled;
                    }
                    scope.$watch("disabled", setDisabledStatus);
                });
                attrs.$observe("orientation", function(val) {
                    if (!angular.isDefined(val)) {
                        scope.orientation = defaults.orientation;
                    }
                    var classNames = scope.orientation.split(" "), useClass;
                    for (var i = 0, l = classNames.length; i < l; i++) {
                        classNames[i] = "ngrs-" + classNames[i];
                    }
                    useClass = classNames.join(" ");
                    $slider.addClass(useClass);
                    if (scope.orientation === "vertical" || scope.orientation === "vertical left" || scope.orientation === "vertical right") {
                        pos = "top";
                        posOpp = "bottom";
                        orientation = 1;
                    }
                });
                attrs.$observe("step", function(val) {
                    if (!angular.isDefined(val)) {
                        scope.step = defaults.step;
                    }
                });
                attrs.$observe("decimalPlaces", function(val) {
                    if (!angular.isDefined(val)) {
                        scope.decimalPlaces = defaults.decimalPlaces;
                    }
                });
                attrs.$observe("showValues", function(val) {
                    if (!angular.isDefined(val)) {
                        scope.showValues = defaults.showValues;
                    } else {
                        if (val === "false") {
                            scope.showValues = false;
                        } else {
                            scope.showValues = true;
                        }
                    }
                });
                attrs.$observe("pinHandle", function(val) {
                    if (!angular.isDefined(val)) {
                        scope.pinHandle = null;
                    } else {
                        if (val === "min" || val === "max") {
                            scope.pinHandle = val;
                        } else {
                            scope.pinHandle = null;
                        }
                    }
                    scope.$watch("pinHandle", setPinHandle);
                });
                attrs.$observe("preventEqualMinMax", function(val) {
                    if (!angular.isDefined(val)) {
                        scope.preventEqualMinMax = defaults.preventEqualMinMax;
                    } else {
                        if (val === "false") {
                            scope.preventEqualMinMax = false;
                        } else {
                            scope.preventEqualMinMax = true;
                        }
                    }
                });
                attrs.$observe("attachHandleValues", function(val) {
                    if (!angular.isDefined(val)) {
                        scope.attachHandleValues = defaults.attachHandleValues;
                    } else {
                        if (val === "true" || val === "") {
                            scope.attachHandleValues = true;
                            element.find(".ngrs-value-runner").addClass("ngrs-attached-handles");
                        } else {
                            scope.attachHandleValues = false;
                        }
                    }
                });
                function modelMin(newValue) {
                    if (scope.getterSetter) {
                        return arguments.length ? scope.modelMin(newValue) : scope.modelMin();
                    } else {
                        return arguments.length ? scope.modelMin = newValue : scope.modelMin;
                    }
                }
                function modelMax(newValue) {
                    if (scope.getterSetter) {
                        return arguments.length ? scope.modelMax(newValue) : scope.modelMax();
                    } else {
                        return arguments.length ? scope.modelMax = newValue : scope.modelMax;
                    }
                }
                scope.$watch("min", setMinMax);
                scope.$watch("max", setMinMax);
                scope.$watch(function() {
                    return modelMin();
                }, setModelMinMax);
                scope.$watch(function() {
                    return modelMax();
                }, setModelMinMax);
                function setPinHandle(status) {
                    if (status === "min") {
                        angular.element(handles[0]).css("display", "none");
                        angular.element(handles[1]).css("display", "block");
                    } else if (status === "max") {
                        angular.element(handles[0]).css("display", "block");
                        angular.element(handles[1]).css("display", "none");
                    } else {
                        angular.element(handles[0]).css("display", "block");
                        angular.element(handles[1]).css("display", "block");
                    }
                }
                function setDisabledStatus(status) {
                    if (status) {
                        $slider.addClass("ngrs-disabled");
                    } else {
                        $slider.removeClass("ngrs-disabled");
                    }
                }
                function setMinMax() {
                    if (scope.min > scope.max) {
                        throwError("min must be less than or equal to max");
                    }
                    if (angular.isDefined(scope.min) && angular.isDefined(scope.max)) {
                        if (!isNumber(scope.min)) {
                            throwError("min must be a number");
                        }
                        if (!isNumber(scope.max)) {
                            throwError("max must be a number");
                        }
                        range = scope.max - scope.min;
                        allowedRange = [ scope.min, scope.max ];
                        setModelMinMax();
                    }
                }
                function setModelMinMax() {
                    if (modelMin() > modelMax()) {
                        throwWarning("modelMin must be less than or equal to modelMax");
                        modelMin(modelMax());
                    }
                    if ((angular.isDefined(modelMin()) || scope.pinHandle === "min") && (angular.isDefined(modelMax()) || scope.pinHandle === "max")) {
                        if (!isNumber(modelMin())) {
                            if (scope.pinHandle !== "min") {
                                throwWarning("modelMin must be a number");
                            }
                            modelMin(scope.min);
                        }
                        if (!isNumber(modelMax())) {
                            if (scope.pinHandle !== "max") {
                                throwWarning("modelMax must be a number");
                            }
                            modelMax(scope.max);
                        }
                        var handle1pos = restrict((modelMin() - scope.min) / range * 100), handle2pos = restrict((modelMax() - scope.min) / range * 100), value1pos, value2pos;
                        if (scope.attachHandleValues) {
                            value1pos = handle1pos;
                            value2pos = handle2pos;
                        }
                        modelMin(Math.max(scope.min, modelMin()));
                        modelMax(Math.min(scope.max, modelMax()));
                        if (scope.filter && scope.filterOptions) {
                            scope.filteredModelMin = $filter(scope.filter)(modelMin(), scope.filterOptions);
                            scope.filteredModelMax = $filter(scope.filter)(modelMax(), scope.filterOptions);
                        } else if (scope.filter) {
                            var filterTokens = scope.filter.split(":"), filterName = scope.filter.split(":")[0], filterOptions = filterTokens.slice().slice(1), modelMinOptions, modelMaxOptions;
                            filterOptions = filterOptions.map(function(arg) {
                                if (isNumber(arg)) {
                                    return +arg;
                                } else if (arg[0] == '"' && arg[arg.length - 1] == '"' || arg[0] == "'" && arg[arg.length - 1] == "'") {
                                    return arg.slice(1, -1);
                                }
                            });
                            modelMinOptions = filterOptions.slice();
                            modelMaxOptions = filterOptions.slice();
                            modelMinOptions.unshift(modelMin());
                            modelMaxOptions.unshift(modelMax());
                            scope.filteredModelMin = $filter(filterName).apply(null, modelMinOptions);
                            scope.filteredModelMax = $filter(filterName).apply(null, modelMaxOptions);
                        } else {
                            scope.filteredModelMin = modelMin();
                            scope.filteredModelMax = modelMax();
                        }
                        if (scope.min === scope.max && modelMin() == modelMax()) {
                            angular.element(handles[0]).css(pos, "0%");
                            angular.element(handles[1]).css(pos, "100%");
                            if (scope.attachHandleValues) {
                                angular.element(values[0]).css(pos, "0%");
                                angular.element(values[1]).css(pos, "100%");
                            }
                            angular.element(join).css(pos, "0%").css(posOpp, "0%");
                        } else {
                            angular.element(handles[0]).css(pos, handle1pos + "%");
                            angular.element(handles[1]).css(pos, handle2pos + "%");
                            if (scope.attachHandleValues) {
                                angular.element(values[0]).css(pos, value1pos + "%");
                                angular.element(values[1]).css(pos, value2pos + "%");
                                angular.element(values[1]).css(posOpp, "auto");
                            }
                            angular.element(join).css(pos, handle1pos + "%").css(posOpp, 100 - handle2pos + "%");
                            if (handle1pos > 95) {
                                angular.element(handles[0]).css("z-index", 3);
                            }
                        }
                    }
                }
                function handleMove(index) {
                    var $handle = handles[index];
                    $handle.bind(onEvent + "X", function(event) {
                        var handleDownClass = (index === 0 ? "ngrs-handle-min" : "ngrs-handle-max") + "-down", modelValue = (index === 0 ? modelMin() : modelMax()) - scope.min, originalPosition = modelValue / range * 100, originalClick = client(event), previousClick = originalClick, previousProposal = false;
                        if (angular.isFunction(scope.onHandleDown)) {
                            scope.onHandleDown();
                        }
                        angular.element("body").bind("selectstart" + eventNamespace, function() {
                            return false;
                        });
                        if (!scope.disabled) {
                            down = true;
                            $handle.addClass("ngrs-down");
                            $slider.addClass("ngrs-focus " + handleDownClass);
                            angular.element("body").addClass("ngrs-touching");
                            $document.bind(moveEvent, function(e) {
                                e.preventDefault();
                                var currentClick = client(e), movement, proposal, other, per = scope.step / range * 100, otherModelPosition = ((index === 0 ? modelMax() : modelMin()) - scope.min) / range * 100;
                                if (currentClick[0] === "x") {
                                    return;
                                }
                                currentClick[0] -= originalClick[0];
                                currentClick[1] -= originalClick[1];
                                movement = [ previousClick[0] !== currentClick[0], previousClick[1] !== currentClick[1] ];
                                proposal = originalPosition + currentClick[orientation] * 100 / (orientation ? $slider.height() : $slider.width());
                                proposal = restrict(proposal);
                                if (scope.preventEqualMinMax) {
                                    if (per === 0) {
                                        per = 1 / range * 100;
                                    }
                                    if (index === 0) {
                                        otherModelPosition = otherModelPosition - per;
                                    } else if (index === 1) {
                                        otherModelPosition = otherModelPosition + per;
                                    }
                                }
                                if (index === 0) {
                                    proposal = proposal > otherModelPosition ? otherModelPosition : proposal;
                                } else if (index === 1) {
                                    proposal = proposal < otherModelPosition ? otherModelPosition : proposal;
                                }
                                if (scope.step > 0) {
                                    if (proposal < 100 && proposal > 0) {
                                        proposal = Math.round(proposal / per) * per;
                                    }
                                }
                                if (proposal > 95 && index === 0) {
                                    $handle.css("z-index", 3);
                                } else {
                                    $handle.css("z-index", "");
                                }
                                if (movement[orientation] && proposal != previousProposal) {
                                    if (index === 0) {
                                        modelMin(parseFloat(parseFloat(proposal * range / 100 + scope.min).toFixed(scope.decimalPlaces)));
                                    } else if (index === 1) {
                                        modelMax(parseFloat(parseFloat(proposal * range / 100 + scope.min).toFixed(scope.decimalPlaces)));
                                    }
                                    scope.$apply();
                                    previousProposal = proposal;
                                }
                                previousClick = currentClick;
                            }).bind(offEvent, function() {
                                if (angular.isFunction(scope.onHandleUp)) {
                                    scope.onHandleUp();
                                }
                                $document.off(moveEvent);
                                $document.off(offEvent);
                                angular.element("body").removeClass("ngrs-touching");
                                down = false;
                                $handle.removeClass("ngrs-down");
                                $handle.removeClass("ngrs-over");
                                $slider.removeClass("ngrs-focus " + handleDownClass);
                            });
                        }
                    }).on(overEvent, function() {
                        $handle.addClass("ngrs-over");
                    }).on(outEvent, function() {
                        if (!down) {
                            $handle.removeClass("ngrs-over");
                        }
                    });
                }
                function throwError(message) {
                    scope.disabled = true;
                    throw new Error("RangeSlider: " + message);
                }
                function throwWarning(message) {
                    $log.warn(message);
                }
                scope.$on("$destroy", function() {
                    $slider.off(eventNamespace);
                    angular.element("body").off(eventNamespace);
                    $document.off(eventNamespace);
                    for (var i = 0, l = handles.length; i < l; i++) {
                        handles[i].off(eventNamespace);
                        handles[i].off(eventNamespace + "X");
                    }
                });
                $slider.bind("selectstart" + eventNamespace, function(event) {
                    return false;
                }).bind("click", function(event) {
                    event.stopPropagation();
                });
                handleMove(0);
                handleMove(1);
            }
        };
    } ]);
    window.requestAnimFrame = function() {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
            window.setTimeout(callback, 1e3 / 60);
        };
    }();
})();